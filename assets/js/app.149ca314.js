(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var o,r,l=e[0],s=e[1],c=e[2],p=0,u=[];p<l.length;p++)r=l[p],Object.prototype.hasOwnProperty.call(a,r)&&a[r]&&u.push(a[r][0]),a[r]=0;for(o in s)Object.prototype.hasOwnProperty.call(s,o)&&(n[o]=s[o]);for(d&&d(e);u.length;)u.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],o=!0,l=1;l<t.length;l++){var s=t[l];0!==a[s]&&(o=!1)}o&&(i.splice(e--,1),n=r(r.s=t[0]))}return n}var o={},a={1:0},i=[];function r(e){if(o[e])return o[e].exports;var t=o[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,r),t.l=!0,t.exports}r.e=function(n){var e=[],t=a[n];if(0!==t)if(t)e.push(t[2]);else{var o=new Promise((function(e,o){t=a[n]=[e,o]}));e.push(t[2]=o);var i,l=document.createElement("script");l.charset="utf-8",l.timeout=120,r.nc&&l.setAttribute("nonce",r.nc),l.src=function(n){return r.p+"assets/js/"+({}[n]||n)+"."+{2:"fc046049",3:"4ad045e9",4:"0247c64c",5:"ec2ca163",6:"5056fac7",7:"1657cd5c",8:"ff0a5696",9:"214ff10f",10:"9ff94c38",11:"d73ae777",12:"147722d9",13:"17466336",14:"6494f36f",15:"f9e20e36",16:"a7f48dff",17:"98ddc9e8",18:"e1db8c2f",19:"659c2e14",20:"6f729f77",21:"38ea711a",22:"8b1b2f19",23:"a46dd954",24:"79ef5a3a",25:"b745d506",26:"6fa5c74c",27:"90519a42",28:"d7fbf5ec",29:"76735b61",30:"5f26f05f",31:"d5dd06e5",32:"5e6be14c",33:"f31c4b84",34:"0a6ab8d1",35:"efc9c314",36:"5bc062f9",37:"6a98ac06",38:"3e8e1e10",39:"fd0deef6",40:"57909854",41:"654802b7",42:"3baefdcd",43:"347ba405",44:"de416d1c",45:"b285702d",46:"d22e5fb2",47:"9c6bb53e",48:"01b2e7b7",49:"319c5f36",50:"ca7aa0f1",51:"e579a298",52:"9ab44cad",53:"1f5a59fa",54:"65fbe712",55:"d65d59e5",56:"30a43b9e",57:"87a6e01e",58:"ceb5735e",59:"8c4ec1c3",60:"0aff4024",61:"1ecdeb21",62:"2ddb0e26",63:"5975f369",64:"f8e623d6",65:"edd0dca5",66:"bb9eb356",67:"be611cba",68:"a724ee28",69:"ac4afd57",70:"57fa4da3",71:"9ba77489",72:"dd361deb",73:"99b5de80",74:"465c3688",75:"cd812a12",76:"9549d997",77:"d354f654",78:"1fa99ee1",79:"38c3adcd",80:"0c6e7c23",81:"6fd7bdaf",82:"5e6f44cc",83:"28234132",84:"69af3738",85:"fbbd884b",86:"a109ecb5",87:"79bbe007",88:"a978eaf9",89:"62e1e39c",90:"fceb620b",91:"063c0fea",92:"7d1a914f",93:"f2c07057",94:"9ecb028f",95:"a210f5e0",96:"02bd629d",97:"70bb3f1c",98:"c2d71960",99:"eacdb09c",100:"7a20315d",101:"894020a4",102:"ceb22011",103:"92de1ff8",104:"568036d9",105:"62d933e9",106:"045b8d4c",107:"3cd4feae",108:"ba9debee",109:"bd467d6e",110:"839231fb",111:"f05f1b9b",112:"21a70ae5",113:"3ddb6a00",114:"f396792b",115:"a2586fd9",116:"f5d11a80",117:"5db75fc6",118:"445ad3f2",119:"ed7bb7f0",120:"430c825c",121:"2b826d41",122:"937d167f",123:"f0179bbe",124:"6c777210",125:"8b31bda7",126:"4898ff49",127:"dc7dba5d",128:"089e960a",129:"f0a82603",130:"d37a1e0e",131:"048f3127",132:"78d43ebd",133:"13a3e1f5",134:"c02f5aa8",135:"a863e0a9",136:"d9c6ec6d",137:"d534a6bf",138:"5ce4ea49",139:"d270f69e",140:"78f0046a",141:"2fb4f22e",142:"0c4885c4",143:"16c15457",144:"3b11cea4",145:"f4e84839",146:"d97cb2ca",147:"7e830bba",148:"3f61dbd4",149:"e27904d2",150:"89dad23e",151:"94fc6dd5",152:"c9f59fad",153:"de8002ac",154:"d1794d82",155:"125067e6",156:"a970758c",157:"af052c44",158:"1e7cbe67",159:"fb44b343",160:"7e8083cc",161:"ecda23eb",162:"cbdd84da",163:"49efbd32",164:"6b9b0013",165:"eb1976d7",166:"e5299e6f",167:"64203309",168:"3d1dda45",169:"b1962eb1",170:"91540ad4",171:"10b57c69",172:"96159b8c",173:"b613022c",174:"2ac6d122",175:"5ae0084e",176:"b271cc29",177:"39315c3f",178:"c883c105",179:"6a12246d",180:"6934e4b8",181:"a4de7ddb",182:"b7969cb6",183:"4e544864",184:"87d3acfe",185:"500d76b3",186:"bb3dcdc2",187:"6344dda9",188:"a704f125",189:"8a385310",190:"ad155ec4",191:"f52e76e6",192:"a5b835b9",193:"a9b437e6",194:"86126558"}[n]+".js"}(n);var s=new Error;i=function(e){l.onerror=l.onload=null,clearTimeout(c);var t=a[n];if(0!==t){if(t){var o=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;s.message="Loading chunk "+n+" failed.\n("+o+": "+i+")",s.name="ChunkLoadError",s.type=o,s.request=i,t[1](s)}a[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:l})}),12e4);l.onerror=l.onload=i,document.head.appendChild(l)}return Promise.all(e)},r.m=n,r.c=o,r.d=function(n,e,t){r.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},r.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},r.t=function(n,e){if(1&e&&(n=r(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(r.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var o in n)r.d(t,o,function(e){return n[e]}.bind(null,o));return t},r.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return r.d(e,"a",e),e},r.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},r.p="/",r.oe=function(n){throw console.error(n),n};var l=window.webpackJsonp=window.webpackJsonp||[],s=l.push.bind(l);l.push=e,l=l.slice();for(var c=0;c<l.length;c++)e(l[c]);var d=s;i.push([245,0]),t()}([function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e,t){var o=t(0),a=t(37).f,i=t(28),r=t(14),l=t(117),s=t(123),c=t(110);n.exports=function(n,e){var t,d,p,u,m,h=n.target,g=n.global,f=n.stat;if(t=g?o:f?o[h]||l(h,{}):(o[h]||{}).prototype)for(d in e){if(u=e[d],p=n.noTargetGet?(m=a(t,d))&&m.value:t[d],!c(g?d:h+(f?".":"#")+d,n.forced)&&void 0!==p){if(typeof u==typeof p)continue;s(u,p)}(n.sham||p&&p.sham)&&i(u,"sham",!0),r(t,d,u,n)}}},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){var o=t(66),a=Function.prototype,i=a.bind,r=a.call,l=o&&i.bind(r,r);n.exports=o?function(n){return n&&l(n)}:function(n){return n&&function(){return r.apply(n,arguments)}}},function(n,e){n.exports=function(n){return"function"==typeof n}},function(n,e,t){var o=t(127),a=t(14),i=t(265);o||a(Object.prototype,"toString",i,{unsafe:!0})},function(n,e,t){var o=t(0),a=t(51),i=t(9),r=t(86),l=t(52),s=t(160),c=a("wks"),d=o.Symbol,p=d&&d.for,u=s?d:d&&d.withoutSetter||r;n.exports=function(n){if(!i(c,n)||!l&&"string"!=typeof c[n]){var e="Symbol."+n;l&&i(d,n)?c[n]=d[n]:c[n]=s&&p?p(e):u(e)}return c[n]}},function(n,e,t){var o=t(66),a=Function.prototype.call;n.exports=o?a.bind(a):function(){return a.apply(a,arguments)}},function(n,e,t){var o=t(2);n.exports=!o((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e,t){var o=t(3),a=t(17),i=o({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(a(n),e)}},function(n,e,t){var o=t(0),a=t(11),i=o.String,r=o.TypeError;n.exports=function(n){if(a(n))return n;throw r(i(n)+" is not an object")}},function(n,e,t){var o=t(4);n.exports=function(n){return"object"==typeof n?null!==n:o(n)}},function(n,e,t){var o=t(0),a=t(83),i=o.String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return i(n)}},function(n,e,t){var o=t(0),a=t(8),i=t(162),r=t(161),l=t(10),s=t(88),c=o.TypeError,d=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=a?r?function(n,e,t){if(l(n),e=s(e),l(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var o=p(n,e);o&&o.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:o.configurable,enumerable:"enumerable"in t?t.enumerable:o.enumerable,writable:!1})}return d(n,e,t)}:d:function(n,e,t){if(l(n),e=s(e),l(t),i)try{return d(n,e,t)}catch(n){}if("get"in t||"set"in t)throw c("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var o=t(0),a=t(4),i=t(9),r=t(28),l=t(117),s=t(91),c=t(38),d=t(71).CONFIGURABLE,p=c.get,u=c.enforce,m=String(String).split("String");(n.exports=function(n,e,t,s){var c,p=!!s&&!!s.unsafe,h=!!s&&!!s.enumerable,g=!!s&&!!s.noTargetGet,f=s&&void 0!==s.name?s.name:e;a(t)&&("Symbol("===String(f).slice(0,7)&&(f="["+String(f).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),(!i(t,"name")||d&&t.name!==f)&&r(t,"name",f),(c=u(t)).source||(c.source=m.join("string"==typeof f?f:""))),n!==o?(p?!g&&n[e]&&(h=!0):delete n[e],h?n[e]=t:r(n,e,t)):h?n[e]=t:l(e,t)})(Function.prototype,"toString",(function(){return a(this)&&p(this).source||s(this)}))},function(n,e,t){var o=t(0),a=t(4),i=function(n){return a(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(o[n]):o[n]&&o[n][e]}},function(n,e){n.exports=!1},function(n,e,t){var o=t(0),a=t(19),i=o.Object;n.exports=function(n){return i(a(n))}},function(n,e,t){"use strict";var o=t(1),a=t(98);o({target:"RegExp",proto:!0,forced:/./.exec!==a},{exec:a})},function(n,e,t){var o=t(0).TypeError;n.exports=function(n){if(null==n)throw o("Can't call method on "+n);return n}},function(n,e,t){var o=t(65),a=t(19);n.exports=function(n){return o(a(n))}},function(n,e,t){"use strict";function o(n,e,t,o,a,i,r,l){var s,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),o&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),r?(s=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),a&&a.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(r)},c._ssrRegister=s):a&&(s=l?function(){a.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:a),s)if(c.functional){c._injectStyles=s;var d=c.render;c.render=function(n,e){return s.call(e),d(n,e)}}else{var p=c.beforeCreate;c.beforeCreate=p?[].concat(p,s):[s]}return{exports:n,options:c}}t.d(e,"a",(function(){return o}))},function(n,e,t){"use strict";var o=t(178).charAt,a=t(12),i=t(38),r=t(166),l=i.set,s=i.getterFor("String Iterator");r(String,"String",(function(n){l(this,{type:"String Iterator",string:a(n),index:0})}),(function(){var n,e=s(this),t=e.string,a=e.index;return a>=t.length?{value:void 0,done:!0}:(n=o(t,a),e.index+=n.length,{value:n,done:!1})}))},function(n,e,t){var o=t(0),a=t(4),i=t(68),r=o.TypeError;n.exports=function(n){if(a(n))return n;throw r(i(n)+" is not a function")}},function(n,e,t){var o=t(54);n.exports=function(n){return o(n.length)}},function(n,e,t){"use strict";var o=t(1),a=t(60).filter;o({target:"Array",proto:!0,forced:!t(96)("filter")},{filter:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){var o=t(0),a=t(179),i=t(180),r=t(149),l=t(28),s=t(6),c=s("iterator"),d=s("toStringTag"),p=r.values,u=function(n,e){if(n){if(n[c]!==p)try{l(n,c,p)}catch(e){n[c]=p}if(n[d]||l(n,d,e),a[e])for(var t in r)if(n[t]!==r[t])try{l(n,t,r[t])}catch(e){n[t]=r[t]}}};for(var m in a)u(o[m]&&o[m].prototype,m);u(i,"DOMTokenList")},function(n,e,t){var o=t(3),a=o({}.toString),i=o("".slice);n.exports=function(n){return i(a(n),8,-1)}},function(n,e,t){var o=t(8),a=t(13),i=t(48);n.exports=o?function(n,e,t){return a.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){"use strict";var o=t(1),a=t(186);o({target:"Array",proto:!0,forced:[].forEach!=a},{forEach:a})},function(n,e,t){var o=t(0),a=t(179),i=t(180),r=t(186),l=t(28),s=function(n){if(n&&n.forEach!==r)try{l(n,"forEach",r)}catch(e){n.forEach=r}};for(var c in a)a[c]&&s(o[c]&&o[c].prototype);s(i)},function(n,e,t){var o=t(14),a=t(285),i=Error.prototype;i.toString!==a&&o(i,"toString",a)},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var o=t(15);n.exports=o("navigator","userAgent")||""},function(n,e,t){var o=t(197),a="object"==typeof self&&self&&self.Object===Object&&self,i=o||a||Function("return this")();n.exports=i},function(n,e,t){var o,a=t(10),i=t(118),r=t(121),l=t(69),s=t(165),c=t(87),d=t(90),p=d("IE_PROTO"),u=function(){},m=function(n){return"<script>"+n+"<\/script>"},h=function(n){n.write(m("")),n.close();var e=n.parentWindow.Object;return n=null,e},g=function(){try{o=new ActiveXObject("htmlfile")}catch(n){}var n,e;g="undefined"!=typeof document?document.domain&&o?h(o):((e=c("iframe")).style.display="none",s.appendChild(e),e.src=String("javascript:"),(n=e.contentWindow.document).open(),n.write(m("document.F=Object")),n.close(),n.F):h(o);for(var t=r.length;t--;)delete g.prototype[r[t]];return g()};l[p]=!0,n.exports=Object.create||function(n,e){var t;return null!==n?(u.prototype=a(n),t=new u,u.prototype=null,t[p]=n):t=g(),void 0===e?t:i.f(t,e)}},function(n,e,t){var o=t(3);n.exports=o({}.isPrototypeOf)},function(n,e,t){var o=t(8),a=t(7),i=t(122),r=t(48),l=t(20),s=t(88),c=t(9),d=t(162),p=Object.getOwnPropertyDescriptor;e.f=o?p:function(n,e){if(n=l(n),e=s(e),d)try{return p(n,e)}catch(n){}if(c(n,e))return r(!a(i.f,n,e),n[e])}},function(n,e,t){var o,a,i,r=t(247),l=t(0),s=t(3),c=t(11),d=t(28),p=t(9),u=t(116),m=t(90),h=t(69),g=l.TypeError,f=l.WeakMap;if(r||u.state){var v=u.state||(u.state=new f),b=s(v.get),x=s(v.has),y=s(v.set);o=function(n,e){if(x(v,n))throw new g("Object already initialized");return e.facade=n,y(v,n,e),e},a=function(n){return b(v,n)||{}},i=function(n){return x(v,n)}}else{var w=m("state");h[w]=!0,o=function(n,e){if(p(n,w))throw new g("Object already initialized");return e.facade=n,d(n,w,e),e},a=function(n){return p(n,w)?n[w]:{}},i=function(n){return p(n,w)}}n.exports={set:o,get:a,has:i,enforce:function(n){return i(n)?a(n):o(n,{})},getterFor:function(n){return function(e){var t;if(!c(e)||(t=a(e)).type!==n)throw g("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var o=t(66),a=Function.prototype,i=a.apply,r=a.call;n.exports="object"==typeof Reflect&&Reflect.apply||(o?r.bind(i):function(){return r.apply(i,arguments)})},function(n,e,t){var o=t(1),a=t(0),i=t(39),r=t(281),l=a.WebAssembly,s=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=r(n,e,s),o({global:!0,forced:s},t)},d=function(n,e){if(l&&l[n]){var t={};t[n]=r("WebAssembly."+n,e,s),o({target:"WebAssembly",stat:!0,forced:s},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),d("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),d("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),d("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var o=t(305),a=t(308);n.exports=function(n,e){var t=a(n,e);return o(t)?t:void 0}},function(n,e,t){"use strict";var o=t(1),a=t(0),i=t(63),r=t(94),l=t(11),s=t(120),c=t(24),d=t(20),p=t(76),u=t(6),m=t(96),h=t(73),g=m("slice"),f=u("species"),v=a.Array,b=Math.max;o({target:"Array",proto:!0,forced:!g},{slice:function(n,e){var t,o,a,u=d(this),m=c(u),g=s(n,m),x=s(void 0===e?m:e,m);if(i(u)&&(t=u.constructor,(r(t)&&(t===v||i(t.prototype))||l(t)&&null===(t=t[f]))&&(t=void 0),t===v||void 0===t))return h(u,g,x);for(o=new(void 0===t?v:t)(b(x-g,0)),a=0;g<x;g++,a++)g in u&&p(o,a,u[g]);return o.length=a,o}})},function(n,e,t){"use strict";t.d(e,"e",(function(){return o})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return r})),t.d(e,"g",(function(){return s})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return d})),t.d(e,"c",(function(){return p})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return h})),t.d(e,"d",(function(){return f})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return b})),t.d(e,"a",(function(){return y}));t(18),t(45),t(145),t(81),t(109),t(115),t(44),t(29),t(5),t(30),t(25),t(84),t(108),t(159),t(56),t(218),t(31),t(148);var o=/#.*$/,a=/\.(md|html)$/,i=/\/$/,r=/^[a-z]+:/i;function l(n){return decodeURI(n).replace(o,"").replace(a,"")}function s(n){return r.test(n)}function c(n){return/^mailto:/.test(n)}function d(n){return/^tel:/.test(n)}function p(n){if(s(n))return n;if(!n)return"404";var e=n.match(o),t=e?e[0]:"",a=l(n);return i.test(a)?n:a+".html"+t}function u(n,e){var t=n.hash,a=function(n){var e=n&&n.match(o);if(e)return e[0]}(e);return(!a||t===a)&&l(n.path)===l(e)}function m(n,e,t){if(s(e))return{type:"external",path:e};t&&(e=function(n,e,t){var o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),r=0;r<i.length;r++){var l=i[r];".."===l?a.pop():"."!==l&&a.push(l)}""!==a[0]&&a.unshift("");return a.join("/")}(e,t));for(var o=l(e),a=0;a<n.length;a++)if(l(n[a].regularPath)===o)return Object.assign({},n[a],{type:"page",path:p(n[a].path)});return console.error('[vuepress] No matching page found for sidebar item "'.concat(e,'"')),{}}function h(n,e,t,o){var a=t.pages,i=t.themeConfig,r=o&&i.locales&&i.locales[o]||i;if("auto"===(n.frontmatter.sidebar||r.sidebar||i.sidebar))return g(n);var l=r.sidebar||i.sidebar;if(l){var s=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(var t in e)if(0===(o=n,/(\.html|\/)$/.test(o)?o:o+"/").indexOf(encodeURI(t)))return{base:t,config:e[t]};var o;return{}}(e,l),c=s.base,d=s.config;return"auto"===d?g(n):d?d.map((function(n){return function n(e,t,o){var a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;if("string"==typeof e)return m(t,e,o);if(Array.isArray(e))return Object.assign(m(t,e[0],o),{title:e[1]});a>3&&console.error("[vuepress] detected a too deep nested sidebar group.");var i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,o),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map((function(e){return n(e,t,o,a+1)})),collapsable:!1!==e.collapsable}}(n,a,c)})):[]}return[]}function g(n){var e=f(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map((function(e){return{type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}}))}]}function f(n){var e;return(n=n.map((function(n){return Object.assign({},n)}))).forEach((function(n){2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)})),n.filter((function(n){return 2===n.level}))}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function b(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function x(n){var e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function y(n,e){return x(e)-x(n)}},function(n,e,t){"use strict";var o=t(1),a=t(60).map;o({target:"Array",proto:!0,forced:!t(96)("map")},{map:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var o=t(39),a=t(7),i=t(3),r=t(113),l=t(2),s=t(10),c=t(4),d=t(58),p=t(54),u=t(12),m=t(19),h=t(132),g=t(47),f=t(286),v=t(114),b=t(6)("replace"),x=Math.max,y=Math.min,w=i([].concat),k=i([].push),j=i("".indexOf),T=i("".slice),S="$0"==="a".replace(/./,"$0"),E=!!/./[b]&&""===/./[b]("a","$0");r("replace",(function(n,e,t){var i=E?"$":"$0";return[function(n,t){var o=m(this),i=null==n?void 0:g(n,b);return i?a(i,n,o,t):a(e,u(o),n,t)},function(n,a){var r=s(this),l=u(n);if("string"==typeof a&&-1===j(a,i)&&-1===j(a,"$<")){var m=t(e,r,l,a);if(m.done)return m.value}var g=c(a);g||(a=u(a));var b=r.global;if(b){var S=r.unicode;r.lastIndex=0}for(var E=[];;){var I=v(r,l);if(null===I)break;if(k(E,I),!b)break;""===u(I[0])&&(r.lastIndex=h(l,p(r.lastIndex),S))}for(var z,C="",A=0,_=0;_<E.length;_++){for(var P=u((I=E[_])[0]),B=x(y(d(I.index),l.length),0),M=[],O=1;O<I.length;O++)k(M,void 0===(z=I[O])?z:String(z));var D=I.groups;if(g){var $=w([P],M,B,l);void 0!==D&&k($,D);var L=u(o(a,void 0,$))}else L=f(P,l,B,M,D,a);B>=A&&(C+=T(l,A,B)+L,A=B+P.length)}return C+T(l,A)}]}),!!l((function(){var n=/./;return n.exec=function(){var n=[];return n.groups={a:"7"},n},"7"!=="".replace(n,"$<a>")}))||!S||E)},function(n,e,t){"use strict";var o=t(2);n.exports=function(n,e){var t=[][n];return!!t&&o((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var o=t(23);n.exports=function(n,e){var t=n[e];return null==t?void 0:o(t)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(82),t(77),t(25),t(5),t(399),t(29),t(30),t(181),t(400),t(104);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(n);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,o)}return t}function i(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}},function(n,e,t){var o=t(16),a=t(116);(n.exports=function(n,e){return a[n]||(a[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.22.3",mode:o?"pure":"global",copyright:"© 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.22.3/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e,t){var o=t(53),a=t(2);n.exports=!!Object.getOwnPropertySymbols&&!a((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&o&&o<41}))},function(n,e,t){var o,a,i=t(0),r=t(33),l=i.process,s=i.Deno,c=l&&l.versions||s&&s.version,d=c&&c.v8;d&&(a=(o=d.split("."))[0]>0&&o[0]<4?1:+(o[0]+o[1])),!a&&r&&(!(o=r.match(/Edge\/(\d+)/))||o[1]>=74)&&(o=r.match(/Chrome\/(\d+)/))&&(a=+o[1]),n.exports=a},function(n,e,t){var o=t(58),a=Math.min;n.exports=function(n){return n>0?a(o(n),9007199254740991):0}},function(n,e,t){var o=t(0);n.exports=o.Promise},function(n,e,t){"use strict";var o=t(1),a=t(0),i=t(2),r=t(63),l=t(11),s=t(17),c=t(24),d=t(76),p=t(152),u=t(96),m=t(6),h=t(53),g=m("isConcatSpreadable"),f=a.TypeError,v=h>=51||!i((function(){var n=[];return n[g]=!1,n.concat()[0]!==n})),b=u("concat"),x=function(n){if(!l(n))return!1;var e=n[g];return void 0!==e?!!e:r(n)};o({target:"Array",proto:!0,forced:!v||!b},{concat:function(n){var e,t,o,a,i,r=s(this),l=p(r,0),u=0;for(e=-1,o=arguments.length;e<o;e++)if(x(i=-1===e?r:arguments[e])){if(u+(a=c(i))>9007199254740991)throw f("Maximum allowed index exceeded");for(t=0;t<a;t++,u++)t in i&&d(l,u,i[t])}else{if(u>=9007199254740991)throw f("Maximum allowed index exceeded");d(l,u++,i)}return l.length=u,l}})},function(n,e,t){t(381),t(382)},function(n,e){var t=Math.ceil,o=Math.floor;n.exports=function(n){var e=+n;return e!=e||0===e?0:(e>0?o:t)(e)}},function(n,e,t){var o=t(3),a=t(23),i=t(66),r=o(o.bind);n.exports=function(n,e){return a(n),void 0===e?n:i?r(n,e):function(){return n.apply(e,arguments)}}},function(n,e,t){var o=t(59),a=t(3),i=t(65),r=t(17),l=t(24),s=t(152),c=a([].push),d=function(n){var e=1==n,t=2==n,a=3==n,d=4==n,p=6==n,u=7==n,m=5==n||p;return function(h,g,f,v){for(var b,x,y=r(h),w=i(y),k=o(g,f),j=l(w),T=0,S=v||s,E=e?S(h,j):t||u?S(h,0):void 0;j>T;T++)if((m||T in w)&&(x=k(b=w[T],T,y),n))if(e)E[T]=x;else if(x)switch(n){case 3:return!0;case 5:return b;case 6:return T;case 2:c(E,b)}else switch(n){case 4:return!1;case 7:c(E,b)}return p?-1:a||d?d:E}};n.exports={forEach:d(0),map:d(1),filter:d(2),some:d(3),every:d(4),find:d(5),findIndex:d(6),filterReject:d(7)}},function(n,e,t){var o=t(164),a=t(121).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return o(n,a)}},function(n,e,t){var o=t(13).f,a=t(9),i=t(6)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!a(n,i)&&o(n,i,{configurable:!0,value:e})}},function(n,e,t){var o=t(27);n.exports=Array.isArray||function(n){return"Array"==o(n)}},function(n,e,t){var o=t(78),a=t(290),i=t(291),r=o?o.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":r&&r in Object(n)?a(n):i(n)}},function(n,e,t){var o=t(0),a=t(3),i=t(2),r=t(27),l=o.Object,s=a("".split);n.exports=i((function(){return!l("z").propertyIsEnumerable(0)}))?function(n){return"String"==r(n)?s(n,""):l(n)}:l},function(n,e,t){var o=t(2);n.exports=!o((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var o=t(0),a=t(15),i=t(4),r=t(36),l=t(160),s=o.Object;n.exports=l?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return i(e)&&r(e.prototype,s(n))}},function(n,e,t){var o=t(0).String;n.exports=function(n){try{return o(n)}catch(n){return"Object"}}},function(n,e){n.exports={}},function(n,e){n.exports={}},function(n,e,t){var o=t(8),a=t(9),i=Function.prototype,r=o&&Object.getOwnPropertyDescriptor,l=a(i,"name"),s=l&&"something"===function(){}.name,c=l&&(!o||o&&r(i,"name").configurable);n.exports={EXISTS:l,PROPER:s,CONFIGURABLE:c}},function(n,e,t){var o=t(3),a=t(10),i=t(248);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=o(Object.getOwnPropertyDescriptor(Object.prototype,"__proto__").set))(t,[]),e=t instanceof Array}catch(n){}return function(t,o){return a(t),i(o),e?n(t,o):t.__proto__=o,t}}():void 0)},function(n,e,t){var o=t(3);n.exports=o([].slice)},function(n,e,t){var o=t(0),a=t(55),i=t(4),r=t(110),l=t(91),s=t(6),c=t(256),d=t(16),p=t(53),u=a&&a.prototype,m=s("species"),h=!1,g=i(o.PromiseRejectionEvent),f=r("Promise",(function(){var n=l(a),e=n!==String(a);if(!e&&66===p)return!0;if(d&&(!u.catch||!u.finally))return!0;if(p>=51&&/native code/.test(n))return!1;var t=new a((function(n){n(1)})),o=function(n){n((function(){}),(function(){}))};return(t.constructor={})[m]=o,!(h=t.then((function(){}))instanceof o)||!e&&c&&!g}));n.exports={CONSTRUCTOR:f,REJECTION_EVENT:g,SUBCLASSING:h}},function(n,e,t){"use strict";var o=t(23),a=function(n){var e,t;this.promise=new n((function(n,o){if(void 0!==e||void 0!==t)throw TypeError("Bad Promise constructor");e=n,t=o})),this.resolve=o(e),this.reject=o(t)};n.exports.f=function(n){return new a(n)}},function(n,e,t){"use strict";var o=t(88),a=t(13),i=t(48);n.exports=function(n,e,t){var r=o(e);r in n?a.f(n,r,i(0,t)):n[r]=t}},function(n,e,t){t(273),t(276),t(277),t(130),t(278)},function(n,e,t){var o=t(34).Symbol;n.exports=o},function(n,e,t){"use strict";t.d(e,"a",(function(){return i}));t(84);var o=t(80);t(77),t(97),t(5),t(131),t(22),t(26),t(192);var a=t(105);t(40),t(31);function i(n){return function(n){if(Array.isArray(n))return Object(o.a)(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||Object(a.a)(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";function o(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}t.d(e,"a",(function(){return o}))},function(n,e,t){"use strict";t(18);var o,a,i=t(1),r=t(0),l=t(7),s=t(3),c=t(4),d=t(11),p=(o=!1,(a=/[ac]/).exec=function(){return o=!0,/./.exec.apply(this,arguments)},!0===a.test("abc")&&o),u=r.Error,m=s(/./.test);i({target:"RegExp",proto:!0,forced:!p},{test:function(n){var e=this.exec;if(!c(e))return m(this,n);var t=l(e,this,n);if(null!==t&&!d(t))throw new u("RegExp exec method returned something other than an Object or null");return!!t}})},function(n,e,t){var o=t(1),a=t(17),i=t(89);o({target:"Object",stat:!0,forced:t(2)((function(){i(1)}))},{keys:function(n){return i(a(n))}})},function(n,e,t){var o=t(0),a=t(127),i=t(4),r=t(27),l=t(6)("toStringTag"),s=o.Object,c="Arguments"==r(function(){return arguments}());n.exports=a?r:function(n){var e,t,o;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),l))?t:c?r(e):"Object"==(o=r(e))&&i(e.callee)?"Arguments":o}},function(n,e,t){t(1)({target:"Array",stat:!0},{isArray:t(63)})},function(n,e,t){var o=t(8),a=t(71).EXISTS,i=t(3),r=t(13).f,l=Function.prototype,s=i(l.toString),c=/function\b(?:\s|\/\*[\S\s]*?\*\/|\/\/[^\n\r]*[\n\r]+)*([^\s(/]*)/,d=i(c.exec);o&&!a&&r(l,"name",{configurable:!0,get:function(){try{return d(c,s(this))[1]}catch(n){return""}}})},function(n,e,t){var o=t(3),a=0,i=Math.random(),r=o(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+r(++a+i,36)}},function(n,e,t){var o=t(0),a=t(11),i=o.document,r=a(i)&&a(i.createElement);n.exports=function(n){return r?i.createElement(n):{}}},function(n,e,t){var o=t(163),a=t(67);n.exports=function(n){var e=o(n,"string");return a(e)?e:e+""}},function(n,e,t){var o=t(164),a=t(121);n.exports=Object.keys||function(n){return o(n,a)}},function(n,e,t){var o=t(51),a=t(86),i=o("keys");n.exports=function(n){return i[n]||(i[n]=a(n))}},function(n,e,t){var o=t(3),a=t(4),i=t(116),r=o(Function.toString);a(i.inspectSource)||(i.inspectSource=function(n){return r(n)}),n.exports=i.inspectSource},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var o=t(27),a=t(0);n.exports="process"==o(a.process)},function(n,e,t){var o=t(3),a=t(2),i=t(4),r=t(83),l=t(15),s=t(91),c=function(){},d=[],p=l("Reflect","construct"),u=/^\s*(?:class|function)\b/,m=o(u.exec),h=!u.exec(c),g=function(n){if(!i(n))return!1;try{return p(c,d,n),!0}catch(n){return!1}},f=function(n){if(!i(n))return!1;switch(r(n)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return h||!!m(u,s(n))}catch(n){return!0}};f.sham=!0,n.exports=!p||a((function(){var n;return g(g.call)||!g(Object)||!g((function(){n=!0}))||n}))?f:g},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(5);function o(n,e,t,o,a,i,r){try{var l=n[i](r),s=l.value}catch(n){return void t(n)}l.done?e(s):Promise.resolve(s).then(o,a)}function a(n){return function(){var e=this,t=arguments;return new Promise((function(a,i){var r=n.apply(e,t);function l(n){o(r,a,i,l,s,"next",n)}function s(n){o(r,a,i,l,s,"throw",n)}l(void 0)}))}}},function(n,e,t){var o=t(2),a=t(6),i=t(53),r=a("species");n.exports=function(n){return i>=51||!o((function(){var e=[];return(e.constructor={})[r]=function(){return{foo:1}},1!==e[n](Boolean).foo}))}},function(n,e,t){"use strict";var o=t(1),a=t(8),i=t(0),r=t(3),l=t(9),s=t(4),c=t(36),d=t(12),p=t(13).f,u=t(123),m=i.Symbol,h=m&&m.prototype;if(a&&s(m)&&(!("description"in h)||void 0!==m().description)){var g={},f=function(){var n=arguments.length<1||void 0===arguments[0]?void 0:d(arguments[0]),e=c(h,this)?new m(n):void 0===n?m():m(n);return""===n&&(g[e]=!0),e};u(f,m),f.prototype=h,h.constructor=f;var v="Symbol(test)"==String(m("test")),b=r(h.toString),x=r(h.valueOf),y=/^Symbol\((.*)\)[^)]+$/,w=r("".replace),k=r("".slice);p(h,"description",{configurable:!0,get:function(){var n=x(this),e=b(n);if(l(g,n))return"";var t=v?k(e,7,-1):w(e,y,"$1");return""===t?void 0:t}}),o({global:!0,forced:!0},{Symbol:f})}},function(n,e,t){"use strict";var o,a,i=t(7),r=t(3),l=t(12),s=t(193),c=t(112),d=t(51),p=t(35),u=t(38).get,m=t(231),h=t(236),g=d("native-string-replace",String.prototype.replace),f=RegExp.prototype.exec,v=f,b=r("".charAt),x=r("".indexOf),y=r("".replace),w=r("".slice),k=(a=/b*/g,i(f,o=/a/,"a"),i(f,a,"a"),0!==o.lastIndex||0!==a.lastIndex),j=c.BROKEN_CARET,T=void 0!==/()??/.exec("")[1];(k||T||j||m||h)&&(v=function(n){var e,t,o,a,r,c,d,m=this,h=u(m),S=l(n),E=h.raw;if(E)return E.lastIndex=m.lastIndex,e=i(v,E,S),m.lastIndex=E.lastIndex,e;var I=h.groups,z=j&&m.sticky,C=i(s,m),A=m.source,_=0,P=S;if(z&&(C=y(C,"y",""),-1===x(C,"g")&&(C+="g"),P=w(S,m.lastIndex),m.lastIndex>0&&(!m.multiline||m.multiline&&"\n"!==b(S,m.lastIndex-1))&&(A="(?: "+A+")",P=" "+P,_++),t=new RegExp("^(?:"+A+")",C)),T&&(t=new RegExp("^"+A+"$(?!\\s)",C)),k&&(o=m.lastIndex),a=i(f,z?t:m,P),z?a?(a.input=w(a.input,_),a[0]=w(a[0],_),a.index=m.lastIndex,m.lastIndex+=a[0].length):m.lastIndex=0:k&&a&&(m.lastIndex=m.global?a.index+a[0].length:o),T&&a&&a.length>1&&i(g,a[0],t,(function(){for(r=1;r<arguments.length-2;r++)void 0===arguments[r]&&(a[r]=void 0)})),a&&I)for(a.groups=c=p(null),r=0;r<I.length;r++)c[(d=I[r])[0]]=a[d[1]];return a}),n.exports=v},function(n,e,t){var o=t(295),a=t(296),i=t(297),r=t(298),l=t(299);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}s.prototype.clear=o,s.prototype.delete=a,s.prototype.get=i,s.prototype.has=r,s.prototype.set=l,n.exports=s},function(n,e,t){var o=t(199);n.exports=function(n,e){for(var t=n.length;t--;)if(o(n[t][0],e))return t;return-1}},function(n,e,t){var o=t(41)(Object,"create");n.exports=o},function(n,e,t){var o=t(317);n.exports=function(n,e){var t=n.__data__;return o(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var o=t(140);n.exports=function(n){if("string"==typeof n||o(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var o=t(1),a=t(8),i=t(13).f;o({target:"Object",stat:!0,forced:Object.defineProperty!==i,sham:!a},{defineProperty:i})},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(42),t(5),t(85),t(192),t(22),t(18),t(81);var o=t(80);function a(n,e){if(n){if("string"==typeof n)return Object(o.a)(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?Object(o.a)(n,e):void 0}}},function(n,e,t){var o,a;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(a="function"==typeof(o=function(){var n,e,t={version:"0.2.0"},o=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function a(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(o[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=a(n,o.minimum,1),t.status=1===n?null:n;var s=t.render(!e),c=s.querySelector(o.barSelector),d=o.speed,p=o.easing;return s.offsetWidth,r((function(e){""===o.positionUsing&&(o.positionUsing=t.getPositioningCSS()),l(c,function(n,e,t){var a;return(a="translate3d"===o.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===o.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,a}(n,d,p)),1===n?(l(s,{transition:"none",opacity:1}),s.offsetWidth,setTimeout((function(){l(s,{transition:"all "+d+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),d)}),d)):setTimeout(e,d)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),o.trickleSpeed)};return o.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*a(Math.random()*e,.1,.95)),e=a(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*o.trickleRate)},n=0,e=0,t.promise=function(o){return o&&"resolved"!==o.state()?(0===e&&t.start(),n++,e++,o.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=o.template;var a,r=e.querySelector(o.barSelector),s=n?"-100":i(t.status||0),d=document.querySelector(o.parent);return l(r,{transition:"all 0 linear",transform:"translate3d("+s+"%,0,0)"}),o.showSpinner||(a=e.querySelector(o.spinnerSelector))&&u(a),d!=document.body&&c(d,"nprogress-custom-parent"),d.appendChild(e),e},t.remove=function(){d(document.documentElement,"nprogress-busy"),d(document.querySelector(o.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var r=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),l=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var o,a=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);a--;)if((o=n[a]+i)in t)return o;return e}(t))}function o(n,e,o){e=t(e),n.style[e]=o}return function(n,e){var t,a,i=arguments;if(2==i.length)for(t in e)void 0!==(a=e[t])&&e.hasOwnProperty(t)&&o(n,t,a);else o(n,i[1],i[2])}}();function s(n,e){return("string"==typeof n?n:p(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=p(n),o=t+e;s(t,e)||(n.className=o.substring(1))}function d(n,e){var t,o=p(n);s(n,e)&&(t=o.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function p(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?o.call(e,t,e,n):o)||(n.exports=a)},function(n){n.exports=JSON.parse('{"_from":"vuepress-plugin-comment@^0.7.3","_id":"vuepress-plugin-comment@0.7.3","_inBundle":false,"_integrity":"sha512-CvuBST37snmQGzGD5lMxyw0u2eXWKVPjegfuwlI2+CTs2qWarKX16dVHHLR8DVa/yL5UGT3VuoNETH/zEexl8A==","_location":"/vuepress-plugin-comment","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"vuepress-plugin-comment@^0.7.3","name":"vuepress-plugin-comment","escapedName":"vuepress-plugin-comment","rawSpec":"^0.7.3","saveSpec":null,"fetchSpec":"^0.7.3"},"_requiredBy":["#DEV:/"],"_resolved":"https://registry.npmjs.org/vuepress-plugin-comment/-/vuepress-plugin-comment-0.7.3.tgz","_shasum":"2cff36b8f90896a7f88d494d78458398b1510249","_spec":"vuepress-plugin-comment@^0.7.3","_where":"/home/runner/work/notes-front-end/notes-front-end","author":{"name":"dongyuanxin"},"bugs":{"url":"https://github.com/dongyuanxin/vuepress-plugin-comment/issues"},"bundleDependencies":false,"dependencies":{"ejs":"^2.6.1","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9"},"deprecated":false,"description":"Comment plugin in vuepress, such as Gitalk, Valine...","homepage":"https://github.com/dongyuanxin/vuepress-plugin-comment#readme","keywords":["vuepress","comment","plugin","vue","gitalk","valine"],"license":"MIT","main":"index.js","name":"vuepress-plugin-comment","repository":{"type":"git","url":"git+ssh://git@github.com/dongyuanxin/vuepress-plugin-comment.git"},"scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"version":"0.7.3"}')},function(n,e,t){"use strict";var o=t(1),a=t(3),i=t(119).indexOf,r=t(46),l=a([].indexOf),s=!!l&&1/l([1],1,-0)<0,c=r("indexOf");o({target:"Array",proto:!0,forced:s||!c},{indexOf:function(n){var e=arguments.length>1?arguments[1]:void 0;return s?l(this,n,e)||0:i(this,n,e)}})},function(n,e,t){"use strict";var o=t(39),a=t(7),i=t(3),r=t(113),l=t(153),s=t(10),c=t(19),d=t(126),p=t(132),u=t(54),m=t(12),h=t(47),g=t(129),f=t(114),v=t(98),b=t(112),x=t(2),y=b.UNSUPPORTED_Y,w=Math.min,k=[].push,j=i(/./.exec),T=i(k),S=i("".slice);r("split",(function(n,e,t){var i;return i="c"=="abbc".split(/(b)*/)[1]||4!="test".split(/(?:)/,-1).length||2!="ab".split(/(?:ab)*/).length||4!=".".split(/(.?)(.?)/).length||".".split(/()()/).length>1||"".split(/.?/).length?function(n,t){var i=m(c(this)),r=void 0===t?4294967295:t>>>0;if(0===r)return[];if(void 0===n)return[i];if(!l(n))return a(e,i,n,r);for(var s,d,p,u=[],h=(n.ignoreCase?"i":"")+(n.multiline?"m":"")+(n.unicode?"u":"")+(n.sticky?"y":""),f=0,b=new RegExp(n.source,h+"g");(s=a(v,b,i))&&!((d=b.lastIndex)>f&&(T(u,S(i,f,s.index)),s.length>1&&s.index<i.length&&o(k,u,g(s,1)),p=s[0].length,f=d,u.length>=r));)b.lastIndex===s.index&&b.lastIndex++;return f===i.length?!p&&j(b,"")||T(u,""):T(u,S(i,f)),u.length>r?g(u,0,r):u}:"0".split(void 0,0).length?function(n,t){return void 0===n&&0===t?[]:a(e,this,n,t)}:e,[function(e,t){var o=c(this),r=null==e?void 0:h(e,n);return r?a(r,e,o,t):a(i,m(o),e,t)},function(n,o){var a=s(this),r=m(n),l=t(i,a,r,o,i!==e);if(l.done)return l.value;var c=d(a,RegExp),h=a.unicode,g=(a.ignoreCase?"i":"")+(a.multiline?"m":"")+(a.unicode?"u":"")+(y?"g":"y"),v=new c(y?"^(?:"+a.source+")":a,g),b=void 0===o?4294967295:o>>>0;if(0===b)return[];if(0===r.length)return null===f(v,r)?[r]:[];for(var x=0,k=0,j=[];k<r.length;){v.lastIndex=y?0:k;var E,I=f(v,y?S(r,k):r);if(null===I||(E=w(u(v.lastIndex+(y?k:0)),r.length))===x)k=p(r,k,h);else{if(T(j,S(r,x,k)),j.length===b)return j;for(var z=1;z<=I.length-1;z++)if(T(j,I[z]),j.length===b)return j;k=x=E}}return T(j,S(r,x)),j}]}),!!x((function(){var n=/(?:)/,e=n.exec;n.exec=function(){return e.apply(this,arguments)};var t="ab".split(n);return 2!==t.length||"a"!==t[0]||"b"!==t[1]})),y)},function(n,e,t){var o=t(2),a=t(4),i=/#|\.prototype\./,r=function(n,e){var t=s[l(n)];return t==d||t!=c&&(a(e)?o(e):!!e)},l=r.normalize=function(n){return String(n).replace(i,".").toLowerCase()},s=r.data={},c=r.NATIVE="N",d=r.POLYFILL="P";n.exports=r},function(n,e,t){var o=t(83),a=t(47),i=t(70),r=t(6)("iterator");n.exports=function(n){if(null!=n)return a(n,r)||a(n,"@@iterator")||i[o(n)]}},function(n,e,t){var o=t(2),a=t(0).RegExp,i=o((function(){var n=a("a","y");return n.lastIndex=2,null!=n.exec("abcd")})),r=i||o((function(){return!a("a","y").sticky})),l=i||o((function(){var n=a("^r","gy");return n.lastIndex=2,null!=n.exec("str")}));n.exports={BROKEN_CARET:l,MISSED_STICKY:r,UNSUPPORTED_Y:i}},function(n,e,t){"use strict";t(18);var o=t(3),a=t(14),i=t(98),r=t(2),l=t(6),s=t(28),c=l("species"),d=RegExp.prototype;n.exports=function(n,e,t,p){var u=l(n),m=!r((function(){var e={};return e[u]=function(){return 7},7!=""[n](e)})),h=m&&!r((function(){var e=!1,t=/a/;return"split"===n&&((t={}).constructor={},t.constructor[c]=function(){return t},t.flags="",t[u]=/./[u]),t.exec=function(){return e=!0,null},t[u](""),!e}));if(!m||!h||t){var g=o(/./[u]),f=e(u,""[n],(function(n,e,t,a,r){var l=o(n),s=e.exec;return s===i||s===d.exec?m&&!r?{done:!0,value:g(e,t,a)}:{done:!0,value:l(t,e,a)}:{done:!1}}));a(String.prototype,n,f[0]),a(d,u,f[1])}p&&s(d[u],"sham",!0)}},function(n,e,t){var o=t(0),a=t(7),i=t(10),r=t(4),l=t(27),s=t(98),c=o.TypeError;n.exports=function(n,e){var t=n.exec;if(r(t)){var o=a(t,n,e);return null!==o&&i(o),o}if("RegExp"===l(n))return a(s,n,e);throw c("RegExp#exec called on incompatible receiver")}},function(n,e,t){"use strict";var o=t(1),a=t(3),i=t(65),r=t(20),l=t(46),s=a([].join),c=i!=Object,d=l("join",",");o({target:"Array",proto:!0,forced:c||!d},{join:function(n){return s(r(this),void 0===n?",":n)}})},function(n,e,t){var o=t(0),a=t(117),i=o["__core-js_shared__"]||a("__core-js_shared__",{});n.exports=i},function(n,e,t){var o=t(0),a=Object.defineProperty;n.exports=function(n,e){try{a(o,n,{value:e,configurable:!0,writable:!0})}catch(t){o[n]=e}return e}},function(n,e,t){var o=t(8),a=t(161),i=t(13),r=t(10),l=t(20),s=t(89);e.f=o&&!a?Object.defineProperties:function(n,e){r(n);for(var t,o=l(e),a=s(e),c=a.length,d=0;c>d;)i.f(n,t=a[d++],o[t]);return n}},function(n,e,t){var o=t(20),a=t(120),i=t(24),r=function(n){return function(e,t,r){var l,s=o(e),c=i(s),d=a(r,c);if(n&&t!=t){for(;c>d;)if((l=s[d++])!=l)return!0}else for(;c>d;d++)if((n||d in s)&&s[d]===t)return n||d||0;return!n&&-1}};n.exports={includes:r(!0),indexOf:r(!1)}},function(n,e,t){var o=t(58),a=Math.max,i=Math.min;n.exports=function(n,e){var t=o(n);return t<0?a(t+e,0):i(t,e)}},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){"use strict";var o={}.propertyIsEnumerable,a=Object.getOwnPropertyDescriptor,i=a&&!o.call({1:2},1);e.f=i?function(n){var e=a(this,n);return!!e&&e.enumerable}:o},function(n,e,t){var o=t(9),a=t(124),i=t(37),r=t(13);n.exports=function(n,e,t){for(var l=a(e),s=r.f,c=i.f,d=0;d<l.length;d++){var p=l[d];o(n,p)||t&&o(t,p)||s(n,p,c(e,p))}}},function(n,e,t){var o=t(15),a=t(3),i=t(61),r=t(92),l=t(10),s=a([].concat);n.exports=o("Reflect","ownKeys")||function(n){var e=i.f(l(n)),t=r.f;return t?s(e,t(n)):e}},function(n,e,t){var o=t(0),a=t(9),i=t(4),r=t(17),l=t(90),s=t(168),c=l("IE_PROTO"),d=o.Object,p=d.prototype;n.exports=s?d.getPrototypeOf:function(n){var e=r(n);if(a(e,c))return e[c];var t=e.constructor;return i(t)&&e instanceof t?t.prototype:e instanceof d?p:null}},function(n,e,t){var o=t(10),a=t(169),i=t(6)("species");n.exports=function(n,e){var t,r=o(n).constructor;return void 0===r||null==(t=o(r)[i])?e:a(t)}},function(n,e,t){var o={};o[t(6)("toStringTag")]="z",n.exports="[object z]"===String(o)},function(n,e){n.exports=function(n){try{return{error:!1,value:n()}}catch(n){return{error:!0,value:n}}}},function(n,e,t){var o=t(0),a=t(120),i=t(24),r=t(76),l=o.Array,s=Math.max;n.exports=function(n,e,t){for(var o=i(n),c=a(e,o),d=a(void 0===t?o:t,o),p=l(s(d-c,0)),u=0;c<d;c++,u++)r(p,u,n[c]);return p.length=u,p}},function(n,e,t){var o=t(1),a=t(15),i=t(39),r=t(7),l=t(3),s=t(2),c=t(63),d=t(4),p=t(11),u=t(67),m=t(73),h=t(52),g=a("JSON","stringify"),f=l(/./.exec),v=l("".charAt),b=l("".charCodeAt),x=l("".replace),y=l(1..toString),w=/[\uD800-\uDFFF]/g,k=/^[\uD800-\uDBFF]$/,j=/^[\uDC00-\uDFFF]$/,T=!h||s((function(){var n=a("Symbol")();return"[null]"!=g([n])||"{}"!=g({a:n})||"{}"!=g(Object(n))})),S=s((function(){return'"\\udf06\\ud834"'!==g("\udf06\ud834")||'"\\udead"'!==g("\udead")})),E=function(n,e){var t=m(arguments),o=e;if((p(e)||void 0!==n)&&!u(n))return c(e)||(e=function(n,e){if(d(o)&&(e=r(o,this,n,e)),!u(e))return e}),t[1]=e,i(g,null,t)},I=function(n,e,t){var o=v(t,e-1),a=v(t,e+1);return f(k,n)&&!f(j,a)||f(j,n)&&!f(k,o)?"\\u"+y(b(n,0),16):n};g&&o({target:"JSON",stat:!0,forced:T||S},{stringify:function(n,e,t){var o=m(arguments),a=i(T?E:g,null,o);return S&&"string"==typeof a?x(a,w,I):a}})},function(n,e,t){t(190)("iterator")},function(n,e,t){"use strict";var o=t(178).charAt;n.exports=function(n,e,t){return e+(t?o(n,e).length:1)}},function(n,e,t){var o=t(289),a=t(49),i=Object.prototype,r=i.hasOwnProperty,l=i.propertyIsEnumerable,s=o(function(){return arguments}())?o:function(n){return a(n)&&r.call(n,"callee")&&!l.call(n,"callee")};n.exports=s},function(n,e,t){var o=t(41)(t(34),"Map");n.exports=o},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var o=t(309),a=t(316),i=t(318),r=t(319),l=t(320);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}s.prototype.clear=o,s.prototype.delete=a,s.prototype.get=i,s.prototype.has=r,s.prototype.set=l,n.exports=s},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var o=t(32),a=t(140),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,r=/^\w*$/;n.exports=function(n,e){if(o(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!a(n))||(r.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var o=t(64),a=t(49);n.exports=function(n){return"symbol"==typeof n||a(n)&&"[object Symbol]"==o(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var o=t(1),a=t(0),i=t(62);o({global:!0},{Reflect:{}}),i(a.Reflect,"Reflect",!0)},function(n,e,t){"use strict";t.d(e,"a",(function(){return a}));t(84);t(77),t(97),t(5),t(131),t(22),t(26);var o=t(105);t(40),t(31);function a(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var o,a,i=[],r=!0,l=!1;try{for(t=t.call(n);!(r=(o=t.next()).done)&&(i.push(o.value),!e||i.length!==e);r=!0);}catch(n){l=!0,a=n}finally{try{r||null==t.return||t.return()}finally{if(l)throw a}}return i}}(n,e)||Object(o.a)(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}},function(n,e,t){"use strict";var o=t(1),a=t(60).some;o({target:"Array",proto:!0,forced:!t(46)("some")},{some:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var o=t(7),a=t(113),i=t(10),r=t(54),l=t(12),s=t(19),c=t(47),d=t(132),p=t(114);a("match",(function(n,e,t){return[function(e){var t=s(this),a=null==e?void 0:c(e,n);return a?o(a,e,t):new RegExp(e)[n](l(t))},function(n){var o=i(this),a=l(n),s=t(e,o,a);if(s.done)return s.value;if(!o.global)return p(o,a);var c=o.unicode;o.lastIndex=0;for(var u,m=[],h=0;null!==(u=p(o,a));){var g=l(u[0]);m[h]=g,""===g&&(o.lastIndex=d(a,r(o.lastIndex),c)),h++}return 0===h?null:m}]}))},function(n,e,t){var o=t(6),a=t(35),i=t(13),r=o("unscopables"),l=Array.prototype;null==l[r]&&i.f(l,r,{configurable:!0,value:a(null)}),n.exports=function(n){l[r][n]=!0}},function(n,e,t){var o=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,o="function"==typeof Symbol?Symbol:{},a=o.iterator||"@@iterator",i=o.asyncIterator||"@@asyncIterator",r=o.toStringTag||"@@toStringTag";function l(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{l({},"")}catch(n){l=function(n,e,t){return n[e]=t}}function s(n,e,t,o){var a=e&&e.prototype instanceof p?e:p,i=Object.create(a.prototype),r=new j(o||[]);return i._invoke=function(n,e,t){var o="suspendedStart";return function(a,i){if("executing"===o)throw new Error("Generator is already running");if("completed"===o){if("throw"===a)throw i;return S()}for(t.method=a,t.arg=i;;){var r=t.delegate;if(r){var l=y(r,t);if(l){if(l===d)continue;return l}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===o)throw o="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);o="executing";var s=c(n,e,t);if("normal"===s.type){if(o=t.done?"completed":"suspendedYield",s.arg===d)continue;return{value:s.arg,done:t.done}}"throw"===s.type&&(o="completed",t.method="throw",t.arg=s.arg)}}}(n,t,r),i}function c(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=s;var d={};function p(){}function u(){}function m(){}var h={};l(h,a,(function(){return this}));var g=Object.getPrototypeOf,f=g&&g(g(T([])));f&&f!==e&&t.call(f,a)&&(h=f);var v=m.prototype=p.prototype=Object.create(h);function b(n){["next","throw","return"].forEach((function(e){l(n,e,(function(n){return this._invoke(e,n)}))}))}function x(n,e){var o;this._invoke=function(a,i){function r(){return new e((function(o,r){!function o(a,i,r,l){var s=c(n[a],n,i);if("throw"!==s.type){var d=s.arg,p=d.value;return p&&"object"==typeof p&&t.call(p,"__await")?e.resolve(p.__await).then((function(n){o("next",n,r,l)}),(function(n){o("throw",n,r,l)})):e.resolve(p).then((function(n){d.value=n,r(d)}),(function(n){return o("throw",n,r,l)}))}l(s.arg)}(a,i,o,r)}))}return o=o?o.then(r,r):r()}}function y(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,y(n,e),"throw"===e.method))return d;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return d}var o=c(t,n.iterator,e.arg);if("throw"===o.type)return e.method="throw",e.arg=o.arg,e.delegate=null,d;var a=o.arg;return a?a.done?(e[n.resultName]=a.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,d):a:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,d)}function w(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function k(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function j(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(w,this),this.reset(!0)}function T(n){if(n){var e=n[a];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var o=-1,i=function e(){for(;++o<n.length;)if(t.call(n,o))return e.value=n[o],e.done=!1,e;return e.value=void 0,e.done=!0,e};return i.next=i}}return{next:S}}function S(){return{value:void 0,done:!0}}return u.prototype=m,l(v,"constructor",m),l(m,"constructor",u),u.displayName=l(m,r,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===u||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,m):(n.__proto__=m,l(n,r,"GeneratorFunction")),n.prototype=Object.create(v),n},n.awrap=function(n){return{__await:n}},b(x.prototype),l(x.prototype,i,(function(){return this})),n.AsyncIterator=x,n.async=function(e,t,o,a,i){void 0===i&&(i=Promise);var r=new x(s(e,t,o,a),i);return n.isGeneratorFunction(t)?r:r.next().then((function(n){return n.done?n.value:r.next()}))},b(v),l(v,r,"Generator"),l(v,a,(function(){return this})),l(v,"toString",(function(){return"[object Generator]"})),n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var o=e.pop();if(o in n)return t.value=o,t.done=!1,t}return t.done=!0,t}},n.values=T,j.prototype={constructor:j,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(k),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function o(t,o){return r.type="throw",r.arg=n,e.next=t,o&&(e.method="next",e.arg=void 0),!!o}for(var a=this.tryEntries.length-1;a>=0;--a){var i=this.tryEntries[a],r=i.completion;if("root"===i.tryLoc)return o("end");if(i.tryLoc<=this.prev){var l=t.call(i,"catchLoc"),s=t.call(i,"finallyLoc");if(l&&s){if(this.prev<i.catchLoc)return o(i.catchLoc,!0);if(this.prev<i.finallyLoc)return o(i.finallyLoc)}else if(l){if(this.prev<i.catchLoc)return o(i.catchLoc,!0)}else{if(!s)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return o(i.finallyLoc)}}}},abrupt:function(n,e){for(var o=this.tryEntries.length-1;o>=0;--o){var a=this.tryEntries[o];if(a.tryLoc<=this.prev&&t.call(a,"finallyLoc")&&this.prev<a.finallyLoc){var i=a;break}}i&&("break"===n||"continue"===n)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var r=i?i.completion:{};return r.type=n,r.arg=e,i?(this.method="next",this.next=i.finallyLoc,d):this.complete(r)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),d},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),k(t),d}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var o=t.completion;if("throw"===o.type){var a=o.arg;k(t)}return a}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:T(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),d}},n}(n.exports);try{regeneratorRuntime=o}catch(n){"object"==typeof globalThis?globalThis.regeneratorRuntime=o:Function("r","regeneratorRuntime = r")(o)}},function(n,e,t){"use strict";var o=t(71).PROPER,a=t(14),i=t(10),r=t(12),l=t(2),s=t(242),c=RegExp.prototype.toString,d=l((function(){return"/a/b"!=c.call({source:"a",flags:"b"})})),p=o&&"toString"!=c.name;(d||p)&&a(RegExp.prototype,"toString",(function(){var n=i(this);return"/"+r(n.source)+"/"+r(s(n))}),{unsafe:!0})},function(n,e,t){"use strict";var o=t(20),a=t(146),i=t(70),r=t(38),l=t(13).f,s=t(166),c=t(16),d=t(8),p=r.set,u=r.getterFor("Array Iterator");n.exports=s(Array,"Array",(function(n,e){p(this,{type:"Array Iterator",target:o(n),index:0,kind:e})}),(function(){var n=u(this),e=n.target,t=n.kind,o=n.index++;return!e||o>=e.length?(n.target=void 0,{value:void 0,done:!0}):"keys"==t?{value:o,done:!1}:"values"==t?{value:e[o],done:!1}:{value:[o,e[o]],done:!1}}),"values");var m=i.Arguments=i.Array;if(a("keys"),a("values"),a("entries"),!c&&d&&"values"!==m.name)try{l(m,"name",{value:"values"})}catch(n){}},function(n,e,t){var o=t(0).TypeError;n.exports=function(n,e){if(n<e)throw o("Not enough arguments");return n}},function(n,e,t){var o=t(0),a=t(7),i=t(23),r=t(10),l=t(68),s=t(111),c=o.TypeError;n.exports=function(n,e){var t=arguments.length<2?s(n):e;if(i(t))return r(a(t,n));throw c(l(n)+" is not iterable")}},function(n,e,t){var o=t(266);n.exports=function(n,e){return new(o(n))(0===e?0:e)}},function(n,e,t){var o=t(11),a=t(27),i=t(6)("match");n.exports=function(n){var e;return o(n)&&(void 0!==(e=n[i])?!!e:"RegExp"==a(n))}},function(n,e,t){var o=t(4),a=t(11),i=t(72);n.exports=function(n,e,t){var r,l;return i&&o(r=e.constructor)&&r!==t&&a(l=r.prototype)&&l!==t.prototype&&i(n,l),n}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,o=/^[-+]0x[0-9a-f]+$/i,a=/^0b[01]+$/i,i=/^0o[0-7]+$/i,r=parseInt,l="object"==typeof global&&global&&global.Object===Object&&global,s="object"==typeof self&&self&&self.Object===Object&&self,c=l||s||Function("return this")(),d=Object.prototype.toString,p=Math.max,u=Math.min,m=function(){return c.Date.now()};function h(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function g(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==d.call(n)}(n))return NaN;if(h(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=h(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var l=a.test(n);return l||i.test(n)?r(n.slice(2),l?2:8):o.test(n)?NaN:+n}n.exports=function(n,e,t){var o,a,i,r,l,s,c=0,d=!1,f=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function b(e){var t=o,i=a;return o=a=void 0,c=e,r=n.apply(i,t)}function x(n){return c=n,l=setTimeout(w,e),d?b(n):r}function y(n){var t=n-s;return void 0===s||t>=e||t<0||f&&n-c>=i}function w(){var n=m();if(y(n))return k(n);l=setTimeout(w,function(n){var t=e-(n-s);return f?u(t,i-(n-c)):t}(n))}function k(n){return l=void 0,v&&o?b(n):(o=a=void 0,r)}function j(){var n=m(),t=y(n);if(o=arguments,a=this,s=n,t){if(void 0===l)return x(s);if(f)return l=setTimeout(w,e),b(s)}return void 0===l&&(l=setTimeout(w,e)),r}return e=g(e)||0,h(t)&&(d=!!t.leading,i=(f="maxWait"in t)?p(g(t.maxWait)||0,e):i,v="trailing"in t?!!t.trailing:v),j.cancel=function(){void 0!==l&&clearTimeout(l),c=0,o=s=a=l=void 0},j.flush=function(){return void 0===l?r:k(m())},j}},function(n,e,t){var o=t(3),a=t(19),i=t(12),r=t(158),l=o("".replace),s="["+r+"]",c=RegExp("^"+s+s+"*"),d=RegExp(s+s+"*$"),p=function(n){return function(e){var t=i(a(e));return 1&n&&(t=l(t,c,"")),2&n&&(t=l(t,d,"")),t}};n.exports={start:p(1),end:p(2),trim:p(3)}},function(n,e){n.exports="\t\n\v\f\r                　\u2028\u2029\ufeff"},function(n,e,t){var o=t(3),a=t(14),i=Date.prototype,r=o(i.toString),l=o(i.getTime);"Invalid Date"!=String(new Date(NaN))&&a(i,"toString",(function(){var n=l(this);return n==n?r(this):"Invalid Date"}))},function(n,e,t){var o=t(52);n.exports=o&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var o=t(8),a=t(2);n.exports=o&&a((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var o=t(8),a=t(2),i=t(87);n.exports=!o&&!a((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var o=t(0),a=t(7),i=t(11),r=t(67),l=t(47),s=t(246),c=t(6),d=o.TypeError,p=c("toPrimitive");n.exports=function(n,e){if(!i(n)||r(n))return n;var t,o=l(n,p);if(o){if(void 0===e&&(e="default"),t=a(o,n,e),!i(t)||r(t))return t;throw d("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e,t){var o=t(3),a=t(9),i=t(20),r=t(119).indexOf,l=t(69),s=o([].push);n.exports=function(n,e){var t,o=i(n),c=0,d=[];for(t in o)!a(l,t)&&a(o,t)&&s(d,t);for(;e.length>c;)a(o,t=e[c++])&&(~r(d,t)||s(d,t));return d}},function(n,e,t){var o=t(15);n.exports=o("document","documentElement")},function(n,e,t){"use strict";var o=t(1),a=t(7),i=t(16),r=t(71),l=t(4),s=t(232),c=t(125),d=t(72),p=t(62),u=t(28),m=t(14),h=t(6),g=t(70),f=t(167),v=r.PROPER,b=r.CONFIGURABLE,x=f.IteratorPrototype,y=f.BUGGY_SAFARI_ITERATORS,w=h("iterator"),k=function(){return this};n.exports=function(n,e,t,r,h,f,j){s(t,e,r);var T,S,E,I=function(n){if(n===h&&P)return P;if(!y&&n in A)return A[n];switch(n){case"keys":case"values":case"entries":return function(){return new t(this,n)}}return function(){return new t(this)}},z=e+" Iterator",C=!1,A=n.prototype,_=A[w]||A["@@iterator"]||h&&A[h],P=!y&&_||I(h),B="Array"==e&&A.entries||_;if(B&&(T=c(B.call(new n)))!==Object.prototype&&T.next&&(i||c(T)===x||(d?d(T,x):l(T[w])||m(T,w,k)),p(T,z,!0,!0),i&&(g[z]=k)),v&&"values"==h&&_&&"values"!==_.name&&(!i&&b?u(A,"name","values"):(C=!0,P=function(){return a(_,this)})),h)if(S={values:I("values"),keys:f?P:I("keys"),entries:I("entries")},j)for(E in S)(y||C||!(E in A))&&m(A,E,S[E]);else o({target:e,proto:!0,forced:y||C},S);return i&&!j||A[w]===P||m(A,w,P,{name:h}),g[e]=P,S}},function(n,e,t){"use strict";var o,a,i,r=t(2),l=t(4),s=t(35),c=t(125),d=t(14),p=t(6),u=t(16),m=p("iterator"),h=!1;[].keys&&("next"in(i=[].keys())?(a=c(c(i)))!==Object.prototype&&(o=a):h=!0),null==o||r((function(){var n={};return o[m].call(n)!==n}))?o={}:u&&(o=s(o)),l(o[m])||d(o,m,(function(){return this})),n.exports={IteratorPrototype:o,BUGGY_SAFARI_ITERATORS:h}},function(n,e,t){var o=t(2);n.exports=!o((function(){function n(){}return n.prototype.constructor=null,Object.getPrototypeOf(new n)!==n.prototype}))},function(n,e,t){var o=t(0),a=t(94),i=t(68),r=o.TypeError;n.exports=function(n){if(a(n))return n;throw r(i(n)+" is not a constructor")}},function(n,e,t){var o,a,i,r,l=t(0),s=t(39),c=t(59),d=t(4),p=t(9),u=t(2),m=t(165),h=t(73),g=t(87),f=t(150),v=t(171),b=t(93),x=l.setImmediate,y=l.clearImmediate,w=l.process,k=l.Dispatch,j=l.Function,T=l.MessageChannel,S=l.String,E=0,I={};try{o=l.location}catch(n){}var z=function(n){if(p(I,n)){var e=I[n];delete I[n],e()}},C=function(n){return function(){z(n)}},A=function(n){z(n.data)},_=function(n){l.postMessage(S(n),o.protocol+"//"+o.host)};x&&y||(x=function(n){f(arguments.length,1);var e=d(n)?n:j(n),t=h(arguments,1);return I[++E]=function(){s(e,void 0,t)},a(E),E},y=function(n){delete I[n]},b?a=function(n){w.nextTick(C(n))}:k&&k.now?a=function(n){k.now(C(n))}:T&&!v?(r=(i=new T).port2,i.port1.onmessage=A,a=c(r.postMessage,r)):l.addEventListener&&d(l.postMessage)&&!l.importScripts&&o&&"file:"!==o.protocol&&!u(_)?(a=_,l.addEventListener("message",A,!1)):a="onreadystatechange"in g("script")?function(n){m.appendChild(g("script")).onreadystatechange=function(){m.removeChild(this),z(n)}}:function(n){setTimeout(C(n),0)}),n.exports={set:x,clear:y}},function(n,e,t){var o=t(33);n.exports=/(?:ipad|iphone|ipod).*applewebkit/i.test(o)},function(n,e,t){var o=t(0),a=t(59),i=t(7),r=t(10),l=t(68),s=t(173),c=t(24),d=t(36),p=t(151),u=t(111),m=t(174),h=o.TypeError,g=function(n,e){this.stopped=n,this.result=e},f=g.prototype;n.exports=function(n,e,t){var o,v,b,x,y,w,k,j=t&&t.that,T=!(!t||!t.AS_ENTRIES),S=!(!t||!t.IS_ITERATOR),E=!(!t||!t.INTERRUPTED),I=a(e,j),z=function(n){return o&&m(o,"normal",n),new g(!0,n)},C=function(n){return T?(r(n),E?I(n[0],n[1],z):I(n[0],n[1])):E?I(n,z):I(n)};if(S)o=n;else{if(!(v=u(n)))throw h(l(n)+" is not iterable");if(s(v)){for(b=0,x=c(n);x>b;b++)if((y=C(n[b]))&&d(f,y))return y;return new g(!1)}o=p(n,v)}for(w=o.next;!(k=i(w,o)).done;){try{y=C(k.value)}catch(n){m(o,"throw",n)}if("object"==typeof y&&y&&d(f,y))return y}return new g(!1)}},function(n,e,t){var o=t(6),a=t(70),i=o("iterator"),r=Array.prototype;n.exports=function(n){return void 0!==n&&(a.Array===n||r[i]===n)}},function(n,e,t){var o=t(7),a=t(10),i=t(47);n.exports=function(n,e,t){var r,l;a(n);try{if(!(r=i(n,"return"))){if("throw"===e)throw t;return t}r=o(r,n)}catch(n){l=!0,r=n}if("throw"===e)throw t;if(l)throw r;return a(r),t}},function(n,e,t){var o=t(55),a=t(176),i=t(74).CONSTRUCTOR;n.exports=i||!a((function(n){o.all(n).then(void 0,(function(){}))}))},function(n,e,t){var o=t(6)("iterator"),a=!1;try{var i=0,r={next:function(){return{done:!!i++}},return:function(){a=!0}};r[o]=function(){return this},Array.from(r,(function(){throw 2}))}catch(n){}n.exports=function(n,e){if(!e&&!a)return!1;var t=!1;try{var i={};i[o]=function(){return{next:function(){return{done:t=!0}}}},n(i)}catch(n){}return t}},function(n,e,t){var o=t(10),a=t(11),i=t(75);n.exports=function(n,e){if(o(n),a(e)&&e.constructor===n)return e;var t=i.f(n);return(0,t.resolve)(e),t.promise}},function(n,e,t){var o=t(3),a=t(58),i=t(12),r=t(19),l=o("".charAt),s=o("".charCodeAt),c=o("".slice),d=function(n){return function(e,t){var o,d,p=i(r(e)),u=a(t),m=p.length;return u<0||u>=m?n?"":void 0:(o=s(p,u))<55296||o>56319||u+1===m||(d=s(p,u+1))<56320||d>57343?n?l(p,u):o:n?c(p,u,u+2):d-56320+(o-55296<<10)+65536}};n.exports={codeAt:d(!1),charAt:d(!0)}},function(n,e){n.exports={CSSRuleList:0,CSSStyleDeclaration:0,CSSValueList:0,ClientRectList:0,DOMRectList:0,DOMStringList:0,DOMTokenList:1,DataTransferItemList:0,FileList:0,HTMLAllCollection:0,HTMLCollection:0,HTMLFormElement:0,HTMLSelectElement:0,MediaList:0,MimeTypeArray:0,NamedNodeMap:0,NodeList:1,PaintRequestList:0,Plugin:0,PluginArray:0,SVGLengthList:0,SVGNumberList:0,SVGPathSegList:0,SVGPointList:0,SVGStringList:0,SVGTransformList:0,SourceBufferList:0,StyleSheetList:0,TextTrackCueList:0,TextTrackList:0,TouchList:0}},function(n,e,t){var o=t(87)("span").classList,a=o&&o.constructor&&o.constructor.prototype;n.exports=a===Object.prototype?void 0:a},function(n,e,t){var o=t(1),a=t(8),i=t(124),r=t(20),l=t(37),s=t(76);o({target:"Object",stat:!0,sham:!a},{getOwnPropertyDescriptors:function(n){for(var e,t,o=r(n),a=l.f,c=i(o),d={},p=0;c.length>p;)void 0!==(t=a(o,e=c[p++]))&&s(d,e,t);return d}})},function(n,e,t){var o=t(1),a=t(2),i=t(17),r=t(125),l=t(168);o({target:"Object",stat:!0,forced:a((function(){r(1)})),sham:!l},{getPrototypeOf:function(n){return r(i(n))}})},function(n,e,t){"use strict";var o,a=t(1),i=t(3),r=t(37).f,l=t(54),s=t(12),c=t(184),d=t(19),p=t(185),u=t(16),m=i("".startsWith),h=i("".slice),g=Math.min,f=p("startsWith");a({target:"String",proto:!0,forced:!!(u||f||(o=r(String.prototype,"startsWith"),!o||o.writable))&&!f},{startsWith:function(n){var e=s(d(this));c(n);var t=l(g(arguments.length>1?arguments[1]:void 0,e.length)),o=s(n);return m?m(e,o,t):h(e,t,t+o.length)===o}})},function(n,e,t){var o=t(0),a=t(153),i=o.TypeError;n.exports=function(n){if(a(n))throw i("The method doesn't accept regular expressions");return n}},function(n,e,t){var o=t(6)("match");n.exports=function(n){var e=/./;try{"/./"[n](e)}catch(t){try{return e[o]=!1,"/./"[n](e)}catch(n){}}return!1}},function(n,e,t){"use strict";var o=t(60).forEach,a=t(46)("forEach");n.exports=a?[].forEach:function(n){return o(this,n,arguments.length>1?arguments[1]:void 0)}},function(n,e,t){var o=t(2);n.exports=!o((function(){return Object.isExtensible(Object.preventExtensions({}))}))},function(n,e,t){var o=t(27),a=t(20),i=t(61).f,r=t(129),l="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[];n.exports.f=function(n){return l&&"Window"==o(n)?function(n){try{return i(n)}catch(n){return r(l)}}(n):i(a(n))}},function(n,e,t){var o=t(6);e.f=o},function(n,e,t){var o=t(274),a=t(9),i=t(189),r=t(13).f;n.exports=function(n){var e=o.Symbol||(o.Symbol={});a(e,n)||r(e,n,{value:i.f(n)})}},function(n,e,t){var o=t(52);n.exports=o&&!!Symbol.for&&!!Symbol.keyFor},function(n,e,t){var o=t(1),a=t(279);o({target:"Array",stat:!0,forced:!t(176)((function(n){Array.from(n)}))},{from:a})},function(n,e,t){"use strict";var o=t(10);n.exports=function(){var n=o(this),e="";return n.hasIndices&&(e+="d"),n.global&&(e+="g"),n.ignoreCase&&(e+="i"),n.multiline&&(e+="m"),n.dotAll&&(e+="s"),n.unicode&&(e+="u"),n.sticky&&(e+="y"),e}},function(n,e,t){var o=t(12);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:o(n)}},function(n,e,t){t(1)({target:"Object",stat:!0,sham:!t(8)},{create:t(35)})},function(n,e){n.exports=function(n,e){for(var t=-1,o=e.length,a=n.length;++t<o;)n[a+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var o=t(99),a=t(300),i=t(301),r=t(302),l=t(303),s=t(304);function c(n){var e=this.__data__=new o(n);this.size=e.size}c.prototype.clear=a,c.prototype.delete=i,c.prototype.get=r,c.prototype.has=l,c.prototype.set=s,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var o=t(64),a=t(135);n.exports=function(n){if(!a(n))return!1;var e=o(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var o=t(321),a=t(49);n.exports=function n(e,t,i,r,l){return e===t||(null==e||null==t||!a(e)&&!a(t)?e!=e&&t!=t:o(e,t,i,r,n,l))}},function(n,e,t){var o=t(204),a=t(324),i=t(205);n.exports=function(n,e,t,r,l,s){var c=1&t,d=n.length,p=e.length;if(d!=p&&!(c&&p>d))return!1;var u=s.get(n),m=s.get(e);if(u&&m)return u==e&&m==n;var h=-1,g=!0,f=2&t?new o:void 0;for(s.set(n,e),s.set(e,n);++h<d;){var v=n[h],b=e[h];if(r)var x=c?r(b,v,h,e,n,s):r(v,b,h,n,e,s);if(void 0!==x){if(x)continue;g=!1;break}if(f){if(!a(e,(function(n,e){if(!i(f,e)&&(v===n||l(v,n,t,r,s)))return f.push(e)}))){g=!1;break}}else if(v!==b&&!l(v,b,t,r,s)){g=!1;break}}return s.delete(n),s.delete(e),g}},function(n,e,t){var o=t(136),a=t(322),i=t(323);function r(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new o;++e<t;)this.add(n[e])}r.prototype.add=r.prototype.push=a,r.prototype.has=i,n.exports=r},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var o=t(334),a=t(340),i=t(210);n.exports=function(n){return i(n)?o(n):a(n)}},function(n,e,t){(function(n){var o=t(34),a=t(336),i=e&&!e.nodeType&&e,r=i&&"object"==typeof n&&n&&!n.nodeType&&n,l=r&&r.exports===i?o.Buffer:void 0,s=(l?l.isBuffer:void 0)||a;n.exports=s}).call(this,t(155)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var o=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==o||"symbol"!=o&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var o=t(337),a=t(338),i=t(339),r=i&&i.isTypedArray,l=r?a(r):o;n.exports=l},function(n,e,t){var o=t(200),a=t(138);n.exports=function(n){return null!=n&&a(n.length)&&!o(n)}},function(n,e,t){var o=t(41)(t(34),"Set");n.exports=o},function(n,e,t){var o=t(135);n.exports=function(n){return n==n&&!o(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var o=t(215),a=t(103);n.exports=function(n,e){for(var t=0,i=(e=o(e,n)).length;null!=n&&t<i;)n=n[a(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var o=t(32),a=t(139),i=t(351),r=t(354);n.exports=function(n,e){return o(n)?n:a(n,e)?[n]:i(r(n))}},function(n,e,t){var o=t(0),a=t(39),i=t(4),r=t(33),l=t(73),s=t(150),c=/MSIE .\./.test(r),d=o.Function,p=function(n){return c?function(e,t){var o=s(arguments.length,1)>2,r=i(e)?e:d(e),c=o?l(arguments,2):void 0;return n(o?function(){a(r,this,c)}:r,t)}:n};n.exports={setTimeout:p(o.setTimeout),setInterval:p(o.setInterval)}},function(n,e,t){"use strict";var o=t(0),a=t(3),i=t(23),r=t(11),l=t(9),s=t(73),c=t(66),d=o.Function,p=a([].concat),u=a([].join),m={},h=function(n,e,t){if(!l(m,e)){for(var o=[],a=0;a<e;a++)o[a]="a["+a+"]";m[e]=d("C,a","return new C("+u(o,",")+")")}return m[e](n,t)};n.exports=c?d.bind:function(n){var e=i(this),t=e.prototype,o=s(arguments,1),a=function(){var t=p(o,s(arguments));return this instanceof a?h(e,t.length,t):e.apply(n,t)};return r(t)&&(a.prototype=t),a}},function(n,e,t){"use strict";var o=t(1),a=t(388).start;o({target:"String",proto:!0,forced:t(390)},{padStart:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}})},function(n,e,t){},function(n,e,t){},function(n,e,t){t(1)({target:"Object",stat:!0},{setPrototypeOf:t(72)})},function(n,e,t){var o=t(1),a=t(15),i=t(39),r=t(217),l=t(169),s=t(10),c=t(11),d=t(35),p=t(2),u=a("Reflect","construct"),m=Object.prototype,h=[].push,g=p((function(){function n(){}return!(u((function(){}),[],n)instanceof n)})),f=!p((function(){u((function(){}))})),v=g||f;o({target:"Reflect",stat:!0,forced:v,sham:v},{construct:function(n,e){l(n),s(e);var t=arguments.length<3?n:l(arguments[2]);if(f&&!g)return u(n,e,t);if(n==t){switch(e.length){case 0:return new n;case 1:return new n(e[0]);case 2:return new n(e[0],e[1]);case 3:return new n(e[0],e[1],e[2]);case 4:return new n(e[0],e[1],e[2],e[3])}var o=[null];return i(h,o,e),new(i(r,n,o))}var a=t.prototype,p=d(c(a)?a:m),v=i(n,p,e);return c(v)?v:p}})},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(287),a=t(292),i=t(363),r=t(371),l=t(380),s=t(240),c=i((function(n){var e=s(n);return l(e)&&(e=void 0),r(o(n,1,l,!0),a(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var o=/["'&<>]/;n.exports=function(n){var e,t=""+n,a=o.exec(t);if(!a)return t;var i="",r=0,l=0;for(r=a.index;r<t.length;r++){switch(t.charCodeAt(r)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}l!==r&&(i+=t.substring(l,r)),l=r+1,i+=e}return l!==r?i+t.substring(l,r):i}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var o=t(402),a=t(403),i=t(404),r=!1,l=t(405).version,s=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=s.concat("cache"),d=/^\uFEFF/;function p(n,t){var a,i,r=t.views,l=/^[A-Za-z]+:\\|^\//.exec(n);if(l&&l.length)a=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(i=e.resolveInclude(n,t.filename),o.existsSync(i)&&(a=i)),a||Array.isArray(r)&&r.some((function(t){return i=e.resolveInclude(n,t,!0),o.existsSync(i)}))&&(a=i),!a)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return a}function u(n,t){var o,a=n.filename,i=arguments.length>1;if(n.cache){if(!a)throw new Error("cache option requires a filename");if(o=e.cache.get(a))return o;i||(t=h(a).toString().replace(d,""))}else if(!i){if(!a)throw new Error("Internal EJS error: no file name or template provided");t=h(a).toString().replace(d,"")}return o=e.compile(t,n),n.cache&&e.cache.set(a,o),o}function m(n,t,o){var a;if(!o){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,o){try{e(a=u(n)(t))}catch(n){o(n)}}));throw new Error("Please provide a callback function")}try{a=u(n)(t)}catch(n){return o(n)}o(null,a)}function h(n){return e.fileLoader(n)}function g(n,e,t,o,a){var i=e.split("\n"),r=Math.max(o-3,0),l=Math.min(i.length,o+3),s=a(t),c=i.slice(r,l).map((function(n,e){var t=e+r+1;return(t==o?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=s,n.message=(s||"ejs")+":"+o+"\n"+c+"\n\n"+n.message,n}function f(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var o={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],o.client=t.client||!1,o.escapeFunction=t.escape||t.escapeFunction||i.escapeXML,o.compileDebug=!1!==t.compileDebug,o.debug=!!t.debug,o.filename=t.filename,o.openDelimiter=t.openDelimiter||e.openDelimiter||"<",o.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",o.delimiter=t.delimiter||e.delimiter||"%",o.strict=t.strict||!1,o.context=t.context,o.cache=t.cache||!1,o.rmWhitespace=t.rmWhitespace,o.root=t.root,o.outputFunctionName=t.outputFunctionName,o.localsName=t.localsName||e.localsName||"locals",o.views=t.views,o.async=t.async,o.destructuredLocals=t.destructuredLocals,o.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,o.strict?o._with=!1:o._with=void 0===t._with||t._with,this.opts=o,this.regex=this.createRegex()}e.cache=i.cache,e.fileLoader=o.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var o=a.dirname,i=a.extname,r=(0,a.resolve)(t?e:o(e),n);return i(n)||(r+=".ejs"),r},e.compile=function(n,e){return e&&e.scope&&(r||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),r=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var o=e||{},a=t||{};return 2==arguments.length&&i.shallowCopyFromList(a,o,s),u(a,n)(o)},e.renderFile=function(){var n,e,t,o=Array.prototype.slice.call(arguments),a=o.shift(),r={filename:a};return"function"==typeof arguments[arguments.length-1]&&(n=o.pop()),o.length?(e=o.shift(),o.length?i.shallowCopy(r,o.pop()):(e.settings&&(e.settings.views&&(r.views=e.settings.views),e.settings["view cache"]&&(r.cache=!0),(t=e.settings["view options"])&&i.shallowCopy(r,t)),i.shallowCopyFromList(r,e,c)),r.filename=a):e={},m(r,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=i.escapeRegExpChars(this.opts.delimiter),t=i.escapeRegExpChars(this.opts.openDelimiter),o=i.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,o),new RegExp(n)},compile:function(){var n,e,t,o=this.opts,r="",l="",s=o.escapeFunction;if(!this.source){if(this.generateSource(),r+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',o.outputFunctionName&&(r+="  var "+o.outputFunctionName+" = __append;\n"),o.destructuredLocals&&o.destructuredLocals.length){for(var c="  var __locals = ("+o.localsName+" || {}),\n",d=0;d<o.destructuredLocals.length;d++){var m=o.destructuredLocals[d];d>0&&(c+=",\n  "),c+=m+" = __locals."+m}r+=c+";\n"}!1!==o._with&&(r+="  with ("+o.localsName+" || {}) {\n",l+="  }\n"),l+="  return __output;\n",this.source=r+this.source+l}n=o.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(o.filename?JSON.stringify(o.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,o.client&&(n="escapeFn = escapeFn || "+s.toString()+";\n"+n,o.compileDebug&&(n="rethrow = rethrow || "+g.toString()+";\n"+n)),o.strict&&(n='"use strict";\n'+n),o.debug&&console.log(n),o.compileDebug&&o.filename&&(n=n+"\n//# sourceURL="+o.filename+"\n");try{if(o.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(o.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(o.filename&&(n.message+=" in "+o.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",o.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var h=o.client?e:function(n){return e.apply(o.context,[n||{},s,function(e,t){var a=i.shallowCopy({},n);return t&&(a=i.shallowCopy(a,t)),function(n,e){var t=i.shallowCopy({},e);return t.filename=p(n,t),u(t)}(e,o)(a)},g])};if(h.dependencies=this.dependencies,o.filename&&"function"==typeof Object.defineProperty){var f=o.filename,v=a.basename(f,a.extname(f));try{Object.defineProperty(h,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return h},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,o=this.parseTemplateText(),a=this.opts.delimiter,r=this.opts.openDelimiter,l=this.opts.closeDelimiter;o&&o.length&&o.forEach((function(s,c){var u,m,g,f,b,x;if(0===s.indexOf(r+a)&&0!==s.indexOf(r+a+a)&&(m=o[c+2])!=a+l&&m!="-"+a+l&&m!="_"+a+l)throw new Error('Could not find matching close tag for "'+s+'".');if(n.legacyInclude&&(g=s.match(/^\s*include\s+(\S+)/))&&(u=o[c-1])&&(u==r+a||u==r+a+"-"||u==r+a+"_"))return f=i.shallowCopy({},t.opts),b=function(n,e){var t,o,a=i.shallowCopy({},e);o=h(t=p(n,a)).toString().replace(d,""),a.filename=t;var r=new v(o,a);return r.generateSource(),{source:r.source,filename:t,template:o}}(g[1],f),x=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(b.template)+"\n      , __filename = "+JSON.stringify(b.filename)+";\n      try {\n"+b.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+b.source+"    ; }).call(this)\n",t.source+=x,void t.dependencies.push(e.resolveInclude(g[1],f.filename));t.scanLine(s)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,o=t.exec(e),a=[];o;)0!==(n=o.index)&&(a.push(e.substring(0,n)),e=e.slice(n)),a.push(o[0]),e=e.slice(o[0].length),o=t.exec(e);return e&&a.push(e),a},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,o=this.opts.openDelimiter,a=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case o+t:case o+t+"_":this.mode=v.modes.EVAL;break;case o+t+"=":this.mode=v.modes.ESCAPED;break;case o+t+"-":this.mode=v.modes.RAW;break;case o+t+"#":this.mode=v.modes.COMMENT;break;case o+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(o+t+t,o+t)+'")\n';break;case t+t+a:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+a,t+a)+'")\n';break;case t+a:case"-"+t+a:case"_"+t+a:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+f(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+f(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=i.escapeXML,e.__express=e.renderFile,e.VERSION=l,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var o={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},a=(t(391),t(21)),i=Object(a.a)(o,(function(){var n=this.$createElement;return(this._self._c||n)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);t(29),t(5),t(30),t(44),t(25);var o={name:"CodeGroup",data:function(){return{codeTabs:[],activeCodeTabIndex:-1}},watch:{activeCodeTabIndex:function(n){this.codeTabs.forEach((function(n){n.elm.classList.remove("theme-code-block__active")})),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted:function(){var n=this;this.codeTabs=(this.$slots.default||[]).filter((function(n){return Boolean(n.componentOptions)})).map((function(e,t){return""===e.componentOptions.propsData.active&&(n.activeCodeTabIndex=t),{title:e.componentOptions.propsData.title,elm:e.elm}})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab:function(n){this.activeCodeTabIndex=n}}},a=(t(392),t(21)),i=Object(a.a)(o,(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"theme-code-group"},[t("div",{staticClass:"theme-code-group__nav"},[t("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(e,o){return t("li",{key:e.title,staticClass:"theme-code-group__li"},[t("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":o===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(o)}}},[n._v("\n            "+n._s(e.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?t("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e,t){"use strict";var o=t(8),a=t(0),i=t(3),r=t(110),l=t(14),s=t(9),c=t(154),d=t(36),p=t(67),u=t(163),m=t(2),h=t(61).f,g=t(37).f,f=t(13).f,v=t(387),b=t(157).trim,x=a.Number,y=x.prototype,w=a.TypeError,k=i("".slice),j=i("".charCodeAt),T=function(n){var e=u(n,"number");return"bigint"==typeof e?e:S(e)},S=function(n){var e,t,o,a,i,r,l,s,c=u(n,"number");if(p(c))throw w("Cannot convert a Symbol value to a number");if("string"==typeof c&&c.length>2)if(c=b(c),43===(e=j(c,0))||45===e){if(88===(t=j(c,2))||120===t)return NaN}else if(48===e){switch(j(c,1)){case 66:case 98:o=2,a=49;break;case 79:case 111:o=8,a=55;break;default:return+c}for(r=(i=k(c,2)).length,l=0;l<r;l++)if((s=j(i,l))<48||s>a)return NaN;return parseInt(i,o)}return+c};if(r("Number",!x(" 0o1")||!x("0b1")||x("+0x1"))){for(var E,I=function(n){var e=arguments.length<1?0:x(T(n)),t=this;return d(y,t)&&m((function(){v(t)}))?c(Object(e),t,I):e},z=o?h(x):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,isFinite,isInteger,isNaN,isSafeInteger,parseFloat,parseInt,fromString,range".split(","),C=0;z.length>C;C++)s(x,E=z[C])&&!s(I,E)&&f(I,E,g(x,E));I.prototype=y,y.constructor=I,l(a,"Number",I)}},function(n,e,t){var o=t(2),a=t(0).RegExp;n.exports=o((function(){var n=a(".","s");return!(n.dotAll&&n.exec("\n")&&"s"===n.flags)}))},function(n,e,t){"use strict";var o=t(167).IteratorPrototype,a=t(35),i=t(48),r=t(62),l=t(70),s=function(){return this};n.exports=function(n,e,t,c){var d=e+" Iterator";return n.prototype=a(o,{next:i(+!c,t)}),r(n,d,!1,!0),l[d]=s,n}},function(n,e,t){var o=t(14);n.exports=function(n,e,t){for(var a in e)o(n,a,e[a],t);return n}},function(n,e,t){"use strict";var o=t(15),a=t(13),i=t(6),r=t(8),l=i("species");n.exports=function(n){var e=o(n),t=a.f;r&&e&&!e[l]&&t(e,l,{configurable:!0,get:function(){return this}})}},function(n,e,t){var o=t(0),a=t(36),i=o.TypeError;n.exports=function(n,e){if(a(e,n))return n;throw i("Incorrect invocation")}},function(n,e,t){var o=t(2),a=t(0).RegExp;n.exports=o((function(){var n=a("(?<a>b)","g");return"b"!==n.exec("b").groups.a||"bc"!=="b".replace(n,"$<a>c")}))},function(n,e,t){var o=t(13).f;n.exports=function(n,e,t){t in n||o(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){"use strict";var o=t(1),a=t(119).includes,i=t(2),r=t(146);o({target:"Array",proto:!0,forced:i((function(){return!Array(1).includes()}))},{includes:function(n){return a(this,n,arguments.length>1?arguments[1]:void 0)}}),r("includes")},function(n,e,t){"use strict";var o=t(1),a=t(3),i=t(184),r=t(19),l=t(12),s=t(185),c=a("".indexOf);o({target:"String",proto:!0,forced:!s("includes")},{includes:function(n){return!!~c(l(r(this)),l(i(n)),arguments.length>1?arguments[1]:void 0)}})},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){"use strict";var o=t(1),a=t(157).trim;o({target:"String",proto:!0,forced:t(385)("trim")},{trim:function(){return a(this)}})},function(n,e,t){var o=t(7),a=t(9),i=t(36),r=t(193),l=RegExp.prototype;n.exports=function(n){var e=n.flags;return void 0!==e||"flags"in l||a(n,"flags")||!i(l,n)?e:o(r,n)}},function(n,e,t){var o=t(129),a=Math.floor,i=function(n,e){var t=n.length,s=a(t/2);return t<8?r(n,e):l(n,i(o(n,0,s),e),i(o(n,s),e),e)},r=function(n,e){for(var t,o,a=n.length,i=1;i<a;){for(o=i,t=n[i];o&&e(n[o-1],t)>0;)n[o]=n[--o];o!==i++&&(n[o]=t)}return n},l=function(n,e,t,o){for(var a=e.length,i=t.length,r=0,l=0;r<a||l<i;)n[r+l]=r<a&&l<i?o(e[r],t[l])<=0?e[r++]:t[l++]:r<a?e[r++]:t[l++];return n};n.exports=i},function(n,e,t){var o=t(0),a=t(8),i=t(112).MISSED_STICKY,r=t(27),l=t(13).f,s=t(38).get,c=RegExp.prototype,d=o.TypeError;a&&i&&l(c,"sticky",{configurable:!0,get:function(){if(this!==c){if("RegExp"===r(this))return!!s(this).sticky;throw d("Incompatible receiver, RegExp required")}}})},function(n,e,t){n.exports=t(408)},function(n,e,t){var o=t(0),a=t(7),i=t(4),r=t(11),l=o.TypeError;n.exports=function(n,e){var t,o;if("string"===e&&i(t=n.toString)&&!r(o=a(t,n)))return o;if(i(t=n.valueOf)&&!r(o=a(t,n)))return o;if("string"!==e&&i(t=n.toString)&&!r(o=a(t,n)))return o;throw l("Can't convert object to primitive value")}},function(n,e,t){var o=t(0),a=t(4),i=t(91),r=o.WeakMap;n.exports=a(r)&&/native code/.test(i(r))},function(n,e,t){var o=t(0),a=t(4),i=o.String,r=o.TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw r("Can't set "+i(n)+" as a prototype")}},function(n,e,t){t(250),t(257),t(258),t(259),t(260),t(261)},function(n,e,t){"use strict";var o,a,i,r=t(1),l=t(16),s=t(93),c=t(0),d=t(7),p=t(14),u=t(233),m=t(72),h=t(62),g=t(234),f=t(23),v=t(4),b=t(11),x=t(235),y=t(126),w=t(170).set,k=t(251),j=t(254),T=t(128),S=t(255),E=t(38),I=t(55),z=t(74),C=t(75),A=z.CONSTRUCTOR,_=z.REJECTION_EVENT,P=z.SUBCLASSING,B=E.getterFor("Promise"),M=E.set,O=I&&I.prototype,D=I,$=O,L=c.TypeError,N=c.document,V=c.process,U=C.f,H=U,R=!!(N&&N.createEvent&&c.dispatchEvent),q=function(n){var e;return!(!b(n)||!v(e=n.then))&&e},F=function(n,e){var t,o,a,i=e.value,r=1==e.state,l=r?n.ok:n.fail,s=n.resolve,c=n.reject,p=n.domain;try{l?(r||(2===e.rejection&&Y(e),e.rejection=1),!0===l?t=i:(p&&p.enter(),t=l(i),p&&(p.exit(),a=!0)),t===n.promise?c(L("Promise-chain cycle")):(o=q(t))?d(o,t,s,c):s(t)):c(i)}catch(n){p&&!a&&p.exit(),c(n)}},J=function(n,e){n.notified||(n.notified=!0,k((function(){for(var t,o=n.reactions;t=o.get();)F(t,n);n.notified=!1,e&&!n.rejection&&W(n)})))},G=function(n,e,t){var o,a;R?((o=N.createEvent("Event")).promise=e,o.reason=t,o.initEvent(n,!1,!0),c.dispatchEvent(o)):o={promise:e,reason:t},!_&&(a=c["on"+n])?a(o):"unhandledrejection"===n&&j("Unhandled promise rejection",t)},W=function(n){d(w,c,(function(){var e,t=n.facade,o=n.value;if(Z(n)&&(e=T((function(){s?V.emit("unhandledRejection",o,t):G("unhandledrejection",t,o)})),n.rejection=s||Z(n)?2:1,e.error))throw e.value}))},Z=function(n){return 1!==n.rejection&&!n.parent},Y=function(n){d(w,c,(function(){var e=n.facade;s?V.emit("rejectionHandled",e):G("rejectionhandled",e,n.value)}))},X=function(n,e,t){return function(o){n(e,o,t)}},K=function(n,e,t){n.done||(n.done=!0,t&&(n=t),n.value=e,n.state=2,J(n,!0))},Q=function(n,e,t){if(!n.done){n.done=!0,t&&(n=t);try{if(n.facade===e)throw L("Promise can't be resolved itself");var o=q(e);o?k((function(){var t={done:!1};try{d(o,e,X(Q,t,n),X(K,t,n))}catch(e){K(t,e,n)}})):(n.value=e,n.state=1,J(n,!1))}catch(e){K({done:!1},e,n)}}};if(A&&($=(D=function(n){x(this,$),f(n),d(o,this);var e=B(this);try{n(X(Q,e),X(K,e))}catch(n){K(e,n)}}).prototype,(o=function(n){M(this,{type:"Promise",done:!1,notified:!1,parent:!1,reactions:new S,rejection:!1,state:0,value:void 0})}).prototype=u($,{then:function(n,e){var t=B(this),o=U(y(this,D));return t.parent=!0,o.ok=!v(n)||n,o.fail=v(e)&&e,o.domain=s?V.domain:void 0,0==t.state?t.reactions.add(o):k((function(){F(o,t)})),o.promise}}),a=function(){var n=new o,e=B(n);this.promise=n,this.resolve=X(Q,e),this.reject=X(K,e)},C.f=U=function(n){return n===D||void 0===n?new a(n):H(n)},!l&&v(I)&&O!==Object.prototype)){i=O.then,P||p(O,"then",(function(n,e){var t=this;return new D((function(n,e){d(i,t,n,e)})).then(n,e)}),{unsafe:!0});try{delete O.constructor}catch(n){}m&&m(O,$)}r({global:!0,wrap:!0,forced:A},{Promise:D}),h(D,"Promise",!1,!0),g("Promise")},function(n,e,t){var o,a,i,r,l,s,c,d,p=t(0),u=t(59),m=t(37).f,h=t(170).set,g=t(171),f=t(252),v=t(253),b=t(93),x=p.MutationObserver||p.WebKitMutationObserver,y=p.document,w=p.process,k=p.Promise,j=m(p,"queueMicrotask"),T=j&&j.value;T||(o=function(){var n,e;for(b&&(n=w.domain)&&n.exit();a;){e=a.fn,a=a.next;try{e()}catch(n){throw a?r():i=void 0,n}}i=void 0,n&&n.enter()},g||b||v||!x||!y?!f&&k&&k.resolve?((c=k.resolve(void 0)).constructor=k,d=u(c.then,c),r=function(){d(o)}):b?r=function(){w.nextTick(o)}:(h=u(h,p),r=function(){h(o)}):(l=!0,s=y.createTextNode(""),new x(o).observe(s,{characterData:!0}),r=function(){s.data=l=!l})),n.exports=T||function(n){var e={fn:n,next:void 0};i&&(i.next=e),a||(a=e,r()),i=e}},function(n,e,t){var o=t(33),a=t(0);n.exports=/ipad|iphone|ipod/i.test(o)&&void 0!==a.Pebble},function(n,e,t){var o=t(33);n.exports=/web0s(?!.*chrome)/i.test(o)},function(n,e,t){var o=t(0);n.exports=function(n,e){var t=o.console;t&&t.error&&(1==arguments.length?t.error(n):t.error(n,e))}},function(n,e){var t=function(){this.head=null,this.tail=null};t.prototype={add:function(n){var e={item:n,next:null};this.head?this.tail.next=e:this.head=e,this.tail=e},get:function(){var n=this.head;if(n)return this.head=n.next,this.tail===n&&(this.tail=null),n.item}},n.exports=t},function(n,e){n.exports="object"==typeof window&&"object"!=typeof Deno},function(n,e,t){"use strict";var o=t(1),a=t(7),i=t(23),r=t(75),l=t(128),s=t(172);o({target:"Promise",stat:!0,forced:t(175)},{all:function(n){var e=this,t=r.f(e),o=t.resolve,c=t.reject,d=l((function(){var t=i(e.resolve),r=[],l=0,d=1;s(n,(function(n){var i=l++,s=!1;d++,a(t,e,n).then((function(n){s||(s=!0,r[i]=n,--d||o(r))}),c)})),--d||o(r)}));return d.error&&c(d.value),t.promise}})},function(n,e,t){"use strict";var o=t(1),a=t(16),i=t(74).CONSTRUCTOR,r=t(55),l=t(15),s=t(4),c=t(14),d=r&&r.prototype;if(o({target:"Promise",proto:!0,forced:i,real:!0},{catch:function(n){return this.then(void 0,n)}}),!a&&s(r)){var p=l("Promise").prototype.catch;d.catch!==p&&c(d,"catch",p,{unsafe:!0})}},function(n,e,t){"use strict";var o=t(1),a=t(7),i=t(23),r=t(75),l=t(128),s=t(172);o({target:"Promise",stat:!0,forced:t(175)},{race:function(n){var e=this,t=r.f(e),o=t.reject,c=l((function(){var r=i(e.resolve);s(n,(function(n){a(r,e,n).then(t.resolve,o)}))}));return c.error&&o(c.value),t.promise}})},function(n,e,t){"use strict";var o=t(1),a=t(7),i=t(75);o({target:"Promise",stat:!0,forced:t(74).CONSTRUCTOR},{reject:function(n){var e=i.f(this);return a(e.reject,void 0,n),e.promise}})},function(n,e,t){"use strict";var o=t(1),a=t(15),i=t(16),r=t(55),l=t(74).CONSTRUCTOR,s=t(177),c=a("Promise"),d=i&&!l;o({target:"Promise",stat:!0,forced:i||l},{resolve:function(n){return s(d&&this===c?r:this,n)}})},function(n,e,t){var o=t(1),a=t(263);o({target:"Object",stat:!0,forced:Object.assign!==a},{assign:a})},function(n,e,t){"use strict";var o=t(8),a=t(3),i=t(7),r=t(2),l=t(89),s=t(92),c=t(122),d=t(17),p=t(65),u=Object.assign,m=Object.defineProperty,h=a([].concat);n.exports=!u||r((function(){if(o&&1!==u({b:1},u(m({},"a",{enumerable:!0,get:function(){m(this,"b",{value:3,enumerable:!1})}}),{b:2})).b)return!0;var n={},e={},t=Symbol();return n[t]=7,"abcdefghijklmnopqrst".split("").forEach((function(n){e[n]=n})),7!=u({},n)[t]||"abcdefghijklmnopqrst"!=l(u({},e)).join("")}))?function(n,e){for(var t=d(n),a=arguments.length,r=1,u=s.f,m=c.f;a>r;)for(var g,f=p(arguments[r++]),v=u?h(l(f),u(f)):l(f),b=v.length,x=0;b>x;)g=v[x++],o&&!i(m,f,g)||(t[g]=f[g]);return t}:u},function(n,e,t){"use strict";var o=t(1),a=t(16),i=t(55),r=t(2),l=t(15),s=t(4),c=t(126),d=t(177),p=t(14),u=i&&i.prototype;if(o({target:"Promise",proto:!0,real:!0,forced:!!i&&r((function(){u.finally.call({then:function(){}},(function(){}))}))},{finally:function(n){var e=c(this,l("Promise")),t=s(n);return this.then(t?function(t){return d(e,n()).then((function(){return t}))}:n,t?function(t){return d(e,n()).then((function(){throw t}))}:n)}}),!a&&s(i)){var m=l("Promise").prototype.finally;u.finally!==m&&p(u,"finally",m,{unsafe:!0})}},function(n,e,t){"use strict";var o=t(127),a=t(83);n.exports=o?{}.toString:function(){return"[object "+a(this)+"]"}},function(n,e,t){var o=t(0),a=t(63),i=t(94),r=t(11),l=t(6)("species"),s=o.Array;n.exports=function(n){var e;return a(n)&&(e=n.constructor,(i(e)&&(e===s||a(e.prototype))||r(e)&&null===(e=e[l]))&&(e=void 0)),void 0===e?s:e}},function(n,e,t){"use strict";var o=t(1),a=t(268).left,i=t(46),r=t(53),l=t(93);o({target:"Array",proto:!0,forced:!i("reduce")||!l&&r>79&&r<83},{reduce:function(n){var e=arguments.length;return a(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){var o=t(0),a=t(23),i=t(17),r=t(65),l=t(24),s=o.TypeError,c=function(n){return function(e,t,o,c){a(t);var d=i(e),p=r(d),u=l(d),m=n?u-1:0,h=n?-1:1;if(o<2)for(;;){if(m in p){c=p[m],m+=h;break}if(m+=h,n?m<0:u<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:u>m;m+=h)m in p&&(c=t(c,p[m],m,d));return c}};n.exports={left:c(!1),right:c(!0)}},function(n,e,t){var o=t(1),a=t(187),i=t(2),r=t(11),l=t(270).onFreeze,s=Object.freeze;o({target:"Object",stat:!0,forced:i((function(){s(1)})),sham:!a},{freeze:function(n){return s&&r(n)?s(l(n)):n}})},function(n,e,t){var o=t(1),a=t(3),i=t(69),r=t(11),l=t(9),s=t(13).f,c=t(61),d=t(188),p=t(271),u=t(86),m=t(187),h=!1,g=u("meta"),f=0,v=function(n){s(n,g,{value:{objectID:"O"+f++,weakData:{}}})},b=n.exports={enable:function(){b.enable=function(){},h=!0;var n=c.f,e=a([].splice),t={};t[g]=1,n(t).length&&(c.f=function(t){for(var o=n(t),a=0,i=o.length;a<i;a++)if(o[a]===g){e(o,a,1);break}return o},o({target:"Object",stat:!0,forced:!0},{getOwnPropertyNames:d.f}))},fastKey:function(n,e){if(!r(n))return"symbol"==typeof n?n:("string"==typeof n?"S":"P")+n;if(!l(n,g)){if(!p(n))return"F";if(!e)return"E";v(n)}return n[g].objectID},getWeakData:function(n,e){if(!l(n,g)){if(!p(n))return!0;if(!e)return!1;v(n)}return n[g].weakData},onFreeze:function(n){return m&&h&&p(n)&&!l(n,g)&&v(n),n}};i[g]=!0},function(n,e,t){var o=t(2),a=t(11),i=t(27),r=t(272),l=Object.isExtensible,s=o((function(){l(1)}));n.exports=s||r?function(n){return!!a(n)&&((!r||"ArrayBuffer"!=i(n))&&(!l||l(n)))}:l},function(n,e,t){var o=t(2);n.exports=o((function(){if("function"==typeof ArrayBuffer){var n=new ArrayBuffer(8);Object.isExtensible(n)&&Object.defineProperty(n,"a",{value:8})}}))},function(n,e,t){"use strict";var o=t(1),a=t(0),i=t(7),r=t(3),l=t(16),s=t(8),c=t(52),d=t(2),p=t(9),u=t(36),m=t(10),h=t(20),g=t(88),f=t(12),v=t(48),b=t(35),x=t(89),y=t(61),w=t(188),k=t(92),j=t(37),T=t(13),S=t(118),E=t(122),I=t(14),z=t(51),C=t(90),A=t(69),_=t(86),P=t(6),B=t(189),M=t(190),O=t(275),D=t(62),$=t(38),L=t(60).forEach,N=C("hidden"),V=$.set,U=$.getterFor("Symbol"),H=Object.prototype,R=a.Symbol,q=R&&R.prototype,F=a.TypeError,J=a.QObject,G=j.f,W=T.f,Z=w.f,Y=E.f,X=r([].push),K=z("symbols"),Q=z("op-symbols"),nn=z("wks"),en=!J||!J.prototype||!J.prototype.findChild,tn=s&&d((function(){return 7!=b(W({},"a",{get:function(){return W(this,"a",{value:7}).a}})).a}))?function(n,e,t){var o=G(H,e);o&&delete H[e],W(n,e,t),o&&n!==H&&W(H,e,o)}:W,on=function(n,e){var t=K[n]=b(q);return V(t,{type:"Symbol",tag:n,description:e}),s||(t.description=e),t},an=function(n,e,t){n===H&&an(Q,e,t),m(n);var o=g(e);return m(t),p(K,o)?(t.enumerable?(p(n,N)&&n[N][o]&&(n[N][o]=!1),t=b(t,{enumerable:v(0,!1)})):(p(n,N)||W(n,N,v(1,{})),n[N][o]=!0),tn(n,o,t)):W(n,o,t)},rn=function(n,e){m(n);var t=h(e),o=x(t).concat(dn(t));return L(o,(function(e){s&&!i(ln,t,e)||an(n,e,t[e])})),n},ln=function(n){var e=g(n),t=i(Y,this,e);return!(this===H&&p(K,e)&&!p(Q,e))&&(!(t||!p(this,e)||!p(K,e)||p(this,N)&&this[N][e])||t)},sn=function(n,e){var t=h(n),o=g(e);if(t!==H||!p(K,o)||p(Q,o)){var a=G(t,o);return!a||!p(K,o)||p(t,N)&&t[N][o]||(a.enumerable=!0),a}},cn=function(n){var e=Z(h(n)),t=[];return L(e,(function(n){p(K,n)||p(A,n)||X(t,n)})),t},dn=function(n){var e=n===H,t=Z(e?Q:h(n)),o=[];return L(t,(function(n){!p(K,n)||e&&!p(H,n)||X(o,K[n])})),o};c||(I(q=(R=function(){if(u(q,this))throw F("Symbol is not a constructor");var n=arguments.length&&void 0!==arguments[0]?f(arguments[0]):void 0,e=_(n),t=function(n){this===H&&i(t,Q,n),p(this,N)&&p(this[N],e)&&(this[N][e]=!1),tn(this,e,v(1,n))};return s&&en&&tn(H,e,{configurable:!0,set:t}),on(e,n)}).prototype,"toString",(function(){return U(this).tag})),I(R,"withoutSetter",(function(n){return on(_(n),n)})),E.f=ln,T.f=an,S.f=rn,j.f=sn,y.f=w.f=cn,k.f=dn,B.f=function(n){return on(P(n),n)},s&&(W(q,"description",{configurable:!0,get:function(){return U(this).description}}),l||I(H,"propertyIsEnumerable",ln,{unsafe:!0}))),o({global:!0,wrap:!0,forced:!c,sham:!c},{Symbol:R}),L(x(nn),(function(n){M(n)})),o({target:"Symbol",stat:!0,forced:!c},{useSetter:function(){en=!0},useSimple:function(){en=!1}}),o({target:"Object",stat:!0,forced:!c,sham:!s},{create:function(n,e){return void 0===e?b(n):rn(b(n),e)},defineProperty:an,defineProperties:rn,getOwnPropertyDescriptor:sn}),o({target:"Object",stat:!0,forced:!c},{getOwnPropertyNames:cn}),O(),D(R,"Symbol"),A[N]=!0},function(n,e,t){var o=t(0);n.exports=o},function(n,e,t){var o=t(7),a=t(15),i=t(6),r=t(14);n.exports=function(){var n=a("Symbol"),e=n&&n.prototype,t=e&&e.valueOf,l=i("toPrimitive");e&&!e[l]&&r(e,l,(function(n){return o(t,this)}))}},function(n,e,t){var o=t(1),a=t(15),i=t(9),r=t(12),l=t(51),s=t(191),c=l("string-to-symbol-registry"),d=l("symbol-to-string-registry");o({target:"Symbol",stat:!0,forced:!s},{for:function(n){var e=r(n);if(i(c,e))return c[e];var t=a("Symbol")(e);return c[e]=t,d[t]=e,t}})},function(n,e,t){var o=t(1),a=t(9),i=t(67),r=t(68),l=t(51),s=t(191),c=l("symbol-to-string-registry");o({target:"Symbol",stat:!0,forced:!s},{keyFor:function(n){if(!i(n))throw TypeError(r(n)+" is not a symbol");if(a(c,n))return c[n]}})},function(n,e,t){var o=t(1),a=t(52),i=t(2),r=t(92),l=t(17);o({target:"Object",stat:!0,forced:!a||i((function(){r.f(1)}))},{getOwnPropertySymbols:function(n){var e=r.f;return e?e(l(n)):[]}})},function(n,e,t){"use strict";var o=t(0),a=t(59),i=t(7),r=t(17),l=t(280),s=t(173),c=t(94),d=t(24),p=t(76),u=t(151),m=t(111),h=o.Array;n.exports=function(n){var e=r(n),t=c(this),o=arguments.length,g=o>1?arguments[1]:void 0,f=void 0!==g;f&&(g=a(g,o>2?arguments[2]:void 0));var v,b,x,y,w,k,j=m(e),T=0;if(!j||this==h&&s(j))for(v=d(e),b=t?new this(v):h(v);v>T;T++)k=f?g(e[T],T):e[T],p(b,T,k);else for(w=(y=u(e,j)).next,b=t?new this:[];!(x=i(w,y)).done;T++)k=f?l(y,g,[x.value,T],!0):x.value,p(b,T,k);return b.length=T,b}},function(n,e,t){var o=t(10),a=t(174);n.exports=function(n,e,t,i){try{return i?e(o(t)[0],t[1]):e(t)}catch(e){a(n,"throw",e)}}},function(n,e,t){"use strict";var o=t(15),a=t(9),i=t(28),r=t(36),l=t(72),s=t(123),c=t(237),d=t(154),p=t(194),u=t(282),m=t(283),h=t(284),g=t(8),f=t(16);n.exports=function(n,e,t,v){var b=v?2:1,x=n.split("."),y=x[x.length-1],w=o.apply(null,x);if(w){var k=w.prototype;if(!f&&a(k,"cause")&&delete k.cause,!t)return w;var j=o("Error"),T=e((function(n,e){var t=p(v?e:n,void 0),o=v?new w(n):new w;return void 0!==t&&i(o,"message",t),h&&i(o,"stack",m(o.stack,2)),this&&r(k,this)&&d(o,this,T),arguments.length>b&&u(o,arguments[b]),o}));if(T.prototype=k,"Error"!==y?l?l(T,j):s(T,j,{name:!0}):g&&"stackTraceLimit"in w&&(c(T,w,"stackTraceLimit"),c(T,w,"prepareStackTrace")),s(T,w),!f)try{k.name!==y&&i(k,"name",y),k.constructor=T}catch(n){}return T}}},function(n,e,t){var o=t(11),a=t(28);n.exports=function(n,e){o(e)&&"cause"in e&&a(n,"cause",e.cause)}},function(n,e,t){var o=t(3),a=Error,i=o("".replace),r=String(a("zxcasd").stack),l=/\n\s*at [^:]*:[^\n]*/,s=l.test(r);n.exports=function(n,e){if(s&&"string"==typeof n&&!a.prepareStackTrace)for(;e--;)n=i(n,l,"");return n}},function(n,e,t){var o=t(2),a=t(48);n.exports=!o((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",a(1,7)),7!==n.stack)}))},function(n,e,t){"use strict";var o=t(8),a=t(2),i=t(10),r=t(35),l=t(194),s=Error.prototype.toString,c=a((function(){if(o){var n=r(Object.defineProperty({},"name",{get:function(){return this===n}}));if("true"!==s.call(n))return!0}return"2: 1"!==s.call({message:1,name:2})||"Error"!==s.call({})}));n.exports=c?function(){var n=i(this),e=l(n.name,"Error"),t=l(n.message);return e?t?e+": "+t:e:t}:s},function(n,e,t){var o=t(3),a=t(17),i=Math.floor,r=o("".charAt),l=o("".replace),s=o("".slice),c=/\$([$&'`]|\d{1,2}|<[^>]*>)/g,d=/\$([$&'`]|\d{1,2})/g;n.exports=function(n,e,t,o,p,u){var m=t+n.length,h=o.length,g=d;return void 0!==p&&(p=a(p),g=c),l(u,g,(function(a,l){var c;switch(r(l,0)){case"$":return"$";case"&":return n;case"`":return s(e,0,t);case"'":return s(e,m);case"<":c=p[s(l,1,-1)];break;default:var d=+l;if(0===d)return a;if(d>h){var u=i(d/10);return 0===u?a:u<=h?void 0===o[u-1]?r(l,1):o[u-1]+r(l,1):a}c=o[d-1]}return void 0===c?"":c}))}},function(n,e,t){var o=t(196),a=t(288);n.exports=function n(e,t,i,r,l){var s=-1,c=e.length;for(i||(i=a),l||(l=[]);++s<c;){var d=e[s];t>0&&i(d)?t>1?n(d,t-1,i,r,l):o(l,d):r||(l[l.length]=d)}return l}},function(n,e,t){var o=t(78),a=t(133),i=t(32),r=o?o.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||a(n)||!!(r&&n&&n[r])}},function(n,e,t){var o=t(64),a=t(49);n.exports=function(n){return a(n)&&"[object Arguments]"==o(n)}},function(n,e,t){var o=t(78),a=Object.prototype,i=a.hasOwnProperty,r=a.toString,l=o?o.toStringTag:void 0;n.exports=function(n){var e=i.call(n,l),t=n[l];try{n[l]=void 0;var o=!0}catch(n){}var a=r.call(n);return o&&(e?n[l]=t:delete n[l]),a}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var o=t(293),a=t(349),i=t(141),r=t(32),l=t(360);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?r(n)?a(n[0],n[1]):o(n):l(n)}},function(n,e,t){var o=t(294),a=t(348),i=t(213);n.exports=function(n){var e=a(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||o(t,n,e)}}},function(n,e,t){var o=t(198),a=t(202);n.exports=function(n,e,t,i){var r=t.length,l=r,s=!i;if(null==n)return!l;for(n=Object(n);r--;){var c=t[r];if(s&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++r<l;){var d=(c=t[r])[0],p=n[d],u=c[1];if(s&&c[2]){if(void 0===p&&!(d in n))return!1}else{var m=new o;if(i)var h=i(p,u,d,n,e,m);if(!(void 0===h?a(u,p,3,i,m):h))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var o=t(100),a=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=o(e,n);return!(t<0)&&(t==e.length-1?e.pop():a.call(e,t,1),--this.size,!0)}},function(n,e,t){var o=t(100);n.exports=function(n){var e=this.__data__,t=o(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var o=t(100);n.exports=function(n){return o(this.__data__,n)>-1}},function(n,e,t){var o=t(100);n.exports=function(n,e){var t=this.__data__,a=o(t,n);return a<0?(++this.size,t.push([n,e])):t[a][1]=e,this}},function(n,e,t){var o=t(99);n.exports=function(){this.__data__=new o,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var o=t(99),a=t(134),i=t(136);n.exports=function(n,e){var t=this.__data__;if(t instanceof o){var r=t.__data__;if(!a||r.length<199)return r.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(r)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var o=t(200),a=t(306),i=t(135),r=t(201),l=/^\[object .+?Constructor\]$/,s=Function.prototype,c=Object.prototype,d=s.toString,p=c.hasOwnProperty,u=RegExp("^"+d.call(p).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||a(n))&&(o(n)?u:l).test(r(n))}},function(n,e,t){var o,a=t(307),i=(o=/[^.]+$/.exec(a&&a.keys&&a.keys.IE_PROTO||""))?"Symbol(src)_1."+o:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var o=t(34)["__core-js_shared__"];n.exports=o},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var o=t(310),a=t(99),i=t(134);n.exports=function(){this.size=0,this.__data__={hash:new o,map:new(i||a),string:new o}}},function(n,e,t){var o=t(311),a=t(312),i=t(313),r=t(314),l=t(315);function s(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var o=n[e];this.set(o[0],o[1])}}s.prototype.clear=o,s.prototype.delete=a,s.prototype.get=i,s.prototype.has=r,s.prototype.set=l,n.exports=s},function(n,e,t){var o=t(101);n.exports=function(){this.__data__=o?o(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var o=t(101),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(o){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return a.call(e,n)?e[n]:void 0}},function(n,e,t){var o=t(101),a=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return o?void 0!==e[n]:a.call(e,n)}},function(n,e,t){var o=t(101);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=o&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var o=t(102);n.exports=function(n){var e=o(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var o=t(102);n.exports=function(n){return o(this,n).get(n)}},function(n,e,t){var o=t(102);n.exports=function(n){return o(this,n).has(n)}},function(n,e,t){var o=t(102);n.exports=function(n,e){var t=o(this,n),a=t.size;return t.set(n,e),this.size+=t.size==a?0:1,this}},function(n,e,t){var o=t(198),a=t(203),i=t(325),r=t(328),l=t(344),s=t(32),c=t(207),d=t(209),p="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,h,g){var f=s(n),v=s(e),b=f?"[object Array]":l(n),x=v?"[object Array]":l(e),y=(b="[object Arguments]"==b?p:b)==p,w=(x="[object Arguments]"==x?p:x)==p,k=b==x;if(k&&c(n)){if(!c(e))return!1;f=!0,y=!1}if(k&&!y)return g||(g=new o),f||d(n)?a(n,e,t,m,h,g):i(n,e,b,t,m,h,g);if(!(1&t)){var j=y&&u.call(n,"__wrapped__"),T=w&&u.call(e,"__wrapped__");if(j||T){var S=j?n.value():n,E=T?e.value():e;return g||(g=new o),h(S,E,t,m,g)}}return!!k&&(g||(g=new o),r(n,e,t,m,h,g))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length;++t<o;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var o=t(78),a=t(326),i=t(199),r=t(203),l=t(327),s=t(137),c=o?o.prototype:void 0,d=c?c.valueOf:void 0;n.exports=function(n,e,t,o,c,p,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!p(new a(n),new a(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=l;case"[object Set]":var h=1&o;if(m||(m=s),n.size!=e.size&&!h)return!1;var g=u.get(n);if(g)return g==e;o|=2,u.set(n,e);var f=r(m(n),m(e),o,c,p,u);return u.delete(n),f;case"[object Symbol]":if(d)return d.call(n)==d.call(e)}return!1}},function(n,e,t){var o=t(34).Uint8Array;n.exports=o},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,o){t[++e]=[o,n]})),t}},function(n,e,t){var o=t(329),a=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,r,l){var s=1&t,c=o(n),d=c.length;if(d!=o(e).length&&!s)return!1;for(var p=d;p--;){var u=c[p];if(!(s?u in e:a.call(e,u)))return!1}var m=l.get(n),h=l.get(e);if(m&&h)return m==e&&h==n;var g=!0;l.set(n,e),l.set(e,n);for(var f=s;++p<d;){var v=n[u=c[p]],b=e[u];if(i)var x=s?i(b,v,u,e,n,l):i(v,b,u,n,e,l);if(!(void 0===x?v===b||r(v,b,t,i,l):x)){g=!1;break}f||(f="constructor"==u)}if(g&&!f){var y=n.constructor,w=e.constructor;y==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof y&&y instanceof y&&"function"==typeof w&&w instanceof w||(g=!1)}return l.delete(n),l.delete(e),g}},function(n,e,t){var o=t(330),a=t(331),i=t(206);n.exports=function(n){return o(n,i,a)}},function(n,e,t){var o=t(196),a=t(32);n.exports=function(n,e,t){var i=e(n);return a(n)?i:o(i,t(n))}},function(n,e,t){var o=t(332),a=t(333),i=Object.prototype.propertyIsEnumerable,r=Object.getOwnPropertySymbols,l=r?function(n){return null==n?[]:(n=Object(n),o(r(n),(function(e){return i.call(n,e)})))}:a;n.exports=l},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,a=0,i=[];++t<o;){var r=n[t];e(r,t,n)&&(i[a++]=r)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var o=t(335),a=t(133),i=t(32),r=t(207),l=t(208),s=t(209),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),d=!t&&a(n),p=!t&&!d&&r(n),u=!t&&!d&&!p&&s(n),m=t||d||p||u,h=m?o(n.length,String):[],g=h.length;for(var f in n)!e&&!c.call(n,f)||m&&("length"==f||p&&("offset"==f||"parent"==f)||u&&("buffer"==f||"byteLength"==f||"byteOffset"==f)||l(f,g))||h.push(f);return h}},function(n,e){n.exports=function(n,e){for(var t=-1,o=Array(n);++t<n;)o[t]=e(t);return o}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var o=t(64),a=t(138),i=t(49),r={};r["[object Float32Array]"]=r["[object Float64Array]"]=r["[object Int8Array]"]=r["[object Int16Array]"]=r["[object Int32Array]"]=r["[object Uint8Array]"]=r["[object Uint8ClampedArray]"]=r["[object Uint16Array]"]=r["[object Uint32Array]"]=!0,r["[object Arguments]"]=r["[object Array]"]=r["[object ArrayBuffer]"]=r["[object Boolean]"]=r["[object DataView]"]=r["[object Date]"]=r["[object Error]"]=r["[object Function]"]=r["[object Map]"]=r["[object Number]"]=r["[object Object]"]=r["[object RegExp]"]=r["[object Set]"]=r["[object String]"]=r["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&a(n.length)&&!!r[o(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var o=t(197),a=e&&!e.nodeType&&e,i=a&&"object"==typeof n&&n&&!n.nodeType&&n,r=i&&i.exports===a&&o.process,l=function(){try{var n=i&&i.require&&i.require("util").types;return n||r&&r.binding&&r.binding("util")}catch(n){}}();n.exports=l}).call(this,t(155)(n))},function(n,e,t){var o=t(341),a=t(342),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!o(n))return a(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var o=t(343)(Object.keys,Object);n.exports=o},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var o=t(345),a=t(134),i=t(346),r=t(211),l=t(347),s=t(64),c=t(201),d=c(o),p=c(a),u=c(i),m=c(r),h=c(l),g=s;(o&&"[object DataView]"!=g(new o(new ArrayBuffer(1)))||a&&"[object Map]"!=g(new a)||i&&"[object Promise]"!=g(i.resolve())||r&&"[object Set]"!=g(new r)||l&&"[object WeakMap]"!=g(new l))&&(g=function(n){var e=s(n),t="[object Object]"==e?n.constructor:void 0,o=t?c(t):"";if(o)switch(o){case d:return"[object DataView]";case p:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case h:return"[object WeakMap]"}return e}),n.exports=g},function(n,e,t){var o=t(41)(t(34),"DataView");n.exports=o},function(n,e,t){var o=t(41)(t(34),"Promise");n.exports=o},function(n,e,t){var o=t(41)(t(34),"WeakMap");n.exports=o},function(n,e,t){var o=t(212),a=t(206);n.exports=function(n){for(var e=a(n),t=e.length;t--;){var i=e[t],r=n[i];e[t]=[i,r,o(r)]}return e}},function(n,e,t){var o=t(202),a=t(350),i=t(357),r=t(139),l=t(212),s=t(213),c=t(103);n.exports=function(n,e){return r(n)&&l(e)?s(c(n),e):function(t){var r=a(t,n);return void 0===r&&r===e?i(t,n):o(e,r,3)}}},function(n,e,t){var o=t(214);n.exports=function(n,e,t){var a=null==n?void 0:o(n,e);return void 0===a?t:a}},function(n,e,t){var o=t(352),a=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,r=o((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(a,(function(n,t,o,a){e.push(o?a.replace(i,"$1"):t||n)})),e}));n.exports=r},function(n,e,t){var o=t(353);n.exports=function(n){var e=o(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var o=t(136);function a(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var o=arguments,a=e?e.apply(this,o):o[0],i=t.cache;if(i.has(a))return i.get(a);var r=n.apply(this,o);return t.cache=i.set(a,r)||i,r};return t.cache=new(a.Cache||o),t}a.Cache=o,n.exports=a},function(n,e,t){var o=t(355);n.exports=function(n){return null==n?"":o(n)}},function(n,e,t){var o=t(78),a=t(356),i=t(32),r=t(140),l=o?o.prototype:void 0,s=l?l.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return a(e,n)+"";if(r(e))return s?s.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,o=null==n?0:n.length,a=Array(o);++t<o;)a[t]=e(n[t],t,n);return a}},function(n,e,t){var o=t(358),a=t(359);n.exports=function(n,e){return null!=n&&a(n,e,o)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var o=t(215),a=t(133),i=t(32),r=t(208),l=t(138),s=t(103);n.exports=function(n,e,t){for(var c=-1,d=(e=o(e,n)).length,p=!1;++c<d;){var u=s(e[c]);if(!(p=null!=n&&t(n,u)))break;n=n[u]}return p||++c!=d?p:!!(d=null==n?0:n.length)&&l(d)&&r(u,d)&&(i(n)||a(n))}},function(n,e,t){var o=t(361),a=t(362),i=t(139),r=t(103);n.exports=function(n){return i(n)?o(r(n)):a(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var o=t(214);n.exports=function(n){return function(e){return o(e,n)}}},function(n,e,t){var o=t(141),a=t(364),i=t(366);n.exports=function(n,e){return i(a(n,e,o),n+"")}},function(n,e,t){var o=t(365),a=Math.max;n.exports=function(n,e,t){return e=a(void 0===e?n.length-1:e,0),function(){for(var i=arguments,r=-1,l=a(i.length-e,0),s=Array(l);++r<l;)s[r]=i[e+r];r=-1;for(var c=Array(e+1);++r<e;)c[r]=i[r];return c[e]=t(s),o(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var o=t(367),a=t(370)(o);n.exports=a},function(n,e,t){var o=t(368),a=t(369),i=t(141),r=a?function(n,e){return a(n,"toString",{configurable:!0,enumerable:!1,value:o(e),writable:!0})}:i;n.exports=r},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var o=t(41),a=function(){try{var n=o(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=a},function(n,e){var t=Date.now;n.exports=function(n){var e=0,o=0;return function(){var a=t(),i=16-(a-o);if(o=a,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var o=t(204),a=t(372),i=t(377),r=t(205),l=t(378),s=t(137);n.exports=function(n,e,t){var c=-1,d=a,p=n.length,u=!0,m=[],h=m;if(t)u=!1,d=i;else if(p>=200){var g=e?null:l(n);if(g)return s(g);u=!1,d=r,h=new o}else h=e?[]:m;n:for(;++c<p;){var f=n[c],v=e?e(f):f;if(f=t||0!==f?f:0,u&&v==v){for(var b=h.length;b--;)if(h[b]===v)continue n;e&&h.push(v),m.push(f)}else d(h,v,t)||(h!==m&&h.push(v),m.push(f))}return m}},function(n,e,t){var o=t(373);n.exports=function(n,e){return!!(null==n?0:n.length)&&o(n,e,0)>-1}},function(n,e,t){var o=t(374),a=t(375),i=t(376);n.exports=function(n,e,t){return e==e?i(n,e,t):o(n,a,t)}},function(n,e){n.exports=function(n,e,t,o){for(var a=n.length,i=t+(o?1:-1);o?i--:++i<a;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var o=t-1,a=n.length;++o<a;)if(n[o]===e)return o;return-1}},function(n,e){n.exports=function(n,e,t){for(var o=-1,a=null==n?0:n.length;++o<a;)if(t(e,n[o]))return!0;return!1}},function(n,e,t){var o=t(211),a=t(379),i=t(137),r=o&&1/i(new o([,-0]))[1]==1/0?function(n){return new o(n)}:a;n.exports=r},function(n,e){n.exports=function(){}},function(n,e,t){var o=t(210),a=t(49);n.exports=function(n){return a(n)&&o(n)}},function(n,e,t){var o=t(1),a=t(0),i=t(216).setInterval;o({global:!0,bind:!0,forced:a.setInterval!==i},{setInterval:i})},function(n,e,t){var o=t(1),a=t(0),i=t(216).setTimeout;o({global:!0,bind:!0,forced:a.setTimeout!==i},{setTimeout:i})},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(71).PROPER,a=t(2),i=t(158);n.exports=function(n){return a((function(){return!!i[n]()||"​᠎"!=="​᠎"[n]()||o&&i[n].name!==n}))}},function(n,e,t){var o=t(1),a=t(217);o({target:"Function",proto:!0,forced:Function.bind!==a},{bind:a})},function(n,e,t){var o=t(3);n.exports=o(1..valueOf)},function(n,e,t){var o=t(3),a=t(54),i=t(12),r=t(389),l=t(19),s=o(r),c=o("".slice),d=Math.ceil,p=function(n){return function(e,t,o){var r,p,u=i(l(e)),m=a(t),h=u.length,g=void 0===o?" ":i(o);return m<=h||""==g?u:((p=s(g,d((r=m-h)/g.length))).length>r&&(p=c(p,0,r)),n?u+p:p+u)}};n.exports={start:p(!1),end:p(!0)}},function(n,e,t){"use strict";var o=t(0),a=t(58),i=t(12),r=t(19),l=o.RangeError;n.exports=function(n){var e=i(r(this)),t="",o=a(n);if(o<0||o==1/0)throw l("Wrong number of repetitions");for(;o>0;(o>>>=1)&&(e+=e))1&o&&(t+=e);return t}},function(n,e,t){var o=t(33);n.exports=/Version\/10(?:\.\d+){1,2}(?: [\w./]+)?(?: Mobile\/\w+)? Safari\//.test(o)},function(n,e,t){"use strict";t(219)},function(n,e,t){"use strict";t(220)},function(n,e,t){"use strict";var o=t(1),a=t(3),i=t(23),r=t(17),l=t(24),s=t(12),c=t(2),d=t(243),p=t(46),u=t(394),m=t(395),h=t(53),g=t(396),f=[],v=a(f.sort),b=a(f.push),x=c((function(){f.sort(void 0)})),y=c((function(){f.sort(null)})),w=p("sort"),k=!c((function(){if(h)return h<70;if(!(u&&u>3)){if(m)return!0;if(g)return g<603;var n,e,t,o,a="";for(n=65;n<76;n++){switch(e=String.fromCharCode(n),n){case 66:case 69:case 70:case 72:t=3;break;case 68:case 71:t=4;break;default:t=2}for(o=0;o<47;o++)f.push({k:e+o,v:t})}for(f.sort((function(n,e){return e.v-n.v})),o=0;o<f.length;o++)e=f[o].k.charAt(0),a.charAt(a.length-1)!==e&&(a+=e);return"DGBEFHACIJK"!==a}}));o({target:"Array",proto:!0,forced:x||!y||!w||!k},{sort:function(n){void 0!==n&&i(n);var e=r(this);if(k)return void 0===n?v(e):v(e,n);var t,o,a=[],c=l(e);for(o=0;o<c;o++)o in e&&b(a,e[o]);for(d(a,function(n){return function(e,t){return void 0===t?-1:void 0===e?1:void 0!==n?+n(e,t)||0:s(e)>s(t)?1:-1}}(n)),t=a.length,o=0;o<t;)e[o]=a[o++];for(;o<c;)delete e[o++];return e}})},function(n,e,t){var o=t(33).match(/firefox\/(\d+)/i);n.exports=!!o&&+o[1]},function(n,e,t){var o=t(33);n.exports=/MSIE|Trident/.test(o)},function(n,e,t){var o=t(33).match(/AppleWebKit\/(\d+)\./);n.exports=!!o&&+o[1]},function(n,e,t){},function(n,e,t){},function(n,e,t){var o=t(1),a=t(2),i=t(20),r=t(37).f,l=t(8),s=a((function(){r(1)}));o({target:"Object",stat:!0,forced:!l||s,sham:!l},{getOwnPropertyDescriptor:function(n,e){return r(i(n),e)}})},function(n,e,t){var o=t(1),a=t(8),i=t(118).f;o({target:"Object",stat:!0,forced:Object.defineProperties!==i,sham:!a},{defineProperties:i})},function(n,e,t){t(1)({target:"Reflect",stat:!0},{ownKeys:t(124)})},function(n,e){},function(n,e){function t(n,e){for(var t=0,o=n.length-1;o>=0;o--){var a=n[o];"."===a?n.splice(o,1):".."===a?(n.splice(o,1),t++):t&&(n.splice(o,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function o(n,e){if(n.filter)return n.filter(e);for(var t=[],o=0;o<n.length;o++)e(n[o],o,n)&&t.push(n[o]);return t}e.resolve=function(){for(var n="",e=!1,a=arguments.length-1;a>=-1&&!e;a--){var i=a>=0?arguments[a]:process.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(n=i+"/"+n,e="/"===i.charAt(0))}return(e?"/":"")+(n=t(o(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var i=e.isAbsolute(n),r="/"===a(n,-1);return(n=t(o(n.split("/"),(function(n){return!!n})),!i).join("/"))||i||(n="."),n&&r&&(n+="/"),(i?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(o(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function o(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var a=o(n.split("/")),i=o(t.split("/")),r=Math.min(a.length,i.length),l=r,s=0;s<r;s++)if(a[s]!==i[s]){l=s;break}var c=[];for(s=l;s<a.length;s++)c.push("..");return(c=c.concat(i.slice(l))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,o=-1,a=!0,i=n.length-1;i>=1;--i)if(47===(e=n.charCodeAt(i))){if(!a){o=i;break}}else a=!1;return-1===o?t?"/":".":t&&1===o?"/":n.slice(0,o)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,o=-1,a=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!a){t=e+1;break}}else-1===o&&(a=!1,o=e+1);return-1===o?"":n.slice(t,o)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,o=-1,a=!0,i=0,r=n.length-1;r>=0;--r){var l=n.charCodeAt(r);if(47!==l)-1===o&&(a=!1,o=r+1),46===l?-1===e?e=r:1!==i&&(i=1):-1!==e&&(i=-1);else if(!a){t=r+1;break}}return-1===e||-1===o||0===i||1===i&&e===o-1&&e===t+1?"":n.slice(e,o)};var a="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var o=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(o,"\\$&"):""};var a={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},i=/[&<>'"]/g;function r(n){return a[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(i,r)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var o=0;o<t.length;o++){var a=t[o];void 0!==e[a]&&(n[a]=e[a])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"_from":"ejs@^2.6.1","_id":"ejs@2.7.4","_inBundle":false,"_integrity":"sha512-7vmuyh5+kuUyJKePhQfRQBhXV5Ce+RnaeeQArKu1EAMpL3WbgMt5WG6uQZpEVvYSSsxMXRKOewtDk9RaTKXRlA==","_location":"/ejs","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"ejs@^2.6.1","name":"ejs","escapedName":"ejs","rawSpec":"^2.6.1","saveSpec":null,"fetchSpec":"^2.6.1"},"_requiredBy":["/vuepress-plugin-comment"],"_resolved":"https://registry.npmjs.org/ejs/-/ejs-2.7.4.tgz","_shasum":"48661287573dcc53e366c7a1ae52c3a120eec9ba","_spec":"ejs@^2.6.1","_where":"/home/runner/work/notes-front-end/notes-front-end/node_modules/vuepress-plugin-comment","author":{"name":"Matthew Eernisse","email":"mde@fleegix.org","url":"http://fleegix.org"},"bugs":{"url":"https://github.com/mde/ejs/issues"},"bundleDependencies":false,"dependencies":{},"deprecated":false,"description":"Embedded JavaScript templates","devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"homepage":"https://github.com/mde/ejs","keywords":["template","engine","ejs"],"license":"Apache-2.0","main":"./lib/ejs.js","name":"ejs","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"scripts":{"postinstall":"node ./postinstall.js","test":"mocha"},"version":"2.7.4"}')},function(n,e,t){"use strict";t(223)},function(n,e,t){"use strict";t(224)},function(n,e,t){"use strict";t.r(e);t(149),t(249),t(262),t(264);var o=t(95),a=(t(147),t(42),t(5),t(22),t(26),t(44),t(25),Object.freeze({}));function i(n){return null==n}function r(n){return null!=n}function l(n){return!0===n}function s(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function p(n){return"[object Object]"===d.call(n)}function u(n){return"[object RegExp]"===d.call(n)}function m(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function h(n){return r(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function g(n){return null==n?"":Array.isArray(n)||p(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function f(n){var e=parseFloat(n);return isNaN(e)?n:e}function v(n,e){for(var t=Object.create(null),o=n.split(","),a=0;a<o.length;a++)t[o[a]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}v("slot,component",!0);var b=v("key,ref,slot,slot-scope,is");function x(n,e){if(n.length){var t=n.indexOf(e);if(t>-1)return n.splice(t,1)}}var y=Object.prototype.hasOwnProperty;function w(n,e){return y.call(n,e)}function k(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var j=/-(\w)/g,T=k((function(n){return n.replace(j,(function(n,e){return e?e.toUpperCase():""}))})),S=k((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),E=/\B([A-Z])/g,I=k((function(n){return n.replace(E,"-$1").toLowerCase()}));var z=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var o=arguments.length;return o?o>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function C(n,e){e=e||0;for(var t=n.length-e,o=new Array(t);t--;)o[t]=n[t+e];return o}function A(n,e){for(var t in e)n[t]=e[t];return n}function _(n){for(var e={},t=0;t<n.length;t++)n[t]&&A(e,n[t]);return e}function P(n,e,t){}var B=function(n,e,t){return!1},M=function(n){return n};function O(n,e){if(n===e)return!0;var t=c(n),o=c(e);if(!t||!o)return!t&&!o&&String(n)===String(e);try{var a=Array.isArray(n),i=Array.isArray(e);if(a&&i)return n.length===e.length&&n.every((function(n,t){return O(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(a||i)return!1;var r=Object.keys(n),l=Object.keys(e);return r.length===l.length&&r.every((function(t){return O(n[t],e[t])}))}catch(n){return!1}}function D(n,e){for(var t=0;t<n.length;t++)if(O(n[t],e))return t;return-1}function $(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}var L=["component","directive","filter"],N=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch"],V={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:B,isReservedAttr:B,isUnknownElement:B,getTagNamespace:P,parsePlatformTagName:M,mustUseProp:B,async:!0,_lifecycleHooks:N},U=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function H(n,e,t,o){Object.defineProperty(n,e,{value:t,enumerable:!!o,writable:!0,configurable:!0})}var R=new RegExp("[^"+U.source+".$_\\d]");var q,F="__proto__"in{},J="undefined"!=typeof window,G="undefined"!=typeof WXEnvironment&&!!WXEnvironment.platform,W=G&&WXEnvironment.platform.toLowerCase(),Z=J&&window.navigator.userAgent.toLowerCase(),Y=Z&&/msie|trident/.test(Z),X=Z&&Z.indexOf("msie 9.0")>0,K=Z&&Z.indexOf("edge/")>0,Q=(Z&&Z.indexOf("android"),Z&&/iphone|ipad|ipod|ios/.test(Z)||"ios"===W),nn=(Z&&/chrome\/\d+/.test(Z),Z&&/phantomjs/.test(Z),Z&&Z.match(/firefox\/(\d+)/)),en={}.watch,tn=!1;if(J)try{var on={};Object.defineProperty(on,"passive",{get:function(){tn=!0}}),window.addEventListener("test-passive",null,on)}catch(n){}var an=function(){return void 0===q&&(q=!J&&!G&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),q},rn=J&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var sn,cn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);sn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=P,pn=0,un=function(){this.id=pn++,this.subs=[]};un.prototype.addSub=function(n){this.subs.push(n)},un.prototype.removeSub=function(n){x(this.subs,n)},un.prototype.depend=function(){un.target&&un.target.addDep(this)},un.prototype.notify=function(){var n=this.subs.slice();for(var e=0,t=n.length;e<t;e++)n[e].update()},un.target=null;var mn=[];function hn(n){mn.push(n),un.target=n}function gn(){mn.pop(),un.target=mn[mn.length-1]}var fn=function(n,e,t,o,a,i,r,l){this.tag=n,this.data=e,this.children=t,this.text=o,this.elm=a,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=r,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=l,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1},vn={child:{configurable:!0}};vn.child.get=function(){return this.componentInstance},Object.defineProperties(fn.prototype,vn);var bn=function(n){void 0===n&&(n="");var e=new fn;return e.text=n,e.isComment=!0,e};function xn(n){return new fn(void 0,void 0,void 0,String(n))}function yn(n){var e=new fn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var wn=Array.prototype,kn=Object.create(wn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=wn[n];H(kn,n,(function(){for(var t=[],o=arguments.length;o--;)t[o]=arguments[o];var a,i=e.apply(this,t),r=this.__ob__;switch(n){case"push":case"unshift":a=t;break;case"splice":a=t.slice(2)}return a&&r.observeArray(a),r.dep.notify(),i}))}));var jn=Object.getOwnPropertyNames(kn),Tn=!0;function Sn(n){Tn=n}var En=function(n){this.value=n,this.dep=new un,this.vmCount=0,H(n,"__ob__",this),Array.isArray(n)?(F?function(n,e){n.__proto__=e}(n,kn):function(n,e,t){for(var o=0,a=t.length;o<a;o++){var i=t[o];H(n,i,e[i])}}(n,kn,jn),this.observeArray(n)):this.walk(n)};function In(n,e){var t;if(c(n)&&!(n instanceof fn))return w(n,"__ob__")&&n.__ob__ instanceof En?t=n.__ob__:Tn&&!an()&&(Array.isArray(n)||p(n))&&Object.isExtensible(n)&&!n._isVue&&(t=new En(n)),e&&t&&t.vmCount++,t}function zn(n,e,t,o,a){var i=new un,r=Object.getOwnPropertyDescriptor(n,e);if(!r||!1!==r.configurable){var l=r&&r.get,s=r&&r.set;l&&!s||2!==arguments.length||(t=n[e]);var c=!a&&In(t);Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=l?l.call(n):t;return un.target&&(i.depend(),c&&(c.dep.depend(),Array.isArray(e)&&_n(e))),e},set:function(e){var o=l?l.call(n):t;e===o||e!=e&&o!=o||l&&!s||(s?s.call(n,e):t=e,c=!a&&In(e),i.notify())}})}}function Cn(n,e,t){if(Array.isArray(n)&&m(e))return n.length=Math.max(n.length,e),n.splice(e,1,t),t;if(e in n&&!(e in Object.prototype))return n[e]=t,t;var o=n.__ob__;return n._isVue||o&&o.vmCount?t:o?(zn(o.value,e,t),o.dep.notify(),t):(n[e]=t,t)}function An(n,e){if(Array.isArray(n)&&m(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||w(n,e)&&(delete n[e],t&&t.dep.notify())}}function _n(n){for(var e=void 0,t=0,o=n.length;t<o;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),Array.isArray(e)&&_n(e)}En.prototype.walk=function(n){for(var e=Object.keys(n),t=0;t<e.length;t++)zn(n,e[t])},En.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)In(n[e])};var Pn=V.optionMergeStrategies;function Bn(n,e){if(!e)return n;for(var t,o,a,i=cn?Reflect.ownKeys(e):Object.keys(e),r=0;r<i.length;r++)"__ob__"!==(t=i[r])&&(o=n[t],a=e[t],w(n,t)?o!==a&&p(o)&&p(a)&&Bn(o,a):Cn(n,t,a));return n}function Mn(n,e,t){return t?function(){var o="function"==typeof e?e.call(t,t):e,a="function"==typeof n?n.call(t,t):n;return o?Bn(o,a):a}:e?n?function(){return Bn("function"==typeof e?e.call(this,this):e,"function"==typeof n?n.call(this,this):n)}:e:n}function On(n,e){var t=e?n?n.concat(e):Array.isArray(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function Dn(n,e,t,o){var a=Object.create(n||null);return e?A(a,e):a}Pn.data=function(n,e,t){return t?Mn(n,e,t):e&&"function"!=typeof e?n:Mn(n,e)},N.forEach((function(n){Pn[n]=On})),L.forEach((function(n){Pn[n+"s"]=Dn})),Pn.watch=function(n,e,t,o){if(n===en&&(n=void 0),e===en&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var a={};for(var i in A(a,n),e){var r=a[i],l=e[i];r&&!Array.isArray(r)&&(r=[r]),a[i]=r?r.concat(l):Array.isArray(l)?l:[l]}return a},Pn.props=Pn.methods=Pn.inject=Pn.computed=function(n,e,t,o){if(!n)return e;var a=Object.create(null);return A(a,n),e&&A(a,e),a},Pn.provide=Mn;var $n=function(n,e){return void 0===e?n:e};function Ln(n,e,t){if("function"==typeof e&&(e=e.options),function(n,e){var t=n.props;if(t){var o,a,i={};if(Array.isArray(t))for(o=t.length;o--;)"string"==typeof(a=t[o])&&(i[T(a)]={type:null});else if(p(t))for(var r in t)a=t[r],i[T(r)]=p(a)?a:{type:a};else 0;n.props=i}}(e),function(n,e){var t=n.inject;if(t){var o=n.inject={};if(Array.isArray(t))for(var a=0;a<t.length;a++)o[t[a]]={from:t[a]};else if(p(t))for(var i in t){var r=t[i];o[i]=p(r)?A({from:i},r):{from:r}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var o=e[t];"function"==typeof o&&(e[t]={bind:o,update:o})}}(e),!e._base&&(e.extends&&(n=Ln(n,e.extends,t)),e.mixins))for(var o=0,a=e.mixins.length;o<a;o++)n=Ln(n,e.mixins[o],t);var i,r={};for(i in n)l(i);for(i in e)w(n,i)||l(i);function l(o){var a=Pn[o]||$n;r[o]=a(n[o],e[o],t,o)}return r}function Nn(n,e,t,o){if("string"==typeof t){var a=n[e];if(w(a,t))return a[t];var i=T(t);if(w(a,i))return a[i];var r=S(i);return w(a,r)?a[r]:a[t]||a[i]||a[r]}}function Vn(n,e,t,o){var a=e[n],i=!w(t,n),r=t[n],l=qn(Boolean,a.type);if(l>-1)if(i&&!w(a,"default"))r=!1;else if(""===r||r===I(n)){var s=qn(String,a.type);(s<0||l<s)&&(r=!0)}if(void 0===r){r=function(n,e,t){if(!w(e,"default"))return;var o=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return"function"==typeof o&&"Function"!==Hn(e.type)?o.call(n):o}(o,a,n);var c=Tn;Sn(!0),In(r),Sn(c)}return r}var Un=/^\s*function (\w+)/;function Hn(n){var e=n&&n.toString().match(Un);return e?e[1]:""}function Rn(n,e){return Hn(n)===Hn(e)}function qn(n,e){if(!Array.isArray(e))return Rn(e,n)?0:-1;for(var t=0,o=e.length;t<o;t++)if(Rn(e[t],n))return t;return-1}function Fn(n,e,t){hn();try{if(e)for(var o=e;o=o.$parent;){var a=o.$options.errorCaptured;if(a)for(var i=0;i<a.length;i++)try{if(!1===a[i].call(o,n,e,t))return}catch(n){Gn(n,o,"errorCaptured hook")}}Gn(n,e,t)}finally{gn()}}function Jn(n,e,t,o,a){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&h(i)&&!i._handled&&(i.catch((function(n){return Fn(n,o,a+" (Promise/async)")})),i._handled=!0)}catch(n){Fn(n,o,a)}return i}function Gn(n,e,t){if(V.errorHandler)try{return V.errorHandler.call(null,n,e,t)}catch(e){e!==n&&Wn(e,null,"config.errorHandler")}Wn(n,e,t)}function Wn(n,e,t){if(!J&&!G||"undefined"==typeof console)throw n;console.error(n)}var Zn,Yn=!1,Xn=[],Kn=!1;function Qn(){Kn=!1;var n=Xn.slice(0);Xn.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var ne=Promise.resolve();Zn=function(){ne.then(Qn),Q&&setTimeout(P)},Yn=!0}else if(Y||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Zn="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(Qn)}:function(){setTimeout(Qn,0)};else{var ee=1,te=new MutationObserver(Qn),oe=document.createTextNode(String(ee));te.observe(oe,{characterData:!0}),Zn=function(){ee=(ee+1)%2,oe.data=String(ee)},Yn=!0}function ae(n,e){var t;if(Xn.push((function(){if(n)try{n.call(e)}catch(n){Fn(n,e,"nextTick")}else t&&t(e)})),Kn||(Kn=!0,Zn()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}var ie=new sn;function re(n){!function n(e,t){var o,a,i=Array.isArray(e);if(!i&&!c(e)||Object.isFrozen(e)||e instanceof fn)return;if(e.__ob__){var r=e.__ob__.dep.id;if(t.has(r))return;t.add(r)}if(i)for(o=e.length;o--;)n(e[o],t);else for(a=Object.keys(e),o=a.length;o--;)n(e[a[o]],t)}(n,ie),ie.clear()}var le=k((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),o="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=o?n.slice(1):n,once:t,capture:o,passive:e}}));function se(n,e){function t(){var n=arguments,o=t.fns;if(!Array.isArray(o))return Jn(o,null,arguments,e,"v-on handler");for(var a=o.slice(),i=0;i<a.length;i++)Jn(a[i],null,n,e,"v-on handler")}return t.fns=n,t}function ce(n,e,t,o,a,r){var s,c,d,p;for(s in n)c=n[s],d=e[s],p=le(s),i(c)||(i(d)?(i(c.fns)&&(c=n[s]=se(c,r)),l(p.once)&&(c=n[s]=a(p.name,c,p.capture)),t(p.name,c,p.capture,p.passive,p.params)):c!==d&&(d.fns=c,n[s]=d));for(s in e)i(n[s])&&o((p=le(s)).name,e[s],p.capture)}function de(n,e,t){var o;n instanceof fn&&(n=n.data.hook||(n.data.hook={}));var a=n[e];function s(){t.apply(this,arguments),x(o.fns,s)}i(a)?o=se([s]):r(a.fns)&&l(a.merged)?(o=a).fns.push(s):o=se([a,s]),o.merged=!0,n[e]=o}function pe(n,e,t,o,a){if(r(e)){if(w(e,t))return n[t]=e[t],a||delete e[t],!0;if(w(e,o))return n[t]=e[o],a||delete e[o],!0}return!1}function ue(n){return s(n)?[xn(n)]:Array.isArray(n)?function n(e,t){var o,a,c,d,p=[];for(o=0;o<e.length;o++)i(a=e[o])||"boolean"==typeof a||(c=p.length-1,d=p[c],Array.isArray(a)?a.length>0&&(me((a=n(a,(t||"")+"_"+o))[0])&&me(d)&&(p[c]=xn(d.text+a[0].text),a.shift()),p.push.apply(p,a)):s(a)?me(d)?p[c]=xn(d.text+a):""!==a&&p.push(xn(a)):me(a)&&me(d)?p[c]=xn(d.text+a.text):(l(e._isVList)&&r(a.tag)&&i(a.key)&&r(t)&&(a.key="__vlist"+t+"_"+o+"__"),p.push(a)));return p}(n):void 0}function me(n){return r(n)&&r(n.text)&&!1===n.isComment}function he(n,e){if(n){for(var t=Object.create(null),o=cn?Reflect.ownKeys(n):Object.keys(n),a=0;a<o.length;a++){var i=o[a];if("__ob__"!==i){for(var r=n[i].from,l=e;l;){if(l._provided&&w(l._provided,r)){t[i]=l._provided[r];break}l=l.$parent}if(!l)if("default"in n[i]){var s=n[i].default;t[i]="function"==typeof s?s.call(e):s}else 0}}return t}}function ge(n,e){if(!n||!n.length)return{};for(var t={},o=0,a=n.length;o<a;o++){var i=n[o],r=i.data;if(r&&r.attrs&&r.attrs.slot&&delete r.attrs.slot,i.context!==e&&i.fnContext!==e||!r||null==r.slot)(t.default||(t.default=[])).push(i);else{var l=r.slot,s=t[l]||(t[l]=[]);"template"===i.tag?s.push.apply(s,i.children||[]):s.push(i)}}for(var c in t)t[c].every(fe)&&delete t[c];return t}function fe(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ve(n){return n.isComment&&n.asyncFactory}function be(n,e,t){var o,i=Object.keys(e).length>0,r=n?!!n.$stable:!i,l=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(r&&t&&t!==a&&l===t.$key&&!i&&!t.$hasNormal)return t;for(var s in o={},n)n[s]&&"$"!==s[0]&&(o[s]=xe(e,s,n[s]))}else o={};for(var c in e)c in o||(o[c]=ye(e,c));return n&&Object.isExtensible(n)&&(n._normalized=o),H(o,"$stable",r),H(o,"$key",l),H(o,"$hasNormal",i),o}function xe(n,e,t){var o=function(){var n=arguments.length?t.apply(null,arguments):t({}),e=(n=n&&"object"==typeof n&&!Array.isArray(n)?[n]:ue(n))&&n[0];return n&&(!e||1===n.length&&e.isComment&&!ve(e))?void 0:n};return t.proxy&&Object.defineProperty(n,e,{get:o,enumerable:!0,configurable:!0}),o}function ye(n,e){return function(){return n[e]}}function we(n,e){var t,o,a,i,l;if(Array.isArray(n)||"string"==typeof n)for(t=new Array(n.length),o=0,a=n.length;o<a;o++)t[o]=e(n[o],o);else if("number"==typeof n)for(t=new Array(n),o=0;o<n;o++)t[o]=e(o+1,o);else if(c(n))if(cn&&n[Symbol.iterator]){t=[];for(var s=n[Symbol.iterator](),d=s.next();!d.done;)t.push(e(d.value,t.length)),d=s.next()}else for(i=Object.keys(n),t=new Array(i.length),o=0,a=i.length;o<a;o++)l=i[o],t[o]=e(n[l],l,o);return r(t)||(t=[]),t._isVList=!0,t}function ke(n,e,t,o){var a,i=this.$scopedSlots[n];i?(t=t||{},o&&(t=A(A({},o),t)),a=i(t)||("function"==typeof e?e():e)):a=this.$slots[n]||("function"==typeof e?e():e);var r=t&&t.slot;return r?this.$createElement("template",{slot:r},a):a}function je(n){return Nn(this.$options,"filters",n)||M}function Te(n,e){return Array.isArray(n)?-1===n.indexOf(e):n!==e}function Se(n,e,t,o,a){var i=V.keyCodes[e]||t;return a&&o&&!V.keyCodes[e]?Te(a,o):i?Te(i,n):o?I(o)!==e:void 0===n}function Ee(n,e,t,o,a){if(t)if(c(t)){var i;Array.isArray(t)&&(t=_(t));var r=function(r){if("class"===r||"style"===r||b(r))i=n;else{var l=n.attrs&&n.attrs.type;i=o||V.mustUseProp(e,l,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var s=T(r),c=I(r);s in i||c in i||(i[r]=t[r],a&&((n.on||(n.on={}))["update:"+r]=function(n){t[r]=n}))};for(var l in t)r(l)}else;return n}function Ie(n,e){var t=this._staticTrees||(this._staticTrees=[]),o=t[n];return o&&!e||Ce(o=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,null,this),"__static__"+n,!1),o}function ze(n,e,t){return Ce(n,"__once__"+e+(t?"_"+t:""),!0),n}function Ce(n,e,t){if(Array.isArray(n))for(var o=0;o<n.length;o++)n[o]&&"string"!=typeof n[o]&&Ae(n[o],e+"_"+o,t);else Ae(n,e,t)}function Ae(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function _e(n,e){if(e)if(p(e)){var t=n.on=n.on?A({},n.on):{};for(var o in e){var a=t[o],i=e[o];t[o]=a?[].concat(a,i):i}}else;return n}function Pe(n,e,t,o){e=e||{$stable:!t};for(var a=0;a<n.length;a++){var i=n[a];Array.isArray(i)?Pe(i,e,t):i&&(i.proxy&&(i.fn.proxy=!0),e[i.key]=i.fn)}return o&&(e.$key=o),e}function Be(n,e){for(var t=0;t<e.length;t+=2){var o=e[t];"string"==typeof o&&o&&(n[e[t]]=e[t+1])}return n}function Me(n,e){return"string"==typeof n?e+n:n}function Oe(n){n._o=ze,n._n=f,n._s=g,n._l=we,n._t=ke,n._q=O,n._i=D,n._m=Ie,n._f=je,n._k=Se,n._b=Ee,n._v=xn,n._e=bn,n._u=Pe,n._g=_e,n._d=Be,n._p=Me}function De(n,e,t,o,i){var r,s=this,c=i.options;w(o,"_uid")?(r=Object.create(o))._original=o:(r=o,o=o._original);var d=l(c._compiled),p=!d;this.data=n,this.props=e,this.children=t,this.parent=o,this.listeners=n.on||a,this.injections=he(c.inject,o),this.slots=function(){return s.$slots||be(n.scopedSlots,s.$slots=ge(t,o)),s.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(n.scopedSlots,this.slots())}}),d&&(this.$options=c,this.$slots=this.slots(),this.$scopedSlots=be(n.scopedSlots,this.$slots)),c._scopeId?this._c=function(n,e,t,a){var i=Re(r,n,e,t,a,p);return i&&!Array.isArray(i)&&(i.fnScopeId=c._scopeId,i.fnContext=o),i}:this._c=function(n,e,t,o){return Re(r,n,e,t,o,p)}}function $e(n,e,t,o,a){var i=yn(n);return i.fnContext=t,i.fnOptions=o,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function Le(n,e){for(var t in e)n[T(t)]=e[t]}Oe(De.prototype);var Ne={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;Ne.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},o=n.data.inlineTemplate;r(o)&&(t.render=o.render,t.staticRenderFns=o.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Ke)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,o,i){0;var r=o.data.scopedSlots,l=n.$scopedSlots,s=!!(r&&!r.$stable||l!==a&&!l.$stable||r&&n.$scopedSlots.$key!==r.$key||!r&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||s);n.$options._parentVnode=o,n.$vnode=o,n._vnode&&(n._vnode.parent=o);if(n.$options._renderChildren=i,n.$attrs=o.data.attrs||a,n.$listeners=t||a,e&&n.$options.props){Sn(!1);for(var d=n._props,p=n.$options._propKeys||[],u=0;u<p.length;u++){var m=p[u],h=n.$options.props;d[m]=Vn(m,h,e,n)}Sn(!0),n.$options.propsData=e}t=t||a;var g=n.$options._parentListeners;n.$options._parentListeners=t,Xe(n,t,g),c&&(n.$slots=ge(i,o.context),n.$forceUpdate());0}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,o=n.componentInstance;o._isMounted||(o._isMounted=!0,tt(o,"mounted")),n.data.keepAlive&&(t._isMounted?((e=o)._inactive=!1,at.push(e)):et(o,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(t&&(e._directInactive=!0,nt(e)))return;if(!e._inactive){e._inactive=!0;for(var o=0;o<e.$children.length;o++)n(e.$children[o]);tt(e,"deactivated")}}(e,!0):e.$destroy())}},Ve=Object.keys(Ne);function Ue(n,e,t,o,s){if(!i(n)){var d=t.$options._base;if(c(n)&&(n=d.extend(n)),"function"==typeof n){var p;if(i(n.cid)&&void 0===(n=function(n,e){if(l(n.error)&&r(n.errorComp))return n.errorComp;if(r(n.resolved))return n.resolved;var t=Fe;t&&r(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t);if(l(n.loading)&&r(n.loadingComp))return n.loadingComp;if(t&&!r(n.owners)){var o=n.owners=[t],a=!0,s=null,d=null;t.$on("hook:destroyed",(function(){return x(o,t)}));var p=function(n){for(var e=0,t=o.length;e<t;e++)o[e].$forceUpdate();n&&(o.length=0,null!==s&&(clearTimeout(s),s=null),null!==d&&(clearTimeout(d),d=null))},u=$((function(t){n.resolved=Je(t,e),a?o.length=0:p(!0)})),m=$((function(e){r(n.errorComp)&&(n.error=!0,p(!0))})),g=n(u,m);return c(g)&&(h(g)?i(n.resolved)&&g.then(u,m):h(g.component)&&(g.component.then(u,m),r(g.error)&&(n.errorComp=Je(g.error,e)),r(g.loading)&&(n.loadingComp=Je(g.loading,e),0===g.delay?n.loading=!0:s=setTimeout((function(){s=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,p(!1))}),g.delay||200)),r(g.timeout)&&(d=setTimeout((function(){d=null,i(n.resolved)&&m(null)}),g.timeout)))),a=!1,n.loading?n.loadingComp:n.resolved}}(p=n,d)))return function(n,e,t,o,a){var i=bn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:o,tag:a},i}(p,e,t,o,s);e=e||{},Tt(n),r(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",o=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var a=e.on||(e.on={}),i=a[o],l=e.model.callback;r(i)?(Array.isArray(i)?-1===i.indexOf(l):i!==l)&&(a[o]=[l].concat(i)):a[o]=l}(n.options,e);var u=function(n,e,t){var o=e.options.props;if(!i(o)){var a={},l=n.attrs,s=n.props;if(r(l)||r(s))for(var c in o){var d=I(c);pe(a,s,c,d,!0)||pe(a,l,c,d,!1)}return a}}(e,n);if(l(n.options.functional))return function(n,e,t,o,i){var l=n.options,s={},c=l.props;if(r(c))for(var d in c)s[d]=Vn(d,c,e||a);else r(t.attrs)&&Le(s,t.attrs),r(t.props)&&Le(s,t.props);var p=new De(t,s,i,o,n),u=l.render.call(null,p._c,p);if(u instanceof fn)return $e(u,t,p.parent,l,p);if(Array.isArray(u)){for(var m=ue(u)||[],h=new Array(m.length),g=0;g<m.length;g++)h[g]=$e(m[g],t,p.parent,l,p);return h}}(n,u,e,t,o);var m=e.on;if(e.on=e.nativeOn,l(n.options.abstract)){var g=e.slot;e={},g&&(e.slot=g)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<Ve.length;t++){var o=Ve[t],a=e[o],i=Ne[o];a===i||a&&a._merged||(e[o]=a?He(i,a):i)}}(e);var f=n.options.name||s;return new fn("vue-component-"+n.cid+(f?"-"+f:""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:u,listeners:m,tag:s,children:o},p)}}}function He(n,e){var t=function(t,o){n(t,o),e(t,o)};return t._merged=!0,t}function Re(n,e,t,o,a,d){return(Array.isArray(t)||s(t))&&(a=o,o=t,t=void 0),l(d)&&(a=2),function(n,e,t,o,a){if(r(t)&&r(t.__ob__))return bn();r(t)&&r(t.is)&&(e=t.is);if(!e)return bn();0;Array.isArray(o)&&"function"==typeof o[0]&&((t=t||{}).scopedSlots={default:o[0]},o.length=0);2===a?o=ue(o):1===a&&(o=function(n){for(var e=0;e<n.length;e++)if(Array.isArray(n[e]))return Array.prototype.concat.apply([],n);return n}(o));var s,d;if("string"==typeof e){var p;d=n.$vnode&&n.$vnode.ns||V.getTagNamespace(e),s=V.isReservedTag(e)?new fn(V.parsePlatformTagName(e),t,o,void 0,void 0,n):t&&t.pre||!r(p=Nn(n.$options,"components",e))?new fn(e,t,o,void 0,void 0,n):Ue(p,t,n,o,e)}else s=Ue(e,t,n,o);return Array.isArray(s)?s:r(s)?(r(d)&&function n(e,t,o){e.ns=t,"foreignObject"===e.tag&&(t=void 0,o=!0);if(r(e.children))for(var a=0,s=e.children.length;a<s;a++){var c=e.children[a];r(c.tag)&&(i(c.ns)||l(o)&&"svg"!==c.tag)&&n(c,t,o)}}(s,d),r(t)&&function(n){c(n.style)&&re(n.style);c(n.class)&&re(n.class)}(t),s):bn()}(n,e,t,o,a)}var qe,Fe=null;function Je(n,e){return(n.__esModule||cn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),c(n)?e.extend(n):n}function Ge(n){if(Array.isArray(n))for(var e=0;e<n.length;e++){var t=n[e];if(r(t)&&(r(t.componentOptions)||ve(t)))return t}}function We(n,e){qe.$on(n,e)}function Ze(n,e){qe.$off(n,e)}function Ye(n,e){var t=qe;return function o(){var a=e.apply(null,arguments);null!==a&&t.$off(n,o)}}function Xe(n,e,t){qe=n,ce(e,t||{},We,Ze,Ye,n),qe=void 0}var Ke=null;function Qe(n){var e=Ke;return Ke=n,function(){Ke=e}}function nt(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function et(n,e){if(e){if(n._directInactive=!1,nt(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)et(n.$children[t]);tt(n,"activated")}}function tt(n,e){hn();var t=n.$options[e],o=e+" hook";if(t)for(var a=0,i=t.length;a<i;a++)Jn(t[a],n,null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),gn()}var ot=[],at=[],it={},rt=!1,lt=!1,st=0;var ct=0,dt=Date.now;if(J&&!Y){var pt=window.performance;pt&&"function"==typeof pt.now&&dt()>document.createEvent("Event").timeStamp&&(dt=function(){return pt.now()})}function ut(){var n,e;for(ct=dt(),lt=!0,ot.sort((function(n,e){return n.id-e.id})),st=0;st<ot.length;st++)(n=ot[st]).before&&n.before(),e=n.id,it[e]=null,n.run();var t=at.slice(),o=ot.slice();st=ot.length=at.length=0,it={},rt=lt=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,et(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],o=t.vm;o._watcher===t&&o._isMounted&&!o._isDestroyed&&tt(o,"updated")}}(o),rn&&V.devtools&&rn.emit("flush")}var mt=0,ht=function(n,e,t,o,a){this.vm=n,a&&(n._watcher=this),n._watchers.push(this),o?(this.deep=!!o.deep,this.user=!!o.user,this.lazy=!!o.lazy,this.sync=!!o.sync,this.before=o.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++mt,this.active=!0,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new sn,this.newDepIds=new sn,this.expression="","function"==typeof e?this.getter=e:(this.getter=function(n){if(!R.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=P)),this.value=this.lazy?void 0:this.get()};ht.prototype.get=function(){var n;hn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Fn(n,e,'getter for watcher "'+this.expression+'"')}finally{this.deep&&re(n),gn(),this.cleanupDeps()}return n},ht.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},ht.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},ht.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():function(n){var e=n.id;if(null==it[e]){if(it[e]=!0,lt){for(var t=ot.length-1;t>st&&ot[t].id>n.id;)t--;ot.splice(t+1,0,n)}else ot.push(n);rt||(rt=!0,ae(ut))}}(this)},ht.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||c(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'+this.expression+'"';Jn(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},ht.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},ht.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},ht.prototype.teardown=function(){if(this.active){this.vm._isBeingDestroyed||x(this.vm._watchers,this);for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1}};var gt={enumerable:!0,configurable:!0,get:P,set:P};function ft(n,e,t){gt.get=function(){return this[e][t]},gt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,gt)}function vt(n){n._watchers=[];var e=n.$options;e.props&&function(n,e){var t=n.$options.propsData||{},o=n._props={},a=n.$options._propKeys=[];n.$parent&&Sn(!1);var i=function(i){a.push(i);var r=Vn(i,e,t,n);zn(o,i,r),i in n||ft(n,"_props",i)};for(var r in e)i(r);Sn(!0)}(n,e.props),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?P:z(e[t],n)}(n,e.methods),e.data?function(n){var e=n.$options.data;p(e=n._data="function"==typeof e?function(n,e){hn();try{return n.call(e,e)}catch(n){return Fn(n,e,"data()"),{}}finally{gn()}}(e,n):e||{})||(e={});var t=Object.keys(e),o=n.$options.props,a=(n.$options.methods,t.length);for(;a--;){var i=t[a];0,o&&w(o,i)||(r=void 0,36!==(r=(i+"").charCodeAt(0))&&95!==r&&ft(n,"_data",i))}var r;In(e,!0)}(n):In(n._data={},!0),e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),o=an();for(var a in e){var i=e[a],r="function"==typeof i?i:i.get;0,o||(t[a]=new ht(n,r||P,P,bt)),a in n||xt(n,a,i)}}(n,e.computed),e.watch&&e.watch!==en&&function(n,e){for(var t in e){var o=e[t];if(Array.isArray(o))for(var a=0;a<o.length;a++)kt(n,t,o[a]);else kt(n,t,o)}}(n,e.watch)}var bt={lazy:!0};function xt(n,e,t){var o=!an();"function"==typeof t?(gt.get=o?yt(e):wt(t),gt.set=P):(gt.get=t.get?o&&!1!==t.cache?yt(e):wt(t.get):P,gt.set=t.set||P),Object.defineProperty(n,e,gt)}function yt(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),un.target&&e.depend(),e.value}}function wt(n){return function(){return n.call(this,this)}}function kt(n,e,t,o){return p(t)&&(o=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,o)}var jt=0;function Tt(n){var e=n.options;if(n.super){var t=Tt(n.super);if(t!==n.superOptions){n.superOptions=t;var o=function(n){var e,t=n.options,o=n.sealedOptions;for(var a in t)t[a]!==o[a]&&(e||(e={}),e[a]=t[a]);return e}(n);o&&A(n.extendOptions,o),(e=n.options=Ln(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function St(n){this._init(n)}function Et(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,o=t.cid,a=n._Ctor||(n._Ctor={});if(a[o])return a[o];var i=n.name||t.options.name;var r=function(n){this._init(n)};return(r.prototype=Object.create(t.prototype)).constructor=r,r.cid=e++,r.options=Ln(t.options,n),r.super=t,r.options.props&&function(n){var e=n.options.props;for(var t in e)ft(n.prototype,"_props",t)}(r),r.options.computed&&function(n){var e=n.options.computed;for(var t in e)xt(n.prototype,t,e[t])}(r),r.extend=t.extend,r.mixin=t.mixin,r.use=t.use,L.forEach((function(n){r[n]=t[n]})),i&&(r.options.components[i]=r),r.superOptions=t.options,r.extendOptions=n,r.sealedOptions=A({},r.options),a[o]=r,r}}function It(n){return n&&(n.Ctor.options.name||n.tag)}function zt(n,e){return Array.isArray(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!u(n)&&n.test(e)}function Ct(n,e){var t=n.cache,o=n.keys,a=n._vnode;for(var i in t){var r=t[i];if(r){var l=r.name;l&&!e(l)&&At(t,i,o,a)}}}function At(n,e,t,o){var a=n[e];!a||o&&a.tag===o.tag||a.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=jt++,e._isVue=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),o=e._parentVnode;t.parent=e.parent,t._parentVnode=o;var a=o.componentOptions;t.propsData=a.propsData,t._parentListeners=a.listeners,t._renderChildren=a.children,t._componentTag=a.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=Ln(Tt(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Xe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,o=t&&t.context;n.$slots=ge(e._renderChildren,o),n.$scopedSlots=a,n._c=function(e,t,o,a){return Re(n,e,t,o,a,!1)},n.$createElement=function(e,t,o,a){return Re(n,e,t,o,a,!0)};var i=t&&t.data;zn(n,"$attrs",i&&i.attrs||a,null,!0),zn(n,"$listeners",e._parentListeners||a,null,!0)}(e),tt(e,"beforeCreate"),function(n){var e=he(n.$options.inject,n);e&&(Sn(!1),Object.keys(e).forEach((function(t){zn(n,t,e[t])})),Sn(!0))}(e),vt(e),function(n){var e=n.$options.provide;e&&(n._provided="function"==typeof e?e.call(n):e)}(e),tt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(St),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Cn,n.prototype.$delete=An,n.prototype.$watch=function(n,e,t){if(p(e))return kt(this,n,e,t);(t=t||{}).user=!0;var o=new ht(this,n,e,t);if(t.immediate){var a='callback for immediate watcher "'+o.expression+'"';hn(),Jn(e,this,[o.value],this,a),gn()}return function(){o.teardown()}}}(St),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var o=this;if(Array.isArray(n))for(var a=0,i=n.length;a<i;a++)o.$on(n[a],t);else(o._events[n]||(o._events[n]=[])).push(t),e.test(n)&&(o._hasHookEvent=!0);return o},n.prototype.$once=function(n,e){var t=this;function o(){t.$off(n,o),e.apply(t,arguments)}return o.fn=e,t.$on(n,o),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(Array.isArray(n)){for(var o=0,a=n.length;o<a;o++)t.$off(n[o],e);return t}var i,r=t._events[n];if(!r)return t;if(!e)return t._events[n]=null,t;for(var l=r.length;l--;)if((i=r[l])===e||i.fn===e){r.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?C(t):t;for(var o=C(arguments,1),a='event handler for "'+n+'"',i=0,r=t.length;i<r;i++)Jn(t[i],e,o,e,a)}return e}}(St),function(n){n.prototype._update=function(n,e){var t=this,o=t.$el,a=t._vnode,i=Qe(t);t._vnode=n,t.$el=a?t.__patch__(a,n):t.__patch__(t.$el,n,e,!1),i(),o&&(o.__vue__=null),t.$el&&(t.$el.__vue__=t),t.$vnode&&t.$parent&&t.$vnode===t.$parent._vnode&&(t.$parent.$el=t.$el)},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){tt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._watcher&&n._watcher.teardown();for(var t=n._watchers.length;t--;)n._watchers[t].teardown();n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),tt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(St),function(n){Oe(n.prototype),n.prototype.$nextTick=function(n){return ae(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,o=t.render,a=t._parentVnode;a&&(e.$scopedSlots=be(a.data.scopedSlots,e.$slots,e.$scopedSlots)),e.$vnode=a;try{Fe=e,n=o.call(e._renderProxy,e.$createElement)}catch(t){Fn(t,e,"render"),n=e._vnode}finally{Fe=null}return Array.isArray(n)&&1===n.length&&(n=n[0]),n instanceof fn||(n=bn()),n.parent=a,n}}(St);var _t=[String,RegExp,Array],Pt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:_t,exclude:_t,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,o=this.keyToCache;if(t){var a=t.tag,i=t.componentInstance,r=t.componentOptions;n[o]={name:It(r),tag:a,componentInstance:i},e.push(o),this.max&&e.length>parseInt(this.max)&&At(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)At(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Ct(n,(function(n){return zt(e,n)}))})),this.$watch("exclude",(function(e){Ct(n,(function(n){return!zt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=Ge(n),t=e&&e.componentOptions;if(t){var o=It(t),a=this.include,i=this.exclude;if(a&&(!o||!zt(a,o))||i&&o&&zt(i,o))return e;var r=this.cache,l=this.keys,s=null==e.key?t.Ctor.cid+(t.tag?"::"+t.tag:""):e.key;r[s]?(e.componentInstance=r[s].componentInstance,x(l,s),l.push(s)):(this.vnodeToCache=e,this.keyToCache=s),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return V}};Object.defineProperty(n,"config",e),n.util={warn:dn,extend:A,mergeOptions:Ln,defineReactive:zn},n.set=Cn,n.delete=An,n.nextTick=ae,n.observable=function(n){return In(n),n},n.options=Object.create(null),L.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,A(n.options.components,Pt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=C(arguments,1);return t.unshift(this),"function"==typeof n.install?n.install.apply(n,t):"function"==typeof n&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=Ln(this.options,n),this}}(n),Et(n),function(n){L.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&p(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&"function"==typeof t&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(St),Object.defineProperty(St.prototype,"$isServer",{get:an}),Object.defineProperty(St.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(St,"FunctionalRenderContext",{value:De}),St.version="2.6.14";var Bt=v("style,class"),Mt=v("input,textarea,option,select,progress"),Ot=v("contenteditable,draggable,spellcheck"),Dt=v("events,caret,typing,plaintext-only"),$t=v("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),Lt="http://www.w3.org/1999/xlink",Nt=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},Vt=function(n){return Nt(n)?n.slice(6,n.length):""},Ut=function(n){return null==n||!1===n};function Ht(n){for(var e=n.data,t=n,o=n;r(o.componentInstance);)(o=o.componentInstance._vnode)&&o.data&&(e=Rt(o.data,e));for(;r(t=t.parent);)t&&t.data&&(e=Rt(e,t.data));return function(n,e){if(r(n)||r(e))return qt(n,Ft(e));return""}(e.staticClass,e.class)}function Rt(n,e){return{staticClass:qt(n.staticClass,e.staticClass),class:r(n.class)?[n.class,e.class]:e.class}}function qt(n,e){return n?e?n+" "+e:n:e||""}function Ft(n){return Array.isArray(n)?function(n){for(var e,t="",o=0,a=n.length;o<a;o++)r(e=Ft(n[o]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):c(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var Jt={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},Gt=v("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),Wt=v("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),Zt=function(n){return Gt(n)||Wt(n)};var Yt=Object.create(null);var Xt=v("text,number,password,search,email,tel,url");var Kt=Object.freeze({createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(Jt[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),Qt={create:function(n,e){no(e)},update:function(n,e){n.data.ref!==e.data.ref&&(no(n,!0),no(e))},destroy:function(n){no(n,!0)}};function no(n,e){var t=n.data.ref;if(r(t)){var o=n.context,a=n.componentInstance||n.elm,i=o.$refs;e?Array.isArray(i[t])?x(i[t],a):i[t]===a&&(i[t]=void 0):n.data.refInFor?Array.isArray(i[t])?i[t].indexOf(a)<0&&i[t].push(a):i[t]=[a]:i[t]=a}}var eo=new fn("",{},[]),to=["create","activate","update","remove","destroy"];function oo(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&r(n.data)===r(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,o=r(t=n.data)&&r(t=t.attrs)&&t.type,a=r(t=e.data)&&r(t=t.attrs)&&t.type;return o===a||Xt(o)&&Xt(a)}(n,e)||l(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function ao(n,e,t){var o,a,i={};for(o=e;o<=t;++o)r(a=n[o].key)&&(i[a]=o);return i}var io={create:ro,update:ro,destroy:function(n){ro(n,eo)}};function ro(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,o,a,i=n===eo,r=e===eo,l=so(n.data.directives,n.context),s=so(e.data.directives,e.context),c=[],d=[];for(t in s)o=l[t],a=s[t],o?(a.oldValue=o.value,a.oldArg=o.arg,po(a,"update",e,n),a.def&&a.def.componentUpdated&&d.push(a)):(po(a,"bind",e,n),a.def&&a.def.inserted&&c.push(a));if(c.length){var p=function(){for(var t=0;t<c.length;t++)po(c[t],"inserted",e,n)};i?de(e,"insert",p):p()}d.length&&de(e,"postpatch",(function(){for(var t=0;t<d.length;t++)po(d[t],"componentUpdated",e,n)}));if(!i)for(t in l)s[t]||po(l[t],"unbind",n,n,r)}(n,e)}var lo=Object.create(null);function so(n,e){var t,o,a=Object.create(null);if(!n)return a;for(t=0;t<n.length;t++)(o=n[t]).modifiers||(o.modifiers=lo),a[co(o)]=o,o.def=Nn(e.$options,"directives",o.name);return a}function co(n){return n.rawName||n.name+"."+Object.keys(n.modifiers||{}).join(".")}function po(n,e,t,o,a){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,o,a)}catch(o){Fn(o,t.context,"directive "+n.name+" "+e+" hook")}}var uo=[Qt,io];function mo(n,e){var t=e.componentOptions;if(!(r(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var o,a,l=e.elm,s=n.data.attrs||{},c=e.data.attrs||{};for(o in r(c.__ob__)&&(c=e.data.attrs=A({},c)),c)a=c[o],s[o]!==a&&ho(l,o,a,e.data.pre);for(o in(Y||K)&&c.value!==s.value&&ho(l,"value",c.value),s)i(c[o])&&(Nt(o)?l.removeAttributeNS(Lt,Vt(o)):Ot(o)||l.removeAttribute(o))}}function ho(n,e,t,o){o||n.tagName.indexOf("-")>-1?go(n,e,t):$t(e)?Ut(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):Ot(e)?n.setAttribute(e,function(n,e){return Ut(e)||"false"===e?"false":"contenteditable"===n&&Dt(e)?e:"true"}(e,t)):Nt(e)?Ut(t)?n.removeAttributeNS(Lt,Vt(e)):n.setAttributeNS(Lt,e,t):go(n,e,t)}function go(n,e,t){if(Ut(t))n.removeAttribute(e);else{if(Y&&!X&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var o=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",o)};n.addEventListener("input",o),n.__ieph=!0}n.setAttribute(e,t)}}var fo={create:mo,update:mo};function vo(n,e){var t=e.elm,o=e.data,a=n.data;if(!(i(o.staticClass)&&i(o.class)&&(i(a)||i(a.staticClass)&&i(a.class)))){var l=Ht(e),s=t._transitionClasses;r(s)&&(l=qt(l,Ft(s))),l!==t._prevClass&&(t.setAttribute("class",l),t._prevClass=l)}}var bo,xo={create:vo,update:vo};function yo(n,e,t){var o=bo;return function a(){var i=e.apply(null,arguments);null!==i&&jo(n,a,t,o)}}var wo=Yn&&!(nn&&Number(nn[1])<=53);function ko(n,e,t,o){if(wo){var a=ct,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=a||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}bo.addEventListener(n,e,tn?{capture:t,passive:o}:t)}function jo(n,e,t,o){(o||bo).removeEventListener(n,e._wrapper||e,t)}function To(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},o=n.data.on||{};bo=e.elm,function(n){if(r(n.__r)){var e=Y?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}r(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),ce(t,o,ko,jo,yo,e.context),bo=void 0}}var So,Eo={create:To,update:To};function Io(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,o,a=e.elm,l=n.data.domProps||{},s=e.data.domProps||{};for(t in r(s.__ob__)&&(s=e.data.domProps=A({},s)),l)t in s||(a[t]="");for(t in s){if(o=s[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),o===l[t])continue;1===a.childNodes.length&&a.removeChild(a.childNodes[0])}if("value"===t&&"PROGRESS"!==a.tagName){a._value=o;var c=i(o)?"":String(o);zo(a,c)&&(a.value=c)}else if("innerHTML"===t&&Wt(a.tagName)&&i(a.innerHTML)){(So=So||document.createElement("div")).innerHTML="<svg>"+o+"</svg>";for(var d=So.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;d.firstChild;)a.appendChild(d.firstChild)}else if(o!==l[t])try{a[t]=o}catch(n){}}}}function zo(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,o=n._vModifiers;if(r(o)){if(o.number)return f(t)!==f(e);if(o.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Co={create:Io,update:Io},Ao=k((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var o=n.split(t);o.length>1&&(e[o[0].trim()]=o[1].trim())}})),e}));function _o(n){var e=Po(n.style);return n.staticStyle?A(n.staticStyle,e):e}function Po(n){return Array.isArray(n)?_(n):"string"==typeof n?Ao(n):n}var Bo,Mo=/^--/,Oo=/\s*!important$/,Do=function(n,e,t){if(Mo.test(e))n.style.setProperty(e,t);else if(Oo.test(t))n.style.setProperty(I(e),t.replace(Oo,""),"important");else{var o=Lo(e);if(Array.isArray(t))for(var a=0,i=t.length;a<i;a++)n.style[o]=t[a];else n.style[o]=t}},$o=["Webkit","Moz","ms"],Lo=k((function(n){if(Bo=Bo||document.createElement("div").style,"filter"!==(n=T(n))&&n in Bo)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<$o.length;t++){var o=$o[t]+e;if(o in Bo)return o}}));function No(n,e){var t=e.data,o=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(o.staticStyle)&&i(o.style))){var a,l,s=e.elm,c=o.staticStyle,d=o.normalizedStyle||o.style||{},p=c||d,u=Po(e.data.style)||{};e.data.normalizedStyle=r(u.__ob__)?A({},u):u;var m=function(n,e){var t,o={};if(e)for(var a=n;a.componentInstance;)(a=a.componentInstance._vnode)&&a.data&&(t=_o(a.data))&&A(o,t);(t=_o(n.data))&&A(o,t);for(var i=n;i=i.parent;)i.data&&(t=_o(i.data))&&A(o,t);return o}(e,!0);for(l in p)i(m[l])&&Do(s,l,"");for(l in m)(a=m[l])!==p[l]&&Do(s,l,null==a?"":a)}}var Vo={create:No,update:No},Uo=/\s+/;function Ho(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Uo).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" "+(n.getAttribute("class")||"")+" ";t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function Ro(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(Uo).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" "+(n.getAttribute("class")||"")+" ",o=" "+e+" ";t.indexOf(o)>=0;)t=t.replace(o," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function qo(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&A(e,Fo(n.name||"v")),A(e,n),e}return"string"==typeof n?Fo(n):void 0}}var Fo=k((function(n){return{enterClass:n+"-enter",enterToClass:n+"-enter-to",enterActiveClass:n+"-enter-active",leaveClass:n+"-leave",leaveToClass:n+"-leave-to",leaveActiveClass:n+"-leave-active"}})),Jo=J&&!X,Go="transition",Wo="transitionend",Zo="animation",Yo="animationend";Jo&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(Go="WebkitTransition",Wo="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(Zo="WebkitAnimation",Yo="webkitAnimationEnd"));var Xo=J?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function Ko(n){Xo((function(){Xo(n)}))}function Qo(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),Ho(n,e))}function na(n,e){n._transitionClasses&&x(n._transitionClasses,e),Ro(n,e)}function ea(n,e,t){var o=oa(n,e),a=o.type,i=o.timeout,r=o.propCount;if(!a)return t();var l="transition"===a?Wo:Yo,s=0,c=function(){n.removeEventListener(l,d),t()},d=function(e){e.target===n&&++s>=r&&c()};setTimeout((function(){s<r&&c()}),i+1),n.addEventListener(l,d)}var ta=/\b(transform|all)(,|$)/;function oa(n,e){var t,o=window.getComputedStyle(n),a=(o[Go+"Delay"]||"").split(", "),i=(o[Go+"Duration"]||"").split(", "),r=aa(a,i),l=(o[Zo+"Delay"]||"").split(", "),s=(o[Zo+"Duration"]||"").split(", "),c=aa(l,s),d=0,p=0;return"transition"===e?r>0&&(t="transition",d=r,p=i.length):"animation"===e?c>0&&(t="animation",d=c,p=s.length):p=(t=(d=Math.max(r,c))>0?r>c?"transition":"animation":null)?"transition"===t?i.length:s.length:0,{type:t,timeout:d,propCount:p,hasTransform:"transition"===t&&ta.test(o[Go+"Property"])}}function aa(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return ia(e)+ia(n[t])})))}function ia(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function ra(n,e){var t=n.elm;r(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var o=qo(n.data.transition);if(!i(o)&&!r(t._enterCb)&&1===t.nodeType){for(var a=o.css,l=o.type,s=o.enterClass,d=o.enterToClass,p=o.enterActiveClass,u=o.appearClass,m=o.appearToClass,h=o.appearActiveClass,g=o.beforeEnter,v=o.enter,b=o.afterEnter,x=o.enterCancelled,y=o.beforeAppear,w=o.appear,k=o.afterAppear,j=o.appearCancelled,T=o.duration,S=Ke,E=Ke.$vnode;E&&E.parent;)S=E.context,E=E.parent;var I=!S._isMounted||!n.isRootInsert;if(!I||w||""===w){var z=I&&u?u:s,C=I&&h?h:p,A=I&&m?m:d,_=I&&y||g,P=I&&"function"==typeof w?w:v,B=I&&k||b,M=I&&j||x,O=f(c(T)?T.enter:T);0;var D=!1!==a&&!X,L=ca(P),N=t._enterCb=$((function(){D&&(na(t,A),na(t,C)),N.cancelled?(D&&na(t,z),M&&M(t)):B&&B(t),t._enterCb=null}));n.data.show||de(n,"insert",(function(){var e=t.parentNode,o=e&&e._pending&&e._pending[n.key];o&&o.tag===n.tag&&o.elm._leaveCb&&o.elm._leaveCb(),P&&P(t,N)})),_&&_(t),D&&(Qo(t,z),Qo(t,C),Ko((function(){na(t,z),N.cancelled||(Qo(t,A),L||(sa(O)?setTimeout(N,O):ea(t,l,N)))}))),n.data.show&&(e&&e(),P&&P(t,N)),D||L||N()}}}function la(n,e){var t=n.elm;r(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var o=qo(n.data.transition);if(i(o)||1!==t.nodeType)return e();if(!r(t._leaveCb)){var a=o.css,l=o.type,s=o.leaveClass,d=o.leaveToClass,p=o.leaveActiveClass,u=o.beforeLeave,m=o.leave,h=o.afterLeave,g=o.leaveCancelled,v=o.delayLeave,b=o.duration,x=!1!==a&&!X,y=ca(m),w=f(c(b)?b.leave:b);0;var k=t._leaveCb=$((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),x&&(na(t,d),na(t,p)),k.cancelled?(x&&na(t,s),g&&g(t)):(e(),h&&h(t)),t._leaveCb=null}));v?v(j):j()}function j(){k.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),x&&(Qo(t,s),Qo(t,p),Ko((function(){na(t,s),k.cancelled||(Qo(t,d),y||(sa(w)?setTimeout(k,w):ea(t,l,k)))}))),m&&m(t,k),x||y||k())}}function sa(n){return"number"==typeof n&&!isNaN(n)}function ca(n){if(i(n))return!1;var e=n.fns;return r(e)?ca(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function da(n,e){!0!==e.data.show&&ra(e)}var pa=function(n){var e,t,o={},a=n.modules,c=n.nodeOps;for(e=0;e<to.length;++e)for(o[to[e]]=[],t=0;t<a.length;++t)r(a[t][to[e]])&&o[to[e]].push(a[t][to[e]]);function d(n){var e=c.parentNode(n);r(e)&&c.removeChild(e,n)}function p(n,e,t,a,i,s,d){if(r(n.elm)&&r(s)&&(n=s[d]=yn(n)),n.isRootInsert=!i,!function(n,e,t,a){var i=n.data;if(r(i)){var s=r(n.componentInstance)&&i.keepAlive;if(r(i=i.hook)&&r(i=i.init)&&i(n,!1),r(n.componentInstance))return u(n,e),m(t,n.elm,a),l(s)&&function(n,e,t,a){var i,l=n;for(;l.componentInstance;)if(l=l.componentInstance._vnode,r(i=l.data)&&r(i=i.transition)){for(i=0;i<o.activate.length;++i)o.activate[i](eo,l);e.push(l);break}m(t,n.elm,a)}(n,e,t,a),!0}}(n,e,t,a)){var p=n.data,g=n.children,v=n.tag;r(v)?(n.elm=n.ns?c.createElementNS(n.ns,v):c.createElement(v,n),b(n),h(n,g,e),r(p)&&f(n,e),m(t,n.elm,a)):l(n.isComment)?(n.elm=c.createComment(n.text),m(t,n.elm,a)):(n.elm=c.createTextNode(n.text),m(t,n.elm,a))}}function u(n,e){r(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,g(n)?(f(n,e),b(n)):(no(n),e.push(n))}function m(n,e,t){r(n)&&(r(t)?c.parentNode(t)===n&&c.insertBefore(n,e,t):c.appendChild(n,e))}function h(n,e,t){if(Array.isArray(e)){0;for(var o=0;o<e.length;++o)p(e[o],t,n.elm,null,!0,e,o)}else s(n.text)&&c.appendChild(n.elm,c.createTextNode(String(n.text)))}function g(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return r(n.tag)}function f(n,t){for(var a=0;a<o.create.length;++a)o.create[a](eo,n);r(e=n.data.hook)&&(r(e.create)&&e.create(eo,n),r(e.insert)&&t.push(n))}function b(n){var e;if(r(e=n.fnScopeId))c.setStyleScope(n.elm,e);else for(var t=n;t;)r(e=t.context)&&r(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e),t=t.parent;r(e=Ke)&&e!==n.context&&e!==n.fnContext&&r(e=e.$options._scopeId)&&c.setStyleScope(n.elm,e)}function x(n,e,t,o,a,i){for(;o<=a;++o)p(t[o],i,n,e,!1,t,o)}function y(n){var e,t,a=n.data;if(r(a))for(r(e=a.hook)&&r(e=e.destroy)&&e(n),e=0;e<o.destroy.length;++e)o.destroy[e](n);if(r(e=n.children))for(t=0;t<n.children.length;++t)y(n.children[t])}function w(n,e,t){for(;e<=t;++e){var o=n[e];r(o)&&(r(o.tag)?(k(o),y(o)):d(o.elm))}}function k(n,e){if(r(e)||r(n.data)){var t,a=o.remove.length+1;for(r(e)?e.listeners+=a:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,a),r(t=n.componentInstance)&&r(t=t._vnode)&&r(t.data)&&k(t,e),t=0;t<o.remove.length;++t)o.remove[t](n,e);r(t=n.data.hook)&&r(t=t.remove)?t(n,e):e()}else d(n.elm)}function j(n,e,t,o){for(var a=t;a<o;a++){var i=e[a];if(r(i)&&oo(n,i))return a}}function T(n,e,t,a,s,d){if(n!==e){r(e.elm)&&r(a)&&(e=a[s]=yn(e));var u=e.elm=n.elm;if(l(n.isAsyncPlaceholder))r(e.asyncFactory.resolved)?I(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(l(e.isStatic)&&l(n.isStatic)&&e.key===n.key&&(l(e.isCloned)||l(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,h=e.data;r(h)&&r(m=h.hook)&&r(m=m.prepatch)&&m(n,e);var f=n.children,v=e.children;if(r(h)&&g(e)){for(m=0;m<o.update.length;++m)o.update[m](n,e);r(m=h.hook)&&r(m=m.update)&&m(n,e)}i(e.text)?r(f)&&r(v)?f!==v&&function(n,e,t,o,a){var l,s,d,u=0,m=0,h=e.length-1,g=e[0],f=e[h],v=t.length-1,b=t[0],y=t[v],k=!a;for(0;u<=h&&m<=v;)i(g)?g=e[++u]:i(f)?f=e[--h]:oo(g,b)?(T(g,b,o,t,m),g=e[++u],b=t[++m]):oo(f,y)?(T(f,y,o,t,v),f=e[--h],y=t[--v]):oo(g,y)?(T(g,y,o,t,v),k&&c.insertBefore(n,g.elm,c.nextSibling(f.elm)),g=e[++u],y=t[--v]):oo(f,b)?(T(f,b,o,t,m),k&&c.insertBefore(n,f.elm,g.elm),f=e[--h],b=t[++m]):(i(l)&&(l=ao(e,u,h)),i(s=r(b.key)?l[b.key]:j(b,e,u,h))?p(b,o,n,g.elm,!1,t,m):oo(d=e[s],b)?(T(d,b,o,t,m),e[s]=void 0,k&&c.insertBefore(n,d.elm,g.elm)):p(b,o,n,g.elm,!1,t,m),b=t[++m]);u>h?x(n,i(t[v+1])?null:t[v+1].elm,t,m,v,o):m>v&&w(e,u,h)}(u,f,v,t,d):r(v)?(r(n.text)&&c.setTextContent(u,""),x(u,null,v,0,v.length-1,t)):r(f)?w(f,0,f.length-1):r(n.text)&&c.setTextContent(u,""):n.text!==e.text&&c.setTextContent(u,e.text),r(h)&&r(m=h.hook)&&r(m=m.postpatch)&&m(n,e)}}}function S(n,e,t){if(l(t)&&r(n.parent))n.parent.data.pendingInsert=e;else for(var o=0;o<e.length;++o)e[o].data.hook.insert(e[o])}var E=v("attrs,class,staticClass,staticStyle,key");function I(n,e,t,o){var a,i=e.tag,s=e.data,c=e.children;if(o=o||s&&s.pre,e.elm=n,l(e.isComment)&&r(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(r(s)&&(r(a=s.hook)&&r(a=a.init)&&a(e,!0),r(a=e.componentInstance)))return u(e,t),!0;if(r(i)){if(r(c))if(n.hasChildNodes())if(r(a=s)&&r(a=a.domProps)&&r(a=a.innerHTML)){if(a!==n.innerHTML)return!1}else{for(var d=!0,p=n.firstChild,m=0;m<c.length;m++){if(!p||!I(p,c[m],t,o)){d=!1;break}p=p.nextSibling}if(!d||p)return!1}else h(e,c,t);if(r(s)){var g=!1;for(var v in s)if(!E(v)){g=!0,f(e,t);break}!g&&s.class&&re(s.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,a){if(!i(e)){var s,d=!1,u=[];if(i(n))d=!0,p(e,u);else{var m=r(n.nodeType);if(!m&&oo(n,e))T(n,e,u,null,null,a);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),l(t)&&I(n,e,u))return S(e,u,!0),n;s=n,n=new fn(c.tagName(s).toLowerCase(),{},[],void 0,s)}var h=n.elm,f=c.parentNode(h);if(p(e,u,h._leaveCb?null:f,c.nextSibling(h)),r(e.parent))for(var v=e.parent,b=g(e);v;){for(var x=0;x<o.destroy.length;++x)o.destroy[x](v);if(v.elm=e.elm,b){for(var k=0;k<o.create.length;++k)o.create[k](eo,v);var j=v.data.hook.insert;if(j.merged)for(var E=1;E<j.fns.length;E++)j.fns[E]()}else no(v);v=v.parent}r(f)?w([n],0,0):r(n.tag)&&y(n)}}return S(e,u,d),e.elm}r(n)&&y(n)}}({nodeOps:Kt,modules:[fo,xo,Eo,Co,Vo,J?{create:da,activate:da,remove:function(n,e){!0!==n.data.show?la(n,e):e()}}:{}].concat(uo)});X&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&xa(n,"input")}));var ua={inserted:function(n,e,t,o){"select"===t.tag?(o.elm&&!o.elm._vOptions?de(t,"postpatch",(function(){ua.componentUpdated(n,e,t)})):ma(n,e,t.context),n._vOptions=[].map.call(n.options,fa)):("textarea"===t.tag||Xt(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",va),n.addEventListener("compositionend",ba),n.addEventListener("change",ba),X&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){ma(n,e,t.context);var o=n._vOptions,a=n._vOptions=[].map.call(n.options,fa);if(a.some((function(n,e){return!O(n,o[e])})))(n.multiple?e.value.some((function(n){return ga(n,a)})):e.value!==e.oldValue&&ga(e.value,a))&&xa(n,"change")}}};function ma(n,e,t){ha(n,e,t),(Y||K)&&setTimeout((function(){ha(n,e,t)}),0)}function ha(n,e,t){var o=e.value,a=n.multiple;if(!a||Array.isArray(o)){for(var i,r,l=0,s=n.options.length;l<s;l++)if(r=n.options[l],a)i=D(o,fa(r))>-1,r.selected!==i&&(r.selected=i);else if(O(fa(r),o))return void(n.selectedIndex!==l&&(n.selectedIndex=l));a||(n.selectedIndex=-1)}}function ga(n,e){return e.every((function(e){return!O(e,n)}))}function fa(n){return"_value"in n?n._value:n.value}function va(n){n.target.composing=!0}function ba(n){n.target.composing&&(n.target.composing=!1,xa(n.target,"input"))}function xa(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function ya(n){return!n.componentInstance||n.data&&n.data.transition?n:ya(n.componentInstance._vnode)}var wa={model:ua,show:{bind:function(n,e,t){var o=e.value,a=(t=ya(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;o&&a?(t.data.show=!0,ra(t,(function(){n.style.display=i}))):n.style.display=o?i:"none"},update:function(n,e,t){var o=e.value;!o!=!e.oldValue&&((t=ya(t)).data&&t.data.transition?(t.data.show=!0,o?ra(t,(function(){n.style.display=n.__vOriginalDisplay})):la(t,(function(){n.style.display="none"}))):n.style.display=o?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,o,a){a||(n.style.display=n.__vOriginalDisplay)}}},ka={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function ja(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?ja(Ge(e.children)):n}function Ta(n){var e={},t=n.$options;for(var o in t.propsData)e[o]=n[o];var a=t._parentListeners;for(var i in a)e[T(i)]=a[i];return e}function Sa(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Ea=function(n){return n.tag||ve(n)},Ia=function(n){return"show"===n.name},za={name:"transition",props:ka,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Ea)).length){0;var o=this.mode;0;var a=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return a;var i=ja(a);if(!i)return a;if(this._leaving)return Sa(n,a);var r="__transition-"+this._uid+"-";i.key=null==i.key?i.isComment?r+"comment":r+i.tag:s(i.key)?0===String(i.key).indexOf(r)?i.key:r+i.key:i.key;var l=(i.data||(i.data={})).transition=Ta(this),c=this._vnode,d=ja(c);if(i.data.directives&&i.data.directives.some(Ia)&&(i.data.show=!0),d&&d.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,d)&&!ve(d)&&(!d.componentInstance||!d.componentInstance._vnode.isComment)){var p=d.data.transition=A({},l);if("out-in"===o)return this._leaving=!0,de(p,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Sa(n,a);if("in-out"===o){if(ve(i))return c;var u,m=function(){u()};de(l,"afterEnter",m),de(l,"enterCancelled",m),de(p,"delayLeave",(function(n){u=n}))}}return a}}},Ca=A({tag:String,moveClass:String},ka);function Aa(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function _a(n){n.data.newPos=n.elm.getBoundingClientRect()}function Pa(n){var e=n.data.pos,t=n.data.newPos,o=e.left-t.left,a=e.top-t.top;if(o||a){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate("+o+"px,"+a+"px)",i.transitionDuration="0s"}}delete Ca.mode;var Ba={Transition:za,TransitionGroup:{props:Ca,beforeMount:function(){var n=this,e=this._update;this._update=function(t,o){var a=Qe(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,a(),e.call(n,t,o)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),o=this.prevChildren=this.children,a=this.$slots.default||[],i=this.children=[],r=Ta(this),l=0;l<a.length;l++){var s=a[l];if(s.tag)if(null!=s.key&&0!==String(s.key).indexOf("__vlist"))i.push(s),t[s.key]=s,(s.data||(s.data={})).transition=r;else;}if(o){for(var c=[],d=[],p=0;p<o.length;p++){var u=o[p];u.data.transition=r,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?c.push(u):d.push(u)}this.kept=n(e,null,c),this.removed=d}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Aa),n.forEach(_a),n.forEach(Pa),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,o=t.style;Qo(t,e),o.transform=o.WebkitTransform=o.transitionDuration="",t.addEventListener(Wo,t._moveCb=function n(o){o&&o.target!==t||o&&!/transform$/.test(o.propertyName)||(t.removeEventListener(Wo,n),t._moveCb=null,na(t,e))})}})))},methods:{hasMove:function(n,e){if(!Jo)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){Ro(t,n)})),Ho(t,e),t.style.display="none",this.$el.appendChild(t);var o=oa(t);return this.$el.removeChild(t),this._hasMove=o.hasTransform}}}};St.config.mustUseProp=function(n,e,t){return"value"===t&&Mt(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},St.config.isReservedTag=Zt,St.config.isReservedAttr=Bt,St.config.getTagNamespace=function(n){return Wt(n)?"svg":"math"===n?"math":void 0},St.config.isUnknownElement=function(n){if(!J)return!0;if(Zt(n))return!1;if(n=n.toLowerCase(),null!=Yt[n])return Yt[n];var e=document.createElement(n);return n.indexOf("-")>-1?Yt[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:Yt[n]=/HTMLUnknownElement/.test(e.toString())},A(St.options.directives,wa),A(St.options.components,Ba),St.prototype.__patch__=J?pa:P,St.prototype.$mount=function(n,e){return function(n,e,t){var o;return n.$el=e,n.$options.render||(n.$options.render=bn),tt(n,"beforeMount"),o=function(){n._update(n._render(),t)},new ht(n,o,P,{before:function(){n._isMounted&&!n._isDestroyed&&tt(n,"beforeUpdate")}},!0),t=!1,null==n.$vnode&&(n._isMounted=!0,tt(n,"mounted")),n}(this,n=n&&J?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},J&&setTimeout((function(){V.devtools&&rn&&rn.emit("init",St)}),0);var Ma=St;
/*!
  * vue-router v3.5.3
  * (c) 2021 Evan You
  * @license MIT
  */function Oa(n,e){for(var t in e)n[t]=e[t];return n}var Da=/[!'()*]/g,$a=function(n){return"%"+n.charCodeAt(0).toString(16)},La=/%2C/g,Na=function(n){return encodeURIComponent(n).replace(Da,$a).replace(La,",")};function Va(n){try{return decodeURIComponent(n)}catch(n){0}return n}var Ua=function(n){return null==n||"object"==typeof n?n:String(n)};function Ha(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),o=Va(t.shift()),a=t.length>0?Va(t.join("=")):null;void 0===e[o]?e[o]=a:Array.isArray(e[o])?e[o].push(a):e[o]=[e[o],a]})),e):e}function Ra(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return Na(e);if(Array.isArray(t)){var o=[];return t.forEach((function(n){void 0!==n&&(null===n?o.push(Na(e)):o.push(Na(e)+"="+Na(n)))})),o.join("&")}return Na(e)+"="+Na(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var qa=/\/?$/;function Fa(n,e,t,o){var a=o&&o.options.stringifyQuery,i=e.query||{};try{i=Ja(i)}catch(n){}var r={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:Za(e,a),matched:n?Wa(n):[]};return t&&(r.redirectedFrom=Za(t,a)),Object.freeze(r)}function Ja(n){if(Array.isArray(n))return n.map(Ja);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=Ja(n[t]);return e}return n}var Ga=Fa(null,{path:"/"});function Wa(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function Za(n,e){var t=n.path,o=n.query;void 0===o&&(o={});var a=n.hash;return void 0===a&&(a=""),(t||"/")+(e||Ra)(o)+a}function Ya(n,e,t){return e===Ga?n===e:!!e&&(n.path&&e.path?n.path.replace(qa,"")===e.path.replace(qa,"")&&(t||n.hash===e.hash&&Xa(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&Xa(n.query,e.query)&&Xa(n.params,e.params))))}function Xa(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),o=Object.keys(e).sort();return t.length===o.length&&t.every((function(t,a){var i=n[t];if(o[a]!==t)return!1;var r=e[t];return null==i||null==r?i===r:"object"==typeof i&&"object"==typeof r?Xa(i,r):String(i)===String(r)}))}function Ka(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var o in t.instances){var a=t.instances[o],i=t.enteredCbs[o];if(a&&i){delete t.enteredCbs[o];for(var r=0;r<i.length;r++)a._isBeingDestroyed||i[r](a)}}}}var Qa={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,o=e.children,a=e.parent,i=e.data;i.routerView=!0;for(var r=a.$createElement,l=t.name,s=a.$route,c=a._routerViewCache||(a._routerViewCache={}),d=0,p=!1;a&&a._routerRoot!==a;){var u=a.$vnode?a.$vnode.data:{};u.routerView&&d++,u.keepAlive&&a._directInactive&&a._inactive&&(p=!0),a=a.$parent}if(i.routerViewDepth=d,p){var m=c[l],h=m&&m.component;return h?(m.configProps&&ni(h,i,m.route,m.configProps),r(h,i,o)):r()}var g=s.matched[d],f=g&&g.components[l];if(!g||!f)return c[l]=null,r();c[l]={component:f},i.registerRouteInstance=function(n,e){var t=g.instances[l];(e&&t!==n||!e&&t===n)&&(g.instances[l]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){g.instances[l]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==g.instances[l]&&(g.instances[l]=n.componentInstance),Ka(s)};var v=g.props&&g.props[l];return v&&(Oa(c[l],{route:s,configProps:v}),ni(f,i,s,v)),r(f,i,o)}};function ni(n,e,t,o){var a=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,o);if(a){a=e.props=Oa({},a);var i=e.attrs=e.attrs||{};for(var r in a)n.props&&r in n.props||(i[r]=a[r],delete a[r])}}function ei(n,e,t){var o=n.charAt(0);if("/"===o)return n;if("?"===o||"#"===o)return e+n;var a=e.split("/");t&&a[a.length-1]||a.pop();for(var i=n.replace(/^\//,"").split("/"),r=0;r<i.length;r++){var l=i[r];".."===l?a.pop():"."!==l&&a.push(l)}return""!==a[0]&&a.unshift(""),a.join("/")}function ti(n){return n.replace(/\/+/g,"/")}var oi=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ai=bi,ii=di,ri=function(n,e){return ui(di(n,e),e)},li=ui,si=vi,ci=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function di(n,e){for(var t,o=[],a=0,i=0,r="",l=e&&e.delimiter||"/";null!=(t=ci.exec(n));){var s=t[0],c=t[1],d=t.index;if(r+=n.slice(i,d),i=d+s.length,c)r+=c[1];else{var p=n[i],u=t[2],m=t[3],h=t[4],g=t[5],f=t[6],v=t[7];r&&(o.push(r),r="");var b=null!=u&&null!=p&&p!==u,x="+"===f||"*"===f,y="?"===f||"*"===f,w=t[2]||l,k=h||g;o.push({name:m||a++,prefix:u||"",delimiter:w,optional:y,repeat:x,partial:b,asterisk:!!v,pattern:k?hi(k):v?".*":"[^"+mi(w)+"]+?"})}}return i<n.length&&(r+=n.substr(i)),r&&o.push(r),o}function pi(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function ui(n,e){for(var t=new Array(n.length),o=0;o<n.length;o++)"object"==typeof n[o]&&(t[o]=new RegExp("^(?:"+n[o].pattern+")$",fi(e)));return function(e,o){for(var a="",i=e||{},r=(o||{}).pretty?pi:encodeURIComponent,l=0;l<n.length;l++){var s=n[l];if("string"!=typeof s){var c,d=i[s.name];if(null==d){if(s.optional){s.partial&&(a+=s.prefix);continue}throw new TypeError('Expected "'+s.name+'" to be defined')}if(oi(d)){if(!s.repeat)throw new TypeError('Expected "'+s.name+'" to not repeat, but received `'+JSON.stringify(d)+"`");if(0===d.length){if(s.optional)continue;throw new TypeError('Expected "'+s.name+'" to not be empty')}for(var p=0;p<d.length;p++){if(c=r(d[p]),!t[l].test(c))throw new TypeError('Expected all "'+s.name+'" to match "'+s.pattern+'", but received `'+JSON.stringify(c)+"`");a+=(0===p?s.prefix:s.delimiter)+c}}else{if(c=s.asterisk?encodeURI(d).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):r(d),!t[l].test(c))throw new TypeError('Expected "'+s.name+'" to match "'+s.pattern+'", but received "'+c+'"');a+=s.prefix+c}}else a+=s}return a}}function mi(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function hi(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function gi(n,e){return n.keys=e,n}function fi(n){return n&&n.sensitive?"":"i"}function vi(n,e,t){oi(e)||(t=e||t,e=[]);for(var o=(t=t||{}).strict,a=!1!==t.end,i="",r=0;r<n.length;r++){var l=n[r];if("string"==typeof l)i+=mi(l);else{var s=mi(l.prefix),c="(?:"+l.pattern+")";e.push(l),l.repeat&&(c+="(?:"+s+c+")*"),i+=c=l.optional?l.partial?s+"("+c+")?":"(?:"+s+"("+c+"))?":s+"("+c+")"}}var d=mi(t.delimiter||"/"),p=i.slice(-d.length)===d;return o||(i=(p?i.slice(0,-d.length):i)+"(?:"+d+"(?=$))?"),i+=a?"$":o&&p?"":"(?="+d+"|$)",gi(new RegExp("^"+i,fi(t)),e)}function bi(n,e,t){return oi(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var o=0;o<t.length;o++)e.push({name:o,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return gi(n,e)}(n,e):oi(n)?function(n,e,t){for(var o=[],a=0;a<n.length;a++)o.push(bi(n[a],e,t).source);return gi(new RegExp("(?:"+o.join("|")+")",fi(t)),e)}(n,e,t):function(n,e,t){return vi(di(n,t),e,t)}(n,e,t)}ai.parse=ii,ai.compile=ri,ai.tokensToFunction=li,ai.tokensToRegExp=si;var xi=Object.create(null);function yi(n,e,t){e=e||{};try{var o=xi[n]||(xi[n]=ai.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),o(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function wi(n,e,t,o){var a="string"==typeof n?{path:n}:n;if(a._normalized)return a;if(a.name){var i=(a=Oa({},n)).params;return i&&"object"==typeof i&&(a.params=Oa({},i)),a}if(!a.path&&a.params&&e){(a=Oa({},a))._normalized=!0;var r=Oa(Oa({},e.params),a.params);if(e.name)a.name=e.name,a.params=r;else if(e.matched.length){var l=e.matched[e.matched.length-1].path;a.path=yi(l,r,e.path)}else 0;return a}var s=function(n){var e="",t="",o=n.indexOf("#");o>=0&&(e=n.slice(o),n=n.slice(0,o));var a=n.indexOf("?");return a>=0&&(t=n.slice(a+1),n=n.slice(0,a)),{path:n,query:t,hash:e}}(a.path||""),c=e&&e.path||"/",d=s.path?ei(s.path,c,t||a.append):c,p=function(n,e,t){void 0===e&&(e={});var o,a=t||Ha;try{o=a(n||"")}catch(n){o={}}for(var i in e){var r=e[i];o[i]=Array.isArray(r)?r.map(Ua):Ua(r)}return o}(s.query,a.query,o&&o.options.parseQuery),u=a.hash||s.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:d,query:p,hash:u}}var ki,ji=function(){},Ti={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,o=this.$route,a=t.resolve(this.to,o,this.append),i=a.location,r=a.route,l=a.href,s={},c=t.options.linkActiveClass,d=t.options.linkExactActiveClass,p=null==c?"router-link-active":c,u=null==d?"router-link-exact-active":d,m=null==this.activeClass?p:this.activeClass,h=null==this.exactActiveClass?u:this.exactActiveClass,g=r.redirectedFrom?Fa(null,wi(r.redirectedFrom),null,t):r;s[h]=Ya(o,g,this.exactPath),s[m]=this.exact||this.exactPath?s[h]:function(n,e){return 0===n.path.replace(qa,"/").indexOf(e.path.replace(qa,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(o,g);var f=s[h]?this.ariaCurrentValue:null,v=function(n){Si(n)&&(e.replace?t.replace(i,ji):t.push(i,ji))},b={click:Si};Array.isArray(this.event)?this.event.forEach((function(n){b[n]=v})):b[this.event]=v;var x={class:s},y=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:l,route:r,navigate:v,isActive:s[m],isExactActive:s[h]});if(y){if(1===y.length)return y[0];if(y.length>1||!y.length)return 0===y.length?n():n("span",{},y)}if("a"===this.tag)x.on=b,x.attrs={href:l,"aria-current":f};else{var w=function n(e){var t;if(e)for(var o=0;o<e.length;o++){if("a"===(t=e[o]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var k=w.data=Oa({},w.data);for(var j in k.on=k.on||{},k.on){var T=k.on[j];j in b&&(k.on[j]=Array.isArray(T)?T:[T])}for(var S in b)S in k.on?k.on[S].push(b[S]):k.on[S]=v;var E=w.data.attrs=Oa({},w.data.attrs);E.href=l,E["aria-current"]=f}else x.on=b}return n(this.tag,x,this.$slots.default)}};function Si(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Ei="undefined"!=typeof window;function Ii(n,e,t,o,a){var i=e||[],r=t||Object.create(null),l=o||Object.create(null);n.forEach((function(n){!function n(e,t,o,a,i,r){var l=a.path,s=a.name;0;var c=a.pathToRegexpOptions||{},d=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return ti(e.path+"/"+n)}(l,i,c.strict);"boolean"==typeof a.caseSensitive&&(c.sensitive=a.caseSensitive);var p={path:d,regex:zi(d,c),components:a.components||{default:a.component},alias:a.alias?"string"==typeof a.alias?[a.alias]:a.alias:[],instances:{},enteredCbs:{},name:s,parent:i,matchAs:r,redirect:a.redirect,beforeEnter:a.beforeEnter,meta:a.meta||{},props:null==a.props?{}:a.components?a.props:{default:a.props}};a.children&&a.children.forEach((function(a){var i=r?ti(r+"/"+a.path):void 0;n(e,t,o,a,p,i)}));t[p.path]||(e.push(p.path),t[p.path]=p);if(void 0!==a.alias)for(var u=Array.isArray(a.alias)?a.alias:[a.alias],m=0;m<u.length;++m){0;var h={path:u[m],children:a.children};n(e,t,o,h,i,p.path||"/")}s&&(o[s]||(o[s]=p))}(i,r,l,n,a)}));for(var s=0,c=i.length;s<c;s++)"*"===i[s]&&(i.push(i.splice(s,1)[0]),c--,s--);return{pathList:i,pathMap:r,nameMap:l}}function zi(n,e){return ai(n,[],e)}function Ci(n,e){var t=Ii(n),o=t.pathList,a=t.pathMap,i=t.nameMap;function r(n,t,r){var l=wi(n,t,!1,e),c=l.name;if(c){var d=i[c];if(!d)return s(null,l);var p=d.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof l.params&&(l.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in l.params)&&p.indexOf(u)>-1&&(l.params[u]=t.params[u]);return l.path=yi(d.path,l.params),s(d,l,r)}if(l.path){l.params={};for(var m=0;m<o.length;m++){var h=o[m],g=a[h];if(Ai(g.regex,l.path,l.params))return s(g,l,r)}}return s(null,l)}function l(n,t){var o=n.redirect,a="function"==typeof o?o(Fa(n,t,null,e)):o;if("string"==typeof a&&(a={path:a}),!a||"object"!=typeof a)return s(null,t);var l=a,c=l.name,d=l.path,p=t.query,u=t.hash,m=t.params;if(p=l.hasOwnProperty("query")?l.query:p,u=l.hasOwnProperty("hash")?l.hash:u,m=l.hasOwnProperty("params")?l.params:m,c){i[c];return r({_normalized:!0,name:c,query:p,hash:u,params:m},void 0,t)}if(d){var h=function(n,e){return ei(n,e.parent?e.parent.path:"/",!0)}(d,n);return r({_normalized:!0,path:yi(h,m),query:p,hash:u},void 0,t)}return s(null,t)}function s(n,t,o){return n&&n.redirect?l(n,o||t):n&&n.matchAs?function(n,e,t){var o=r({_normalized:!0,path:yi(t,e.params)});if(o){var a=o.matched,i=a[a.length-1];return e.params=o.params,s(i,e)}return s(null,e)}(0,t,n.matchAs):Fa(n,t,o,e)}return{match:r,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Ii([e||n],o,a,i,t),t&&t.alias.length&&Ii(t.alias.map((function(n){return{path:n,children:[e]}})),o,a,i,t)},getRoutes:function(){return o.map((function(n){return a[n]}))},addRoutes:function(n){Ii(n,o,a,i)}}}function Ai(n,e,t){var o=e.match(n);if(!o)return!1;if(!t)return!0;for(var a=1,i=o.length;a<i;++a){var r=n.keys[a-1];r&&(t[r.name||"pathMatch"]="string"==typeof o[a]?Va(o[a]):o[a])}return!0}var _i=Ei&&window.performance&&window.performance.now?window.performance:Date;function Pi(){return _i.now().toFixed(3)}var Bi=Pi();function Mi(){return Bi}function Oi(n){return Bi=n}var Di=Object.create(null);function $i(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=Oa({},window.history.state);return t.key=Mi(),window.history.replaceState(t,"",e),window.addEventListener("popstate",Vi),function(){window.removeEventListener("popstate",Vi)}}function Li(n,e,t,o){if(n.app){var a=n.options.scrollBehavior;a&&n.app.$nextTick((function(){var i=function(){var n=Mi();if(n)return Di[n]}(),r=a.call(n,e,t,o?i:null);r&&("function"==typeof r.then?r.then((function(n){Fi(n,i)})).catch((function(n){0})):Fi(r,i))}))}}function Ni(){var n=Mi();n&&(Di[n]={x:window.pageXOffset,y:window.pageYOffset})}function Vi(n){Ni(),n.state&&n.state.key&&Oi(n.state.key)}function Ui(n){return Ri(n.x)||Ri(n.y)}function Hi(n){return{x:Ri(n.x)?n.x:window.pageXOffset,y:Ri(n.y)?n.y:window.pageYOffset}}function Ri(n){return"number"==typeof n}var qi=/^#\d/;function Fi(n,e){var t,o="object"==typeof n;if(o&&"string"==typeof n.selector){var a=qi.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(a){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),o=n.getBoundingClientRect();return{x:o.left-t.left-e.x,y:o.top-t.top-e.y}}(a,i={x:Ri((t=i).x)?t.x:0,y:Ri(t.y)?t.y:0})}else Ui(n)&&(e=Hi(n))}else o&&Ui(n)&&(e=Hi(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var Ji,Gi=Ei&&((-1===(Ji=window.navigator.userAgent).indexOf("Android 2.")&&-1===Ji.indexOf("Android 4.0")||-1===Ji.indexOf("Mobile Safari")||-1!==Ji.indexOf("Chrome")||-1!==Ji.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function Wi(n,e){Ni();var t=window.history;try{if(e){var o=Oa({},t.state);o.key=Mi(),t.replaceState(o,"",n)}else t.pushState({key:Oi(Pi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function Zi(n){Wi(n,!0)}function Yi(n,e,t){var o=function(a){a>=n.length?t():n[a]?e(n[a],(function(){o(a+1)})):o(a+1)};o(0)}var Xi={redirected:2,aborted:4,cancelled:8,duplicated:16};function Ki(n,e){return nr(n,e,Xi.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return er.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function Qi(n,e){return nr(n,e,Xi.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function nr(n,e,t,o){var a=new Error(o);return a._isRouter=!0,a.from=n,a.to=e,a.type=t,a}var er=["params","query","hash"];function tr(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function or(n,e){return tr(n)&&n._isRouter&&(null==e||n.type===e)}function ar(n){return function(e,t,o){var a=!1,i=0,r=null;ir(n,(function(n,e,t,l){if("function"==typeof n&&void 0===n.cid){a=!0,i++;var s,c=sr((function(e){var a;((a=e).__esModule||lr&&"Module"===a[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:ki.extend(e),t.components[l]=e,--i<=0&&o()})),d=sr((function(n){var e="Failed to resolve async component "+l+": "+n;r||(r=tr(n)?n:new Error(e),o(r))}));try{s=n(c,d)}catch(n){d(n)}if(s)if("function"==typeof s.then)s.then(c,d);else{var p=s.component;p&&"function"==typeof p.then&&p.then(c,d)}}})),a||o()}}function ir(n,e){return rr(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function rr(n){return Array.prototype.concat.apply([],n)}var lr="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function sr(n){var e=!1;return function(){for(var t=[],o=arguments.length;o--;)t[o]=arguments[o];if(!e)return e=!0,n.apply(this,t)}}var cr=function(n,e){this.router=n,this.base=function(n){if(!n)if(Ei){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=Ga,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function dr(n,e,t,o){var a=ir(n,(function(n,o,a,i){var r=function(n,e){"function"!=typeof n&&(n=ki.extend(n));return n.options[e]}(n,e);if(r)return Array.isArray(r)?r.map((function(n){return t(n,o,a,i)})):t(r,o,a,i)}));return rr(o?a.reverse():a)}function pr(n,e){if(e)return function(){return n.apply(e,arguments)}}cr.prototype.listen=function(n){this.cb=n},cr.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},cr.prototype.onError=function(n){this.errorCbs.push(n)},cr.prototype.transitionTo=function(n,e,t){var o,a=this;try{o=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(o,(function(){a.updateRoute(o),e&&e(o),a.ensureURL(),a.router.afterHooks.forEach((function(n){n&&n(o,i)})),a.ready||(a.ready=!0,a.readyCbs.forEach((function(n){n(o)})))}),(function(n){t&&t(n),n&&!a.ready&&(or(n,Xi.redirected)&&i===Ga||(a.ready=!0,a.readyErrorCbs.forEach((function(e){e(n)}))))}))},cr.prototype.confirmTransition=function(n,e,t){var o=this,a=this.current;this.pending=n;var i,r,l=function(n){!or(n)&&tr(n)&&(o.errorCbs.length?o.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},s=n.matched.length-1,c=a.matched.length-1;if(Ya(n,a)&&s===c&&n.matched[s]===a.matched[c])return this.ensureURL(),n.hash&&Li(this.router,a,n,!1),l(((r=nr(i=a,n,Xi.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",r));var d=function(n,e){var t,o=Math.max(n.length,e.length);for(t=0;t<o&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),p=d.updated,u=d.deactivated,m=d.activated,h=[].concat(function(n){return dr(n,"beforeRouteLeave",pr,!0)}(u),this.router.beforeHooks,function(n){return dr(n,"beforeRouteUpdate",pr)}(p),m.map((function(n){return n.beforeEnter})),ar(m)),g=function(e,t){if(o.pending!==n)return l(Qi(a,n));try{e(n,a,(function(e){!1===e?(o.ensureURL(!0),l(function(n,e){return nr(n,e,Xi.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(a,n))):tr(e)?(o.ensureURL(!0),l(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(l(Ki(a,n)),"object"==typeof e&&e.replace?o.replace(e):o.push(e)):t(e)}))}catch(n){l(n)}};Yi(h,g,(function(){Yi(function(n){return dr(n,"beforeRouteEnter",(function(n,e,t,o){return function(n,e,t){return function(o,a,i){return n(o,a,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,o)}))}(m).concat(o.router.resolveHooks),g,(function(){if(o.pending!==n)return l(Qi(a,n));o.pending=null,e(n),o.router.app&&o.router.app.$nextTick((function(){Ka(n)}))}))}))},cr.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},cr.prototype.setupListeners=function(){},cr.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=Ga,this.pending=null};var ur=function(n){function e(e,t){n.call(this,e,t),this._startLocation=mr(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,o=Gi&&t;o&&this.listeners.push($i());var a=function(){var t=n.current,a=mr(n.base);n.current===Ga&&a===n._startLocation||n.transitionTo(a,(function(n){o&&Li(e,n,t,!0)}))};window.addEventListener("popstate",a),this.listeners.push((function(){window.removeEventListener("popstate",a)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){Wi(ti(o.base+n.fullPath)),Li(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){Zi(ti(o.base+n.fullPath)),Li(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(mr(this.base)!==this.current.fullPath){var e=ti(this.base+this.current.fullPath);n?Wi(e):Zi(e)}},e.prototype.getCurrentLocation=function(){return mr(this.base)},e}(cr);function mr(n){var e=window.location.pathname,t=e.toLowerCase(),o=n.toLowerCase();return!n||t!==o&&0!==t.indexOf(ti(o+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var hr=function(n){function e(e,t,o){n.call(this,e,t),o&&function(n){var e=mr(n);if(!/^\/#/.test(e))return window.location.replace(ti(n+"/#"+e)),!0}(this.base)||gr()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=Gi&&e;t&&this.listeners.push($i());var o=function(){var e=n.current;gr()&&n.transitionTo(fr(),(function(o){t&&Li(n.router,o,e,!0),Gi||xr(o.fullPath)}))},a=Gi?"popstate":"hashchange";window.addEventListener(a,o),this.listeners.push((function(){window.removeEventListener(a,o)}))}},e.prototype.push=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){br(n.fullPath),Li(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this,a=this.current;this.transitionTo(n,(function(n){xr(n.fullPath),Li(o.router,n,a,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;fr()!==e&&(n?br(e):xr(e))},e.prototype.getCurrentLocation=function(){return fr()},e}(cr);function gr(){var n=fr();return"/"===n.charAt(0)||(xr("/"+n),!1)}function fr(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function vr(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function br(n){Gi?Wi(vr(n)):window.location.hash=n}function xr(n){Gi?Zi(vr(n)):window.location.replace(vr(n))}var yr=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index+1).concat(n),o.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var o=this;this.transitionTo(n,(function(n){o.stack=o.stack.slice(0,o.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var o=this.stack[t];this.confirmTransition(o,(function(){var n=e.current;e.index=t,e.updateRoute(o),e.router.afterHooks.forEach((function(e){e&&e(o,n)}))}),(function(n){or(n,Xi.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(cr),wr=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Ci(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!Gi&&!1!==n.fallback,this.fallback&&(e="hash"),Ei||(e="abstract"),this.mode=e,e){case"history":this.history=new ur(this,n.base);break;case"hash":this.history=new hr(this,n.base,this.fallback);break;case"abstract":this.history=new yr(this,n.base);break;default:0}},kr={currentRoute:{configurable:!0}};function jr(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}wr.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},kr.currentRoute.get=function(){return this.history&&this.history.current},wr.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof ur||t instanceof hr){var o=function(n){t.setupListeners(),function(n){var o=t.current,a=e.options.scrollBehavior;Gi&&a&&"fullPath"in n&&Li(e,n,o,!1)}(n)};t.transitionTo(t.getCurrentLocation(),o,o)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},wr.prototype.beforeEach=function(n){return jr(this.beforeHooks,n)},wr.prototype.beforeResolve=function(n){return jr(this.resolveHooks,n)},wr.prototype.afterEach=function(n){return jr(this.afterHooks,n)},wr.prototype.onReady=function(n,e){this.history.onReady(n,e)},wr.prototype.onError=function(n){this.history.onError(n)},wr.prototype.push=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.push(n,e,t)}));this.history.push(n,e,t)},wr.prototype.replace=function(n,e,t){var o=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){o.history.replace(n,e,t)}));this.history.replace(n,e,t)},wr.prototype.go=function(n){this.history.go(n)},wr.prototype.back=function(){this.go(-1)},wr.prototype.forward=function(){this.go(1)},wr.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},wr.prototype.resolve=function(n,e,t){var o=wi(n,e=e||this.history.current,t,this),a=this.match(o,e),i=a.redirectedFrom||a.fullPath;return{location:o,route:a,href:function(n,e,t){var o="hash"===t?"#"+e:e;return n?ti(n+"/"+o):o}(this.history.base,i,this.mode),normalizedTo:o,resolved:a}},wr.prototype.getRoutes=function(){return this.matcher.getRoutes()},wr.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==Ga&&this.history.transitionTo(this.history.getCurrentLocation())},wr.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==Ga&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(wr.prototype,kr),wr.install=function n(e){if(!n.installed||ki!==e){n.installed=!0,ki=e;var t=function(n){return void 0!==n},o=function(n,e){var o=n.$options._parentVnode;t(o)&&t(o=o.data)&&t(o=o.registerRouteInstance)&&o(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,o(this,this)},destroyed:function(){o(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",Qa),e.component("RouterLink",Ti);var a=e.config.optionMergeStrategies;a.beforeRouteEnter=a.beforeRouteLeave=a.beforeRouteUpdate=a.created}},wr.version="3.5.3",wr.isNavigationFailure=or,wr.NavigationFailureType=Xi,wr.START_LOCATION=Ga,Ei&&window.Vue&&window.Vue.use(wr);var Tr=wr;t(181),t(182),t(267),t(82),t(183),t(29),t(30),t(269);function Sr(n){n.locales&&Object.keys(n.locales).forEach((function(e){n.locales[e].path=e})),Object.freeze(n)}t(77),t(97),t(131);function Er(n){return(Er="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}var Ir=t(79),zr=(t(195),t(18),t(45),t(238),t(239),t(40),t(31),{NotFound:function(){return Promise.all([t.e(0),t.e(15)]).then(t.bind(null,585))},Layout:function(){return Promise.all([t.e(0),t.e(2)]).then(t.bind(null,584))}}),Cr={"v-768367e2":function(){return t.e(36).then(t.bind(null,587))},"v-d0a13a84":function(){return t.e(37).then(t.bind(null,588))},"v-2ba7b4d5":function(){return t.e(38).then(t.bind(null,589))},"v-09b07641":function(){return t.e(39).then(t.bind(null,590))},"v-94759ba8":function(){return t.e(40).then(t.bind(null,591))},"v-e13358fa":function(){return t.e(41).then(t.bind(null,592))},"v-1f47639c":function(){return t.e(42).then(t.bind(null,593))},"v-a54556a4":function(){return t.e(43).then(t.bind(null,594))},"v-119caaee":function(){return t.e(44).then(t.bind(null,595))},"v-2eddfdda":function(){return t.e(45).then(t.bind(null,596))},"v-21d8afeb":function(){return t.e(46).then(t.bind(null,597))},"v-370bb2c9":function(){return t.e(47).then(t.bind(null,598))},"v-76af4c12":function(){return t.e(48).then(t.bind(null,599))},"v-59ea62a4":function(){return t.e(49).then(t.bind(null,600))},"v-4c0a766c":function(){return t.e(50).then(t.bind(null,601))},"v-240078e0":function(){return t.e(51).then(t.bind(null,602))},"v-056cb10a":function(){return t.e(52).then(t.bind(null,603))},"v-79ac4976":function(){return t.e(53).then(t.bind(null,604))},"v-9973f104":function(){return t.e(54).then(t.bind(null,605))},"v-4e6abdc5":function(){return t.e(55).then(t.bind(null,606))},"v-37036a26":function(){return t.e(56).then(t.bind(null,607))},"v-142c4b83":function(){return t.e(57).then(t.bind(null,608))},"v-70b7207a":function(){return t.e(58).then(t.bind(null,609))},"v-354ba35d":function(){return t.e(59).then(t.bind(null,610))},"v-cfb19bce":function(){return t.e(60).then(t.bind(null,611))},"v-89224ada":function(){return t.e(61).then(t.bind(null,612))},"v-1f5da569":function(){return t.e(62).then(t.bind(null,613))},"v-1400beac":function(){return t.e(63).then(t.bind(null,614))},"v-829901ca":function(){return t.e(64).then(t.bind(null,615))},"v-a9f47444":function(){return t.e(65).then(t.bind(null,616))},"v-7bd1ca64":function(){return t.e(66).then(t.bind(null,617))},"v-1732d362":function(){return t.e(67).then(t.bind(null,618))},"v-86f0ff4e":function(){return t.e(68).then(t.bind(null,619))},"v-0cc7563e":function(){return t.e(69).then(t.bind(null,620))},"v-8a33a710":function(){return Promise.all([t.e(0),t.e(16)]).then(t.bind(null,621))},"v-bec52126":function(){return t.e(70).then(t.bind(null,622))},"v-ceb0edd0":function(){return t.e(71).then(t.bind(null,623))},"v-9fb14a2c":function(){return t.e(72).then(t.bind(null,624))},"v-13b23dae":function(){return t.e(73).then(t.bind(null,625))},"v-203057c8":function(){return t.e(74).then(t.bind(null,626))},"v-5d8ec06d":function(){return t.e(75).then(t.bind(null,627))},"v-5801946e":function(){return t.e(76).then(t.bind(null,628))},"v-74664c83":function(){return t.e(77).then(t.bind(null,629))},"v-4908690b":function(){return t.e(78).then(t.bind(null,630))},"v-fb370f06":function(){return t.e(79).then(t.bind(null,631))},"v-31a6a882":function(){return t.e(80).then(t.bind(null,632))},"v-44e2ea1a":function(){return t.e(81).then(t.bind(null,633))},"v-28146ea1":function(){return t.e(82).then(t.bind(null,634))},"v-ef2ec8a6":function(){return t.e(83).then(t.bind(null,635))},"v-fb6e6346":function(){return t.e(84).then(t.bind(null,636))},"v-a5baf23a":function(){return t.e(85).then(t.bind(null,637))},"v-62775647":function(){return t.e(86).then(t.bind(null,638))},"v-7ddaa860":function(){return t.e(87).then(t.bind(null,639))},"v-e8b0f490":function(){return t.e(88).then(t.bind(null,640))},"v-0ae5a9bc":function(){return t.e(89).then(t.bind(null,641))},"v-227c81ae":function(){return t.e(90).then(t.bind(null,642))},"v-33de3fe1":function(){return Promise.all([t.e(0),t.e(17)]).then(t.bind(null,643))},"v-329c94d8":function(){return t.e(91).then(t.bind(null,644))},"v-38d64c12":function(){return t.e(92).then(t.bind(null,645))},"v-5b414b04":function(){return t.e(93).then(t.bind(null,646))},"v-f7d71be6":function(){return t.e(94).then(t.bind(null,647))},"v-1aa834f7":function(){return t.e(95).then(t.bind(null,648))},"v-4a255ebe":function(){return t.e(96).then(t.bind(null,649))},"v-3d4d4ad8":function(){return t.e(97).then(t.bind(null,650))},"v-054e32aa":function(){return t.e(98).then(t.bind(null,651))},"v-0c1b4099":function(){return t.e(99).then(t.bind(null,652))},"v-1bd6c58a":function(){return t.e(100).then(t.bind(null,653))},"v-4688d30f":function(){return t.e(101).then(t.bind(null,654))},"v-5724ced2":function(){return t.e(102).then(t.bind(null,655))},"v-af4c07f2":function(){return t.e(103).then(t.bind(null,656))},"v-09b2f671":function(){return t.e(104).then(t.bind(null,586))},"v-f0e5a688":function(){return t.e(105).then(t.bind(null,657))},"v-77ef150e":function(){return t.e(106).then(t.bind(null,658))},"v-44afb06d":function(){return t.e(107).then(t.bind(null,659))},"v-15a8cec6":function(){return t.e(108).then(t.bind(null,660))},"v-f2696468":function(){return t.e(18).then(t.bind(null,661))},"v-a45689ae":function(){return t.e(109).then(t.bind(null,662))},"v-1aa5a292":function(){return t.e(110).then(t.bind(null,663))},"v-6cf68056":function(){return t.e(8).then(t.bind(null,664))},"v-603d9e38":function(){return t.e(111).then(t.bind(null,665))},"v-3f9649d2":function(){return t.e(9).then(t.bind(null,666))},"v-5c3398e2":function(){return t.e(112).then(t.bind(null,667))},"v-00d198cf":function(){return t.e(113).then(t.bind(null,668))},"v-10e281d8":function(){return t.e(25).then(t.bind(null,669))},"v-0910fc9a":function(){return t.e(114).then(t.bind(null,670))},"v-7a9c696e":function(){return t.e(5).then(t.bind(null,671))},"v-6cc34f95":function(){return t.e(115).then(t.bind(null,672))},"v-0bdb65db":function(){return t.e(116).then(t.bind(null,673))},"v-2ab16e45":function(){return t.e(117).then(t.bind(null,674))},"v-9888aae6":function(){return t.e(118).then(t.bind(null,675))},"v-0572c1aa":function(){return t.e(26).then(t.bind(null,676))},"v-6387b2f0":function(){return t.e(119).then(t.bind(null,677))},"v-45814ce9":function(){return t.e(120).then(t.bind(null,678))},"v-62ada9b3":function(){return t.e(121).then(t.bind(null,679))},"v-856062ce":function(){return t.e(122).then(t.bind(null,680))},"v-07a1b0b5":function(){return t.e(19).then(t.bind(null,681))},"v-7152c6bb":function(){return t.e(123).then(t.bind(null,682))},"v-739f697e":function(){return t.e(124).then(t.bind(null,683))},"v-585525e0":function(){return t.e(125).then(t.bind(null,684))},"v-efd22a0a":function(){return t.e(126).then(t.bind(null,685))},"v-25e5648a":function(){return t.e(127).then(t.bind(null,686))},"v-e5df6596":function(){return t.e(128).then(t.bind(null,687))},"v-693092bb":function(){return t.e(129).then(t.bind(null,688))},"v-3334fcbb":function(){return t.e(130).then(t.bind(null,689))},"v-0caf1fdb":function(){return t.e(131).then(t.bind(null,690))},"v-507dad0a":function(){return t.e(132).then(t.bind(null,691))},"v-0eff529f":function(){return t.e(137).then(t.bind(null,692))},"v-68c0f48a":function(){return t.e(133).then(t.bind(null,693))},"v-34aa7b86":function(){return t.e(138).then(t.bind(null,694))},"v-09038db5":function(){return t.e(139).then(t.bind(null,695))},"v-083b3713":function(){return t.e(140).then(t.bind(null,696))},"v-24eb3483":function(){return t.e(141).then(t.bind(null,697))},"v-5426fc63":function(){return t.e(142).then(t.bind(null,698))},"v-358d6d7e":function(){return t.e(136).then(t.bind(null,699))},"v-85c4362a":function(){return t.e(143).then(t.bind(null,700))},"v-72766126":function(){return t.e(27).then(t.bind(null,701))},"v-ac8c93d4":function(){return t.e(144).then(t.bind(null,702))},"v-342bb966":function(){return t.e(145).then(t.bind(null,703))},"v-6157df39":function(){return t.e(147).then(t.bind(null,704))},"v-a747ade8":function(){return t.e(146).then(t.bind(null,705))},"v-24294898":function(){return t.e(148).then(t.bind(null,706))},"v-5f6f758e":function(){return t.e(149).then(t.bind(null,707))},"v-4eaf1eab":function(){return t.e(150).then(t.bind(null,708))},"v-55ad473c":function(){return t.e(151).then(t.bind(null,709))},"v-51db4340":function(){return t.e(152).then(t.bind(null,710))},"v-f29668a2":function(){return t.e(153).then(t.bind(null,711))},"v-3fbd6196":function(){return t.e(154).then(t.bind(null,712))},"v-14bf56d8":function(){return t.e(155).then(t.bind(null,713))},"v-7849f14a":function(){return t.e(156).then(t.bind(null,714))},"v-0c43a93e":function(){return t.e(3).then(t.bind(null,715))},"v-914be310":function(){return t.e(10).then(t.bind(null,716))},"v-4b33a0fc":function(){return t.e(7).then(t.bind(null,717))},"v-e910ea2e":function(){return t.e(157).then(t.bind(null,718))},"v-9dd99cf6":function(){return t.e(158).then(t.bind(null,719))},"v-8d0417cc":function(){return t.e(159).then(t.bind(null,720))},"v-46373fc2":function(){return t.e(160).then(t.bind(null,721))},"v-24f2dc8c":function(){return t.e(20).then(t.bind(null,722))},"v-57d26e26":function(){return t.e(161).then(t.bind(null,723))},"v-872bc0d8":function(){return t.e(162).then(t.bind(null,724))},"v-9ebbc8cc":function(){return t.e(163).then(t.bind(null,725))},"v-9152731e":function(){return t.e(6).then(t.bind(null,726))},"v-28296e0a":function(){return t.e(28).then(t.bind(null,727))},"v-7fdbdcfc":function(){return t.e(11).then(t.bind(null,728))},"v-2cd89bf0":function(){return t.e(164).then(t.bind(null,729))},"v-0a8a952c":function(){return t.e(4).then(t.bind(null,730))},"v-155f6902":function(){return t.e(29).then(t.bind(null,731))},"v-12090137":function(){return t.e(165).then(t.bind(null,732))},"v-1237fee2":function(){return t.e(30).then(t.bind(null,733))},"v-c516b5da":function(){return t.e(166).then(t.bind(null,734))},"v-16cea650":function(){return t.e(167).then(t.bind(null,735))},"v-35b5c424":function(){return t.e(168).then(t.bind(null,736))},"v-543b1f60":function(){return t.e(169).then(t.bind(null,737))},"v-bb49f58c":function(){return t.e(21).then(t.bind(null,738))},"v-448d3032":function(){return t.e(170).then(t.bind(null,739))},"v-50a06977":function(){return t.e(31).then(t.bind(null,740))},"v-b041636c":function(){return t.e(32).then(t.bind(null,741))},"v-31e4b958":function(){return t.e(171).then(t.bind(null,742))},"v-442b5a91":function(){return t.e(33).then(t.bind(null,743))},"v-ee4028c4":function(){return t.e(172).then(t.bind(null,744))},"v-5c4c5168":function(){return t.e(173).then(t.bind(null,745))},"v-19d39f68":function(){return t.e(174).then(t.bind(null,746))},"v-60be060a":function(){return t.e(175).then(t.bind(null,747))},"v-3b93b6c4":function(){return t.e(176).then(t.bind(null,748))},"v-3edfb5c9":function(){return t.e(177).then(t.bind(null,749))},"v-ca2df650":function(){return t.e(178).then(t.bind(null,750))},"v-65a89695":function(){return t.e(179).then(t.bind(null,751))},"v-7be5c8d6":function(){return t.e(180).then(t.bind(null,752))},"v-501ae650":function(){return t.e(22).then(t.bind(null,753))},"v-f262342e":function(){return t.e(12).then(t.bind(null,754))},"v-189a620b":function(){return t.e(181).then(t.bind(null,755))},"v-7593113f":function(){return t.e(34).then(t.bind(null,756))},"v-7d33582d":function(){return t.e(13).then(t.bind(null,757))},"v-5e159a9e":function(){return t.e(182).then(t.bind(null,758))},"v-3f3a9c6d":function(){return t.e(23).then(t.bind(null,759))},"v-a7ae7326":function(){return t.e(35).then(t.bind(null,760))},"v-d73b99a6":function(){return t.e(24).then(t.bind(null,761))},"v-f5a073a2":function(){return t.e(183).then(t.bind(null,762))},"v-66c7385c":function(){return t.e(184).then(t.bind(null,763))},"v-a64046a6":function(){return t.e(185).then(t.bind(null,764))},"v-90d1f7e6":function(){return t.e(186).then(t.bind(null,765))},"v-2ec62ba6":function(){return t.e(187).then(t.bind(null,766))},"v-d9cccf82":function(){return t.e(188).then(t.bind(null,767))},"v-191fb5de":function(){return t.e(189).then(t.bind(null,768))},"v-43ae2c82":function(){return t.e(190).then(t.bind(null,769))},"v-a21e1e74":function(){return t.e(191).then(t.bind(null,770))},"v-55887b9b":function(){return t.e(135).then(t.bind(null,771))},"v-51ff37b9":function(){return t.e(134).then(t.bind(null,772))}};function Ar(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var _r=/-(\w)/g,Pr=Ar((function(n){return n.replace(_r,(function(n,e){return e?e.toUpperCase():""}))})),Br=/\B([A-Z])/g,Mr=Ar((function(n){return n.replace(Br,"-$1").toLowerCase()})),Or=Ar((function(n){return n.charAt(0).toUpperCase()+n.slice(1)}));function Dr(n,e){if(e)return n(e)?n(e):e.includes("-")?n(Or(Pr(e))):n(Or(e))||n(Mr(e))}var $r=Object.assign({},zr,Cr),Lr=function(n){return $r[n]},Nr=function(n){return Cr[n]},Vr=function(n){return zr[n]},Ur=function(n){return Ma.component(n)};function Hr(n){return Dr(Nr,n)}function Rr(n){return Dr(Vr,n)}function qr(n){return Dr(Lr,n)}function Fr(n){return Dr(Ur,n)}function Jr(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return Promise.all(e.filter((function(n){return n})).map(function(){var n=Object(o.a)(regeneratorRuntime.mark((function n(e){var t;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:if(Fr(e)||!qr(e)){n.next=5;break}return n.next=3,qr(e)();case 3:t=n.sent,Ma.component(e,t.default);case 5:case"end":return n.stop()}}),n)})));return function(e){return n.apply(this,arguments)}}()))}function Gr(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var Wr=t(143),Zr=(t(130),t(115),t(56),t(225)),Yr=t.n(Zr),Xr=t(226),Kr=t.n(Xr),Qr={created:function(){if(this.siteMeta=this.$site.headTags.filter((function(n){return"meta"===Object(Wr.a)(n,1)[0]})).map((function(n){var e=Object(Wr.a)(n,2);e[0];return e[1]})),this.$ssrContext){var n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map((function(n){var e="<meta";return Object.keys(n).forEach((function(t){e+=" ".concat(t,'="').concat(Kr()(n[t]),'"')})),e+">"})).join("\n    "):"",this.$ssrContext.canonicalLink=el(this.$canonicalUrl)}var e},mounted:function(){this.currentMetaTags=Object(Ir.a)(document.querySelectorAll("meta")),this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta:function(){document.title=this.$title,document.documentElement.lang=this.$lang;var n=this.getMergedMetaTags();this.currentMetaTags=tl(n,this.currentMetaTags)},getMergedMetaTags:function(){var n=this.$page.frontmatter.meta||[];return Yr()([{name:"description",content:this.$description}],n,this.siteMeta,ol)},updateCanonicalLink:function(){nl(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",el(this.$canonicalUrl))}},watch:{$page:function(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy:function(){tl(null,this.currentMetaTags),nl()}};function nl(){var n=document.querySelector("link[rel='canonical']");n&&n.remove()}function el(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return n?'<link href="'.concat(n,'" rel="canonical" />'):""}function tl(n,e){if(e&&Object(Ir.a)(e).filter((function(n){return n.parentNode===document.head})).forEach((function(n){return document.head.removeChild(n)})),n)return n.map((function(n){var e=document.createElement("meta");return Object.keys(n).forEach((function(t){e.setAttribute(t,n[t])})),document.head.appendChild(e),e}))}function ol(n){for(var e=0,t=["name","property","itemprop"];e<t.length;e++){var o=t[e];if(n.hasOwnProperty(o))return n[o]+o}return JSON.stringify(n)}t(144);var al=t(156),il={mounted:function(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(al)()((function(){this.setActiveHash()}),300),setActiveHash:function(){for(var n=this,e=[].slice.call(document.querySelectorAll(".sidebar-link")),t=[].slice.call(document.querySelectorAll(".header-anchor")).filter((function(n){return e.some((function(e){return e.hash===n.hash}))})),o=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+o,r=0;r<t.length;r++){var l=t[r],s=t[r+1],c=0===r&&0===o||o>=l.parentElement.offsetTop+10&&(!s||o<s.parentElement.offsetTop-10),d=decodeURIComponent(this.$route.hash);if(c&&d!==decodeURIComponent(l.hash)){var p=l;if(i===a)for(var u=r+1;u<t.length;u++)if(d===decodeURIComponent(t[u].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(p.hash),(function(){n.$nextTick((function(){n.$vuepress.$set("disableScrollBehavior",!1)}))}))}}}},beforeDestroy:function(){window.removeEventListener("scroll",this.onScroll)}},rl=(t(85),t(106)),ll=t.n(rl),sl={mounted:function(){var n=this;ll.a.configure({showSpinner:!1}),this.$router.beforeEach((function(n,e,t){n.path===e.path||Ma.component(n.name)||ll.a.start(),t()})),this.$router.afterEach((function(){ll.a.done(),n.isSidebarOpen=!1}))}};t(81),t(57),t(84),t(383);function cl(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}t(104);function dl(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}function pl(n,e,t){return e&&dl(n.prototype,e),t&&dl(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}t(384);var ul=function(){function n(){cl(this,n);this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}return pl(n,[{key:"show",value:function(n){var e=this,t=n.text,o=void 0===t?"":t,a=n.duration,i=void 0===a?3e3:a,r=document.createElement("div");r.className="message move-in",r.innerHTML='\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">'.concat(o,"</div>\n    "),this.containerEl.appendChild(r),i>0&&setTimeout((function(){e.close(r)}),i)}},{key:"close",value:function(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",(function(){n.remove()}))}}]),n}(),ml={mounted:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated:function(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy:function(){var n=this;setTimeout((function(){(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach((function(e){document.querySelectorAll(e).forEach(n.generateCopyButton)}))}),1e3)},generateCopyButton:function(n){var e=this;if(!n.classList.contains("codecopy-enabled")){var t=document.createElement("i");t.className="code-copy",t.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',t.title="Copy to clipboard",t.addEventListener("click",(function(){e.copyToClipboard(n.innerText)})),n.appendChild(t),n.classList.add("codecopy-enabled")}},copyToClipboard:function(n){var e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);var t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy"),(new ul).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};t(241),t(108),t(109),t(145),t(386);!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var o=document.head||document.getElementsByTagName("head")[0],a=document.createElement("style");a.type="text/css","top"===t&&o.firstChild?o.insertBefore(a,o.firstChild):o.appendChild(a),a.styleSheet?a.styleSheet.cssText=n:a.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var hl={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},gl={},fl=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},vl=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:hl[n]},bl=function n(e,t,o){var a=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))a[n]=t[n];else{var e=n.replace("data","");a.dataset[e]=t[n]}})),o&&o.forEach((function(e){var t=e.tag,o=e.attrs,i=e.children;a.appendChild(n(t,o,i))})),a},xl=function(n,e,t){var o,a=(o=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(o));return 1!==a.length||t?a:a[0]},yl=function(n,e){var t,o,a=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),r=n.match(/<script>([\s\S]+)<\/script>/),l={css:a&&a[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:r&&r[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};l.htmlTpl=fl(l.html),l.jsTpl=(t=l.js,o=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(o,"\n})")),l.script=function(n,e){var t=n.split(/export\s+default/),o="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),a=window.Babel?window.Babel.transform(o,{presets:["es2015"]}).code:o,i=[eval][0](a);return i.template=e,i}(l.js,l.html);var s=vl("vue");return l.jsLib.unshift(s),l},wl=function(n,e){var t,o=n.match(/<style>([\s\S]+)<\/style>/),a=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),r={css:o&&o[1].replace(/^\n|\n$/g,""),html:a&&a[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return r.htmlTpl=r.html,r.jsTpl=r.js,r.script=(t=r.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),r},kl=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function jl(){var n=xl(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=xl(n,"vuepress-plugin-demo-block__code"),t=xl(n,"vuepress-plugin-demo-block__display"),o=xl(n,"vuepress-plugin-demo-block__footer"),a=xl(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),r=decodeURIComponent(n.dataset.config),l=decodeURIComponent(n.dataset.type);r=r?JSON.parse(r):{};var s=e.querySelector("div").clientHeight,c="react"===l?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,o="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),a=new Function("return ".concat(o))(),i={js:a,css:a.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:kl(n),htmlTpl:fl("")},r=vl("react"),l=vl("reactDOM");return i.jsLib.unshift(r,l),i}(i,r):"vanilla"===l?wl(i,r):yl(i,r),d=bl("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(o.appendChild(d),d.addEventListener("click",Tl.bind(null,d,s,e,o)),vl("jsfiddle")&&o.appendChild(function(n){var e=n.css,t=n.htmlTpl,o=n.jsTpl,a=n.jsLib,i=n.cssLib,r=a.concat(i).concat(vl("cssLib")).concat(vl("jsLib")).join(",");return bl("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:o}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:r}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),vl("codepen")&&o.appendChild(function(n){var e=n.css,t=n.htmlTpl,o=n.jsTpl,a=n.jsLib,i=n.cssLib,r=JSON.stringify({css:e,html:t,js:o,js_external:a.concat(vl("jsLib")).join(";"),css_external:i.concat(vl("cssLib")).join(";"),layout:vl("codepenLayout"),js_pre_processor:vl("codepenJsProcessor"),editors:vl("codepenEditors")});return bl("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:r}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==r.horizontal?r.horizontal:vl("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var p=e.firstChild.cloneNode(!0);p.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(p)}if(c.css&&function(n){if(!gl[n]){var e=bl("style",{innerHTML:n});document.body.appendChild(e),gl[n]=!0}}(c.css),"react"===l)ReactDOM.render(React.createElement(c.js),a);else if("vue"===l){var u=(new(Vue.extend(c.script))).$mount();a.appendChild(u.$el)}else"vanilla"===l&&(a.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){jl()}),300)}function Tl(n,e,t,o){var a="1"!==n.dataset.isExpand;t.style.height=a?"".concat(e,"px"):0,a?o.classList.add("vuepress-plugin-demo-block__show-link"):o.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=a?"1":"0"}var Sl={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},jl()},updated:function(){jl()}},El=(t(230),"auto"),Il="zoom-in",zl="zoom-out",Cl="grab",Al="move";function _l(n,e,t){var o=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],a={passive:!1};o?n.addEventListener(e,t,a):n.removeEventListener(e,t,a)}function Pl(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Bl(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ml(n,e,t){!function(n){var e=Ol,t=Dl;if(n.transition){var o=n.transition;delete n.transition,n[e]=o}if(n.transform){var a=n.transform;delete n.transform,n[t]=a}}(e);var o=n.style,a={};for(var i in e)t&&(a[i]=o[i]||""),o[i]=e[i];return a}var Ol="transition",Dl="transform",$l="transform",Ll="transitionend";var Nl=function(){},Vl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Nl,onClose:Nl,onGrab:Nl,onMove:Nl,onRelease:Nl,onBeforeOpen:Nl,onBeforeClose:Nl,onBeforeGrab:Nl,onBeforeRelease:Nl,onImageLoading:Nl,onImageLoaded:Nl},Ul={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),Rl(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var o=this.lastScrollPosition.x-e,a=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(a)>=i||Math.abs(o)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(Hl(n)&&!Rl(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){Hl(n)&&!Rl(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,o=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,o)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,o=e.clientY;this.move(t,o)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function Hl(n){return 0===n.button}function Rl(n){return n.metaKey||n.ctrlKey}var ql={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ml(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),_l(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ml(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},Fl="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},Jl=function(){function n(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}return function(e,t,o){return t&&n(e.prototype,t),o&&n(e,o),e}}(),Gl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var o in t)Object.prototype.hasOwnProperty.call(t,o)&&(n[o]=t[o])}return n},Wl={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Bl(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,o=n.transitionDuration,a=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Cl:zl,transition:$l+"\n        "+o+"s\n        "+a,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ml(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ml(this.el,{transform:"none"})},grab:function(n,e,t){var o=Zl(),a=o.x-n,i=o.y-e;Ml(this.el,{cursor:Al,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var o=Zl(),a=o.x-n,i=o.y-e;Ml(this.el,{transition:$l,transform:"translate3d(\n        "+(this.translate.x+a)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ml(this.el,this.styleClose)},restoreOpenStyle:function(){Ml(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=Zl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,o=this.instance.options,a=o.customSize,i=o.scaleBase;if(!a&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(a&&"object"===(void 0===a?"undefined":Fl(a)))return{x:a.width/this.rect.width,y:a.height/this.rect.height};var r=this.rect.width/2,l=this.rect.height/2,s=Zl(),c={x:s.x-r,y:s.y-l},d=c.x/r,p=c.y/l,u=i+Math.min(d,p);if(a&&"string"==typeof a){var m=t||this.el.naturalWidth,h=e||this.el.naturalHeight,g=parseFloat(a)*m/(100*this.rect.width),f=parseFloat(a)*h/(100*this.rect.height);if(u>g||u>f)return{x:g,y:f}}return{x:u,y:u}}};function Zl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function Yl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(o){_l(n,o,e[o],t)}))}var Xl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(Wl),this.overlay=Object.create(ql),this.handler=Object.create(Ul),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=Gl({},Vl,e),this.overlay.init(this),this.handler.init(this)}return Jl(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Il,_l(n,"click",this.handler.click),this.options.preloadImage&&Pl(Bl(n)));return this}},{key:"config",value:function(n){return n?(Gl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var o="string"==typeof n?document.querySelector(n):n;if("IMG"===o.tagName){if(this.options.onBeforeOpen(o),this.target.init(o,this),!this.options.preloadImage){var a=this.target.srcOriginal;null!=a&&(this.options.onImageLoading(o),Pl(a,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),_l(document,"scroll",this.handler.scroll),_l(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&_l(window,"resize",this.handler.resizeWindow);var i=function n(){_l(o,Ll,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&Yl(document,e.handler,!0),t(o)};return _l(o,Ll,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=El,this.overlay.fadeOut(),this.target.zoomOut(),_l(document,"scroll",this.handler.scroll,!1),_l(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&_l(window,"resize",this.handler.resizeWindow,!1);var o=function o(){_l(t,Ll,o,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&Yl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return _l(t,Ll,o),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var a=this.target.el;this.options.onBeforeGrab(a),this.released=!1,this.target.grab(n,e,t);var i=function n(){_l(a,Ll,n,!1),o(a)};return _l(a,Ll,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Al,this.target.move(n,e,t);var a=this.target.el,i=function n(){_l(a,Ll,n,!1),o(a)};return _l(a,Ll,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=El,this.target.restoreOpenStyle();var o=function o(){_l(t,Ll,o,!1),n.lock=!1,n.released=!0,e(t)};return _l(t,Ll,o),this}}}]),n}(),Kl=".theme-vdoing-content img:not(.no-zoom)",Ql=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ns=Number("500"),es=function(){function n(){cl(this,n),this.instance=new Xl(Ql)}return pl(n,[{key:"update",value:function(){var n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Kl;"undefined"!=typeof window&&this.instance.listen(n)}},{key:"updateDelay",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Kl,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ns;setTimeout((function(){return n.update(e)}),t)}}]),n}(),ts=[Qr,il,sl,ml,Sl,{watch:{"$page.path":function(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted:function(){this.$vuepress.zooming=new es,this.$vuepress.zooming.updateDelay()}}],os={name:"GlobalLayout",computed:{layout:function(){var n=this.getLayout();return Gr("layout",n),Ma.component(n)}},methods:{getLayout:function(){if(this.$page.path){var n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},as=t(21),is=Object(as.a)(os,(function(){var n=this.$createElement;return(this._self._c||n)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){var o;switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),(o=n[e]).push.apply(o,Object(Ir.a)(t));break;default:throw new Error("Unknown option name.")}}(is,"mixins",ts);var rs=[{name:"v-768367e2",path:"/web/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-768367e2").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/00.目录页/01.前端.html",redirect:"/web/"},{name:"v-d0a13a84",path:"/ui/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-d0a13a84").then(t)}},{path:"/ui/index.html",redirect:"/ui/"},{path:"/00.目录页/02.页面.html",redirect:"/ui/"},{name:"v-2ba7b4d5",path:"/technology/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-2ba7b4d5").then(t)}},{path:"/technology/index.html",redirect:"/technology/"},{path:"/00.目录页/03.技术.html",redirect:"/technology/"},{name:"v-09b07641",path:"/more/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-09b07641").then(t)}},{path:"/more/index.html",redirect:"/more/"},{path:"/00.目录页/04.更多.html",redirect:"/more/"},{name:"v-94759ba8",path:"/pages/a61298/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-94759ba8").then(t)}},{path:"/pages/a61298/index.html",redirect:"/pages/a61298/"},{path:"/01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.html",redirect:"/pages/a61298/"},{name:"v-e13358fa",path:"/pages/8143cc480faf9a11/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-e13358fa").then(t)}},{path:"/pages/8143cc480faf9a11/index.html",redirect:"/pages/8143cc480faf9a11/"},{path:"/01.前端/25.JavaScript文章/02.new命令原理.html",redirect:"/pages/8143cc480faf9a11/"},{name:"v-1f47639c",path:"/pages/b1af5cb8996363c5/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-1f47639c").then(t)}},{path:"/pages/b1af5cb8996363c5/index.html",redirect:"/pages/b1af5cb8996363c5/"},{path:"/01.前端/25.JavaScript文章/03.ES5面向对象.html",redirect:"/pages/b1af5cb8996363c5/"},{name:"v-a54556a4",path:"/pages/1f4123be6f45abcd/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-a54556a4").then(t)}},{path:"/pages/1f4123be6f45abcd/index.html",redirect:"/pages/1f4123be6f45abcd/"},{path:"/01.前端/25.JavaScript文章/04.ES6面向对象.html",redirect:"/pages/1f4123be6f45abcd/"},{name:"v-119caaee",path:"/pages/e808fba1fa8fbab2/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-119caaee").then(t)}},{path:"/pages/e808fba1fa8fbab2/index.html",redirect:"/pages/e808fba1fa8fbab2/"},{path:"/01.前端/25.JavaScript文章/06.多种数组去重性能对比.html",redirect:"/pages/e808fba1fa8fbab2/"},{name:"v-2eddfdda",path:"/pages/fd4a16d56b83c1bc/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-2eddfdda").then(t)}},{path:"/pages/fd4a16d56b83c1bc/index.html",redirect:"/pages/fd4a16d56b83c1bc/"},{path:"/01.前端/25.JavaScript文章/100.比typeof运算符更准确的类型判断.html",redirect:"/pages/fd4a16d56b83c1bc/"},{name:"v-21d8afeb",path:"/pages/8481d1/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-21d8afeb").then(t)}},{path:"/pages/8481d1/index.html",redirect:"/pages/8481d1/"},{path:"/01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.html",redirect:"/pages/8481d1/"},{name:"v-370bb2c9",path:"/pages/40b4db2d38ba85f2/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-370bb2c9").then(t)}},{path:"/pages/40b4db2d38ba85f2/index.html",redirect:"/pages/40b4db2d38ba85f2/"},{path:"/01.前端/25.JavaScript文章/50.js随机打乱数组.html",redirect:"/pages/40b4db2d38ba85f2/"},{name:"v-76af4c12",path:"/pages/40f623be692cf8bc/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-76af4c12").then(t)}},{path:"/pages/40f623be692cf8bc/index.html",redirect:"/pages/40f623be692cf8bc/"},{path:"/01.前端/25.JavaScript文章/60.判断是否为移动端浏览器.html",redirect:"/pages/40f623be692cf8bc/"},{name:"v-59ea62a4",path:"/pages/f1acb712033ac8da/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-59ea62a4").then(t)}},{path:"/pages/f1acb712033ac8da/index.html",redirect:"/pages/f1acb712033ac8da/"},{path:"/01.前端/25.JavaScript文章/70.将一维数组按指定长度转为二维数组.html",redirect:"/pages/f1acb712033ac8da/"},{name:"v-4c0a766c",path:"/pages/0f6a0ac99b62ede5/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-4c0a766c").then(t)}},{path:"/pages/0f6a0ac99b62ede5/index.html",redirect:"/pages/0f6a0ac99b62ede5/"},{path:"/01.前端/25.JavaScript文章/80.防抖与节流函数.html",redirect:"/pages/0f6a0ac99b62ede5/"},{name:"v-240078e0",path:"/pages/7a91be2d502346ce/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-240078e0").then(t)}},{path:"/pages/7a91be2d502346ce/index.html",redirect:"/pages/7a91be2d502346ce/"},{path:"/01.前端/25.JavaScript文章/90.JS获取和修改url参数.html",redirect:"/pages/7a91be2d502346ce/"},{name:"v-056cb10a",path:"/note/javascript/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-056cb10a").then(t)}},{path:"/note/javascript/index.html",redirect:"/note/javascript/"},{path:"/01.前端/40.学习笔记/00.《JavaScript教程》笔记.html",redirect:"/note/javascript/"},{name:"v-79ac4976",path:"/note/js/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-79ac4976").then(t)}},{path:"/note/js/index.html",redirect:"/note/js/"},{path:"/01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.html",redirect:"/note/js/"},{name:"v-9973f104",path:"/note/es6/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-9973f104").then(t)}},{path:"/note/es6/index.html",redirect:"/note/es6/"},{path:"/01.前端/40.学习笔记/10.《ES6 教程》笔记.html",redirect:"/note/es6/"},{name:"v-4e6abdc5",path:"/note/vue/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-4e6abdc5").then(t)}},{path:"/note/vue/index.html",redirect:"/note/vue/"},{path:"/01.前端/40.学习笔记/20.《Vue》笔记.html",redirect:"/note/vue/"},{name:"v-37036a26",path:"/note/react/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-37036a26").then(t)}},{path:"/note/react/index.html",redirect:"/note/react/"},{path:"/01.前端/40.学习笔记/25.《React》笔记.html",redirect:"/note/react/"},{name:"v-142c4b83",path:"/note/typescript-axios/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-142c4b83").then(t)}},{path:"/note/typescript-axios/index.html",redirect:"/note/typescript-axios/"},{path:"/01.前端/40.学习笔记/30.《TypeScript 从零实现 axios》.html",redirect:"/note/typescript-axios/"},{name:"v-70b7207a",path:"/note/git/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-70b7207a").then(t)}},{path:"/note/git/index.html",redirect:"/note/git/"},{path:"/01.前端/40.学习笔记/33.《Git》学习笔记.html",redirect:"/note/git/"},{name:"v-354ba35d",path:"/pages/51afd6/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-354ba35d").then(t)}},{path:"/pages/51afd6/index.html",redirect:"/pages/51afd6/"},{path:"/01.前端/40.学习笔记/35.TypeScript笔记.html",redirect:"/pages/51afd6/"},{name:"v-cfb19bce",path:"/note/wx-miniprogram/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-cfb19bce").then(t)}},{path:"/note/wx-miniprogram/index.html",redirect:"/note/wx-miniprogram/"},{path:"/01.前端/40.学习笔记/40.小程序笔记.html",redirect:"/note/wx-miniprogram/"},{name:"v-89224ada",path:"/pages/4643cd/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-89224ada").then(t)}},{path:"/pages/4643cd/index.html",redirect:"/pages/4643cd/"},{path:"/01.前端/40.学习笔记/50.JS设计模式总结笔记.html",redirect:"/pages/4643cd/"},{name:"v-1f5da569",path:"/pages/8309a5b876fc95e3/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-1f5da569").then(t)}},{path:"/pages/8309a5b876fc95e3/index.html",redirect:"/pages/8309a5b876fc95e3/"},{path:"/02.页面/10.HTML/10.常用meta整理.html",redirect:"/pages/8309a5b876fc95e3/"},{name:"v-1400beac",path:"/pages/c8f128/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-1400beac").then(t)}},{path:"/pages/c8f128/index.html",redirect:"/pages/c8f128/"},{path:"/02.页面/20.CSS/00.CSS教程和技巧收藏.html",redirect:"/pages/c8f128/"},{name:"v-829901ca",path:"/pages/0a83b083bdf257cb/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-829901ca").then(t)}},{path:"/pages/0a83b083bdf257cb/index.html",redirect:"/pages/0a83b083bdf257cb/"},{path:"/02.页面/20.CSS/01.flex布局语法.html",redirect:"/pages/0a83b083bdf257cb/"},{name:"v-a9f47444",path:"/pages/ea6db1530c42ad51/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-a9f47444").then(t)}},{path:"/pages/ea6db1530c42ad51/index.html",redirect:"/pages/ea6db1530c42ad51/"},{path:"/02.页面/20.CSS/02.flex布局案例-基础.html",redirect:"/pages/ea6db1530c42ad51/"},{name:"v-7bd1ca64",path:"/pages/eff61bc8b4f4695d/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-7bd1ca64").then(t)}},{path:"/pages/eff61bc8b4f4695d/index.html",redirect:"/pages/eff61bc8b4f4695d/"},{path:"/02.页面/20.CSS/03.flex布局案例-骰子.html",redirect:"/pages/eff61bc8b4f4695d/"},{name:"v-1732d362",path:"/pages/df9e7c7214fa5046/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-1732d362").then(t)}},{path:"/pages/df9e7c7214fa5046/index.html",redirect:"/pages/df9e7c7214fa5046/"},{path:"/02.页面/20.CSS/04.flex布局案例-圣杯布局.html",redirect:"/pages/df9e7c7214fa5046/"},{name:"v-86f0ff4e",path:"/pages/85b5a3fe218a34b7/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-86f0ff4e").then(t)}},{path:"/pages/85b5a3fe218a34b7/index.html",redirect:"/pages/85b5a3fe218a34b7/"},{path:"/02.页面/20.CSS/05.flex布局案例-网格布局.html",redirect:"/pages/85b5a3fe218a34b7/"},{name:"v-0cc7563e",path:"/pages/05cc577fb51c7998/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0cc7563e").then(t)}},{path:"/pages/05cc577fb51c7998/index.html",redirect:"/pages/05cc577fb51c7998/"},{path:"/02.页面/20.CSS/06.flex布局案例-输入框布局.html",redirect:"/pages/05cc577fb51c7998/"},{name:"v-8a33a710",path:"/pages/02d7f59d98d87409/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-8a33a710").then(t)}},{path:"/pages/02d7f59d98d87409/index.html",redirect:"/pages/02d7f59d98d87409/"},{path:"/02.页面/20.CSS/07.CSS3之transition过渡.html",redirect:"/pages/02d7f59d98d87409/"},{name:"v-bec52126",path:"/pages/c2c0432138f6e042/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-bec52126").then(t)}},{path:"/pages/c2c0432138f6e042/index.html",redirect:"/pages/c2c0432138f6e042/"},{path:"/02.页面/20.CSS/08.CSS3之animation动画.html",redirect:"/pages/c2c0432138f6e042/"},{name:"v-ceb0edd0",path:"/pages/3d52574260725aea/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-ceb0edd0").then(t)}},{path:"/pages/3d52574260725aea/index.html",redirect:"/pages/3d52574260725aea/"},{path:"/02.页面/20.CSS/20.「布局技巧」图片未加载前自动撑开元素高度.html",redirect:"/pages/3d52574260725aea/"},{name:"v-9fb14a2c",path:"/pages/42b66999cc27dc25/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-9fb14a2c").then(t)}},{path:"/pages/42b66999cc27dc25/index.html",redirect:"/pages/42b66999cc27dc25/"},{path:"/02.页面/20.CSS/30.文字在一行或多行时超出显示省略号.html",redirect:"/pages/42b66999cc27dc25/"},{name:"v-13b23dae",path:"/pages/20a978023139589d/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-13b23dae").then(t)}},{path:"/pages/20a978023139589d/index.html",redirect:"/pages/20a978023139589d/"},{path:"/02.页面/20.CSS/35.从box-sizing属性入手，了解盒子模型.html",redirect:"/pages/20a978023139589d/"},{name:"v-203057c8",path:"/pages/cb7cb251adba4bf7/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-203057c8").then(t)}},{path:"/pages/cb7cb251adba4bf7/index.html",redirect:"/pages/cb7cb251adba4bf7/"},{path:"/02.页面/20.CSS/40.水平垂直居中的几种方式-案例.html",redirect:"/pages/cb7cb251adba4bf7/"},{name:"v-5d8ec06d",path:"/pages/5dde351274f1e39d/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-5d8ec06d").then(t)}},{path:"/pages/5dde351274f1e39d/index.html",redirect:"/pages/5dde351274f1e39d/"},{path:"/02.页面/20.CSS/45.如何根据系统主题自动响应CSS深色模式.html",redirect:"/pages/5dde351274f1e39d/"},{name:"v-5801946e",path:"/pages/941581927b4a38f8/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-5801946e").then(t)}},{path:"/pages/941581927b4a38f8/index.html",redirect:"/pages/941581927b4a38f8/"},{path:"/02.页面/20.CSS/50.「css技巧」使用hover和attr()定制悬浮提示.html",redirect:"/pages/941581927b4a38f8/"},{name:"v-74664c83",path:"/pages/3da0d7/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-74664c83").then(t)}},{path:"/pages/3da0d7/index.html",redirect:"/pages/3da0d7/"},{path:"/02.页面/20.CSS/60.CSS-function汇总.html",redirect:"/pages/3da0d7/"},{name:"v-4908690b",path:"/pages/9a7ee40fc232253e/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-4908690b").then(t)}},{path:"/pages/9a7ee40fc232253e/index.html",redirect:"/pages/9a7ee40fc232253e/"},{path:"/03.技术/01.技术文档/01.Git使用手册.html",redirect:"/pages/9a7ee40fc232253e/"},{name:"v-fb370f06",path:"/pages/ad247c4332211551/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-fb370f06").then(t)}},{path:"/pages/ad247c4332211551/index.html",redirect:"/pages/ad247c4332211551/"},{path:"/03.技术/01.技术文档/02.Markdown使用教程.html",redirect:"/pages/ad247c4332211551/"},{name:"v-31a6a882",path:"/pages/61f2f95fd7da14fd/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-31a6a882").then(t)}},{path:"/pages/61f2f95fd7da14fd/index.html",redirect:"/pages/61f2f95fd7da14fd/"},{path:"/03.技术/01.技术文档/03.npm常用命令.html",redirect:"/pages/61f2f95fd7da14fd/"},{name:"v-44e2ea1a",path:"/pages/dec4f3f00e71a312/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-44e2ea1a").then(t)}},{path:"/pages/dec4f3f00e71a312/index.html",redirect:"/pages/dec4f3f00e71a312/"},{path:"/03.技术/01.技术文档/10.npm packageJson属性详解.html",redirect:"/pages/dec4f3f00e71a312/"},{name:"v-28146ea1",path:"/pages/4e8444e2d534d14f/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-28146ea1").then(t)}},{path:"/pages/4e8444e2d534d14f/index.html",redirect:"/pages/4e8444e2d534d14f/"},{path:"/03.技术/01.技术文档/15.yaml语言教程.html",redirect:"/pages/4e8444e2d534d14f/"},{name:"v-ef2ec8a6",path:"/pages/4c778760be26d8b3/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-ef2ec8a6").then(t)}},{path:"/pages/4c778760be26d8b3/index.html",redirect:"/pages/4c778760be26d8b3/"},{path:"/03.技术/02.GitHub技巧/01.GitHub高级搜索技巧.html",redirect:"/pages/4c778760be26d8b3/"},{name:"v-fb6e6346",path:"/pages/6b9d359ec5aa5019/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-fb6e6346").then(t)}},{path:"/pages/6b9d359ec5aa5019/index.html",redirect:"/pages/6b9d359ec5aa5019/"},{path:"/03.技术/02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.html",redirect:"/pages/6b9d359ec5aa5019/"},{name:"v-a5baf23a",path:"/pages/f44d2f9ad04ab8d3/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-a5baf23a").then(t)}},{path:"/pages/f44d2f9ad04ab8d3/index.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{path:"/03.技术/02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.html",redirect:"/pages/f44d2f9ad04ab8d3/"},{name:"v-62775647",path:"/pages/95331c6a9613faf8/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-62775647").then(t)}},{path:"/pages/95331c6a9613faf8/index.html",redirect:"/pages/95331c6a9613faf8/"},{path:"/03.技术/02.GitHub技巧/10.GitHub加速下载项目的方法.html",redirect:"/pages/95331c6a9613faf8/"},{name:"v-7ddaa860",path:"/pages/117708e0af7f0bd9/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-7ddaa860").then(t)}},{path:"/pages/117708e0af7f0bd9/index.html",redirect:"/pages/117708e0af7f0bd9/"},{path:"/03.技术/03.Nodejs/01.nodejs递归读取所有文件.html",redirect:"/pages/117708e0af7f0bd9/"},{name:"v-e8b0f490",path:"/pages/41f87d890d0a02af/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-e8b0f490").then(t)}},{path:"/pages/41f87d890d0a02af/index.html",redirect:"/pages/41f87d890d0a02af/"},{path:"/03.技术/04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.html",redirect:"/pages/41f87d890d0a02af/"},{name:"v-0ae5a9bc",path:"/pages/1da0bf9a988eafe5/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0ae5a9bc").then(t)}},{path:"/pages/1da0bf9a988eafe5/index.html",redirect:"/pages/1da0bf9a988eafe5/"},{path:"/03.技术/04.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.html",redirect:"/pages/1da0bf9a988eafe5/"},{name:"v-227c81ae",path:"/pages/a5f73af5185fdf0a/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-227c81ae").then(t)}},{path:"/pages/a5f73af5185fdf0a/index.html",redirect:"/pages/a5f73af5185fdf0a/"},{path:"/03.技术/04.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.html",redirect:"/pages/a5f73af5185fdf0a/"},{name:"v-33de3fe1",path:"/pages/d557b9a89a215d2e/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-33de3fe1").then(t)}},{path:"/pages/d557b9a89a215d2e/index.html",redirect:"/pages/d557b9a89a215d2e/"},{path:"/03.技术/04.博客搭建/10.vdoing主题效果图.html",redirect:"/pages/d557b9a89a215d2e/"},{name:"v-329c94d8",path:"/pages/f2a556/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-329c94d8").then(t)}},{path:"/pages/f2a556/index.html",redirect:"/pages/f2a556/"},{path:"/04.更多/01.学习/00.费曼学习法.html",redirect:"/pages/f2a556/"},{name:"v-38d64c12",path:"/pages/e60c81/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-38d64c12").then(t)}},{path:"/pages/e60c81/index.html",redirect:"/pages/e60c81/"},{path:"/04.更多/01.学习/01.笔记方法.html",redirect:"/pages/e60c81/"},{name:"v-5b414b04",path:"/pages/a8692ab3bdcb4588/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-5b414b04").then(t)}},{path:"/pages/a8692ab3bdcb4588/index.html",redirect:"/pages/a8692ab3bdcb4588/"},{path:"/04.更多/01.学习/02.提高学习效率的策略.html",redirect:"/pages/a8692ab3bdcb4588/"},{name:"v-f7d71be6",path:"/pages/996822b2a2ca6e3b/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-f7d71be6").then(t)}},{path:"/pages/996822b2a2ca6e3b/index.html",redirect:"/pages/996822b2a2ca6e3b/"},{path:"/04.更多/01.学习/03.提高记忆的技巧.html",redirect:"/pages/996822b2a2ca6e3b/"},{name:"v-1aa834f7",path:"/pages/c3f302a03c8daf79/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-1aa834f7").then(t)}},{path:"/pages/c3f302a03c8daf79/index.html",redirect:"/pages/c3f302a03c8daf79/"},{path:"/04.更多/01.学习/04.自律小建议.html",redirect:"/pages/c3f302a03c8daf79/"},{name:"v-4a255ebe",path:"/pages/9ba2b8fb13de1957/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-4a255ebe").then(t)}},{path:"/pages/9ba2b8fb13de1957/index.html",redirect:"/pages/9ba2b8fb13de1957/"},{path:"/04.更多/01.学习/05.处理问题的思路.html",redirect:"/pages/9ba2b8fb13de1957/"},{name:"v-3d4d4ad8",path:"/pages/ce818a/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-3d4d4ad8").then(t)}},{path:"/pages/ce818a/index.html",redirect:"/pages/ce818a/"},{path:"/04.更多/01.学习/10.搜索引擎使用技巧.html",redirect:"/pages/ce818a/"},{name:"v-054e32aa",path:"/pages/aea6571b7a8bae86/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-054e32aa").then(t)}},{path:"/pages/aea6571b7a8bae86/index.html",redirect:"/pages/aea6571b7a8bae86/"},{path:"/04.更多/03.面试/01.面试问题集锦.html",redirect:"/pages/aea6571b7a8bae86/"},{name:"v-0c1b4099",path:"/pages/2d615df9a36a98ed/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0c1b4099").then(t)}},{path:"/pages/2d615df9a36a98ed/index.html",redirect:"/pages/2d615df9a36a98ed/"},{path:"/04.更多/05.心情杂货/01.一个完美主义者的自我救赎.html",redirect:"/pages/2d615df9a36a98ed/"},{name:"v-1bd6c58a",path:"/pages/d6d331/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-1bd6c58a").then(t)}},{path:"/pages/d6d331/index.html",redirect:"/pages/d6d331/"},{path:"/04.更多/05.心情杂货/10.反向拆解让人上瘾的套路，找回自律.html",redirect:"/pages/d6d331/"},{name:"v-4688d30f",path:"/pages/baaa02/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-4688d30f").then(t)}},{path:"/pages/baaa02/index.html",redirect:"/pages/baaa02/"},{path:"/04.更多/10.实用技巧/01.2分钟规则.html",redirect:"/pages/baaa02/"},{name:"v-5724ced2",path:"/pages/dcebaf/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-5724ced2").then(t)}},{path:"/pages/dcebaf/index.html",redirect:"/pages/dcebaf/"},{path:"/04.更多/10.实用技巧/10.一行代码“黑”掉任意网站.html",redirect:"/pages/dcebaf/"},{name:"v-af4c07f2",path:"/friends/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-af4c07f2").then(t)}},{path:"/friends/index.html",redirect:"/friends/"},{path:"/04.更多/99.友情链接.html",redirect:"/friends/"},{name:"v-09b2f671",path:"/about/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-09b2f671").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/05.关于/01.关于.html",redirect:"/about/"},{name:"v-f0e5a688",path:"/pages/beb6c0bd8a66cea6/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-f0e5a688").then(t)}},{path:"/pages/beb6c0bd8a66cea6/index.html",redirect:"/pages/beb6c0bd8a66cea6/"},{path:"/06.收藏夹/01.网站.html",redirect:"/pages/beb6c0bd8a66cea6/"},{name:"v-77ef150e",path:"/pages/47cf96/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-77ef150e").then(t)}},{path:"/pages/47cf96/index.html",redirect:"/pages/47cf96/"},{path:"/06.收藏夹/02.常用的前端轮子.html",redirect:"/pages/47cf96/"},{name:"v-44afb06d",path:"/pages/fa842a/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-44afb06d").then(t)}},{path:"/pages/fa842a/index.html",redirect:"/pages/fa842a/"},{path:"/1100.H5&CSS3/101.HTML.html",redirect:"/pages/fa842a/"},{name:"v-15a8cec6",path:"/pages/d8978d/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-15a8cec6").then(t)}},{path:"/pages/d8978d/index.html",redirect:"/pages/d8978d/"},{path:"/1100.H5&CSS3/200.CSS基础/201.CSS-1基础.html",redirect:"/pages/d8978d/"},{name:"v-f2696468",path:"/pages/687c1b/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-f2696468").then(t)}},{path:"/pages/687c1b/index.html",redirect:"/pages/687c1b/"},{path:"/1100.H5&CSS3/200.CSS基础/202.CSS-2属性.html",redirect:"/pages/687c1b/"},{name:"v-a45689ae",path:"/pages/528b1e/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-a45689ae").then(t)}},{path:"/pages/528b1e/index.html",redirect:"/pages/528b1e/"},{path:"/1100.H5&CSS3/200.CSS基础/301.CSS-3动画.html",redirect:"/pages/528b1e/"},{name:"v-1aa5a292",path:"/pages/9aeeea/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-1aa5a292").then(t)}},{path:"/pages/9aeeea/index.html",redirect:"/pages/9aeeea/"},{path:"/1100.H5&CSS3/200.CSS基础/401.CSS-8Less.html",redirect:"/pages/9aeeea/"},{name:"v-6cf68056",path:"/pages/335968/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-6cf68056").then(t)}},{path:"/pages/335968/index.html",redirect:"/pages/335968/"},{path:"/1100.H5&CSS3/300.CSS布局/301.CSS-盒子模型.html",redirect:"/pages/335968/"},{name:"v-603d9e38",path:"/pages/3d870b/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-603d9e38").then(t)}},{path:"/pages/3d870b/index.html",redirect:"/pages/3d870b/"},{path:"/1100.H5&CSS3/300.CSS布局/302.CSS-标准流.html",redirect:"/pages/3d870b/"},{name:"v-3f9649d2",path:"/pages/9fccab/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-3f9649d2").then(t)}},{path:"/pages/9fccab/index.html",redirect:"/pages/9fccab/"},{path:"/1100.H5&CSS3/300.CSS布局/303.CSS-浮动.html",redirect:"/pages/9fccab/"},{name:"v-5c3398e2",path:"/pages/558f03/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-5c3398e2").then(t)}},{path:"/pages/558f03/index.html",redirect:"/pages/558f03/"},{path:"/1100.H5&CSS3/300.CSS布局/304.CSS-定位.html",redirect:"/pages/558f03/"},{name:"v-00d198cf",path:"/pages/78ced3/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-00d198cf").then(t)}},{path:"/pages/78ced3/index.html",redirect:"/pages/78ced3/"},{path:"/1100.H5&CSS3/300.CSS布局/305.CSS-传统布局总结.html",redirect:"/pages/78ced3/"},{name:"v-10e281d8",path:"/pages/b5b50a/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-10e281d8").then(t)}},{path:"/pages/b5b50a/index.html",redirect:"/pages/b5b50a/"},{path:"/1100.H5&CSS3/300.CSS布局/306.CSS-Flexible.html",redirect:"/pages/b5b50a/"},{name:"v-0910fc9a",path:"/pages/824a06/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0910fc9a").then(t)}},{path:"/pages/824a06/index.html",redirect:"/pages/824a06/"},{path:"/1100.H5&CSS3/300.CSS布局/309.CSS-移动端适配.html",redirect:"/pages/824a06/"},{name:"v-7a9c696e",path:"/pages/ac76d8/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-7a9c696e").then(t)}},{path:"/pages/ac76d8/index.html",redirect:"/pages/ac76d8/"},{path:"/1100.H5&CSS3/300.CSS布局/391.CSS项目案例——京东.html",redirect:"/pages/ac76d8/"},{name:"v-6cc34f95",path:"/pages/d2628c/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-6cc34f95").then(t)}},{path:"/pages/d2628c/index.html",redirect:"/pages/d2628c/"},{path:"/1100.H5&CSS3/300.CSS布局/392.CSS项目案例——考拉.html",redirect:"/pages/d2628c/"},{name:"v-0bdb65db",path:"/pages/da720c/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0bdb65db").then(t)}},{path:"/pages/da720c/index.html",redirect:"/pages/da720c/"},{path:"/1100.H5&CSS3/401.CSS-高级技巧.html",redirect:"/pages/da720c/"},{name:"v-2ab16e45",path:"/pages/abf94c/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-2ab16e45").then(t)}},{path:"/pages/abf94c/index.html",redirect:"/pages/abf94c/"},{path:"/1100.H5&CSS3/501.代码规范.html",redirect:"/pages/abf94c/"},{name:"v-9888aae6",path:"/pages/84d48a/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-9888aae6").then(t)}},{path:"/pages/84d48a/index.html",redirect:"/pages/84d48a/"},{path:"/1200.JS/100.入门/101.入门.html",redirect:"/pages/84d48a/"},{name:"v-0572c1aa",path:"/pages/e22d1e/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0572c1aa").then(t)}},{path:"/pages/e22d1e/index.html",redirect:"/pages/e22d1e/"},{path:"/1200.JS/100.入门/102.Web 应用的生命周期.html",redirect:"/pages/e22d1e/"},{name:"v-6387b2f0",path:"/pages/ebb062/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-6387b2f0").then(t)}},{path:"/pages/ebb062/index.html",redirect:"/pages/ebb062/"},{path:"/1200.JS/200.理解/201.函数的定义与参数.html",redirect:"/pages/ebb062/"},{name:"v-45814ce9",path:"/pages/2a1d9d/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-45814ce9").then(t)}},{path:"/pages/2a1d9d/index.html",redirect:"/pages/2a1d9d/"},{path:"/1200.JS/200.理解/202..理解函数调用.html",redirect:"/pages/2a1d9d/"},{name:"v-62ada9b3",path:"/pages/adb64b/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-62ada9b3").then(t)}},{path:"/pages/adb64b/index.html",redirect:"/pages/adb64b/"},{path:"/1200.JS/200.理解/203.this—函数上下文.html",redirect:"/pages/adb64b/"},{name:"v-856062ce",path:"/pages/0afc0f/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-856062ce").then(t)}},{path:"/pages/0afc0f/index.html",redirect:"/pages/0afc0f/"},{path:"/1200.JS/200.理解/204.作用域.html",redirect:"/pages/0afc0f/"},{name:"v-07a1b0b5",path:"/pages/f616f1/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-07a1b0b5").then(t)}},{path:"/pages/f616f1/index.html",redirect:"/pages/f616f1/"},{path:"/1200.JS/200.理解/205.闭包.html",redirect:"/pages/f616f1/"},{name:"v-7152c6bb",path:"/pages/f59f90/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-7152c6bb").then(t)}},{path:"/pages/f59f90/index.html",redirect:"/pages/f59f90/"},{path:"/1200.JS/300.语法/301.基础语法.html",redirect:"/pages/f59f90/"},{name:"v-739f697e",path:"/pages/c65afb/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-739f697e").then(t)}},{path:"/pages/c65afb/index.html",redirect:"/pages/c65afb/"},{path:"/1200.JS/300.语法/302.ES6.html",redirect:"/pages/c65afb/"},{name:"v-585525e0",path:"/pages/ea650c/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-585525e0").then(t)}},{path:"/pages/ea650c/index.html",redirect:"/pages/ea650c/"},{path:"/1200.JS/300.语法/303.Function.html",redirect:"/pages/ea650c/"},{name:"v-efd22a0a",path:"/pages/fa990b/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-efd22a0a").then(t)}},{path:"/pages/fa990b/index.html",redirect:"/pages/fa990b/"},{path:"/1200.JS/300.语法/304.标准内置对象-1Object.html",redirect:"/pages/fa990b/"},{name:"v-25e5648a",path:"/pages/b412ad/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-25e5648a").then(t)}},{path:"/pages/b412ad/index.html",redirect:"/pages/b412ad/"},{path:"/1200.JS/300.语法/305.标准内置对象-2String.html",redirect:"/pages/b412ad/"},{name:"v-e5df6596",path:"/pages/e7e591/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-e5df6596").then(t)}},{path:"/pages/e7e591/index.html",redirect:"/pages/e7e591/"},{path:"/1200.JS/300.语法/306.标准内置对象-3Array.html",redirect:"/pages/e7e591/"},{name:"v-693092bb",path:"/pages/267da2/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-693092bb").then(t)}},{path:"/pages/267da2/index.html",redirect:"/pages/267da2/"},{path:"/1200.JS/300.语法/307.标准内置对象-4RegExp.html",redirect:"/pages/267da2/"},{name:"v-3334fcbb",path:"/pages/c814e7/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-3334fcbb").then(t)}},{path:"/pages/c814e7/index.html",redirect:"/pages/c814e7/"},{path:"/1200.JS/300.语法/308.标准内置对象-5Number.html",redirect:"/pages/c814e7/"},{name:"v-0caf1fdb",path:"/pages/00d50a/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0caf1fdb").then(t)}},{path:"/pages/00d50a/index.html",redirect:"/pages/00d50a/"},{path:"/1200.JS/300.语法/309.标准内置对象-6Math.html",redirect:"/pages/00d50a/"},{name:"v-507dad0a",path:"/pages/fbbc79/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-507dad0a").then(t)}},{path:"/pages/fbbc79/index.html",redirect:"/pages/fbbc79/"},{path:"/1200.JS/300.语法/310.标准内置对象-7Date.html",redirect:"/pages/fbbc79/"},{name:"v-0eff529f",path:"/pages/085b49/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0eff529f").then(t)}},{path:"/pages/085b49/index.html",redirect:"/pages/085b49/"},{path:"/1200.JS/300.语法/315.异常.html",redirect:"/pages/085b49/"},{name:"v-68c0f48a",path:"/pages/45bd67/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-68c0f48a").then(t)}},{path:"/pages/45bd67/index.html",redirect:"/pages/45bd67/"},{path:"/1200.JS/300.语法/311.标准内置对象-8JSON.html",redirect:"/pages/45bd67/"},{name:"v-34aa7b86",path:"/pages/925f93/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-34aa7b86").then(t)}},{path:"/pages/925f93/index.html",redirect:"/pages/925f93/"},{path:"/1200.JS/400.异步/401.异步-1定时器.html",redirect:"/pages/925f93/"},{name:"v-09038db5",path:"/pages/0e6a48/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-09038db5").then(t)}},{path:"/pages/0e6a48/index.html",redirect:"/pages/0e6a48/"},{path:"/1200.JS/400.异步/402.异步-2Promise.html",redirect:"/pages/0e6a48/"},{name:"v-083b3713",path:"/pages/9ef7a8/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-083b3713").then(t)}},{path:"/pages/9ef7a8/index.html",redirect:"/pages/9ef7a8/"},{path:"/1200.JS/400.异步/403.异步-3async&await.html",redirect:"/pages/9ef7a8/"},{name:"v-24eb3483",path:"/pages/8313cc/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-24eb3483").then(t)}},{path:"/pages/8313cc/index.html",redirect:"/pages/8313cc/"},{path:"/1200.JS/500.模块化/501.模块化-1ES6模块化.html",redirect:"/pages/8313cc/"},{name:"v-5426fc63",path:"/pages/e5923d/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-5426fc63").then(t)}},{path:"/pages/e5923d/index.html",redirect:"/pages/e5923d/"},{path:"/1200.JS/500.模块化/502.模块化-2ES5模块化.html",redirect:"/pages/e5923d/"},{name:"v-358d6d7e",path:"/pages/cb9d10/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-358d6d7e").then(t)}},{path:"/pages/cb9d10/index.html",redirect:"/pages/cb9d10/"},{path:"/1200.JS/300.语法/314.面向对象.html",redirect:"/pages/cb9d10/"},{name:"v-85c4362a",path:"/pages/c8b589/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-85c4362a").then(t)}},{path:"/pages/c8b589/index.html",redirect:"/pages/c8b589/"},{path:"/1200.JS/500.模块化/503.模块化-3常见模块化规范.html",redirect:"/pages/c8b589/"},{name:"v-72766126",path:"/pages/39c4a3/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-72766126").then(t)}},{path:"/pages/39c4a3/index.html",redirect:"/pages/39c4a3/"},{path:"/1200.JS/700.DOM&BOM/701.DOM.html",redirect:"/pages/39c4a3/"},{name:"v-ac8c93d4",path:"/pages/560afc/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-ac8c93d4").then(t)}},{path:"/pages/560afc/index.html",redirect:"/pages/560afc/"},{path:"/1200.JS/600.网络/601.Ajax.html",redirect:"/pages/560afc/"},{name:"v-342bb966",path:"/pages/3b0c3a/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-342bb966").then(t)}},{path:"/pages/3b0c3a/index.html",redirect:"/pages/3b0c3a/"},{path:"/1200.JS/700.DOM&BOM/702.BOM.html",redirect:"/pages/3b0c3a/"},{name:"v-6157df39",path:"/pages/baf83c/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-6157df39").then(t)}},{path:"/pages/baf83c/index.html",redirect:"/pages/baf83c/"},{path:"/1200.JS/800.常用框架/802.Layui.html",redirect:"/pages/baf83c/"},{name:"v-a747ade8",path:"/pages/bbc451/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-a747ade8").then(t)}},{path:"/pages/bbc451/index.html",redirect:"/pages/bbc451/"},{path:"/1200.JS/800.常用框架/801. jQuery.html",redirect:"/pages/bbc451/"},{name:"v-24294898",path:"/pages/364e02/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-24294898").then(t)}},{path:"/pages/364e02/index.html",redirect:"/pages/364e02/"},{path:"/1210.TS/101.入门.html",redirect:"/pages/364e02/"},{name:"v-5f6f758e",path:"/pages/fb0221/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-5f6f758e").then(t)}},{path:"/pages/fb0221/index.html",redirect:"/pages/fb0221/"},{path:"/1210.TS/102.JS变量类型.html",redirect:"/pages/fb0221/"},{name:"v-4eaf1eab",path:"/pages/1322e7/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-4eaf1eab").then(t)}},{path:"/pages/1322e7/index.html",redirect:"/pages/1322e7/"},{path:"/1210.TS/103.TS专属数据类型&使用.html",redirect:"/pages/1322e7/"},{name:"v-55ad473c",path:"/pages/288b06/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-55ad473c").then(t)}},{path:"/pages/288b06/index.html",redirect:"/pages/288b06/"},{path:"/1210.TS/104.TS函数.html",redirect:"/pages/288b06/"},{name:"v-51db4340",path:"/pages/d281f9/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-51db4340").then(t)}},{path:"/pages/d281f9/index.html",redirect:"/pages/d281f9/"},{path:"/1210.TS/105.TS类.html",redirect:"/pages/d281f9/"},{name:"v-f29668a2",path:"/pages/e73701/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-f29668a2").then(t)}},{path:"/pages/e73701/index.html",redirect:"/pages/e73701/"},{path:"/1210.TS/106.TS接口.html",redirect:"/pages/e73701/"},{name:"v-3fbd6196",path:"/pages/e0eec1/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-3fbd6196").then(t)}},{path:"/pages/e0eec1/index.html",redirect:"/pages/e0eec1/"},{path:"/1210.TS/107.TS泛型.html",redirect:"/pages/e0eec1/"},{name:"v-14bf56d8",path:"/pages/306c32/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-14bf56d8").then(t)}},{path:"/pages/306c32/index.html",redirect:"/pages/306c32/"},{path:"/1210.TS/108.TS补充.html",redirect:"/pages/306c32/"},{name:"v-7849f14a",path:"/pages/b62d08/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-7849f14a").then(t)}},{path:"/pages/b62d08/index.html",redirect:"/pages/b62d08/"},{path:"/1300.Node/100.Node/101.入门.html",redirect:"/pages/b62d08/"},{name:"v-0c43a93e",path:"/pages/6f1f8f/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0c43a93e").then(t)}},{path:"/pages/6f1f8f/index.html",redirect:"/pages/6f1f8f/"},{path:"/1301.Webpack/100.Webpack5/101.入门.html",redirect:"/pages/6f1f8f/"},{name:"v-914be310",path:"/pages/e2b92d/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-914be310").then(t)}},{path:"/pages/e2b92d/index.html",redirect:"/pages/e2b92d/"},{path:"/1301.Webpack/200.Webpack3/101.入门.html",redirect:"/pages/e2b92d/"},{name:"v-4b33a0fc",path:"/pages/b41819/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-4b33a0fc").then(t)}},{path:"/pages/b41819/index.html",redirect:"/pages/b41819/"},{path:"/1402.Vue2.x/100.基础/101.入门.html",redirect:"/pages/b41819/"},{name:"v-e910ea2e",path:"/pages/49b47f/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-e910ea2e").then(t)}},{path:"/pages/49b47f/index.html",redirect:"/pages/49b47f/"},{path:"/1402.Vue2.x/100.基础/102.插值语法.html",redirect:"/pages/49b47f/"},{name:"v-9dd99cf6",path:"/pages/18d9ea/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-9dd99cf6").then(t)}},{path:"/pages/18d9ea/index.html",redirect:"/pages/18d9ea/"},{path:"/1402.Vue2.x/100.基础/103.绑定属性.html",redirect:"/pages/18d9ea/"},{name:"v-8d0417cc",path:"/pages/10562f/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-8d0417cc").then(t)}},{path:"/pages/10562f/index.html",redirect:"/pages/10562f/"},{path:"/1402.Vue2.x/100.基础/104.计算属性和侦听器.html",redirect:"/pages/10562f/"},{name:"v-46373fc2",path:"/pages/5aff0b/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-46373fc2").then(t)}},{path:"/pages/5aff0b/index.html",redirect:"/pages/5aff0b/"},{path:"/1402.Vue2.x/100.基础/105.事件监听.html",redirect:"/pages/5aff0b/"},{name:"v-24f2dc8c",path:"/pages/7627a1/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-24f2dc8c").then(t)}},{path:"/pages/7627a1/index.html",redirect:"/pages/7627a1/"},{path:"/1402.Vue2.x/100.基础/106.条件和循环.html",redirect:"/pages/7627a1/"},{name:"v-57d26e26",path:"/pages/6780f9/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-57d26e26").then(t)}},{path:"/pages/6780f9/index.html",redirect:"/pages/6780f9/"},{path:"/1402.Vue2.x/100.基础/107.表单双向绑定.html",redirect:"/pages/6780f9/"},{name:"v-872bc0d8",path:"/pages/15ab90/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-872bc0d8").then(t)}},{path:"/pages/15ab90/index.html",redirect:"/pages/15ab90/"},{path:"/1402.Vue2.x/200.组件/201.组件化开发.html",redirect:"/pages/15ab90/"},{name:"v-9ebbc8cc",path:"/pages/cca4b3/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-9ebbc8cc").then(t)}},{path:"/pages/cca4b3/index.html",redirect:"/pages/cca4b3/"},{path:"/1402.Vue2.x/200.组件/202.插槽.html",redirect:"/pages/cca4b3/"},{name:"v-9152731e",path:"/pages/ac2e39/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-9152731e").then(t)}},{path:"/pages/ac2e39/index.html",redirect:"/pages/ac2e39/"},{path:"/1402.Vue2.x/300.Vue CLI/301.入门.html",redirect:"/pages/ac2e39/"},{name:"v-28296e0a",path:"/pages/9741e2/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-28296e0a").then(t)}},{path:"/pages/9741e2/index.html",redirect:"/pages/9741e2/"},{path:"/1402.Vue2.x/400.Vue Router/401.Vue Router入门.html",redirect:"/pages/9741e2/"},{name:"v-7fdbdcfc",path:"/pages/347f26/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-7fdbdcfc").then(t)}},{path:"/pages/347f26/index.html",redirect:"/pages/347f26/"},{path:"/1403.Vue3.x/100.基础/101.入门.html",redirect:"/pages/347f26/"},{name:"v-2cd89bf0",path:"/pages/47f5c4/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-2cd89bf0").then(t)}},{path:"/pages/47f5c4/index.html",redirect:"/pages/47f5c4/"},{path:"/1403.Vue3.x/100.基础/102.模版语法&指令.html",redirect:"/pages/47f5c4/"},{name:"v-0a8a952c",path:"/pages/3dbba2/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-0a8a952c").then(t)}},{path:"/pages/3dbba2/index.html",redirect:"/pages/3dbba2/"},{path:"/1403.Vue3.x/100.基础/103.条件渲染&列表渲染.html",redirect:"/pages/3dbba2/"},{name:"v-155f6902",path:"/pages/af8c61/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-155f6902").then(t)}},{path:"/pages/af8c61/index.html",redirect:"/pages/af8c61/"},{path:"/1403.Vue3.x/100.基础/104.计算属性&侦听器.html",redirect:"/pages/af8c61/"},{name:"v-12090137",path:"/pages/973ddb/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-12090137").then(t)}},{path:"/pages/973ddb/index.html",redirect:"/pages/973ddb/"},{path:"/1403.Vue3.x/100.基础/105.表单的双向绑定.html",redirect:"/pages/973ddb/"},{name:"v-1237fee2",path:"/pages/3c9e8f/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-1237fee2").then(t)}},{path:"/pages/3c9e8f/index.html",redirect:"/pages/3c9e8f/"},{path:"/1403.Vue3.x/1000.项目/101.搭建项目.html",redirect:"/pages/3c9e8f/"},{name:"v-c516b5da",path:"/pages/d2d257/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-c516b5da").then(t)}},{path:"/pages/d2d257/index.html",redirect:"/pages/d2d257/"},{path:"/1403.Vue3.x/100.基础/106.组件化开发.html",redirect:"/pages/d2d257/"},{name:"v-16cea650",path:"/pages/b5412c/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-16cea650").then(t)}},{path:"/pages/b5412c/index.html",redirect:"/pages/b5412c/"},{path:"/1403.Vue3.x/1000.项目/102.重点.html",redirect:"/pages/b5412c/"},{name:"v-35b5c424",path:"/pages/e8afc3/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-35b5c424").then(t)}},{path:"/pages/e8afc3/index.html",redirect:"/pages/e8afc3/"},{path:"/1403.Vue3.x/200.组件/201.父子组件通讯.html",redirect:"/pages/e8afc3/"},{name:"v-543b1f60",path:"/pages/9026a0/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-543b1f60").then(t)}},{path:"/pages/9026a0/index.html",redirect:"/pages/9026a0/"},{path:"/1403.Vue3.x/200.组件/202.非父子组件通讯.html",redirect:"/pages/9026a0/"},{name:"v-bb49f58c",path:"/pages/fff569/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-bb49f58c").then(t)}},{path:"/pages/fff569/index.html",redirect:"/pages/fff569/"},{path:"/1403.Vue3.x/200.组件/203.插槽.html",redirect:"/pages/fff569/"},{name:"v-448d3032",path:"/pages/4e1afb/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-448d3032").then(t)}},{path:"/pages/4e1afb/index.html",redirect:"/pages/4e1afb/"},{path:"/1403.Vue3.x/200.组件/204.动态组件.html",redirect:"/pages/4e1afb/"},{name:"v-50a06977",path:"/pages/f515e4/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-50a06977").then(t)}},{path:"/pages/f515e4/index.html",redirect:"/pages/f515e4/"},{path:"/1403.Vue3.x/200.组件/205.异步组件.html",redirect:"/pages/f515e4/"},{name:"v-b041636c",path:"/pages/85ff80/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-b041636c").then(t)}},{path:"/pages/85ff80/index.html",redirect:"/pages/85ff80/"},{path:"/1403.Vue3.x/200.组件/206.生命周期.html",redirect:"/pages/85ff80/"},{name:"v-31e4b958",path:"/pages/fcbaec/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-31e4b958").then(t)}},{path:"/pages/fcbaec/index.html",redirect:"/pages/fcbaec/"},{path:"/1403.Vue3.x/200.组件/207.组件的v-model.html",redirect:"/pages/fcbaec/"},{name:"v-442b5a91",path:"/pages/5570af/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-442b5a91").then(t)}},{path:"/pages/5570af/index.html",redirect:"/pages/5570af/"},{path:"/1403.Vue3.x/300.动画/301.Vue动画.html",redirect:"/pages/5570af/"},{name:"v-ee4028c4",path:"/pages/958e61/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-ee4028c4").then(t)}},{path:"/pages/958e61/index.html",redirect:"/pages/958e61/"},{path:"/1403.Vue3.x/400.Composition Api/401.旧解决方案.html",redirect:"/pages/958e61/"},{name:"v-5c4c5168",path:"/pages/52c08c/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-5c4c5168").then(t)}},{path:"/pages/52c08c/index.html",redirect:"/pages/52c08c/"},{path:"/1403.Vue3.x/400.Composition Api/402.响应式Api.html",redirect:"/pages/52c08c/"},{name:"v-19d39f68",path:"/pages/4f74c8/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-19d39f68").then(t)}},{path:"/pages/4f74c8/index.html",redirect:"/pages/4f74c8/"},{path:"/1403.Vue3.x/400.Composition Api/403.计算属性&侦听器.html",redirect:"/pages/4f74c8/"},{name:"v-60be060a",path:"/pages/563ede/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-60be060a").then(t)}},{path:"/pages/563ede/index.html",redirect:"/pages/563ede/"},{path:"/1403.Vue3.x/400.Composition Api/404.其他.html",redirect:"/pages/563ede/"},{name:"v-3b93b6c4",path:"/pages/2b61b7/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-3b93b6c4").then(t)}},{path:"/pages/2b61b7/index.html",redirect:"/pages/2b61b7/"},{path:"/1403.Vue3.x/500.高级语法/501.h 函数 & JSX.html",redirect:"/pages/2b61b7/"},{name:"v-3edfb5c9",path:"/pages/aa7419/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-3edfb5c9").then(t)}},{path:"/pages/aa7419/index.html",redirect:"/pages/aa7419/"},{path:"/1403.Vue3.x/500.高级语法/502.自定义指令.html",redirect:"/pages/aa7419/"},{name:"v-ca2df650",path:"/pages/847cf9/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-ca2df650").then(t)}},{path:"/pages/847cf9/index.html",redirect:"/pages/847cf9/"},{path:"/1403.Vue3.x/500.高级语法/503.Teleport.html",redirect:"/pages/847cf9/"},{name:"v-65a89695",path:"/pages/73db51/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-65a89695").then(t)}},{path:"/pages/73db51/index.html",redirect:"/pages/73db51/"},{path:"/1403.Vue3.x/500.高级语法/504.插件.html",redirect:"/pages/73db51/"},{name:"v-7be5c8d6",path:"/pages/e0a730/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-7be5c8d6").then(t)}},{path:"/pages/e0a730/index.html",redirect:"/pages/e0a730/"},{path:"/1403.Vue3.x/500.高级语法/505.nextTick与eventloop.html",redirect:"/pages/e0a730/"},{name:"v-501ae650",path:"/pages/d4f613/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-501ae650").then(t)}},{path:"/pages/d4f613/index.html",redirect:"/pages/d4f613/"},{path:"/1403.Vue3.x/500.高级语法/506.historyApiFallback.html",redirect:"/pages/d4f613/"},{name:"v-f262342e",path:"/pages/2e2905/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-f262342e").then(t)}},{path:"/pages/2e2905/index.html",redirect:"/pages/2e2905/"},{path:"/1403.Vue3.x/600.Vue源码/601.源码.html",redirect:"/pages/2e2905/"},{name:"v-189a620b",path:"/pages/6f4bd5/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-189a620b").then(t)}},{path:"/pages/6f4bd5/index.html",redirect:"/pages/6f4bd5/"},{path:"/1403.Vue3.x/600.Vue源码/611.MiniVue.html",redirect:"/pages/6f4bd5/"},{name:"v-7593113f",path:"/pages/af8fd5/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-7593113f").then(t)}},{path:"/pages/af8fd5/index.html",redirect:"/pages/af8fd5/"},{path:"/1403.Vue3.x/700.VueCLI&Vite/100.VueCLI.html",redirect:"/pages/af8fd5/"},{name:"v-7d33582d",path:"/pages/fe7980/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-7d33582d").then(t)}},{path:"/pages/fe7980/index.html",redirect:"/pages/fe7980/"},{path:"/1403.Vue3.x/700.VueCLI&Vite/200.Vite.html",redirect:"/pages/fe7980/"},{name:"v-5e159a9e",path:"/pages/39a5b4/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-5e159a9e").then(t)}},{path:"/pages/39a5b4/index.html",redirect:"/pages/39a5b4/"},{path:"/1403.Vue3.x/800.VueRouter/801.路由.html",redirect:"/pages/39a5b4/"},{name:"v-3f3a9c6d",path:"/pages/1c8fc2/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-3f3a9c6d").then(t)}},{path:"/pages/1c8fc2/index.html",redirect:"/pages/1c8fc2/"},{path:"/1403.Vue3.x/800.VueRouter/802.VueRouter.html",redirect:"/pages/1c8fc2/"},{name:"v-a7ae7326",path:"/pages/47a190/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-a7ae7326").then(t)}},{path:"/pages/47a190/index.html",redirect:"/pages/47a190/"},{path:"/1403.Vue3.x/900.Vuex/901.状态管理.html",redirect:"/pages/47a190/"},{name:"v-d73b99a6",path:"/pages/fa4384/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-d73b99a6").then(t)}},{path:"/pages/fa4384/index.html",redirect:"/pages/fa4384/"},{path:"/1403.Vue3.x/900.Vuex/902.Vuex.html",redirect:"/pages/fa4384/"},{name:"v-f5a073a2",path:"/pages/00b1d8/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-f5a073a2").then(t)}},{path:"/pages/00b1d8/index.html",redirect:"/pages/00b1d8/"},{path:"/1500.微信小程序/101.入门.html",redirect:"/pages/00b1d8/"},{name:"v-66c7385c",path:"/pages/d80ad7/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-66c7385c").then(t)}},{path:"/pages/d80ad7/index.html",redirect:"/pages/d80ad7/"},{path:"/9999.推荐/101.index.html",redirect:"/pages/d80ad7/"},{name:"v-a64046a6",path:"/archives/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-a64046a6").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-90d1f7e6",path:"/categories/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-90d1f7e6").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-2ec62ba6",path:"/tags/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-2ec62ba6").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-d9cccf82",path:"/pages/f2e63f/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-d9cccf82").then(t)}},{path:"/pages/f2e63f/index.html",redirect:"/pages/f2e63f/"},{path:"/_posts/随笔/你知道的越多，不知道的也就越多.html",redirect:"/pages/f2e63f/"},{name:"v-191fb5de",path:"/pages/829589/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-191fb5de").then(t)}},{path:"/pages/829589/index.html",redirect:"/pages/829589/"},{path:"/_posts/随笔/我做了一个手写春联小网页，祝大家虎年暴富.html",redirect:"/pages/829589/"},{name:"v-43ae2c82",path:"/pages/cd8bde/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-43ae2c82").then(t)}},{path:"/pages/cd8bde/index.html",redirect:"/pages/cd8bde/"},{path:"/_posts/随笔/拥抱生活，拥抱快乐.html",redirect:"/pages/cd8bde/"},{name:"v-a21e1e74",path:"/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-a21e1e74").then(t)}},{path:"/index.html",redirect:"/"},{name:"v-55887b9b",path:"/pages/1d766f/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-55887b9b").then(t)}},{path:"/pages/1d766f/index.html",redirect:"/pages/1d766f/"},{path:"/1200.JS/300.语法/313.标准内置对象-10Map.html",redirect:"/pages/1d766f/"},{name:"v-51ff37b9",path:"/pages/41ad52/",component:is,beforeEnter:function(n,e,t){Jr("Layout","v-51ff37b9").then(t)}},{path:"/pages/41ad52/index.html",redirect:"/pages/41ad52/"},{path:"/1200.JS/300.语法/312.标准内置对象-9Set.html",redirect:"/pages/41ad52/"},{path:"*",component:is}],ls={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"keywords",content:"前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"前端",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"01.前端",imgUrl:"/img/web.png",description:"JavaScript、ES6、Vue框架等前端技术"}},title:"前端",date:"2020-03-11T21:50:53.000Z",permalink:"/web",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/01.前端.md",key:"v-768367e2",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"页面",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"02.页面",imgUrl:"/img/ui.png",description:"html(5)/css(3)，前端页面相关技术"}},title:"页面",date:"2020-03-11T21:50:54.000Z",permalink:"/ui",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E9%A1%B5%E9%9D%A2.html",relativePath:"00.目录页/02.页面.md",key:"v-d0a13a84",path:"/ui/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"技术",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"03.技术",imgUrl:"/img/other.png",description:"技术文档、教程、技巧、总结等文章"}},title:"技术",date:"2020-03-11T21:50:55.000Z",permalink:"/technology",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%8A%80%E6%9C%AF.html",relativePath:"00.目录页/03.技术.md",key:"v-2ba7b4d5",path:"/technology/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"更多",frontmatter:{pageComponent:{name:"Catalogue",data:{key:"04.更多",imgUrl:"/img/more.png",description:"学习、面试、在线工具等更多文章和页面"}},title:"更多",date:"2020-03-11T21:50:56.000Z",permalink:"/more",sidebar:!1,article:!1,comment:!1,editLink:!1},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/04.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/04.更多.md",key:"v-09b07641",path:"/more/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"33个非常实用的JavaScript一行代码",frontmatter:{title:"33个非常实用的JavaScript一行代码",date:"2021-11-02T09:51:37.000Z",permalink:"/pages/a61298/",categories:["前端","JavaScript文章"],tags:["JavaScript"],author:"CUGGZ"},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/01.33%E4%B8%AA%E9%9D%9E%E5%B8%B8%E5%AE%9E%E7%94%A8%E7%9A%84JavaScript%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81.html",relativePath:"01.前端/25.JavaScript文章/01.33个非常实用的JavaScript一行代码.md",key:"v-94759ba8",path:"/pages/a61298/",headers:[{level:2,title:"一、日期处理",slug:"一、日期处理",normalizedTitle:"一、日期处理",charIndex:2},{level:3,title:"1. 检察日期是否有效",slug:"_1-检察日期是否有效",normalizedTitle:"1. 检察日期是否有效",charIndex:13},{level:3,title:"2. 计算两个日期之间的间隔",slug:"_2-计算两个日期之间的间隔",normalizedTitle:"2. 计算两个日期之间的间隔",charIndex:193},{level:3,title:"3. 查找日期位于一年中的第几天",slug:"_3-查找日期位于一年中的第几天",normalizedTitle:"3. 查找日期位于一年中的第几天",charIndex:421},{level:3,title:"4. 时间格式化",slug:"_4-时间格式化",normalizedTitle:"4. 时间格式化",charIndex:640},{level:2,title:"二、字符串处理",slug:"二、字符串处理",normalizedTitle:"二、字符串处理",charIndex:881},{level:3,title:"1. 字符串首字母大写",slug:"_1-字符串首字母大写",normalizedTitle:"1. 字符串首字母大写",charIndex:893},{level:3,title:"2. 翻转字符串",slug:"_2-翻转字符串",normalizedTitle:"2. 翻转字符串",charIndex:1060},{level:3,title:"3. 随机字符串",slug:"_3-随机字符串",normalizedTitle:"3. 随机字符串",charIndex:1221},{level:3,title:"4. 截断字符串",slug:"_4-截断字符串",normalizedTitle:"4. 截断字符串",charIndex:1350},{level:3,title:"5. 去除字符串中的HTML",slug:"_5-去除字符串中的html",normalizedTitle:"5. 去除字符串中的html",charIndex:1632},{level:2,title:"三、数组处理",slug:"三、数组处理",normalizedTitle:"三、数组处理",charIndex:1788},{level:3,title:"1. 从数组中移除重复项",slug:"_1-从数组中移除重复项",normalizedTitle:"1. 从数组中移除重复项",charIndex:1799},{level:3,title:"2. 判断数组是否为空",slug:"_2-判断数组是否为空",normalizedTitle:"2. 判断数组是否为空",charIndex:1967},{level:3,title:"3. 合并两个数组",slug:"_3-合并两个数组",normalizedTitle:"3. 合并两个数组",charIndex:2127},{level:2,title:"四、数字操作",slug:"四、数字操作",normalizedTitle:"四、数字操作",charIndex:2254},{level:3,title:"1. 判断一个数是奇数还是偶数",slug:"_1-判断一个数是奇数还是偶数",normalizedTitle:"1. 判断一个数是奇数还是偶数",charIndex:2265},{level:3,title:"2. 获得一组数的平均值",slug:"_2-获得一组数的平均值",normalizedTitle:"2. 获得一组数的平均值",charIndex:2374},{level:3,title:"3. 获取两个整数之间的随机整数",slug:"_3-获取两个整数之间的随机整数",normalizedTitle:"3. 获取两个整数之间的随机整数",charIndex:2513},{level:3,title:"4. 指定位数四舍五入",slug:"_4-指定位数四舍五入",normalizedTitle:"4. 指定位数四舍五入",charIndex:2667},{level:2,title:"五、颜色操作",slug:"五、颜色操作",normalizedTitle:"五、颜色操作",charIndex:2840},{level:3,title:"1. 将RGB转化为十六机制",slug:"_1-将rgb转化为十六机制",normalizedTitle:"1. 将rgb转化为十六机制",charIndex:2851},{level:3,title:"2. 获取随机十六进制颜色",slug:"_2-获取随机十六进制颜色",normalizedTitle:"2. 获取随机十六进制颜色",charIndex:3051},{level:2,title:"六、浏览器操作",slug:"六、浏览器操作",normalizedTitle:"六、浏览器操作",charIndex:3218},{level:3,title:"1. 复制内容到剪切板",slug:"_1-复制内容到剪切板",normalizedTitle:"1. 复制内容到剪切板",charIndex:3230},{level:3,title:"2. 清除所有cookie",slug:"_2-清除所有cookie",normalizedTitle:"2. 清除所有cookie",charIndex:3418},{level:3,title:"3. 获取选中的文本",slug:"_3-获取选中的文本",normalizedTitle:"3. 获取选中的文本",charIndex:3684},{level:3,title:"4. 检测是否是黑暗模式",slug:"_4-检测是否是黑暗模式",normalizedTitle:"4. 检测是否是黑暗模式",charIndex:3836},{level:3,title:"5. 滚动到页面顶部",slug:"_5-滚动到页面顶部",normalizedTitle:"5. 滚动到页面顶部",charIndex:4023},{level:3,title:"6. 判断当前标签页是否激活",slug:"_6-判断当前标签页是否激活",normalizedTitle:"6. 判断当前标签页是否激活",charIndex:4128},{level:3,title:"7. 判断当前是否是苹果设备",slug:"_7-判断当前是否是苹果设备",normalizedTitle:"7. 判断当前是否是苹果设备",charIndex:4225},{level:3,title:"8. 是否滚动到页面底部",slug:"_8-是否滚动到页面底部",normalizedTitle:"8. 是否滚动到页面底部",charIndex:4379},{level:3,title:"9. 重定向到一个URL",slug:"_9-重定向到一个url",normalizedTitle:"9. 重定向到一个url",charIndex:4555},{level:3,title:"10. 打开浏览器打印框",slug:"_10-打开浏览器打印框",normalizedTitle:"10. 打开浏览器打印框",charIndex:4689},{level:2,title:"七、其他操作",slug:"七、其他操作",normalizedTitle:"七、其他操作",charIndex:4781},{level:3,title:"1. 随机布尔值",slug:"_1-随机布尔值",normalizedTitle:"1. 随机布尔值",charIndex:4792},{level:3,title:"2. 变量交换",slug:"_2-变量交换",normalizedTitle:"2. 变量交换",charIndex:4960},{level:3,title:"3. 获取变量的类型",slug:"_3-获取变量的类型",normalizedTitle:"3. 获取变量的类型",charIndex:5043},{level:3,title:"4. 华氏度和摄氏度之间的转化",slug:"_4-华氏度和摄氏度之间的转化",normalizedTitle:"4. 华氏度和摄氏度之间的转化",charIndex:5446},{level:3,title:"5. 检测对象是否为空",slug:"_5-检测对象是否为空",normalizedTitle:"5. 检测对象是否为空",charIndex:5813}],headersStr:"一、日期处理 1. 检察日期是否有效 2. 计算两个日期之间的间隔 3. 查找日期位于一年中的第几天 4. 时间格式化 二、字符串处理 1. 字符串首字母大写 2. 翻转字符串 3. 随机字符串 4. 截断字符串 5. 去除字符串中的HTML 三、数组处理 1. 从数组中移除重复项 2. 判断数组是否为空 3. 合并两个数组 四、数字操作 1. 判断一个数是奇数还是偶数 2. 获得一组数的平均值 3. 获取两个整数之间的随机整数 4. 指定位数四舍五入 五、颜色操作 1. 将RGB转化为十六机制 2. 获取随机十六进制颜色 六、浏览器操作 1. 复制内容到剪切板 2. 清除所有cookie 3. 获取选中的文本 4. 检测是否是黑暗模式 5. 滚动到页面顶部 6. 判断当前标签页是否激活 7. 判断当前是否是苹果设备 8. 是否滚动到页面底部 9. 重定向到一个URL 10. 打开浏览器打印框 七、其他操作 1. 随机布尔值 2. 变量交换 3. 获取变量的类型 4. 华氏度和摄氏度之间的转化 5. 检测对象是否为空",content:"# 一、日期处理\n\n\n# 1. 检察日期是否有效\n\n该方法用于检测给出的日期是否有效：\n\nconst isDateValid = (...val) => !Number.isNaN(new Date(...val).valueOf());\n\nisDateValid(\"December 17, 1995 03:24:00\");  // true\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 计算两个日期之间的间隔\n\n该方法用于计算两个日期之间的间隔时间：\n\nconst dayDif = (date1, date2) => Math.ceil(Math.abs(date1.getTime() - date2.getTime()) / 86400000)\n\ndayDif(new Date(\"2021-11-3\"), new Date(\"2022-2-1\"))  // 90\n复制代码\n\n\n1\n2\n3\n4\n\n\n距离过年还有90天~\n\n\n# 3. 查找日期位于一年中的第几天\n\n该方法用于检测给出的日期位于今年的第几天：\n\nconst dayOfYear = (date) => Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 1000 / 60 / 60 / 24);\n\ndayOfYear(new Date());   // 307\n复制代码\n\n\n1\n2\n3\n4\n\n\n2021年已经过去300多天了~\n\n\n# 4. 时间格式化\n\n该方法可以用于将时间转化为hour:minutes:seconds的格式：\n\nconst timeFromDate = date => date.toTimeString().slice(0, 8);\n\ntimeFromDate(new Date(2021, 11, 2, 12, 30, 0));  // 12:30:00\ntimeFromDate(new Date());  // 返回当前时间 09:00:00\n复制代码\n\n\n1\n2\n3\n4\n5\n\n\n\n# 二、字符串处理\n\n\n# 1. 字符串首字母大写\n\n该方法用于将英文字符串的首字母大写处理：\n\nconst capitalize = str => str.charAt(0).toUpperCase() + str.slice(1)\n\ncapitalize(\"hello world\")  // Hello world\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 翻转字符串\n\n该方法用于将一个字符串进行翻转操作，返回翻转后的字符串：\n\nconst reverse = str => str.split('').reverse().join('');\n\nreverse('hello world');   // 'dlrow olleh'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 随机字符串\n\n该方法用于生成一个随机的字符串：\n\nconst randomString = () => Math.random().toString(36).slice(2);\n\nrandomString();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 截断字符串\n\n该方法可以从指定长度处截断字符串:\n\nconst truncateString = (string, length) => string.length < length ? string : `${string.slice(0, length - 3)}...`;\n\ntruncateString('Hi, I should be truncated because I am too loooong!', 36)   // 'Hi, I should be truncated because...'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 5. 去除字符串中的HTML\n\n该方法用于去除字符串中的HTML元素：\n\nconst stripHtml = html => (new DOMParser().parseFromString(html, 'text/html')).body.textContent || '';\n复制代码\n\n\n1\n2\n\n\n\n# 三、数组处理\n\n\n# 1. 从数组中移除重复项\n\n该方法用于移除数组中的重复项：\n\nconst removeDuplicates = (arr) => [...new Set(arr)];\n\nconsole.log(removeDuplicates([1, 2, 2, 3, 3, 4, 4, 5, 5, 6]));\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 判断数组是否为空\n\n该方法用于判断一个数组是否为空数组，它将返回一个布尔值：\n\nconst isNotEmpty = arr => Array.isArray(arr) && arr.length > 0;\n\nisNotEmpty([1, 2, 3]);  // true\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 合并两个数组\n\n可以使用下面两个方法来合并两个数组：\n\nconst merge = (a, b) => a.concat(b);\n\nconst merge = (a, b) => [...a, ...b];\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 四、数字操作\n\n\n# 1. 判断一个数是奇数还是偶数\n\n该方法用于判断一个数字是奇数还是偶数：\n\nconst isEven = num => num % 2 === 0;\n\nisEven(996);\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 获得一组数的平均值\n\nconst average = (...args) => args.reduce((a, b) => a + b) / args.length;\n\naverage(1, 2, 3, 4, 5);   // 3\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 获取两个整数之间的随机整数\n\n该方法用于获取两个整数之间的随机整数\n\nconst random = (min, max) => Math.floor(Math.random() * (max - min + 1) + min);\n\nrandom(1, 50);\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 指定位数四舍五入\n\n该方法用于将一个数字按照指定位进行四舍五入：\n\nconst round = (n, d) => Number(Math.round(n + \"e\" + d) + \"e-\" + d)\n\nround(1.005, 2) //1.01\nround(1.555, 2) //1.56\n复制代码\n\n\n1\n2\n3\n4\n5\n\n\n\n# 五、颜色操作\n\n\n# 1. 将RGB转化为十六机制\n\n该方法可以将一个RGB的颜色值转化为16进制值：\n\nconst rgbToHex = (r, g, b) => \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n\nrgbToHex(255, 255, 255);  // '#ffffff'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 获取随机十六进制颜色\n\n该方法用于获取一个随机的十六进制颜色值：\n\nconst randomHex = () => `#${Math.floor(Math.random() * 0xffffff).toString(16).padEnd(6, \"0\")}`;\n\nrandomHex();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 六、浏览器操作\n\n\n# 1. 复制内容到剪切板\n\n该方法使用 navigator.clipboard.writeText 来实现将文本复制到剪贴板：\n\nconst copyToClipboard = (text) => navigator.clipboard.writeText(text);\n\ncopyToClipboard(\"Hello World\");\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 清除所有cookie\n\n该方法可以通过使用 document.cookie 来访问 cookie 并清除存储在网页中的所有 cookie：\n\nconst clearCookies = document.cookie.split(';').forEach(cookie => document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new Date(0).toUTCString()};path=/`));\n复制代码\n\n\n1\n2\n\n\n\n# 3. 获取选中的文本\n\n该方法通过内置的 getSelection 属性获取用户选择的文本：\n\nconst getSelectedText = () => window.getSelection().toString();\n\ngetSelectedText();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 检测是否是黑暗模式\n\n该方法用于检测当前的环境是否是黑暗模式，它是一个布尔值：\n\nconst isDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches\n\nconsole.log(isDarkMode)\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 5. 滚动到页面顶部\n\n该方法用于在页面中返回顶部：\n\nconst goToTop = () => window.scrollTo(0, 0);\n\ngoToTop();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 6. 判断当前标签页是否激活\n\n该方法用于检测当前标签页是否已经激活：\n\nconst isTabInView = () => !document.hidden;\n复制代码\n\n\n1\n2\n\n\n\n# 7. 判断当前是否是苹果设备\n\n该方法用于检测当前的设备是否是苹果的设备：\n\nconst isAppleDevice = () => /Mac|iPod|iPhone|iPad/.test(navigator.platform);\n\nisAppleDevice();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 8. 是否滚动到页面底部\n\n该方法用于判断页面是否已经底部：\n\nconst scrolledToBottom = () => document.documentElement.clientHeight + window.scrollY >= document.documentElement.scrollHeight;\n复制代码\n\n\n1\n2\n\n\n\n# 9. 重定向到一个URL\n\n该方法用于重定向到一个新的URL：\n\nconst redirect = url => location.href = url\n\nredirect(\"https://www.google.com/\")\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 10. 打开浏览器打印框\n\n该方法用于打开浏览器的打印框：\n\nconst showPrintDialog = () => window.print()\n复制代码\n\n\n1\n2\n\n\n\n# 七、其他操作\n\n\n# 1. 随机布尔值\n\n该方法可以返回一个随机的布尔值，使用Math.random()可以获得0-1的随机数，与0.5进行比较，就有一半的概率获得真值或者假值。\n\nconst randomBoolean = () => Math.random() >= 0.5;\n\nrandomBoolean();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 变量交换\n\n可以使用以下形式在不适用第三个变量的情况下，交换两个变量的值：\n\n[foo, bar] = [bar, foo];\n复制代码\n\n\n1\n2\n\n\n\n# 3. 获取变量的类型\n\n该方法用于获取一个变量的类型：\n\nconst trueTypeOf = (obj) => Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();\n\ntrueTypeOf('');     // string\ntrueTypeOf(0);      // number\ntrueTypeOf();       // undefined\ntrueTypeOf(null);   // null\ntrueTypeOf({});     // object\ntrueTypeOf([]);     // array\ntrueTypeOf(0);      // number\ntrueTypeOf(() => {});  // function\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4. 华氏度和摄氏度之间的转化\n\n该方法用于摄氏度和华氏度之间的转化：\n\nconst celsiusToFahrenheit = (celsius) => celsius * 9/5 + 32;\nconst fahrenheitToCelsius = (fahrenheit) => (fahrenheit - 32) * 5/9;\n\ncelsiusToFahrenheit(15);    // 59\ncelsiusToFahrenheit(0);     // 32\ncelsiusToFahrenheit(-20);   // -4\nfahrenheitToCelsius(59);    // 15\nfahrenheitToCelsius(32);    // 0\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5. 检测对象是否为空\n\n该方法用于检测一个JavaScript对象是否为空：\n\nconst isEmpty = obj => Reflect.ownKeys(obj).length === 0 && obj.constructor === Object;\n复制代码\n\n\n1\n2\n\n\n> 作者：CUGGZ 链接：https://juejin.cn/post/7025771605422768159",normalizedContent:"# 一、日期处理\n\n\n# 1. 检察日期是否有效\n\n该方法用于检测给出的日期是否有效：\n\nconst isdatevalid = (...val) => !number.isnan(new date(...val).valueof());\n\nisdatevalid(\"december 17, 1995 03:24:00\");  // true\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 计算两个日期之间的间隔\n\n该方法用于计算两个日期之间的间隔时间：\n\nconst daydif = (date1, date2) => math.ceil(math.abs(date1.gettime() - date2.gettime()) / 86400000)\n\ndaydif(new date(\"2021-11-3\"), new date(\"2022-2-1\"))  // 90\n复制代码\n\n\n1\n2\n3\n4\n\n\n距离过年还有90天~\n\n\n# 3. 查找日期位于一年中的第几天\n\n该方法用于检测给出的日期位于今年的第几天：\n\nconst dayofyear = (date) => math.floor((date - new date(date.getfullyear(), 0, 0)) / 1000 / 60 / 60 / 24);\n\ndayofyear(new date());   // 307\n复制代码\n\n\n1\n2\n3\n4\n\n\n2021年已经过去300多天了~\n\n\n# 4. 时间格式化\n\n该方法可以用于将时间转化为hour:minutes:seconds的格式：\n\nconst timefromdate = date => date.totimestring().slice(0, 8);\n\ntimefromdate(new date(2021, 11, 2, 12, 30, 0));  // 12:30:00\ntimefromdate(new date());  // 返回当前时间 09:00:00\n复制代码\n\n\n1\n2\n3\n4\n5\n\n\n\n# 二、字符串处理\n\n\n# 1. 字符串首字母大写\n\n该方法用于将英文字符串的首字母大写处理：\n\nconst capitalize = str => str.charat(0).touppercase() + str.slice(1)\n\ncapitalize(\"hello world\")  // hello world\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 翻转字符串\n\n该方法用于将一个字符串进行翻转操作，返回翻转后的字符串：\n\nconst reverse = str => str.split('').reverse().join('');\n\nreverse('hello world');   // 'dlrow olleh'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 随机字符串\n\n该方法用于生成一个随机的字符串：\n\nconst randomstring = () => math.random().tostring(36).slice(2);\n\nrandomstring();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 截断字符串\n\n该方法可以从指定长度处截断字符串:\n\nconst truncatestring = (string, length) => string.length < length ? string : `${string.slice(0, length - 3)}...`;\n\ntruncatestring('hi, i should be truncated because i am too loooong!', 36)   // 'hi, i should be truncated because...'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 5. 去除字符串中的html\n\n该方法用于去除字符串中的html元素：\n\nconst striphtml = html => (new domparser().parsefromstring(html, 'text/html')).body.textcontent || '';\n复制代码\n\n\n1\n2\n\n\n\n# 三、数组处理\n\n\n# 1. 从数组中移除重复项\n\n该方法用于移除数组中的重复项：\n\nconst removeduplicates = (arr) => [...new set(arr)];\n\nconsole.log(removeduplicates([1, 2, 2, 3, 3, 4, 4, 5, 5, 6]));\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 判断数组是否为空\n\n该方法用于判断一个数组是否为空数组，它将返回一个布尔值：\n\nconst isnotempty = arr => array.isarray(arr) && arr.length > 0;\n\nisnotempty([1, 2, 3]);  // true\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 合并两个数组\n\n可以使用下面两个方法来合并两个数组：\n\nconst merge = (a, b) => a.concat(b);\n\nconst merge = (a, b) => [...a, ...b];\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 四、数字操作\n\n\n# 1. 判断一个数是奇数还是偶数\n\n该方法用于判断一个数字是奇数还是偶数：\n\nconst iseven = num => num % 2 === 0;\n\niseven(996);\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 获得一组数的平均值\n\nconst average = (...args) => args.reduce((a, b) => a + b) / args.length;\n\naverage(1, 2, 3, 4, 5);   // 3\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 3. 获取两个整数之间的随机整数\n\n该方法用于获取两个整数之间的随机整数\n\nconst random = (min, max) => math.floor(math.random() * (max - min + 1) + min);\n\nrandom(1, 50);\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 指定位数四舍五入\n\n该方法用于将一个数字按照指定位进行四舍五入：\n\nconst round = (n, d) => number(math.round(n + \"e\" + d) + \"e-\" + d)\n\nround(1.005, 2) //1.01\nround(1.555, 2) //1.56\n复制代码\n\n\n1\n2\n3\n4\n5\n\n\n\n# 五、颜色操作\n\n\n# 1. 将rgb转化为十六机制\n\n该方法可以将一个rgb的颜色值转化为16进制值：\n\nconst rgbtohex = (r, g, b) => \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).tostring(16).slice(1);\n\nrgbtohex(255, 255, 255);  // '#ffffff'\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 获取随机十六进制颜色\n\n该方法用于获取一个随机的十六进制颜色值：\n\nconst randomhex = () => `#${math.floor(math.random() * 0xffffff).tostring(16).padend(6, \"0\")}`;\n\nrandomhex();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 六、浏览器操作\n\n\n# 1. 复制内容到剪切板\n\n该方法使用 navigator.clipboard.writetext 来实现将文本复制到剪贴板：\n\nconst copytoclipboard = (text) => navigator.clipboard.writetext(text);\n\ncopytoclipboard(\"hello world\");\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 清除所有cookie\n\n该方法可以通过使用 document.cookie 来访问 cookie 并清除存储在网页中的所有 cookie：\n\nconst clearcookies = document.cookie.split(';').foreach(cookie => document.cookie = cookie.replace(/^ +/, '').replace(/=.*/, `=;expires=${new date(0).toutcstring()};path=/`));\n复制代码\n\n\n1\n2\n\n\n\n# 3. 获取选中的文本\n\n该方法通过内置的 getselection 属性获取用户选择的文本：\n\nconst getselectedtext = () => window.getselection().tostring();\n\ngetselectedtext();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 4. 检测是否是黑暗模式\n\n该方法用于检测当前的环境是否是黑暗模式，它是一个布尔值：\n\nconst isdarkmode = window.matchmedia && window.matchmedia('(prefers-color-scheme: dark)').matches\n\nconsole.log(isdarkmode)\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 5. 滚动到页面顶部\n\n该方法用于在页面中返回顶部：\n\nconst gototop = () => window.scrollto(0, 0);\n\ngototop();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 6. 判断当前标签页是否激活\n\n该方法用于检测当前标签页是否已经激活：\n\nconst istabinview = () => !document.hidden;\n复制代码\n\n\n1\n2\n\n\n\n# 7. 判断当前是否是苹果设备\n\n该方法用于检测当前的设备是否是苹果的设备：\n\nconst isappledevice = () => /mac|ipod|iphone|ipad/.test(navigator.platform);\n\nisappledevice();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 8. 是否滚动到页面底部\n\n该方法用于判断页面是否已经底部：\n\nconst scrolledtobottom = () => document.documentelement.clientheight + window.scrolly >= document.documentelement.scrollheight;\n复制代码\n\n\n1\n2\n\n\n\n# 9. 重定向到一个url\n\n该方法用于重定向到一个新的url：\n\nconst redirect = url => location.href = url\n\nredirect(\"https://www.google.com/\")\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 10. 打开浏览器打印框\n\n该方法用于打开浏览器的打印框：\n\nconst showprintdialog = () => window.print()\n复制代码\n\n\n1\n2\n\n\n\n# 七、其他操作\n\n\n# 1. 随机布尔值\n\n该方法可以返回一个随机的布尔值，使用math.random()可以获得0-1的随机数，与0.5进行比较，就有一半的概率获得真值或者假值。\n\nconst randomboolean = () => math.random() >= 0.5;\n\nrandomboolean();\n复制代码\n\n\n1\n2\n3\n4\n\n\n\n# 2. 变量交换\n\n可以使用以下形式在不适用第三个变量的情况下，交换两个变量的值：\n\n[foo, bar] = [bar, foo];\n复制代码\n\n\n1\n2\n\n\n\n# 3. 获取变量的类型\n\n该方法用于获取一个变量的类型：\n\nconst truetypeof = (obj) => object.prototype.tostring.call(obj).slice(8, -1).tolowercase();\n\ntruetypeof('');     // string\ntruetypeof(0);      // number\ntruetypeof();       // undefined\ntruetypeof(null);   // null\ntruetypeof({});     // object\ntruetypeof([]);     // array\ntruetypeof(0);      // number\ntruetypeof(() => {});  // function\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 4. 华氏度和摄氏度之间的转化\n\n该方法用于摄氏度和华氏度之间的转化：\n\nconst celsiustofahrenheit = (celsius) => celsius * 9/5 + 32;\nconst fahrenheittocelsius = (fahrenheit) => (fahrenheit - 32) * 5/9;\n\ncelsiustofahrenheit(15);    // 59\ncelsiustofahrenheit(0);     // 32\ncelsiustofahrenheit(-20);   // -4\nfahrenheittocelsius(59);    // 15\nfahrenheittocelsius(32);    // 0\n复制代码\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 5. 检测对象是否为空\n\n该方法用于检测一个javascript对象是否为空：\n\nconst isempty = obj => reflect.ownkeys(obj).length === 0 && obj.constructor === object;\n复制代码\n\n\n1\n2\n\n\n> 作者：cuggz 链接：https://juejin.cn/post/7025771605422768159",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"new命令原理",frontmatter:{title:"new命令原理",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/8143cc480faf9a11",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/02.new%E5%91%BD%E4%BB%A4%E5%8E%9F%E7%90%86.html",relativePath:"01.前端/25.JavaScript文章/02.new命令原理.md",key:"v-e13358fa",path:"/pages/8143cc480faf9a11/",excerpt:'<h1 id="new命令原理"><a class="header-anchor" href="#new命令原理">#</a> new命令原理</h1>\n<p>使用new命令时，它后面的函数依次执行下面的步骤：</p>\n<ol>\n<li>创建一个空对象，作为将要返回的实例对象。</li>\n<li>将这个空对象的原型，指向构造函数的prototype属性。</li>\n<li>将这个空对象赋值给函数内部的this关键字。</li>\n<li>开始执行构造函数内部的代码。</li>\n<li>如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。</li>\n</ol>\n',headersStr:null,content:"# new命令原理\n\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n 1. 创建一个空对象，作为将要返回的实例对象。\n 2. 将这个空对象的原型，指向构造函数的prototype属性。\n 3. 将这个空对象赋值给函数内部的this关键字。\n 4. 开始执行构造函数内部的代码。\n 5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n\n// 构造函数\nfunction Person(name,age){\n    this.name = name\n    this.age = age\n}\n\n// 自定义_new\nfunction _new() {\n  // 将 arguments 对象转为数组\n  var args = [].slice.call(arguments);\n  // 取出构造函数\n  var constructor = args.shift();\n  // 创建一个空对象，继承构造函数的 prototype 属性\n  var context = Object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, args);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n}\n\n// 自定义_new2\nfunction _new2(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {\n  // 创建一个空对象，并继承构造函数的 prototype 属性\n  var context = Object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, params);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n  // （当用户在构造函数内部自定义返回对象的话则使用该对象，否则返回context）\n}\n\n\n// 通过自定义_new 返回实例\nvar actor = _new(Person, '张三', 28);\nconsole.log(actor.name) // 张三\n\n// 通过自定义_new2 返回实例\nvar actor2 = _new2(Person, ['李四', 29]);\nconsole.log(actor2.name) // 李四\n\n// 通过new命令 返回实例\nvar actor3 = new Person('王五',30)\nconsole.log(actor3.name) // 王五\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n",normalizedContent:"# new命令原理\n\n使用new命令时，它后面的函数依次执行下面的步骤：\n\n 1. 创建一个空对象，作为将要返回的实例对象。\n 2. 将这个空对象的原型，指向构造函数的prototype属性。\n 3. 将这个空对象赋值给函数内部的this关键字。\n 4. 开始执行构造函数内部的代码。\n 5. 如果构造函数内有返回值且为对象类型，则返回该对象，否则返回上面创建的实例对象。\n\n// 构造函数\nfunction person(name,age){\n    this.name = name\n    this.age = age\n}\n\n// 自定义_new\nfunction _new() {\n  // 将 arguments 对象转为数组\n  var args = [].slice.call(arguments);\n  // 取出构造函数\n  var constructor = args.shift();\n  // 创建一个空对象，继承构造函数的 prototype 属性\n  var context = object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, args);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n}\n\n// 自定义_new2\nfunction _new2(/* 构造函数 */ constructor, /* 构造函数参数 */ params) {\n  // 创建一个空对象，并继承构造函数的 prototype 属性\n  var context = object.create(constructor.prototype);\n  // 执行构造函数，并将context对象赋值给函数内部的this\n  var result = constructor.apply(context, params);\n  // 如果返回结果是对象，就直接返回，否则返回 context 对象\n  return (typeof result === 'object' && result != null) ? result : context;\n  // （当用户在构造函数内部自定义返回对象的话则使用该对象，否则返回context）\n}\n\n\n// 通过自定义_new 返回实例\nvar actor = _new(person, '张三', 28);\nconsole.log(actor.name) // 张三\n\n// 通过自定义_new2 返回实例\nvar actor2 = _new2(person, ['李四', 29]);\nconsole.log(actor2.name) // 李四\n\n// 通过new命令 返回实例\nvar actor3 = new person('王五',30)\nconsole.log(actor3.name) // 王五\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"ES5面向对象",frontmatter:{title:"ES5面向对象",date:"2020-02-22T10:35:43.000Z",permalink:"/pages/b1af5cb8996363c5",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/03.ES5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"01.前端/25.JavaScript文章/03.ES5面向对象.md",key:"v-1f47639c",path:"/pages/b1af5cb8996363c5/",headersStr:null,content:"# ES5面向对象\n\n//面向对象封装\nfunction Student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\n  this.name = props.name || '匿名';  // 默认‘匿名’\n  this.grade = props.grade || 1;\n}\nStudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\n}\n\n\n//使用\nfunction createStudent(props) { // 对于new构造函数的封装，其优点：一是不需要new来调用，二是参数灵活\n    return new Student(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nvar niming = createStudent(); \nniming.hello();\n\nvar xiaoming = createStudent({\n  name:'小明',\n  grade:2\n});\nxiaoming.hello();\n\n\n//继承\nfunction inherits(Child, Parent) { // 继承的封装方法 inherits(子类, 父类) \n    var F = function () {}; // 定义空方法F\n    F.prototype = Parent.prototype; //F原型指向父类原型\n    Child.prototype = new F(); // 子类原型指向 new F() 方法\n    Child.prototype.constructor = Child; // 修正子类原型上的构造函数为子类本身函数\n}\n\nfunction PrimaryStudent(props) { //定义子类 构造函数\n    Student.call(this, props); // 修正this指向\n    this.age = props.age || 8; //新增子类属性\n}\n\ninherits(PrimaryStudent, Student);//调用继承封装方法实现继承\n\nPrimaryStudent.prototype.getAge = function(){ //对子类添加方法\n  console.log(this.name +'同学，你今年'+ this.age +'岁');\n}\n\n\n//使用继承后的\nfunction createPrimaryStudent(props) { // 对于new构造函数的封装，其优点：一是不需要再new来调用，二是参数灵活\n    return new PrimaryStudent(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nvar xiaohong = createPrimaryStudent({\n  name:'小红',\n  grade:3,\n  age:10\n});\nxiaohong.hello();\nxiaohong.getAge();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n",normalizedContent:"# es5面向对象\n\n//面向对象封装\nfunction student(props){ // 构造函数 （构造函数内定于属性。尊从首字母大写的约定）\n  this.name = props.name || '匿名';  // 默认‘匿名’\n  this.grade = props.grade || 1;\n}\nstudent.prototype.hello = function(){ // 在构造函数的原型上定义方法\n  console.log('你好,'+ this.name +'同学，你在'+ this.grade+'年级');\n}\n\n\n//使用\nfunction createstudent(props) { // 对于new构造函数的封装，其优点：一是不需要new来调用，二是参数灵活\n    return new student(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nvar niming = createstudent(); \nniming.hello();\n\nvar xiaoming = createstudent({\n  name:'小明',\n  grade:2\n});\nxiaoming.hello();\n\n\n//继承\nfunction inherits(child, parent) { // 继承的封装方法 inherits(子类, 父类) \n    var f = function () {}; // 定义空方法f\n    f.prototype = parent.prototype; //f原型指向父类原型\n    child.prototype = new f(); // 子类原型指向 new f() 方法\n    child.prototype.constructor = child; // 修正子类原型上的构造函数为子类本身函数\n}\n\nfunction primarystudent(props) { //定义子类 构造函数\n    student.call(this, props); // 修正this指向\n    this.age = props.age || 8; //新增子类属性\n}\n\ninherits(primarystudent, student);//调用继承封装方法实现继承\n\nprimarystudent.prototype.getage = function(){ //对子类添加方法\n  console.log(this.name +'同学，你今年'+ this.age +'岁');\n}\n\n\n//使用继承后的\nfunction createprimarystudent(props) { // 对于new构造函数的封装，其优点：一是不需要再new来调用，二是参数灵活\n    return new primarystudent(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nvar xiaohong = createprimarystudent({\n  name:'小红',\n  grade:3,\n  age:10\n});\nxiaohong.hello();\nxiaohong.getage();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"ES6面向对象",frontmatter:{title:"ES6面向对象",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/1f4123be6f45abcd",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/04.ES6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"01.前端/25.JavaScript文章/04.ES6面向对象.md",key:"v-a54556a4",path:"/pages/1f4123be6f45abcd/",headersStr:null,content:"# ES6面向对象\n\n//面向对象封装\nclass Student{ //定义类 (尊从首字母大写的约定)\n    constructor(props){  // 构造函数 （构造函数内定于属性）\n        this.name = props.name || '匿名'; // 默认'匿名'\n      this.grade = props.grade || 1;\n    }\n    hello(){ // 在构造函数的原型上定义方法\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\n    }\n}\n\n\n\n//使用\nfunction createStudent(props) { // 对于new构造函数的封装，其优点：一是不需要new来调用，二是参数灵活\n    return new Student(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nlet niming = createStudent(); \nniming.hello();\n\nlet xiaoming = createStudent({\n  name:'小明',\n  grade:2\n});\nxiaoming.hello();\n\n\n\n//继承\nclass PrimaryStudent extends Student { //class 子类 extends 父类\n    constructor(props) {\n        super(props); // 用super调用父类的构造方法实现属性继承\n        this.age = props.age || 8; //新增子类属性\n    }\n\n    getAge() { //对子类添加方法\n        console.log(`${this.name}同学，你今年${this.age}岁`);\n    }\n}\n\n\n//使用继承后的\nfunction createPrimaryStudent(props) { // 对于new构造函数的封装，其优点：一是不需要再new来调用，二是参数灵活\n    return new PrimaryStudent(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nlet xiaohong = createPrimaryStudent({\n  name:'小红',\n  grade:3,\n  age:10\n});\nxiaohong.hello();\nxiaohong.getAge();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n",normalizedContent:"# es6面向对象\n\n//面向对象封装\nclass student{ //定义类 (尊从首字母大写的约定)\n    constructor(props){  // 构造函数 （构造函数内定于属性）\n        this.name = props.name || '匿名'; // 默认'匿名'\n      this.grade = props.grade || 1;\n    }\n    hello(){ // 在构造函数的原型上定义方法\n        console.log(`你好,${this.name}同学，你在${this.grade}年级`);\n    }\n}\n\n\n\n//使用\nfunction createstudent(props) { // 对于new构造函数的封装，其优点：一是不需要new来调用，二是参数灵活\n    return new student(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nlet niming = createstudent(); \nniming.hello();\n\nlet xiaoming = createstudent({\n  name:'小明',\n  grade:2\n});\nxiaoming.hello();\n\n\n\n//继承\nclass primarystudent extends student { //class 子类 extends 父类\n    constructor(props) {\n        super(props); // 用super调用父类的构造方法实现属性继承\n        this.age = props.age || 8; //新增子类属性\n    }\n\n    getage() { //对子类添加方法\n        console.log(`${this.name}同学，你今年${this.age}岁`);\n    }\n}\n\n\n//使用继承后的\nfunction createprimarystudent(props) { // 对于new构造函数的封装，其优点：一是不需要再new来调用，二是参数灵活\n    return new primarystudent(props || {}) // 通过new创建构造函数，并传入参数/属性\n}\n\nlet xiaohong = createprimarystudent({\n  name:'小红',\n  grade:3,\n  age:10\n});\nxiaohong.hello();\nxiaohong.getage();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"多种数组去重性能对比",frontmatter:{title:"多种数组去重性能对比",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/e808fba1fa8fbab2",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/06.%E5%A4%9A%E7%A7%8D%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94.html",relativePath:"01.前端/25.JavaScript文章/06.多种数组去重性能对比.md",key:"v-119caaee",path:"/pages/e808fba1fa8fbab2/",headers:[{level:2,title:"测试模板",slug:"测试模板",normalizedTitle:"测试模板",charIndex:17},{level:2,title:"测试代码",slug:"测试代码",normalizedTitle:"测试代码",charIndex:539},{level:2,title:"结论",slug:"结论",normalizedTitle:"结论",charIndex:2281}],headersStr:"测试模板 测试代码 结论",content:"# 多种数组去重性能对比\n\n\n# 测试模板\n\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\nlet arr1 = Array.from(new Array(1000000), (x, index) => { \n  return index\n})\n\nlet arr2 = Array.from(new Array(500000), (x, index) => {\n  return index + index\n})\n\nlet start = new Date().getTime()\nconsole.log('开始数组去重')\n\n// 数组去重\nfunction distinct(a, b) {\n  let arr = a.concat(b);\n  // 去重方法\n}\n\n\n\nconsole.log('去重后的长度', distinct(arr1, arr2).length)\nlet end = new Date().getTime()\nconsole.log('耗时', end - start + 'ms')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 测试代码\n\n// 创建一个 1 ~ 10w 的数组，Array.from为ES6语法\nlet arr1 = Array.from(new Array(1000000), (x, index) => { \n  return index\n})\n\nlet arr2 = Array.from(new Array(500000), (x, index) => {\n  return index + index\n})\n\nlet start = new Date().getTime()\nconsole.log('开始数组去重')\n\n// 数组去重\nfunction distinct(a, b) {\n  let arr = a.concat(b);\n  \n  // 方法1，耗时约11675ms，约11s\n  // return arr.filter((item, index) => {\n  //   return arr.indexOf(item) === index\n  // })\n\n  // 方法2，耗时约22851ms，约22s，性能最差\n  // for (let i = 0, len = arr.length; i < len; i++) {\n  //   for (let j = i + 1; j < len; j++) {\n  //     if (arr[i] == arr[j]) {\n  //       arr.splice(j, 1);\n  //       // splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一\n  //       len--;\n  //       j--;\n  //     }\n  //   }\n  // }\n  // return arr\n\n  //方法3，耗时约12789ms，约12s，和方法1相当\n  // let result = []\n  // for (let i of arr) {\n  //   !result.includes(i) && result.push(i)\n  // }\n  // return result\n\n  //方法4，耗时约23ms，ES5标准中性能最高\n  // arr = arr.sort()\n  // let result = [arr[0]]\n  // for (let i = 1, len = arr.length; i < len; i++) {\n  //   arr[i] !== arr[i - 1] && result.push(arr[i])\n  // }\n  // return result\n\n  // 方法5，ES6的Set数据结构，耗时约20ms，性能高，代码简洁\n  // return Array.from(new Set([...a, ...b]))\n\n  // 方法6，耗时约16ms，所有方法中 性能最高！ (千万级数据量下效率比方法5高4倍，for...of 为ES6语法)\n  let result = []\n  let obj = {}\n  for (let i of arr) {\n    if (!obj[i]) {\n      result.push(i)\n      obj[i] = 1\n    }\n  }\n  return result\n\n}\n\n\n\nconsole.log('去重后的长度', distinct(arr1, arr2).length)\nlet end = new Date().getTime()\nconsole.log('耗时', end - start + 'ms')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 结论\n\nES5标准中性能最高的数组去重方法为:\n\n// 耗时约23ms\narr = arr.sort()\nlet result = [arr[0]]\nfor (let i = 1, len = arr.length; i < len; i++) {\n    arr[i] !== arr[i - 1] && result.push(arr[i])\n}\nreturn result\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nES6标准中性能最高的数组去重方法为:\n\n// 耗时约16ms (千万级数据量下效率比使用Set数据结构方法高4倍，for...of 为ES6语法)\nlet result = []\nlet obj = {}\nfor (let i of arr) {\n    if (!obj[i]) {\n        result.push(i)\n        obj[i] = 1\n    }\n}\nreturn result\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n代码既简洁性能又相对高的去重方法为：\n\n// 耗时约20ms，性能高，代码简洁\nreturn Array.from(new Set([...a, ...b]))\n\n\n1\n2\n",normalizedContent:"# 多种数组去重性能对比\n\n\n# 测试模板\n\n// 创建一个 1 ~ 10w 的数组，array.from为es6语法\nlet arr1 = array.from(new array(1000000), (x, index) => { \n  return index\n})\n\nlet arr2 = array.from(new array(500000), (x, index) => {\n  return index + index\n})\n\nlet start = new date().gettime()\nconsole.log('开始数组去重')\n\n// 数组去重\nfunction distinct(a, b) {\n  let arr = a.concat(b);\n  // 去重方法\n}\n\n\n\nconsole.log('去重后的长度', distinct(arr1, arr2).length)\nlet end = new date().gettime()\nconsole.log('耗时', end - start + 'ms')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 测试代码\n\n// 创建一个 1 ~ 10w 的数组，array.from为es6语法\nlet arr1 = array.from(new array(1000000), (x, index) => { \n  return index\n})\n\nlet arr2 = array.from(new array(500000), (x, index) => {\n  return index + index\n})\n\nlet start = new date().gettime()\nconsole.log('开始数组去重')\n\n// 数组去重\nfunction distinct(a, b) {\n  let arr = a.concat(b);\n  \n  // 方法1，耗时约11675ms，约11s\n  // return arr.filter((item, index) => {\n  //   return arr.indexof(item) === index\n  // })\n\n  // 方法2，耗时约22851ms，约22s，性能最差\n  // for (let i = 0, len = arr.length; i < len; i++) {\n  //   for (let j = i + 1; j < len; j++) {\n  //     if (arr[i] == arr[j]) {\n  //       arr.splice(j, 1);\n  //       // splice 会改变数组长度，所以要将数组长度 len 和下标 j 减一\n  //       len--;\n  //       j--;\n  //     }\n  //   }\n  // }\n  // return arr\n\n  //方法3，耗时约12789ms，约12s，和方法1相当\n  // let result = []\n  // for (let i of arr) {\n  //   !result.includes(i) && result.push(i)\n  // }\n  // return result\n\n  //方法4，耗时约23ms，es5标准中性能最高\n  // arr = arr.sort()\n  // let result = [arr[0]]\n  // for (let i = 1, len = arr.length; i < len; i++) {\n  //   arr[i] !== arr[i - 1] && result.push(arr[i])\n  // }\n  // return result\n\n  // 方法5，es6的set数据结构，耗时约20ms，性能高，代码简洁\n  // return array.from(new set([...a, ...b]))\n\n  // 方法6，耗时约16ms，所有方法中 性能最高！ (千万级数据量下效率比方法5高4倍，for...of 为es6语法)\n  let result = []\n  let obj = {}\n  for (let i of arr) {\n    if (!obj[i]) {\n      result.push(i)\n      obj[i] = 1\n    }\n  }\n  return result\n\n}\n\n\n\nconsole.log('去重后的长度', distinct(arr1, arr2).length)\nlet end = new date().gettime()\nconsole.log('耗时', end - start + 'ms')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n\n# 结论\n\nes5标准中性能最高的数组去重方法为:\n\n// 耗时约23ms\narr = arr.sort()\nlet result = [arr[0]]\nfor (let i = 1, len = arr.length; i < len; i++) {\n    arr[i] !== arr[i - 1] && result.push(arr[i])\n}\nreturn result\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nes6标准中性能最高的数组去重方法为:\n\n// 耗时约16ms (千万级数据量下效率比使用set数据结构方法高4倍，for...of 为es6语法)\nlet result = []\nlet obj = {}\nfor (let i of arr) {\n    if (!obj[i]) {\n        result.push(i)\n        obj[i] = 1\n    }\n}\nreturn result\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n代码既简洁性能又相对高的去重方法为：\n\n// 耗时约20ms，性能高，代码简洁\nreturn array.from(new set([...a, ...b]))\n\n\n1\n2\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"比typeof运算符更准确的类型判断",frontmatter:{title:"比typeof运算符更准确的类型判断",date:"2020-04-13T15:56:54.000Z",permalink:"/pages/fd4a16d56b83c1bc",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/100.%E6%AF%94typeof%E8%BF%90%E7%AE%97%E7%AC%A6%E6%9B%B4%E5%87%86%E7%A1%AE%E7%9A%84%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD.html",relativePath:"01.前端/25.JavaScript文章/100.比typeof运算符更准确的类型判断.md",key:"v-2eddfdda",path:"/pages/fd4a16d56b83c1bc/",headersStr:null,content:'# 比typeof运算符更准确的类型判断\n\n不同数据类型的Object.prototype.toString方法返回值如下。\n\n * 数值：返回[object Number]。\n * 字符串：返回[object String]。\n * 布尔值：返回[object Boolean]。\n * undefined：返回[object Undefined]。\n * null：返回[object Null]。\n * 数组：返回[object Array]。\n * arguments 对象：返回[object Arguments]。\n * 函数：返回[object Function]。\n * Error 对象：返回[object Error]。\n * Date 对象：返回[object Date]。\n * RegExp 对象：返回[object RegExp]。\n * 其他对象：返回[object Object]。\n\n这就是说，Object.prototype.toString可以看出一个值到底是什么类型。\n\nObject.prototype.toString.call(2) // "[object Number]"\nObject.prototype.toString.call(\'\') // "[object String]"\nObject.prototype.toString.call(true) // "[object Boolean]"\nObject.prototype.toString.call(undefined) // "[object Undefined]"\nObject.prototype.toString.call(null) // "[object Null]"\nObject.prototype.toString.call(Math) // "[object Math]"\nObject.prototype.toString.call({}) // "[object Object]"\nObject.prototype.toString.call([]) // "[object Array]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。\n\nvar type = function (o){\n    var s = Object.prototype.toString.call(o)\n    return s.match(/\\[object (.*?)\\]/)[1].toLowerCase()\n}\ntype({}); // "object"\ntype([]); // "array"\ntype(5); // "number"\ntype(null); // "null"\ntype(); // "undefined"\ntype(/abcd/); // "regex"\ntype(new Date()); // "date"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。\n\nvar type = function (o){\n  var s = Object.prototype.toString.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].toLowerCase();\n};\n\n[\'Null\',\n \'Undefined\',\n \'Object\',\n \'Array\',\n \'String\',\n \'Number\',\n \'Boolean\',\n \'Function\',\n \'RegExp\'\n].forEach(function (t) {\n  type[\'is\' + t] = function (o) {\n    return type(o) === t.toLowerCase();\n  };\n});\n\ntype.isObject({}) // true\ntype.isNumber(NaN) // true\ntype.isRegExp(/abc/) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n',normalizedContent:'# 比typeof运算符更准确的类型判断\n\n不同数据类型的object.prototype.tostring方法返回值如下。\n\n * 数值：返回[object number]。\n * 字符串：返回[object string]。\n * 布尔值：返回[object boolean]。\n * undefined：返回[object undefined]。\n * null：返回[object null]。\n * 数组：返回[object array]。\n * arguments 对象：返回[object arguments]。\n * 函数：返回[object function]。\n * error 对象：返回[object error]。\n * date 对象：返回[object date]。\n * regexp 对象：返回[object regexp]。\n * 其他对象：返回[object object]。\n\n这就是说，object.prototype.tostring可以看出一个值到底是什么类型。\n\nobject.prototype.tostring.call(2) // "[object number]"\nobject.prototype.tostring.call(\'\') // "[object string]"\nobject.prototype.tostring.call(true) // "[object boolean]"\nobject.prototype.tostring.call(undefined) // "[object undefined]"\nobject.prototype.tostring.call(null) // "[object null]"\nobject.prototype.tostring.call(math) // "[object math]"\nobject.prototype.tostring.call({}) // "[object object]"\nobject.prototype.tostring.call([]) // "[object array]"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n利用这个特性，可以写出一个比typeof运算符更准确的类型判断函数。\n\nvar type = function (o){\n    var s = object.prototype.tostring.call(o)\n    return s.match(/\\[object (.*?)\\]/)[1].tolowercase()\n}\ntype({}); // "object"\ntype([]); // "array"\ntype(5); // "number"\ntype(null); // "null"\ntype(); // "undefined"\ntype(/abcd/); // "regex"\ntype(new date()); // "date"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n在上面这个type函数的基础上，还可以加上专门判断某种类型数据的方法。\n\nvar type = function (o){\n  var s = object.prototype.tostring.call(o);\n  return s.match(/\\[object (.*?)\\]/)[1].tolowercase();\n};\n\n[\'null\',\n \'undefined\',\n \'object\',\n \'array\',\n \'string\',\n \'number\',\n \'boolean\',\n \'function\',\n \'regexp\'\n].foreach(function (t) {\n  type[\'is\' + t] = function (o) {\n    return type(o) === t.tolowercase();\n  };\n});\n\ntype.isobject({}) // true\ntype.isnumber(nan) // true\ntype.isregexp(/abc/) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"四级文件(测试)",frontmatter:{title:"四级文件(测试)",date:"2020-12-11T11:15:53.000Z",permalink:"/pages/8481d1/",categories:["前端","JavaScript文章","三级目录"],tags:[null]},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/1110.%E4%B8%89%E7%BA%A7%E7%9B%AE%E5%BD%95/00.%E5%9B%9B%E7%BA%A7%E6%96%87%E4%BB%B6.html",relativePath:"01.前端/25.JavaScript文章/1110.三级目录/00.四级文件.md",key:"v-21d8afeb",path:"/pages/8481d1/",headers:[{level:2,title:"测试文件",slug:"测试文件",normalizedTitle:"测试文件",charIndex:2}],headersStr:"测试文件",content:"# 测试文件\n\nTest Test\n\nyarn create vuepress-site [optionalDirectoryName]\n# OR npx create-vuepress-site [optionalDirectoryName]\n\n\n1\n2\n\n\nnpx create-vuepress-site [optionalDirectoryName]\n\n\n1\n",normalizedContent:"# 测试文件\n\ntest test\n\nyarn create vuepress-site [optionaldirectoryname]\n# or npx create-vuepress-site [optionaldirectoryname]\n\n\n1\n2\n\n\nnpx create-vuepress-site [optionaldirectoryname]\n\n\n1\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"JS随机打乱数组",frontmatter:{title:"JS随机打乱数组",date:"2020-02-08T17:42:03.000Z",permalink:"/pages/40b4db2d38ba85f2",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/50.js%E9%9A%8F%E6%9C%BA%E6%89%93%E4%B9%B1%E6%95%B0%E7%BB%84.html",relativePath:"01.前端/25.JavaScript文章/50.js随机打乱数组.md",key:"v-370bb2c9",path:"/pages/40b4db2d38ba85f2/",headersStr:null,content:"# JS随机打乱数组\n\nfunction shuffle(arr) { // 随机打乱数组\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\n  for (let i = 0; i < _arr.length; i++) {\n    let j = getRandomInt(0, i)\n    let t = _arr[i]\n    _arr[i] = _arr[j]\n    _arr[j] = t\n  }\n  return _arr\n}\nfunction getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n<html>\n  原数组：<span id=\"span1\"></span>\n  <button id=\"btn\">click me！打乱数组</button> </br></br>\n  打乱结果：<span id=\"span2\"></span>\n</html>\n<script>\n    function getRandomInt(min, max) { // 获取min到max的一个随机数，包含min和max本身\n      return Math.floor(Math.random() * (max - min + 1) + min)\n    }\n\n    function shuffle(arr) { // 随机打乱数组\n      let _arr = arr.slice() // 调用数组副本，不改变原数组\n      for (let i = 0; i < _arr.length; i++) {\n        let j = getRandomInt(0, i)\n        let t = _arr[i]\n        _arr[i] = _arr[j]\n        _arr[j] = t\n      }\n      return _arr\n    }\n\n    //使用\n    function $(el){\n      return document.querySelector(el)\n    }\n    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const $span2 = $('#span2');\n\n    $('#span1').textContent = arr;\n    $('#btn').onclick = function () {\n      $span2.textContent = shuffle(arr);\n    }\n  <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n",normalizedContent:"# js随机打乱数组\n\nfunction shuffle(arr) { // 随机打乱数组\n  let _arr = arr.slice() // 调用数组副本，不改变原数组\n  for (let i = 0; i < _arr.length; i++) {\n    let j = getrandomint(0, i)\n    let t = _arr[i]\n    _arr[i] = _arr[j]\n    _arr[j] = t\n  }\n  return _arr\n}\nfunction getrandomint(min, max) { // 获取min到max的一个随机数，包含min和max本身\n  return math.floor(math.random() * (max - min + 1) + min)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n<html>\n  原数组：<span id=\"span1\"></span>\n  <button id=\"btn\">click me！打乱数组</button> </br></br>\n  打乱结果：<span id=\"span2\"></span>\n</html>\n<script>\n    function getrandomint(min, max) { // 获取min到max的一个随机数，包含min和max本身\n      return math.floor(math.random() * (max - min + 1) + min)\n    }\n\n    function shuffle(arr) { // 随机打乱数组\n      let _arr = arr.slice() // 调用数组副本，不改变原数组\n      for (let i = 0; i < _arr.length; i++) {\n        let j = getrandomint(0, i)\n        let t = _arr[i]\n        _arr[i] = _arr[j]\n        _arr[j] = t\n      }\n      return _arr\n    }\n\n    //使用\n    function $(el){\n      return document.queryselector(el)\n    }\n    let arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];\n    const $span2 = $('#span2');\n\n    $('#span1').textcontent = arr;\n    $('#btn').onclick = function () {\n      $span2.textcontent = shuffle(arr);\n    }\n  <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"判断是否为移动端浏览器",frontmatter:{title:"判断是否为移动端浏览器",date:"2020-01-04T15:25:11.000Z",permalink:"/pages/40f623be692cf8bc",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/60.%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%B5%8F%E8%A7%88%E5%99%A8.html",relativePath:"01.前端/25.JavaScript文章/60.判断是否为移动端浏览器.md",key:"v-76af4c12",path:"/pages/40f623be692cf8bc/",headersStr:null,content:"# 判断是否为移动端浏览器\n\nconst flag = navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i);\nif(flag){\n    // 移动端\n} else {\n    // PC端\n}\n\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"# 判断是否为移动端浏览器\n\nconst flag = navigator.useragent.match(/(phone|pad|pod|iphone|ipod|ios|ipad|android|mobile|blackberry|iemobile|mqqbrowser|juc|fennec|wosbrowser|browserng|webos|symbian|windows phone)/i);\nif(flag){\n    // 移动端\n} else {\n    // pc端\n}\n\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"将一维数组按指定长度转为二维数组",frontmatter:{title:"将一维数组按指定长度转为二维数组",date:"2020-02-23T13:49:31.000Z",permalink:"/pages/f1acb712033ac8da",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/70.%E5%B0%86%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E6%8C%89%E6%8C%87%E5%AE%9A%E9%95%BF%E5%BA%A6%E8%BD%AC%E4%B8%BA%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.html",relativePath:"01.前端/25.JavaScript文章/70.将一维数组按指定长度转为二维数组.md",key:"v-59ea62a4",path:"/pages/f1acb712033ac8da/",headers:[{level:2,title:"应用场景示例",slug:"应用场景示例",normalizedTitle:"应用场景示例",charIndex:509}],headersStr:"应用场景示例",content:'# 将一维数组按指定长度转为二维数组\n\n将一维数组按指定长度转为二维数组\n\nfunction pages(arr, len) {\n    const pages = []\n    arr.forEach((item, index) => {\n        const page = Math.floor(index / len)\n        if (!pages[page]) {\n            pages[page] = []\n        }\n        pages[page].push(item)\n    })\n    return pages\n}\n\n// 使用\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(pages(arr, 3)) // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nconsole.log(pages(arr, 8)) // [[1, 2, 3, 4, 5, 6, 7, 8], [9]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 应用场景示例\n\n如图，按需求，图标模块中的图标个数是不确定的，每页最多显示8个，超出8个的显示到第二页，实现向左滑动翻页。提供的数据是一个一维数组，这时就可以使用上面的代码按长度为8转为二维数组，再分页渲染到页面。\n\n\n\n<template>\n    <swiper>\n        <swiper-slide v-for="(page, index) of pages" :key="index">\n            <div class="icon" v-for="item of page" :key="item.id">\n                <div class="icon-img">\n                    <img :src="item.imgUrl">\n                </div>\n                <p>{{item.desc}}</p>\n            </div>\n        </swiper-slide>\n    </swiper>\n<template>\n<script>\n  ...\n  data () {\n    return {\n      iconList: [] // 图标数据\n    }\n  },\n  computed: {\n    pages () {\n      const pages = []\n      this.iconList.forEach((item, index) => {\n        const page = Math.floor(index / 8)\n        if (!pages[page]) {\n          pages[page] = []\n        }\n        pages[page].push(item)\n      })\n      return pages\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n',normalizedContent:'# 将一维数组按指定长度转为二维数组\n\n将一维数组按指定长度转为二维数组\n\nfunction pages(arr, len) {\n    const pages = []\n    arr.foreach((item, index) => {\n        const page = math.floor(index / len)\n        if (!pages[page]) {\n            pages[page] = []\n        }\n        pages[page].push(item)\n    })\n    return pages\n}\n\n// 使用\nconst arr = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nconsole.log(pages(arr, 3)) // [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nconsole.log(pages(arr, 8)) // [[1, 2, 3, 4, 5, 6, 7, 8], [9]]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 应用场景示例\n\n如图，按需求，图标模块中的图标个数是不确定的，每页最多显示8个，超出8个的显示到第二页，实现向左滑动翻页。提供的数据是一个一维数组，这时就可以使用上面的代码按长度为8转为二维数组，再分页渲染到页面。\n\n\n\n<template>\n    <swiper>\n        <swiper-slide v-for="(page, index) of pages" :key="index">\n            <div class="icon" v-for="item of page" :key="item.id">\n                <div class="icon-img">\n                    <img :src="item.imgurl">\n                </div>\n                <p>{{item.desc}}</p>\n            </div>\n        </swiper-slide>\n    </swiper>\n<template>\n<script>\n  ...\n  data () {\n    return {\n      iconlist: [] // 图标数据\n    }\n  },\n  computed: {\n    pages () {\n      const pages = []\n      this.iconlist.foreach((item, index) => {\n        const page = math.floor(index / 8)\n        if (!pages[page]) {\n          pages[page] = []\n        }\n        pages[page].push(item)\n      })\n      return pages\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"防抖与节流函数",frontmatter:{title:"防抖与节流函数",date:"2020-02-29T15:07:47.000Z",permalink:"/pages/0f6a0ac99b62ede5",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/80.%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81%E5%87%BD%E6%95%B0.html",relativePath:"01.前端/25.JavaScript文章/80.防抖与节流函数.md",key:"v-4c0a766c",path:"/pages/0f6a0ac99b62ede5/",headers:[{level:2,title:"防抖函数",slug:"防抖函数",normalizedTitle:"防抖函数",charIndex:55},{level:3,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:180},{level:2,title:"节流函数",slug:"节流函数",normalizedTitle:"节流函数",charIndex:5},{level:3,title:"封装",slug:"封装-2",normalizedTitle:"封装",charIndex:180},{level:2,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:932},{level:3,title:"防抖应用场景",slug:"防抖应用场景",normalizedTitle:"防抖应用场景",charIndex:1033},{level:3,title:"节流的应用场景",slug:"节流的应用场景",normalizedTitle:"节流的应用场景",charIndex:1201},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:1378}],excerpt:'<h1 id="防抖与节流函数"><a class="header-anchor" href="#防抖与节流函数">#</a> 防抖与节流函数</h1>\n<p>防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。</p>\n<p>区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。</p>\n',headersStr:"防抖函数 封装 节流函数 封装 应用场景 防抖应用场景 节流的应用场景 示例",content:"# 防抖与节流函数\n\n防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\n\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\n\n\n# 防抖函数\n\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\n\n\n# 封装\n\n// 防抖函数\nfunction debounce(func, wait) {\n    let timeout = null;\n    return function () {\n        let context = this;\n        let args = arguments;\n        if (timeout) clearTimeout(timeout);\n        timeout = setTimeout(() => {\n            func.apply(context, args)\n        }, wait);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 节流函数\n\n规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效\n\n\n# 封装\n\n// 节流函数\nfunction throttle(func, wait) {\n    let timeout = null;\n    return function () {\n        let context = this;\n        let args = arguments;\n        if (!timeout) {\n            timeout = setTimeout(() => {\n                timeout = null;\n                func.apply(context, args)\n            }, wait)\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 应用场景\n\n常见的应用场景都是使用高频事件来调用函数的过程当中，比如应用于window对象的resize、scroll事件，拖拽时的mousemove事件，文字输入、自动完成的keyup事件。\n\n\n# 防抖应用场景\n\n * scroll事件滚动触发事件\n * 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。\n * 表单验证\n * 按钮提交事件。\n * 浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。\n\n\n# 节流的应用场景\n\n * DOM 元素的拖拽功能实现（mousemove）\n * 搜索联想（keyup）\n * 计算鼠标移动的距离（mousemove）\n * Canvas 模拟画板功能（mousemove）\n * 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）\n * 监听滚动事件判断是否到页面底部自动加载更多\n\n\n# 示例\n\nSee the Pen 防抖与节流函数 by xugaoyi (@xugaoyi) on CodePen.",normalizedContent:"# 防抖与节流函数\n\n防抖和节流的作用都是在高频事件中防止函数被多次调用，是一种性能优化的方案。\n\n区别在于，防抖函数只会在高频事件结束后n毫秒调用一次函数，节流函数会在高频事件触发过程当中每隔n毫秒调用一次函数。\n\n\n# 防抖函数\n\n触发高频事件后一段时间（wait）只会执行一次函数，如果指定时间（wait）内高频事件再次被触发，则重新计算时间。\n\n\n# 封装\n\n// 防抖函数\nfunction debounce(func, wait) {\n    let timeout = null;\n    return function () {\n        let context = this;\n        let args = arguments;\n        if (timeout) cleartimeout(timeout);\n        timeout = settimeout(() => {\n            func.apply(context, args)\n        }, wait);\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 节流函数\n\n规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效\n\n\n# 封装\n\n// 节流函数\nfunction throttle(func, wait) {\n    let timeout = null;\n    return function () {\n        let context = this;\n        let args = arguments;\n        if (!timeout) {\n            timeout = settimeout(() => {\n                timeout = null;\n                func.apply(context, args)\n            }, wait)\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 应用场景\n\n常见的应用场景都是使用高频事件来调用函数的过程当中，比如应用于window对象的resize、scroll事件，拖拽时的mousemove事件，文字输入、自动完成的keyup事件。\n\n\n# 防抖应用场景\n\n * scroll事件滚动触发事件\n * 搜索框输入查询，如果用户一直在输入中，没有必要不停地调用去请求服务端接口，等用户停止输入的时候，再调用，设置一个合适的时间间隔，有效减轻服务端压力。\n * 表单验证\n * 按钮提交事件。\n * 浏览器窗口缩放，resize事件(如窗口停止改变大小之后重新计算布局)等。\n\n\n# 节流的应用场景\n\n * dom 元素的拖拽功能实现（mousemove）\n * 搜索联想（keyup）\n * 计算鼠标移动的距离（mousemove）\n * canvas 模拟画板功能（mousemove）\n * 射击游戏的 mousedown/keydown 事件（单位时间只能发射一颗子弹）\n * 监听滚动事件判断是否到页面底部自动加载更多\n\n\n# 示例\n\nsee the pen 防抖与节流函数 by xugaoyi (@xugaoyi) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"JS获取和修改url参数",frontmatter:{title:"JS获取和修改url参数",date:"2020-03-05T12:45:37.000Z",permalink:"/pages/7a91be2d502346ce",categories:["前端","JavaScript文章"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/25.JavaScript%E6%96%87%E7%AB%A0/90.JS%E8%8E%B7%E5%8F%96%E5%92%8C%E4%BF%AE%E6%94%B9url%E5%8F%82%E6%95%B0.html",relativePath:"01.前端/25.JavaScript文章/90.JS获取和修改url参数.md",key:"v-240078e0",path:"/pages/7a91be2d502346ce/",headers:[{level:2,title:"获取url参数",slug:"获取url参数",normalizedTitle:"获取url参数",charIndex:19},{level:2,title:"修改url参数",slug:"修改url参数",normalizedTitle:"修改url参数",charIndex:7},{level:2,title:"不刷新页面修改url参数",slug:"不刷新页面修改url参数",normalizedTitle:"不刷新页面修改url参数",charIndex:951},{level:2,title:"URL 的编码和解码",slug:"url-的编码和解码",normalizedTitle:"url 的编码和解码",charIndex:1015}],headersStr:"获取url参数 修改url参数 不刷新页面修改url参数 URL 的编码和解码",content:"# JS获取和修改url参数\n\n\n# 获取url参数\n\n/**\n * 获取url里的参数\n * @param arg 参数名\n * @returns\n */\nfunction getURLString(arg) {\n    var reg = new RegExp(\"(^|&)\" + arg + \"=([^&]*)(&|$)\", \"i\");\n    var r = window.location.search.substr(1).match(reg);\n    if (r != null)\n        return unescape(r[2]);\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 修改url参数\n\n/**\n * url地址修改\n * @param url 待修改url\n * @param arg 修改的参数名\n * @param arg_val 修改的具体值\n * @returns {String}\n */\nfunction changeURLArg(url, arg, arg_val) {\n    var pattern = arg + '=([^&]*)';\n    var replaceText = arg + '=' + arg_val;\n    if (url.match(pattern)) {\n        var tmp = '/(' + arg + '=)([^&]*)/gi';\n        tmp = url.replace(eval(tmp), replaceText);\n        return tmp;\n    } else {\n        if (url.match('[\\?]')) {\n            return url + '&' + replaceText;\n        } else {\n            return url + '?' + replaceText;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 不刷新页面修改url参数\n\nhttps://www.cnblogs.com/wuting/p/8946927.html\n\n\n# URL 的编码和解码\n\n比如，UTF-8 的操作系统上，http://www.example.com/q=春节这个 URL 之中，汉字“春节”不是 URL 的合法字符，所以被浏览器自动转成http://www.example.com/q=%E6%98%A5%E8%8A%82。其中，“春”转成了%E6%98%A5，“节”转成了%E8%8A%82。这是因为“春”和“节”的 UTF-8 编码分别是E6 98 A5和E8 8A 82，将每个字节前面加上百分号，就构成了 URL 编码。\n\nJavaScript 提供四个 URL 的编码/解码方法。\n\n * encodeURI()\n * encodeURIComponent()\n * decodeURI()\n * decodeURIComponent()\n\n查看文档",normalizedContent:"# js获取和修改url参数\n\n\n# 获取url参数\n\n/**\n * 获取url里的参数\n * @param arg 参数名\n * @returns\n */\nfunction geturlstring(arg) {\n    var reg = new regexp(\"(^|&)\" + arg + \"=([^&]*)(&|$)\", \"i\");\n    var r = window.location.search.substr(1).match(reg);\n    if (r != null)\n        return unescape(r[2]);\n    return null;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 修改url参数\n\n/**\n * url地址修改\n * @param url 待修改url\n * @param arg 修改的参数名\n * @param arg_val 修改的具体值\n * @returns {string}\n */\nfunction changeurlarg(url, arg, arg_val) {\n    var pattern = arg + '=([^&]*)';\n    var replacetext = arg + '=' + arg_val;\n    if (url.match(pattern)) {\n        var tmp = '/(' + arg + '=)([^&]*)/gi';\n        tmp = url.replace(eval(tmp), replacetext);\n        return tmp;\n    } else {\n        if (url.match('[\\?]')) {\n            return url + '&' + replacetext;\n        } else {\n            return url + '?' + replacetext;\n        }\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 不刷新页面修改url参数\n\nhttps://www.cnblogs.com/wuting/p/8946927.html\n\n\n# url 的编码和解码\n\n比如，utf-8 的操作系统上，http://www.example.com/q=春节这个 url 之中，汉字“春节”不是 url 的合法字符，所以被浏览器自动转成http://www.example.com/q=%e6%98%a5%e8%8a%82。其中，“春”转成了%e6%98%a5，“节”转成了%e8%8a%82。这是因为“春”和“节”的 utf-8 编码分别是e6 98 a5和e8 8a 82，将每个字节前面加上百分号，就构成了 url 编码。\n\njavascript 提供四个 url 的编码/解码方法。\n\n * encodeuri()\n * encodeuricomponent()\n * decodeuri()\n * decodeuricomponent()\n\n查看文档",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"《JavaScript教程》笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《JavaScript教程》笔记",imgUrl:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200112120340.png",description:"本章内容为博主在原教程基础上添加学习笔记，教程版权归原作者所有。来源：<a href='https://wangdoc.com/javascript/' target='_blank'>JavaScript教程</a>"}},title:"《JavaScript教程》笔记",date:"2020-01-12T11:51:53.000Z",permalink:"/note/javascript",article:!1,comment:!1,editLink:!1,author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/00.%E3%80%8AJavaScript%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/40.学习笔记/00.《JavaScript教程》笔记.md",key:"v-056cb10a",path:"/note/javascript/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"《JavaScript高级程序设计》笔记",frontmatter:{title:"《JavaScript高级程序设计》笔记",date:"2020-06-12T12:39:01.000Z",permalink:"/note/js/",categories:["笔记"],tags:["笔记","红宝书"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/05.%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E3%80%8B%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/40.学习笔记/05.《JavaScript高级程序设计》笔记.md",key:"v-79ac4976",path:"/note/js/",headers:[{level:2,title:"第1章  JavaScript简介",slug:"第1章-javascript简介",normalizedTitle:"第1章  javascript简介",charIndex:null},{level:2,title:"第2章 在HTML中使用JavaScript",slug:"第2章-在html中使用javascript",normalizedTitle:"第2章 在html中使用javascript",charIndex:311},{level:2,title:"第3章 基本概念",slug:"第3章-基本概念",normalizedTitle:"第3章 基本概念",charIndex:574},{level:2,title:"第4章 变量、作用域和内存问题",slug:"第4章-变量、作用域和内存问题",normalizedTitle:"第4章 变量、作用域和内存问题",charIndex:3040},{level:2,title:"第5章 引用类型",slug:"第5章-引用类型",normalizedTitle:"第5章 引用类型",charIndex:3754},{level:3,title:"Array类型",slug:"array类型",normalizedTitle:"array类型",charIndex:4026},{level:4,title:"join() 转换方法 (不改原数组)",slug:"join-转换方法-不改原数组",normalizedTitle:"join() 转换方法 (不改原数组)",charIndex:4291},{level:4,title:"栈方法，后进先出 push() 、pop()      (改变原数组)",slug:"栈方法-后进先出-push-、pop-改变原数组",normalizedTitle:"栈方法，后进先出 push() 、pop()      (改变原数组)",charIndex:null},{level:4,title:"队列方法，先进先出  push()、shift()   、unshift() (改变原数组)",slug:"队列方法-先进先出-push-、shift-、unshift-改变原数组",normalizedTitle:"队列方法，先进先出  push()、shift()   、unshift() (改变原数组)",charIndex:null},{level:4,title:"重排序方法 reverse() 反转  sort() 排序   （改变原数组）",slug:"重排序方法-reverse-反转-sort-排序-改变原数组",normalizedTitle:"重排序方法 reverse() 反转  sort() 排序   （改变原数组）",charIndex:null},{level:4,title:"操作方法 concat() 拼接，slice() 切片，splice() 移接",slug:"操作方法-concat-拼接-slice-切片-splice-移接",normalizedTitle:"操作方法 concat() 拼接，slice() 切片，splice() 移接",charIndex:5160},{level:4,title:"位置方法 indexOf()、lastIndexOf()",slug:"位置方法-indexof-、lastindexof",normalizedTitle:"位置方法 indexof()、lastindexof()",charIndex:6007},{level:4,title:"迭代方法 every()、some() 、filter()、map() 、forEach()  （都不会改变原数组）",slug:"迭代方法-every-、some-、filter-、map-、foreach-都不会改变原数组",normalizedTitle:"迭代方法 every()、some() 、filter()、map() 、foreach()  （都不会改变原数组）",charIndex:null},{level:4,title:"归并方法 reduce()  reduceRight()",slug:"归并方法-reduce-reduceright",normalizedTitle:"归并方法 reduce()  reduceright()",charIndex:null},{level:2,title:"第6章 面向对象的程序设计",slug:"第6章-面向对象的程序设计",normalizedTitle:"第6章 面向对象的程序设计",charIndex:7906},{level:3,title:"6.1 理解对象",slug:"_6-1-理解对象",normalizedTitle:"6.1 理解对象",charIndex:7924},{level:4,title:"6.1.1 对象的属性",slug:"_6-1-1-对象的属性",normalizedTitle:"6.1.1 对象的属性",charIndex:7996},{level:5,title:"1.数据属性",slug:"_1-数据属性",normalizedTitle:"1.数据属性",charIndex:8030},{level:5,title:"2.访问器属性",slug:"_2-访问器属性",normalizedTitle:"2.访问器属性",charIndex:8513},{level:4,title:"6.1.2 定义多个属性",slug:"_6-1-2-定义多个属性",normalizedTitle:"6.1.2 定义多个属性",charIndex:9061},{level:4,title:"6.1.3 读取属性的特性（描述符对象）",slug:"_6-1-3-读取属性的特性-描述符对象",normalizedTitle:"6.1.3 读取属性的特性（描述符对象）",charIndex:9716},{level:3,title:"6.2 创建对象",slug:"_6-2-创建对象",normalizedTitle:"6.2 创建对象",charIndex:10654},{level:4,title:"6.2.1 工厂模式",slug:"_6-2-1-工厂模式",normalizedTitle:"6.2.1 工厂模式",charIndex:10738},{level:2,title:"第7章 函数表达式",slug:"第7章-函数表达式",normalizedTitle:"第7章 函数表达式",charIndex:10753},{level:2,title:"第8章 BOM",slug:"第8章-bom",normalizedTitle:"第8章 bom",charIndex:10767},{level:2,title:"第9章 客户端检测",slug:"第9章-客户端检测",normalizedTitle:"第9章 客户端检测",charIndex:10779},{level:2,title:"第10章 DOM",slug:"第10章-dom",normalizedTitle:"第10章 dom",charIndex:10793},{level:2,title:"第11章 DOM扩展",slug:"第11章-dom扩展",normalizedTitle:"第11章 dom扩展",charIndex:10806},{level:2,title:"第12章 DOM2和DOM3",slug:"第12章-dom2和dom3",normalizedTitle:"第12章 dom2和dom3",charIndex:10821},{level:2,title:"第13章 事件",slug:"第13章-事件",normalizedTitle:"第13章 事件",charIndex:10840},{level:2,title:"第14章 表单脚本",slug:"第14章-表单脚本",normalizedTitle:"第14章 表单脚本",charIndex:10852},{level:2,title:"第15章 使用Canvas绘图",slug:"第15章-使用canvas绘图",normalizedTitle:"第15章 使用canvas绘图",charIndex:10866},{level:2,title:"第16章 HTML5脚本编程",slug:"第16章-html5脚本编程",normalizedTitle:"第16章 html5脚本编程",charIndex:10886},{level:2,title:"第17章 错误处理与调试",slug:"第17章-错误处理与调试",normalizedTitle:"第17章 错误处理与调试",charIndex:10905},{level:2,title:"第18章 JavaScript与XML",slug:"第18章-javascript与xml",normalizedTitle:"第18章 javascript与xml",charIndex:10922},{level:2,title:"第19章 E4X",slug:"第19章-e4x",normalizedTitle:"第19章 e4x",charIndex:10946},{level:2,title:"第20章 JSON",slug:"第20章-json",normalizedTitle:"第20章 json",charIndex:10959},{level:2,title:"第21章 Ajax与Comet",slug:"第21章-ajax与comet",normalizedTitle:"第21章 ajax与comet",charIndex:10973},{level:2,title:"第22章 高级技巧",slug:"第22章-高级技巧",normalizedTitle:"第22章 高级技巧",charIndex:10993},{level:2,title:"第23章 离线应用与客户端存储",slug:"第23章-离线应用与客户端存储",normalizedTitle:"第23章 离线应用与客户端存储",charIndex:11007},{level:2,title:"第24章 最佳实践",slug:"第24章-最佳实践",normalizedTitle:"第24章 最佳实践",charIndex:11027},{level:2,title:"第25章 新兴的API",slug:"第25章-新兴的api",normalizedTitle:"第25章 新兴的api",charIndex:11041}],headersStr:"第1章  JavaScript简介 第2章 在HTML中使用JavaScript 第3章 基本概念 第4章 变量、作用域和内存问题 第5章 引用类型 Array类型 join() 转换方法 (不改原数组) 栈方法，后进先出 push() 、pop()      (改变原数组) 队列方法，先进先出  push()、shift()   、unshift() (改变原数组) 重排序方法 reverse() 反转  sort() 排序   （改变原数组） 操作方法 concat() 拼接，slice() 切片，splice() 移接 位置方法 indexOf()、lastIndexOf() 迭代方法 every()、some() 、filter()、map() 、forEach()  （都不会改变原数组） 归并方法 reduce()  reduceRight() 第6章 面向对象的程序设计 6.1 理解对象 6.1.1 对象的属性 1.数据属性 2.访问器属性 6.1.2 定义多个属性 6.1.3 读取属性的特性（描述符对象） 6.2 创建对象 6.2.1 工厂模式 第7章 函数表达式 第8章 BOM 第9章 客户端检测 第10章 DOM 第11章 DOM扩展 第12章 DOM2和DOM3 第13章 事件 第14章 表单脚本 第15章 使用Canvas绘图 第16章 HTML5脚本编程 第17章 错误处理与调试 第18章 JavaScript与XML 第19章 E4X 第20章 JSON 第21章 Ajax与Comet 第22章 高级技巧 第23章 离线应用与客户端存储 第24章 最佳实践 第25章 新兴的API",content:"# 《JavaScript高级程序设计》笔记\n\n\n# 第1章 JavaScript简介\n\n * JavaScript诞生于1995年\n\n * 一个完整的JavaScript由这三部分组成：\n   \n   * ECMAScript (核心)\n   * DOM (文档对象模型)\n   * BOM (浏览器对象模型)\n\n * ECMAScript的 宿主环境 包含 ：\n   \n   * 浏览器\n   * Node\n   * flash\n\n * ECMAScript大致规定了下列组成部分：\n   \n   * 语法\n   * 类型\n   * 语句\n   * 关键字\n   * 保留字\n   * 操作符\n   * 对象\n\n\n# 第2章 在HTML中使用JavaScript\n\n * <script> 标签有下列常见属性：\n   * async 表示立即下载脚本，不妨碍页面的其他操作（异步下载）\n     * 无法保证每个js的顺序\n     * 用于互不依赖的js\n     * 主要目的是不让页面等js\n   * defer 延迟到文档完全解析和显示之后在执行\n     * 在</html>标签之后执行\n   * src 外部文件链接\n   * type 表示编写代码使用的脚本语言的内容类型\n     * text/javascript\n\n\n# 第3章 基本概念\n\n * 语法，借鉴了C语言\n   \n   * 区分大小写\n   * 标识符，指的是变量、函数、属性的名字\n     * 第一个字符必须是 字母、下划线、或美元符号\n     * 其他字符可以是字母、下划线、美元符号或数字\n\n * 严格模式\n   \n   \"use strict\"\n   \n   \n   1\n   \n\n * 数据类型\n   \n   * 基本数据类型\n     * Undefined、Null、Boolean、Number、String\n     * typeof操作符，一般用于基本类型的检测，返回相应类型的字符串\n       * “undefined”,\"boolean\",\"string\",\"number\",\"object\",\"function\"\n   * 复杂数据类型\n     * Object\n\n * Null类型\n   \n   * 表示空对象指针\n   * 只要意在保存对象的变量还没有真正保证对象，则保存null\n   * undefined派生自null，因此用==比较返回true\n\n * 浮点数，指的是数值中包含一个小数点，并且小数点后面至少有一位数字\n\n * NaN\n   \n   * 任何涉及NaN的操作都返回NaN\n   * NaN与任何值都不相等，包括NaN本身\n\n * 数值转换\n   \n   * 有3个函数可以把非数值转换为数值\n     * Number() 可以用于任何数据类型\n     * parseInt() 专门用于字符串转数值，用于解析整数\n     * parseFloat() 专门用于字符串转数值，用于解析浮点数\n\n * 字符串\n   \n   * 数值、布尔值、对象、字符串值本身 都有toString()方法，用于转为字符串\n   * undefined和null没有toString()方法，但可以使用String()方法\n\n * Object类型\n   \n   * 对象其实就是一组数据与功能的集合\n   \n   * 使用Object()构造函数创建对象\n     \n     var obj = new Object(); // 同 obj = {}\n     \n     \n     1\n     \n   \n   * 每个对象实例都有下列属性和方法\n     \n     * constructor 指向用于创建当前对象的构造函数 。（对于上面例子而言，就是Object()）\n     * hasOwnProperty(propertyName) 用于检查给定属性是否在当前对象实例中\n     * isPrototypeOf(Object) 用于检查传入的对象是否是当前对象的原型\n     * propertyIsEnumerable(propertyName) 用于检查给定的属性是否能够使用for-in来枚举\n     * toLocaleString() 返回对象的字符串表示，该字符串与执行环境的地区对应\n     * toString() 返回对象的字符串表示\n     * valueOf() 返回对象的字符串、数值、布尔值表示。通常与toString()返回值相同\n     \n     所有对象都有以上属性和方法\n\n * 操作符\n   \n   * 一元操作符\n     * ++\n     * --\n     * 前置与后置的区别是与其他数运算时，前置会先执行递增（减）再与其他数运算，后置会先与其他数运算再对自身执行递增(减)\n   * 布尔操作符\n     * 与 (&&)\n       * 短路操作，即如果第一个操作数能决定结果，就不会对第二个操作数求值\n     * 或 (||)\n       * 短路操作，即如果第一个操作数能决定结果，就不会对第二个操作数求值\n     * 非 (!)\n       * 先使用Boolean()转成布尔值再取反\n\n * 语句（也称流控制语句）\n   \n   * if-else\n   \n   * do-while\n     \n     * 后测试循环语句，在对表达式求值之前，循环体内的代码至少会被执行一次\n       \n       var i = 0\n       do {\n           i += 2\n       } while (i < 10)  // 只要i小于10就会一直循环\n       \n       \n       1\n       2\n       3\n       4\n       \n   \n   * while\n     \n     * 前测试语句\n       \n       var i = 0\n       while (i < 10) {\n           i += 2\n       } // 只要i小于10就会一直循环\n       \n       \n       1\n       2\n       3\n       4\n       \n   \n   * for\n     \n     * 使用while循环做不到的，使用for循环同样做不到。就是说，for循环只是把与循环有关的代码集合在一个位置\n       \n       for(初始化;条件;循环后执行){\n           // ...\n       }\n       \n       \n       1\n       2\n       3\n       \n     \n     * break 立即退出循环\n     \n     * continue 退出当前单次循环\n   \n   * \n   \n   * for- in 用来枚举对象的属性\n\n * 函数\n   \n   * 任何函数都可以在任何时候返回任何值\n   * 未指定返回值的函数会返回一个undefined\n   * 通过arguments访问参数，它是一个类数组\n\n\n# 第4章 变量、作用域和内存问题\n\n * 变量包含两种类型的值：\n   \n   * 基本类型值，指的是简单的数据段\n   * 引用类型值，指的是那些可能由多个值构成的对象\n\n * 复制变量值\n   \n   * 复制基本类型的变量值只是复制了该值的副本\n   * 复制引用类型的变量值时，同样也会将存储在变量对象的值复制一份放到新变量的空间中，不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。两个变量指向同一个对象。\n\n * 传递参数\n   \n   * 所有函数的参数都是按值传递的\n\n * 检测类型\n   \n   * typeof 检测基础类型\n   * instanceof检测引用类型\n     * 变量 instanceof 构造函数（例：obj instanceof Object）\n     * 所有引用类型的值都是Object的实例\n\n * 执行环境\n   \n   * 在浏览器中，全局执行环境是window对象\n   * 每个函数都有自己的执行环境\n\n * 作用域链\n   \n   * 当代码在一个环境中执行时，会创建变量对象的一个作用域链\n   * 作用域链的前端，始终是当前执行的代码所在环境的变量对象。\n   * 作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含对象。这样一直延续到全局执行环境。\n   * 全局执行环境的变量对象始终都是作用域链中的最后一个对象。\n\n * 垃圾收集\n   \n   * JavaScript具有自动垃圾收集机制\n     * 对于不再使用的变量打上标记，被打上标记的变量将在执行回收时被清除，释放内存空间。\n\n\n# 第5章 引用类型\n\n * 引用类型的值是引用类型的一个实例\n\n * 引用类型就是一种数据结构，描述了一类对象所具有的属性和方法\n\n * 创建Object实例的方式有两种：\n   \n   * var obj = new Object()\n     \n     \n     1\n     \n   \n   * var obj = {} // 与 new Object() 相同，但实际不会调用Object构造函数\n     \n     \n     1\n     \n\n * 访问对象的属性有两种：\n   \n   * 点表示法 和 方括号表示法\n\n\n# Array类型\n\n * length属性不是只读的\n\n * 检测数组\n   \n   * value instanceof Array\n     \n     \n     1\n     \n   \n   * Array.isArray(value)\n     \n     \n     1\n     \n\n * 转换方法\n   \n   * toLocaleString() 与toString()相同\n   * toString() 返回数组中每个值的字符串形式用逗号分隔拼接而成的字符串\n   * valueOf() 返回数组本身\n\n# join() 转换方法 (不改原数组)\n\n接收一个参数，用作分隔符的字符串，然后返回包含所有数组项的字符串。\n\nvar arr = ['red','blue','green']\nvar arrStr = arr.join('|') // \"red|blue|green\"\n\narr.join() // \"red,blue,green\"\narr.join('') // \"redbluegreen\"\n\n\n1\n2\n3\n4\n5\n\n\n# 栈方法，后进先出 push() 、pop() (改变原数组)\n\n * push() 向数组末尾添加成员，返回总长\n * pop() 移除数组末尾一个成员，返回该成员\n\n# 队列方法，先进先出 push()、shift() 、unshift() (改变原数组)\n\n * shift() 移除数组首个成员，返回该成员\n\n * unshift() 在数组前面添加成员，返回总长\n\npush()和shift() 形成队列方法\n\nunshift和pop() 形成反方向队列方法\n\n# 重排序方法 reverse() 反转 sort() 排序 （改变原数组）\n\n * reverse() 反转数组项的顺序\n * sort() 接收一个函数作为参数，函数接收两个参数。\n   * 自定义排序：函数内，如果第一个参数应该位于第二个之前，则手动返回一个负数，如果两个参数相等，手动返回0，如果第一个参数应该位于第二个参数之后，则手动返回一个正数。\n\n// 升序\narr.sort(function(a,b){\n    if(a < b) {\n        return -1\n    } else if (a > b) {\n        return 1\n    } else {\n        retunr 0\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n简写：\n\narr.sort((a,b) => {\n    return a-b // 升序， b-a 降序\n})\n\n\n1\n2\n3\n\n\n# 操作方法 concat() 拼接，slice() 切片，splice() 移接\n\n * concat() 拼接数组 （不改原数组）\n   \n   var arr1 = ['a','b']\n   var arr2 = arr1.concat('c','d') // ['a','b','c','d']\n   \n   \n   1\n   2\n   \n\n * slice() 切片（不改原数组）\n   \n   * slice(起始位置 [, 结束位置]) 返回起始位置到结束位置的成员，不包含结束位置。\n   \n   var arr1 = [1,2,3,4,5]\n   var arr2 = arr1.slice(1,3) // [2,3]\n   var arr3 = arr1.slice(2) // [3,4,5]\n   \n   \n   1\n   2\n   3\n   \n\n * splice() 移接 （改变原数组）\n   \n   * splice(起始位置, 要删除的个数，要插入的项)\n     * 要插入的项 可以有0个或多个\n   * splice() 始终返回一个数组，该数组成员中包含原始数组中被删除的项，如果没有则返回空数组。\n   * 数组最强大的方法，可用于删除、插入、替换操作\n   \n   arr = [1,2,3,4]\n   arr.splice(1,1) // [2]\n   arr // [1,3,4]\n   \n   \n   arr = [1,2,3,4]\n   arr.splice(2,0,'a') // []\n   arr // [1,2,'a',3,4]\n   \n   arr = [1,2,3,4]\n   arr.splice(3,1,'a') // [4]\n   arr // [1,2,3,'a']\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n# 位置方法 indexOf()、lastIndexOf()\n\n * 查找项的位置，没有则返回-1\n * indexOf() 从前面开始找，lastIndexOf() 从后面开始找\n\n# 迭代方法 every()、some() 、filter()、map() 、forEach() （都不会改变原数组）\n\n * 5个迭代方法，每个方法都接收两个参数：\n   \n   * 在每项上运行的函数\n   * 运行函数的作用域对象\n\n * 函数接收三个参数：\n   \n   * 数组项的值\n   * 该项的索引\n   * 数组本身\n\n * every() 如果函数对每项都返回true，则返回true\n   \n   * 例：判断数组每一项是否都大于2\n     \n     var numbers = [1,2,3,2,1]\n     var result = numbers.every((item,index,array) => {\n         return item > 2\n     })\n     result // false\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n * some() 如果函数对任一项返回true，则返回true\n   \n   * 例：判断数组是否包含大于2的值\n     \n     var numbers = [1,2,3,2,1]\n     var result = numbers.some((item,index,array) => {\n         return item > 2\n     })\n     result // true\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n * filter() 返回函数会返回true的项组成的数组\n   \n   * 例：过滤掉数组中小于等于2的数\n     \n     var numbers = [1,2,3,4,5]\n     var result = numbers.filter((item,index,array) => {\n         return item >2\n     })\n     result // [3,4,5]\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n * map() 返回每次函数调用的结果组成的数组\n   \n   * 例：给数组每一项乘以2\n     \n     var numbers = [1,2,3,4,5]\n     var result = numbers.map((item,index,array) => {\n         return item * 2\n     })\n     result // [2,4,6,8,10]\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n * forEach() 循环数组每一项，没有返回值\n   \n   * 例：循环每一项\n     \n     var numbers = [1,2,3,4,5]\n     numbers.forEach((item,index,array) => {\n         // 做一些操作\n     })\n     \n     \n     1\n     2\n     3\n     4\n     \n\n# 归并方法 reduce() reduceRight()\n\n * reduce() 归并为\n\n * reduceRight() 从右边归并\n\n * 这两个方法都会迭代数组所有项，然后构建一个最终结果并返回\n\n * 方法接收两个参数： 每一项上调用的函数，归并基础的初始值\n\n * 函数接收4个参数：前一个的值、当前值、当前值的索引、数组对象\n\n * 例：求数组每一项之和\n   \n   var numbers = [1,2,3,4,5]\n   var result = number.reduce((prev,cur,index,arr) => {\n       return prev + cur\n   })\n   result // 15\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * reduce()方法，第一次执行函数时，prev是数组的第一项，cur是数组的第二项\n\n\n# 第6章 面向对象的程序设计\n\n\n# 6.1 理解对象\n\n * 对象的定义：无序属性的集合，其属性可以包含基本值、对象或者函数。\n   * 一组键值对，其中值可以是数据或函数\n\n# 6.1.1 对象的属性\n\n包含两种：数据属性 和 访问器属性\n\n# 1.数据属性\n\n * configurable 可配置性（限制 delete删除属性和Object.defineProperty()方法是否起效。），默认true\n * enumerable 可列举性，默认true\n * writable 可写性，默认true\n * value 值，默认undefined\n\n使用Object.defineProperty()方法修改这些默认属性。接收三个值：属性所在的对象、属性名、描述符对象。\n\nvar person = {}\nObject.defineProperty(person,'name',{\n    writable: false,\n    value: 'xu'\n})\n\nconsole.log(person.name) // xu\nperson.name = 'gao' // 修改无效\nconsole.log(person.name) // xu\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用此方法定义属性如未指定configurable、enumerable、writable 将默认false。\n\n# 2.访问器属性\n\n包含两个函数：getter函数和setter函数（这两个函数都是非必需）。读取时调用getter，访问时调用setter。\n\n使用Object.defineProperty()方法定义访问器属性。\n\nvar book = {\n    _year: 2020,\n    edition: 1\n};\n\nObject.defineProperty(book, 'year', {\n    get: function() {\n        return this._year\n    },\n    set: function(newValue){\n        if(newValue > 2020) {\n            this._year = newValue\n            this.edition += newValue - 2020\n        }\n    }\n})\n\nbook.year = 2021\nconsole.log(book.edition) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n当getter函数和setter函数只指定其中一个时，另外一个将不能用。\n\n# 6.1.2 定义多个属性\n\nObject.defineProperties()方法定义多个属性。接收两个参数: 要添加或修改属性的对象 、第二个参数是一个对象，其属性与第一个参数中的属性一一对应。\n\nvar book = {}\nObject.defineProperties(book, {\n    _year: { // 数据属性\n        writable: true,\n        value: 2004\n    },\n    edition: { // 数据属性\n        writable: true,\n        value: 1\n    },\n    year: { // 访问器属性\n        get: function() {\n            return this._year\n        },\n        set: function(newValue){\n            if(newValue > 2004){\n                this._year = newValue\n                this.edition += newValue - 2004\n            }\n        }\n    }\n})\n\n// 定义了三个属性，每个属性有不同的描述符\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 6.1.3 读取属性的特性（描述符对象）\n\nObject.getOwnPropertyDescriptor()方法获取描述符，接收两个参数： 属性所在的对象、属性名\n\nvar book = {}\nObject.defineProperties(book, {\n    _year: { // 数据属性\n        writable: true,\n        value: 2004\n    },\n    edition: { // 数据属性\n        writable: true,\n        value: 1\n    },\n    year: { // 访问器属性\n        get: function() {\n            return this._year\n        },\n        set: function(newValue){\n            if(newValue > 2004){\n                this._year = newValue\n                this.edition += newValue - 2004\n            }\n        }\n    }\n})\n\nvar descriptor = Object.getOwnPropertyDescriptor(book, \"_year\")\nconsole.log(descriptor) // {value: 2020, writable: true, enumerable: false, configurable: false}\nvar descriptor = Object.getOwnPropertyDescriptor(book, \"year\")\nconsole.log(descriptor) // {enumerable: false, configurable: false, get: ƒ, set: ƒ}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 6.2 创建对象\n\n使用Object构造函数或对象字面量方式创建对象。缺点：使用同一个接口创建很多对象时，会产生大量重复代码。解决方案：使用工厂模式的一种变体。\n\n# 6.2.1 工厂模式\n\n\n# 第7章 函数表达式\n\n\n# 第8章 BOM\n\n\n# 第9章 客户端检测\n\n\n# 第10章 DOM\n\n\n# 第11章 DOM扩展\n\n\n# 第12章 DOM2和DOM3\n\n\n# 第13章 事件\n\n\n# 第14章 表单脚本\n\n\n# 第15章 使用Canvas绘图\n\n\n# 第16章 HTML5脚本编程\n\n\n# 第17章 错误处理与调试\n\n\n# 第18章 JavaScript与XML\n\n\n# 第19章 E4X\n\n\n# 第20章 JSON\n\n\n# 第21章 Ajax与Comet\n\n\n# 第22章 高级技巧\n\n\n# 第23章 离线应用与客户端存储\n\n\n# 第24章 最佳实践\n\n\n# 第25章 新兴的API",normalizedContent:"# 《javascript高级程序设计》笔记\n\n\n# 第1章 javascript简介\n\n * javascript诞生于1995年\n\n * 一个完整的javascript由这三部分组成：\n   \n   * ecmascript (核心)\n   * dom (文档对象模型)\n   * bom (浏览器对象模型)\n\n * ecmascript的 宿主环境 包含 ：\n   \n   * 浏览器\n   * node\n   * flash\n\n * ecmascript大致规定了下列组成部分：\n   \n   * 语法\n   * 类型\n   * 语句\n   * 关键字\n   * 保留字\n   * 操作符\n   * 对象\n\n\n# 第2章 在html中使用javascript\n\n * <script> 标签有下列常见属性：\n   * async 表示立即下载脚本，不妨碍页面的其他操作（异步下载）\n     * 无法保证每个js的顺序\n     * 用于互不依赖的js\n     * 主要目的是不让页面等js\n   * defer 延迟到文档完全解析和显示之后在执行\n     * 在</html>标签之后执行\n   * src 外部文件链接\n   * type 表示编写代码使用的脚本语言的内容类型\n     * text/javascript\n\n\n# 第3章 基本概念\n\n * 语法，借鉴了c语言\n   \n   * 区分大小写\n   * 标识符，指的是变量、函数、属性的名字\n     * 第一个字符必须是 字母、下划线、或美元符号\n     * 其他字符可以是字母、下划线、美元符号或数字\n\n * 严格模式\n   \n   \"use strict\"\n   \n   \n   1\n   \n\n * 数据类型\n   \n   * 基本数据类型\n     * undefined、null、boolean、number、string\n     * typeof操作符，一般用于基本类型的检测，返回相应类型的字符串\n       * “undefined”,\"boolean\",\"string\",\"number\",\"object\",\"function\"\n   * 复杂数据类型\n     * object\n\n * null类型\n   \n   * 表示空对象指针\n   * 只要意在保存对象的变量还没有真正保证对象，则保存null\n   * undefined派生自null，因此用==比较返回true\n\n * 浮点数，指的是数值中包含一个小数点，并且小数点后面至少有一位数字\n\n * nan\n   \n   * 任何涉及nan的操作都返回nan\n   * nan与任何值都不相等，包括nan本身\n\n * 数值转换\n   \n   * 有3个函数可以把非数值转换为数值\n     * number() 可以用于任何数据类型\n     * parseint() 专门用于字符串转数值，用于解析整数\n     * parsefloat() 专门用于字符串转数值，用于解析浮点数\n\n * 字符串\n   \n   * 数值、布尔值、对象、字符串值本身 都有tostring()方法，用于转为字符串\n   * undefined和null没有tostring()方法，但可以使用string()方法\n\n * object类型\n   \n   * 对象其实就是一组数据与功能的集合\n   \n   * 使用object()构造函数创建对象\n     \n     var obj = new object(); // 同 obj = {}\n     \n     \n     1\n     \n   \n   * 每个对象实例都有下列属性和方法\n     \n     * constructor 指向用于创建当前对象的构造函数 。（对于上面例子而言，就是object()）\n     * hasownproperty(propertyname) 用于检查给定属性是否在当前对象实例中\n     * isprototypeof(object) 用于检查传入的对象是否是当前对象的原型\n     * propertyisenumerable(propertyname) 用于检查给定的属性是否能够使用for-in来枚举\n     * tolocalestring() 返回对象的字符串表示，该字符串与执行环境的地区对应\n     * tostring() 返回对象的字符串表示\n     * valueof() 返回对象的字符串、数值、布尔值表示。通常与tostring()返回值相同\n     \n     所有对象都有以上属性和方法\n\n * 操作符\n   \n   * 一元操作符\n     * ++\n     * --\n     * 前置与后置的区别是与其他数运算时，前置会先执行递增（减）再与其他数运算，后置会先与其他数运算再对自身执行递增(减)\n   * 布尔操作符\n     * 与 (&&)\n       * 短路操作，即如果第一个操作数能决定结果，就不会对第二个操作数求值\n     * 或 (||)\n       * 短路操作，即如果第一个操作数能决定结果，就不会对第二个操作数求值\n     * 非 (!)\n       * 先使用boolean()转成布尔值再取反\n\n * 语句（也称流控制语句）\n   \n   * if-else\n   \n   * do-while\n     \n     * 后测试循环语句，在对表达式求值之前，循环体内的代码至少会被执行一次\n       \n       var i = 0\n       do {\n           i += 2\n       } while (i < 10)  // 只要i小于10就会一直循环\n       \n       \n       1\n       2\n       3\n       4\n       \n   \n   * while\n     \n     * 前测试语句\n       \n       var i = 0\n       while (i < 10) {\n           i += 2\n       } // 只要i小于10就会一直循环\n       \n       \n       1\n       2\n       3\n       4\n       \n   \n   * for\n     \n     * 使用while循环做不到的，使用for循环同样做不到。就是说，for循环只是把与循环有关的代码集合在一个位置\n       \n       for(初始化;条件;循环后执行){\n           // ...\n       }\n       \n       \n       1\n       2\n       3\n       \n     \n     * break 立即退出循环\n     \n     * continue 退出当前单次循环\n   \n   * \n   \n   * for- in 用来枚举对象的属性\n\n * 函数\n   \n   * 任何函数都可以在任何时候返回任何值\n   * 未指定返回值的函数会返回一个undefined\n   * 通过arguments访问参数，它是一个类数组\n\n\n# 第4章 变量、作用域和内存问题\n\n * 变量包含两种类型的值：\n   \n   * 基本类型值，指的是简单的数据段\n   * 引用类型值，指的是那些可能由多个值构成的对象\n\n * 复制变量值\n   \n   * 复制基本类型的变量值只是复制了该值的副本\n   * 复制引用类型的变量值时，同样也会将存储在变量对象的值复制一份放到新变量的空间中，不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。两个变量指向同一个对象。\n\n * 传递参数\n   \n   * 所有函数的参数都是按值传递的\n\n * 检测类型\n   \n   * typeof 检测基础类型\n   * instanceof检测引用类型\n     * 变量 instanceof 构造函数（例：obj instanceof object）\n     * 所有引用类型的值都是object的实例\n\n * 执行环境\n   \n   * 在浏览器中，全局执行环境是window对象\n   * 每个函数都有自己的执行环境\n\n * 作用域链\n   \n   * 当代码在一个环境中执行时，会创建变量对象的一个作用域链\n   * 作用域链的前端，始终是当前执行的代码所在环境的变量对象。\n   * 作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含对象。这样一直延续到全局执行环境。\n   * 全局执行环境的变量对象始终都是作用域链中的最后一个对象。\n\n * 垃圾收集\n   \n   * javascript具有自动垃圾收集机制\n     * 对于不再使用的变量打上标记，被打上标记的变量将在执行回收时被清除，释放内存空间。\n\n\n# 第5章 引用类型\n\n * 引用类型的值是引用类型的一个实例\n\n * 引用类型就是一种数据结构，描述了一类对象所具有的属性和方法\n\n * 创建object实例的方式有两种：\n   \n   * var obj = new object()\n     \n     \n     1\n     \n   \n   * var obj = {} // 与 new object() 相同，但实际不会调用object构造函数\n     \n     \n     1\n     \n\n * 访问对象的属性有两种：\n   \n   * 点表示法 和 方括号表示法\n\n\n# array类型\n\n * length属性不是只读的\n\n * 检测数组\n   \n   * value instanceof array\n     \n     \n     1\n     \n   \n   * array.isarray(value)\n     \n     \n     1\n     \n\n * 转换方法\n   \n   * tolocalestring() 与tostring()相同\n   * tostring() 返回数组中每个值的字符串形式用逗号分隔拼接而成的字符串\n   * valueof() 返回数组本身\n\n# join() 转换方法 (不改原数组)\n\n接收一个参数，用作分隔符的字符串，然后返回包含所有数组项的字符串。\n\nvar arr = ['red','blue','green']\nvar arrstr = arr.join('|') // \"red|blue|green\"\n\narr.join() // \"red,blue,green\"\narr.join('') // \"redbluegreen\"\n\n\n1\n2\n3\n4\n5\n\n\n# 栈方法，后进先出 push() 、pop() (改变原数组)\n\n * push() 向数组末尾添加成员，返回总长\n * pop() 移除数组末尾一个成员，返回该成员\n\n# 队列方法，先进先出 push()、shift() 、unshift() (改变原数组)\n\n * shift() 移除数组首个成员，返回该成员\n\n * unshift() 在数组前面添加成员，返回总长\n\npush()和shift() 形成队列方法\n\nunshift和pop() 形成反方向队列方法\n\n# 重排序方法 reverse() 反转 sort() 排序 （改变原数组）\n\n * reverse() 反转数组项的顺序\n * sort() 接收一个函数作为参数，函数接收两个参数。\n   * 自定义排序：函数内，如果第一个参数应该位于第二个之前，则手动返回一个负数，如果两个参数相等，手动返回0，如果第一个参数应该位于第二个参数之后，则手动返回一个正数。\n\n// 升序\narr.sort(function(a,b){\n    if(a < b) {\n        return -1\n    } else if (a > b) {\n        return 1\n    } else {\n        retunr 0\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n简写：\n\narr.sort((a,b) => {\n    return a-b // 升序， b-a 降序\n})\n\n\n1\n2\n3\n\n\n# 操作方法 concat() 拼接，slice() 切片，splice() 移接\n\n * concat() 拼接数组 （不改原数组）\n   \n   var arr1 = ['a','b']\n   var arr2 = arr1.concat('c','d') // ['a','b','c','d']\n   \n   \n   1\n   2\n   \n\n * slice() 切片（不改原数组）\n   \n   * slice(起始位置 [, 结束位置]) 返回起始位置到结束位置的成员，不包含结束位置。\n   \n   var arr1 = [1,2,3,4,5]\n   var arr2 = arr1.slice(1,3) // [2,3]\n   var arr3 = arr1.slice(2) // [3,4,5]\n   \n   \n   1\n   2\n   3\n   \n\n * splice() 移接 （改变原数组）\n   \n   * splice(起始位置, 要删除的个数，要插入的项)\n     * 要插入的项 可以有0个或多个\n   * splice() 始终返回一个数组，该数组成员中包含原始数组中被删除的项，如果没有则返回空数组。\n   * 数组最强大的方法，可用于删除、插入、替换操作\n   \n   arr = [1,2,3,4]\n   arr.splice(1,1) // [2]\n   arr // [1,3,4]\n   \n   \n   arr = [1,2,3,4]\n   arr.splice(2,0,'a') // []\n   arr // [1,2,'a',3,4]\n   \n   arr = [1,2,3,4]\n   arr.splice(3,1,'a') // [4]\n   arr // [1,2,3,'a']\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n# 位置方法 indexof()、lastindexof()\n\n * 查找项的位置，没有则返回-1\n * indexof() 从前面开始找，lastindexof() 从后面开始找\n\n# 迭代方法 every()、some() 、filter()、map() 、foreach() （都不会改变原数组）\n\n * 5个迭代方法，每个方法都接收两个参数：\n   \n   * 在每项上运行的函数\n   * 运行函数的作用域对象\n\n * 函数接收三个参数：\n   \n   * 数组项的值\n   * 该项的索引\n   * 数组本身\n\n * every() 如果函数对每项都返回true，则返回true\n   \n   * 例：判断数组每一项是否都大于2\n     \n     var numbers = [1,2,3,2,1]\n     var result = numbers.every((item,index,array) => {\n         return item > 2\n     })\n     result // false\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n * some() 如果函数对任一项返回true，则返回true\n   \n   * 例：判断数组是否包含大于2的值\n     \n     var numbers = [1,2,3,2,1]\n     var result = numbers.some((item,index,array) => {\n         return item > 2\n     })\n     result // true\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n * filter() 返回函数会返回true的项组成的数组\n   \n   * 例：过滤掉数组中小于等于2的数\n     \n     var numbers = [1,2,3,4,5]\n     var result = numbers.filter((item,index,array) => {\n         return item >2\n     })\n     result // [3,4,5]\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n * map() 返回每次函数调用的结果组成的数组\n   \n   * 例：给数组每一项乘以2\n     \n     var numbers = [1,2,3,4,5]\n     var result = numbers.map((item,index,array) => {\n         return item * 2\n     })\n     result // [2,4,6,8,10]\n     \n     \n     1\n     2\n     3\n     4\n     5\n     \n\n * foreach() 循环数组每一项，没有返回值\n   \n   * 例：循环每一项\n     \n     var numbers = [1,2,3,4,5]\n     numbers.foreach((item,index,array) => {\n         // 做一些操作\n     })\n     \n     \n     1\n     2\n     3\n     4\n     \n\n# 归并方法 reduce() reduceright()\n\n * reduce() 归并为\n\n * reduceright() 从右边归并\n\n * 这两个方法都会迭代数组所有项，然后构建一个最终结果并返回\n\n * 方法接收两个参数： 每一项上调用的函数，归并基础的初始值\n\n * 函数接收4个参数：前一个的值、当前值、当前值的索引、数组对象\n\n * 例：求数组每一项之和\n   \n   var numbers = [1,2,3,4,5]\n   var result = number.reduce((prev,cur,index,arr) => {\n       return prev + cur\n   })\n   result // 15\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n * reduce()方法，第一次执行函数时，prev是数组的第一项，cur是数组的第二项\n\n\n# 第6章 面向对象的程序设计\n\n\n# 6.1 理解对象\n\n * 对象的定义：无序属性的集合，其属性可以包含基本值、对象或者函数。\n   * 一组键值对，其中值可以是数据或函数\n\n# 6.1.1 对象的属性\n\n包含两种：数据属性 和 访问器属性\n\n# 1.数据属性\n\n * configurable 可配置性（限制 delete删除属性和object.defineproperty()方法是否起效。），默认true\n * enumerable 可列举性，默认true\n * writable 可写性，默认true\n * value 值，默认undefined\n\n使用object.defineproperty()方法修改这些默认属性。接收三个值：属性所在的对象、属性名、描述符对象。\n\nvar person = {}\nobject.defineproperty(person,'name',{\n    writable: false,\n    value: 'xu'\n})\n\nconsole.log(person.name) // xu\nperson.name = 'gao' // 修改无效\nconsole.log(person.name) // xu\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用此方法定义属性如未指定configurable、enumerable、writable 将默认false。\n\n# 2.访问器属性\n\n包含两个函数：getter函数和setter函数（这两个函数都是非必需）。读取时调用getter，访问时调用setter。\n\n使用object.defineproperty()方法定义访问器属性。\n\nvar book = {\n    _year: 2020,\n    edition: 1\n};\n\nobject.defineproperty(book, 'year', {\n    get: function() {\n        return this._year\n    },\n    set: function(newvalue){\n        if(newvalue > 2020) {\n            this._year = newvalue\n            this.edition += newvalue - 2020\n        }\n    }\n})\n\nbook.year = 2021\nconsole.log(book.edition) // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n当getter函数和setter函数只指定其中一个时，另外一个将不能用。\n\n# 6.1.2 定义多个属性\n\nobject.defineproperties()方法定义多个属性。接收两个参数: 要添加或修改属性的对象 、第二个参数是一个对象，其属性与第一个参数中的属性一一对应。\n\nvar book = {}\nobject.defineproperties(book, {\n    _year: { // 数据属性\n        writable: true,\n        value: 2004\n    },\n    edition: { // 数据属性\n        writable: true,\n        value: 1\n    },\n    year: { // 访问器属性\n        get: function() {\n            return this._year\n        },\n        set: function(newvalue){\n            if(newvalue > 2004){\n                this._year = newvalue\n                this.edition += newvalue - 2004\n            }\n        }\n    }\n})\n\n// 定义了三个属性，每个属性有不同的描述符\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 6.1.3 读取属性的特性（描述符对象）\n\nobject.getownpropertydescriptor()方法获取描述符，接收两个参数： 属性所在的对象、属性名\n\nvar book = {}\nobject.defineproperties(book, {\n    _year: { // 数据属性\n        writable: true,\n        value: 2004\n    },\n    edition: { // 数据属性\n        writable: true,\n        value: 1\n    },\n    year: { // 访问器属性\n        get: function() {\n            return this._year\n        },\n        set: function(newvalue){\n            if(newvalue > 2004){\n                this._year = newvalue\n                this.edition += newvalue - 2004\n            }\n        }\n    }\n})\n\nvar descriptor = object.getownpropertydescriptor(book, \"_year\")\nconsole.log(descriptor) // {value: 2020, writable: true, enumerable: false, configurable: false}\nvar descriptor = object.getownpropertydescriptor(book, \"year\")\nconsole.log(descriptor) // {enumerable: false, configurable: false, get: ƒ, set: ƒ}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 6.2 创建对象\n\n使用object构造函数或对象字面量方式创建对象。缺点：使用同一个接口创建很多对象时，会产生大量重复代码。解决方案：使用工厂模式的一种变体。\n\n# 6.2.1 工厂模式\n\n\n# 第7章 函数表达式\n\n\n# 第8章 bom\n\n\n# 第9章 客户端检测\n\n\n# 第10章 dom\n\n\n# 第11章 dom扩展\n\n\n# 第12章 dom2和dom3\n\n\n# 第13章 事件\n\n\n# 第14章 表单脚本\n\n\n# 第15章 使用canvas绘图\n\n\n# 第16章 html5脚本编程\n\n\n# 第17章 错误处理与调试\n\n\n# 第18章 javascript与xml\n\n\n# 第19章 e4x\n\n\n# 第20章 json\n\n\n# 第21章 ajax与comet\n\n\n# 第22章 高级技巧\n\n\n# 第23章 离线应用与客户端存储\n\n\n# 第24章 最佳实践\n\n\n# 第25章 新兴的api",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"《ES6 教程》笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《ES6 教程》笔记",imgUrl:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200112160453.png",description:"本章内容为博主在原教程基础上添加学习笔记，教程版权归原作者所有。来源：<a href='https://es6.ruanyifeng.com/' target='_blank'>ES6教程</a>"}},title:"《ES6 教程》笔记",date:"2020-01-12T15:49:22.000Z",permalink:"/note/es6/",article:!1,comment:!1,editLink:!1,author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/10.%E3%80%8AES6%20%E6%95%99%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/40.学习笔记/10.《ES6 教程》笔记.md",key:"v-9973f104",path:"/note/es6/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"《Vue》笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《Vue》笔记",imgUrl:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200204143633.png",description:"本章内容是博主的Vue学习笔记，非教程文档，请以官方文档为准。"}},title:"《Vue》笔记",date:"2020-02-04T12:16:12.000Z",permalink:"/note/vue/",article:!1,comment:!1,editLink:!1,author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/20.%E3%80%8AVue%E3%80%8B%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/40.学习笔记/20.《Vue》笔记.md",key:"v-4e6abdc5",path:"/note/vue/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"《React》笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《React》笔记",imgUrl:"data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9Ii0xMS41IC0xMC4yMzE3NCAyMyAyMC40NjM0OCI+CiAgPHRpdGxlPlJlYWN0IExvZ288L3RpdGxlPgogIDxjaXJjbGUgY3g9IjAiIGN5PSIwIiByPSIyLjA1IiBmaWxsPSIjNjFkYWZiIi8+CiAgPGcgc3Ryb2tlPSIjNjFkYWZiIiBzdHJva2Utd2lkdGg9IjEiIGZpbGw9Im5vbmUiPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIi8+CiAgICA8ZWxsaXBzZSByeD0iMTEiIHJ5PSI0LjIiIHRyYW5zZm9ybT0icm90YXRlKDYwKSIvPgogICAgPGVsbGlwc2Ugcng9IjExIiByeT0iNC4yIiB0cmFuc2Zvcm09InJvdGF0ZSgxMjApIi8+CiAgPC9nPgo8L3N2Zz4K",description:"本章内容是博主的React学习笔记，非教程文档，请以官方文档为准。"}},title:"《React》笔记",date:"2021-03-25T19:50:12.000Z",permalink:"/note/react/",article:!1,comment:!1,editLink:!1,author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/25.%E3%80%8AReact%E3%80%8B%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/40.学习笔记/25.《React》笔记.md",key:"v-37036a26",path:"/note/react/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"《TypeScript 从零实现 axios》",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《TypeScript 从零实现 axios》",imgUrl:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200105104632.png",description:"学习使用 TypeScript 从零实现 axios 库"}},title:"《TypeScript 从零实现 axios》",date:"2020-01-05T10:40:48.000Z",permalink:"/note/typescript-axios",article:!1,comment:!1,editLink:!1,author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/30.%E3%80%8ATypeScript%20%E4%BB%8E%E9%9B%B6%E5%AE%9E%E7%8E%B0%20axios%E3%80%8B.html",relativePath:"01.前端/40.学习笔记/30.《TypeScript 从零实现 axios》.md",key:"v-142c4b83",path:"/note/typescript-axios/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"《Git》学习笔记",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"《Git》学习笔记",imgUrl:"https://avatars3.githubusercontent.com/u/18133?s=200&v=4",description:"<a href='https://git-scm.com/book/zh/v2' target='_blank'>Git官网文档</a>的学习笔记，以官方文档为准。"}},title:"《Git》学习笔记",date:"2020-11-18T17:40:48.000Z",permalink:"/note/git",article:!1,comment:!1,editLink:!1,author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/33.%E3%80%8AGit%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/40.学习笔记/33.《Git》学习笔记.md",key:"v-70b7207a",path:"/note/git/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"TypeScript笔记",frontmatter:{title:"TypeScript笔记",date:"2020-10-08T13:02:48.000Z",permalink:"/pages/51afd6/",categories:["前端","学习笔记"],tags:["TypeScript"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/35.TypeScript%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/40.学习笔记/35.TypeScript笔记.md",key:"v-354ba35d",path:"/pages/51afd6/",headers:[{level:2,title:"类型注解",slug:"类型注解",normalizedTitle:"类型注解",charIndex:61},{level:3,title:"有哪些基础类型注解？",slug:"有哪些基础类型注解",normalizedTitle:"有哪些基础类型注解？",charIndex:220},{level:3,title:"什么是类型注解和类型推断、类型断言？",slug:"什么是类型注解和类型推断、类型断言",normalizedTitle:"什么是类型注解和类型推断、类型断言？",charIndex:506},{level:3,title:"对象的类型",slug:"对象的类型",normalizedTitle:"对象的类型",charIndex:877},{level:3,title:"函数的类型注解",slug:"函数的类型注解",normalizedTitle:"函数的类型注解",charIndex:1334},{level:3,title:"数组的类型注解",slug:"数组的类型注解",normalizedTitle:"数组的类型注解",charIndex:1825},{level:2,title:"元组",slug:"元组",normalizedTitle:"元组",charIndex:2474},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:349},{level:2,title:"ES6 class类中应用TS",slug:"es6-class类中应用ts",normalizedTitle:"es6 class类中应用ts",charIndex:4152},{level:3,title:"class类的修饰器",slug:"class类的修饰器",normalizedTitle:"class类的修饰器",charIndex:4172},{level:3,title:"class类的构造函数中使用类型校验",slug:"class类的构造函数中使用类型校验",normalizedTitle:"class类的构造函数中使用类型校验",charIndex:4796},{level:3,title:"class类的getter、setter和static",slug:"class类的getter、setter和static",normalizedTitle:"class类的getter、setter和static",charIndex:5174},{level:3,title:"class类的只读属性",slug:"class类的只读属性",normalizedTitle:"class类的只读属性",charIndex:5701},{level:3,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:5970},{level:2,title:"联合类型和类型保护",slug:"联合类型和类型保护",normalizedTitle:"联合类型和类型保护",charIndex:6361},{level:2,title:"枚举",slug:"枚举",normalizedTitle:"枚举",charIndex:7252},{level:2,title:"泛型",slug:"泛型",normalizedTitle:"泛型",charIndex:7925},{level:3,title:"函数中的泛型使用",slug:"函数中的泛型使用",normalizedTitle:"函数中的泛型使用",charIndex:7963},{level:3,title:"class类中使用泛型",slug:"class类中使用泛型",normalizedTitle:"class类中使用泛型",charIndex:8727},{level:2,title:"配置文件tsconfig.json",slug:"配置文件tsconfig-json",normalizedTitle:"配置文件tsconfig.json",charIndex:9796}],headersStr:"类型注解 有哪些基础类型注解？ 什么是类型注解和类型推断、类型断言？ 对象的类型 函数的类型注解 数组的类型注解 元组 接口 ES6 class类中应用TS class类的修饰器 class类的构造函数中使用类型校验 class类的getter、setter和static class类的只读属性 抽象类 联合类型和类型保护 枚举 泛型 函数中的泛型使用 class类中使用泛型 配置文件tsconfig.json",content:"# TypeScript 学习笔记\n\nTypeScript 的类型校验是给程序员看的，在编译后不会存在TS代码。\n\n\n# 类型注解\n\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\n    ///...\n}\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\n\nconst test:number = 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 有哪些基础类型注解？\n\n// 基础类型\n:string\n:number\n:boolean\n\n:null  // 只能是null值\n:undefined // 只能是undefined值\n\n:symbol\n\n// 引用类型\n:object // 不常用，多使用接口来给对象进行类型注解\n\n// 其他\n:any  // 任意类型\n:void  // 空，用于函数的无返回值的注解\n:never // 用于标注函数代码永远执行不完（如抛出错误的函数，死循环函数）\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 什么是类型注解和类型推断、类型断言？\n\n类型注解 是显式的标注类型\n\n类型推断 是编辑器根据值来自动推断出类型 (编辑器中鼠标移到变量会显示类型的提示)。\n\n类型断言 是告诉编译器，“相信我，它就是这个类型”。\n\n// 类型注解就是显式的写出类型\nconst myNumber: number = 123\n\n// 类型推断是根据值来推断类型 (鼠标移到变量会显示类型(或直接显示值)的提示)\nconst myString = 'test'\n\n// 类型断言（开发者明确知道是什么类型）\nconst someValue:any = 'abc'\nconst strLength:number = (someValue as string).length // 断言someValue是字符串类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 对象的类型\n\n// 对象字面量的类型检查\nconst xiaojiejie: {\n  name: string,\n  age: number\n} = {\n  name: '小红',\n  age: 18\n}\n\n// 标注:object\nconst obj:object = {}\n\n// 使用接口\ninterface Person{\n    name: string\n    age: number\n}\nconst xjj: Person = {\n    name: 'xh',\n    age: 18\n}\n\n// class类的类型检查\nclass Parson { }\nconst xiaobai: Parson = new Parson()\n\n// 函数和返回值的类型检查\nconst fn: ()=> string = () => '123'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 函数的类型注解\n\n// 函数返回值的类型注解 fn(): number {}\nfunction getTotal2(one: number, two: number): number {\n  return one + two\n}\ngetTotal2(1,2)\n\n\n// 无返回值: void\nfunction sayHello(): void {\n  console.log(\"Hello\")\n}\n\n// 永远执行不玩的函数\nfunction setTimer():never {\n  throw new Error()\n  console.log(123)\n}\n\n// 参数是对象时的注解 （也可以用接口）\nfunction add({ one, two }: {one: number, two: number}) {\n  return  one + two\n}\n\nconst total = add({one: 1, two: 2})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 数组的类型注解\n\nconst numberArr: number[] = [1, 2, 3]\nconst stringArr: string[] = ['a', 'b']\nconst undefinedArr: undefined[] = [undefined, undefined]\nconst arr: (number | string | boolean)[] = [1, 'a', true, false] // 用到联合类型\n\n// 类型别名 type alias\ntype lady = { name: string, age: number }\n\nconst xiaojj: lady[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n// 或用类的方式\nclass Ady2 {\n  name: string;\n  age: number;\n}\n\nconst xiaojj2: Ady2[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 元组\n\n元组，可以理解为：已知元素数量和类型的数组\n\n// 联合类型\nconst xjj:(string | number)[] = ['a',22,'b'] // 规定整个数组当中可以有string或number\n\n// 元组注解 注意这里的注解只有一个中括号\nconst xjj1: [string, number, number] = ['a', 22, 33] // 规定了数组每个元素对应位置的类型\n\n// Note: 在开发中元祖的使用在相对少\n\n\n// CSV的方式定义数据格式； （二维数组时需要多加一个中括号）\nconst xjj2: [string, number, number][] = [\n  ['a', 22, 33],\n  ['a', 22, 33]\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 接口\n\n接口，可以理解为对象属性的类型描述。和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如type Girl = string\n\ninterface Girl { // 接口 （理解：对象属性的类型描述）\n  readonly name: string; // 只读属性 （定义之后不能再修改）\n  age: number;\n  waistline?: number; // 加个问号表示是可选值\n  [propname: string]: any; // 表示可以有不限制属性名的属性，但属性名需要是字符串，值可以是任意类型\n  say(): string; // 函数类型，返回值是string (如无返回值时是 void)。  say()也可以加入参数类型检查，如say(p:number)\n}\n// 和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如 type Girl = string\n\n// 接口的继承\ninterface Teacher extends Girl {\n  teach(): string;\n}\n\n\nconst girl = {\n  name: '大脚',\n  age: 18,\n  sex: '女',\n  say() {\n    return '欢迎光临'\n  },\n  teach() {\n    return '教'\n  }\n}\n\n\nconst screenResume = ({ name, age, bust, sex }: Girl) => {\n  console.log(name, age, bust, sex)\n}\nconst getResume = ({ name, age, bust, teach}: Teacher) => {\n  teach();\n  console.log(name, age, bust)\n}\nscreenResume(girl)\ngetResume(girl)\n\n\n// 接口在class类中的使用\nclass xiaojjj implements Girl {\n  name = \"xiaojj\"\n  age = 18\n  bust = 98\n  sex = '女'\n  say() {\n    return '欢迎光临'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n可索引的类型\n\ninterface Arr {\n    [index: number]:string   // 表示通过索引访问数据时返回的类型是string\n}\n\nconst myArr:Arr = ['1','2','3']\nconst myStr:string = myArr[1]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# ES6 class类中应用TS\n\n\n# class类的修饰器\n\n// 类的修饰器：\n// public (公共) 允许内外部使用\n// protected (受保护的) 允许在内部和继承内使用\n// private (私有) 允许在内部使用，但不能在继承中使用\n\n// 类的内部和外部，{}内属于内部，外面是外部\nclass Person {\n   // public 内外都可以使用，可省略，不写时默认public。 protected只允许内部使用\n  name: string // 这里的string注释是TS使用的\n  private age: 18\n  public sayHello() {\n    console.log(this.name + this.age + 'say hello')\n  }\n}\n\nclass Teacher2 extends Person {\n  public sayBye() {\n    console.log(this.name + ' say bye') // protected 可以在继承中使用到\n  }\n}\n\nconst person = new Person();\nperson.name = 'test' // 在类的外部定义\nconsole.log(person.name)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# class类的构造函数中使用类型校验\n\nclass Person2 {\n  constructor(public name: string) {\n    this.name = name\n  }\n}\n\nclass Teacher3 extends Person2{\n  constructor(public age: number) {\n    super('test-name') // 这里传的值是给Person2的构造函数。即使父类没有构造函数，子类的构造函数内也要写super()\n  }\n}\nconst teacher3 = new Teacher3(18)\nconsole.log(teacher3.name)\nconsole.log(teacher3.age)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# class类的getter、setter和static\n\nclass Xjj {\n  constructor(private _age: number) { }\n  get age() {\n    return this._age - 10;\n  }  // 访问器属性，以属性的形式访问age，并可以对属性进行包装\n  set age(age: number) {\n    this._age = age+3;\n   }\n}\n\nconst dj = new Xjj(28);\ndj.age = 25\n\nconsole.log(dj.age)\n\n\n// 静态属性 static。  静态属性指不需要通过实例化，直接通过Girl.prop的方式就可以访问到属性\nclass Girl {\n  static sayLove() {\n    return 'I love you'\n  }\n}\n\n// const girl = new Girl()\nconsole.log(Girl.sayLove())\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# class类的只读属性\n\n// 只读属性\nclass Person {\n  public readonly _name: string // 只读属性\n  constructor(name: string) {\n    this._name = name;\n  }\n}\n\nconst person = new Person('testName');\n// person._name = '222'; // 不能修改只读属性\nconsole.log(person._name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 抽象类\n\n/ 抽象类\nabstract class Girls {\n  abstract skill(); // 注意这里只是定义抽象方法，而不具有方法的实现\n}\n\nclass Waiter extends Girls{ // 继承了抽象类之后要 实现抽象类内的成员\n  skill() {\n    console.log('大爷1')\n  }\n}\n\nclass BaseTeacher extends Girls{\n  skill() {\n    console.log('大爷2')\n  }\n}\n\nclass SeniorTeacher extends Girls{\n  skill() {\n    console.log('大爷3')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 联合类型和类型保护\n\n联合类型 指某个参数可以是多种类型。\n\n类型保护 指参数属于某个类型才有相应的操作。\n\ninterface Waiter {\n  anjiao: boolean\n  say: () => {}\n}\n\ninterface Teacher {\n  anjiao: boolean\n  skill: () => {}\n}\n\nfunction judgeWho(animal: (Waiter | Teacher)) { // 联合类型\n  // 第一种断言方法\n  if (animal.anjiao) {\n    // (animal as Teacher) 的意思是：断言 animal 是 Teacher类型\n    (animal as Teacher).skill()\n  } else {\n    (animal as Waiter).say()\n  }\n\n  // 第二种断言方法\n  if ('skill' in animal) {\n    animal.skill()\n  } else {\n    animal.say()\n  }\n\n  // 第三种类型保护方法是使用typeof来判断 (代码省略)\n}\n\n\nclass NumberObj {\n  count: number\n}\nfunction addObj(first: object | NumberObj, second: object | NumberObj) { // 联合类型\n  if (first instanceof NumberObj && second instanceof NumberObj) { // 类型保护\n    return first.count + second.count;\n  }\n  return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 枚举\n\n// Enum枚举类型   (个人理解枚举：约定一组可选的常量。 使用常量名表示某个值的含义，增强可读性。)\n\n// js写法\n// const Status = {\n//   MASSAGE: 0,\n//   SPA: 1,\n//   DABAOJIAN: 2\n// }\n\n// ts写法\nenum Status {\n  MASSAGE,  // 如果想从1开始，给MASSAGE = 1, 即可\n  SPA,\n  DABAOJIAN\n} // 默认赋值 0 、1、2\n\nconsole.log(Status.MASSAGE, Status[0]) // 0, MASSAGE  可以通过下标反查\n\nfunction getStatus(status: any) {\n  if (status === Status.MASSAGE) {\n    return 'massage'\n  } else if (status === Status.SPA) {\n    return 'spa'\n  } else if (status === Status.DABAOJIAN) {\n    return 'dabaojian'\n  }\n}\n\nconst result = getStatus(Status.SPA)\nconsole.log(result)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 泛型\n\n泛型，最简单的理解：泛指的类型。（类似函数中的形参与实参）\n\n\n# 函数中的泛型使用\n\n\n// function join(first: string | number, second: string | number) {\n//   return `${first}${second}`\n// }\n// join('jspang', 1); // 如果我想第一个参数是字符串，第二个也必须是字符串，这么就用到泛型\n\n\n// 泛型使用，如同定义形参，在调用时指定类型\nfunction join<JSPang>(first: JSPang, second: JSPang) {\n  return `${first}${second}`\n}\n\njoin<string>('jspang', '123');\njoin<number>(11, 22);\n\n// 泛型中数组的使用\nfunction myFun<ANY>(params:ANY[]) { // ANY[] or Array<ANY>\n  return params\n}\nmyFun<string>(['a', 'b'])\n\n\n// 两个类型参数的使用（工作中，常用T表示泛型）\nfunction join2<T,P>(first: T, second: P) {\n  return `${first}${second}`\n}\n\njoin2<string,number>('jspang', 123);\njoin2<number, string>(11, '22');\njoin2(11, '22'); // 泛型也支持类型推断 （鼠标移到函数名有提示）\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# class类中使用泛型\n\n// class SelectGirl {\n//   constructor(private girls: string[] | number[]) { } // private 私有的参数，外部无法修改\n//   getGirl(index: number): string | number {\n//     return this.girls[index]\n//   }\n// }\n\n// 使用泛型\nclass SelectGirl<T> {   // 泛型的约束: <T extends number | string>\n  constructor(private girls: T[]) { } // private 私有的参数，外部无法修改\n  getGirl(index: number): T {\n    return this.girls[index]\n  }\n}\n\n// const selectGirl = new SelectGirl<string>(['大脚', 'xiaohong', 'xiaobai'])\nconst selectGirl = new SelectGirl<number>([101, 102, 103])\nconsole.log(selectGirl.getGirl(1))\n\n\n// 泛型中的继承\ninterface Girl {\n  name: string\n}\nclass SelectGirl2<T extends Girl> { // 泛型T中必须有一个name属性，继承自Girl接口\n  constructor(private girls: T[]) { } // private 私有的参数，外部无法修改\n  getGirl(index: number): string {\n    return this.girls[index].name\n  }\n}\n\nconst selectGirl2 = new SelectGirl2([\n  {name: '大脚1'},\n  {name: '大脚2'},\n  {name: '大脚3'}\n])\n\nconsole.log(selectGirl2.getGirl(1))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 配置文件tsconfig.json\n\n// 此文件由命令 tsc -init 生成\n// 直接运行 tsc 命令就会运用此配置文件\n// 选项详解：https://www.tslang.cn/docs/handbook/compiler-options.html\n{\n  // \"include\": [\"demo15-1.ts\"],              // 要编译的指定文件，不配置此项时运行tsc默认编译全部\n  // \"files\": [\"demo15-1.ts\"],                // 和include类似\n  // \"exclude\": [\"demo15-3.ts\"],              // 要排除编译的指定文件\n  \"compilerOptions\": { // 编译选项\n    /* 基本选项 */\n    // \"incremental\": true,                   /* 启用增量编译 */\n    \"target\": \"es5\",                          /* 指定 ECMAScript 目标版本: 'ES3' (default), 'ES5', 'ES2015', 'ES2016', 'ES2017', 'ES2018', 'ES2019' or 'ESNEXT'. */\n    \"module\": \"commonjs\",                     /* 指定模块代码生成: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'ESNext'. */\n    // \"lib\": [],                             /* 指定要包含在编译中的库文件. */\n    // \"allowJs\": true,                       /* 允许编译javascript文件*/\n    // \"checkJs\": true,                       /* 报告.js文件中的错误。 */\n    // \"jsx\": \"preserve\",                     /* 指定 JSX代码生成: 'preserve', 'react-native', or 'react'. */\n    // \"declaration\": true,                   /* 生成相应的 .d.ts文件 */\n    // \"declarationMap\": true,                /* 为每个相应的 .d.ts文件生成一个sourcemap (编译后代码对源码的映射)*/\n    \"sourceMap\": true,                        /* 生成源文件与输出文件的映射关系文件(.map)。*/\n    // \"outFile\": \"./\",                       /* 将输出文件合并为一个文件. */\n    \"outDir\": \"./build\",                      /* 输出的js文件目录。 */\n    \"rootDir\": \"./src\",                       /* ts源文件目录。 */\n    // \"composite\": true,                     /* 启用 项目编译 */\n    // \"tsBuildInfoFile\": \"./\",               /* 指定用于存储增量编译信息的文件 */\n    // \"removeComments\": true,                /* 不输出注释到编译结果.（删除所有注释，除了以 /!*开头的版权信息。） */\n    // \"noEmit\": true,                        /* 不发出输出.Do not emit outputs. */\n    // \"importHelpers\": true,                 /* 从“tslib”导入发出助手. Import emit helpers from 'tslib'. */\n    // \"downlevelIteration\": true,            /* Provide full support for iterables in 'for-of', spread, and destructuring when targeting 'ES5' or 'ES3'. */\n    // \"isolatedModules\": true,               /* 将每个文件作为单独的模块（与“ts.transpileModule”类似） */\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                           /* 启用所有严格类型检查选项。 打开此选项后，下面这些选项就不需要单独设置*/\n    // \"noImplicitAny\": true,                 /* 对隐含的“any”类型的表达式和声明引发错误. (为false时允许any不用特意声明)*/\n    // \"strictNullChecks\": true,              /* 启用严格的null检查. (为false时允许赋值为null)*/\n    // \"strictFunctionTypes\": true,           /* 启用严格检查函数类型. */\n    // \"strictBindCallApply\": true,           /* 启用函数上严格的“bind”、“call”和“apply”方法. */\n    // \"strictPropertyInitialization\": true,  /* 启用 严格检查类中的属性初始化. */\n    // \"noImplicitThis\": true,                /* 在隐含的“any”类型的“this”表达式上引发错误。 */\n    // \"alwaysStrict\": true,                  /* 以严格模式解析并为每个源文件发出“use strict”。 */\n\n    /* 附加检查。Additional Checks  */\n    // \"noUnusedLocals\": true,                /* 若有未使用的局部变量则抛错 */\n    // \"noUnusedParameters\": true,            /* 若有未使用的参数则抛错。 */\n    // \"noImplicitReturns\": true,             /* 不是函数的所有返回路径都有返回值时报错。*/\n    // \"noFallthroughCasesInSwitch\": true,    /* 报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿） */\n\n    /* 模块解析选项 */\n    // \"moduleResolution\": \"node\",            /* 决定如何处理模块：'node' (Node.js) or 'classic' (TypeScript pre-1.6). */\n    // \"baseUrl\": \"./\",                       /* 用于解析非绝对模块名称的基础目录。 */\n    // \"paths\": {},                           /* 模块名到基于 baseUrl的路径映射的列表。 */\n    // \"rootDirs\": [],                        /* List of root folders whose combined content represents the structure of the project at runtime. */\n    // \"typeRoots\": [],                       /* List of folders to include type definitions from. */\n    // \"types\": [],                           /* 要包含的类型声明文件名列表 */\n    // \"allowSyntheticDefaultImports\": true,  /* Allow default imports from modules with no default export. This does not affect code emit, just typechecking. */\n    \"esModuleInterop\": true                   /* 启用s emit interoperability between CommonJS and ES Modules via creation of namespace objects for all imports. Implies 'allowSyntheticDefaultImports'. */\n    // \"preserveSymlinks\": true,              /* Do not resolve the real path of symlinks. */\n    // \"allowUmdGlobalAccess\": true,          /* Allow accessing UMD globals from modules. */\n\n    /* Source Map Options */\n    // \"sourceRoot\": \"\",                      /* Specify the location where debugger should locate TypeScript files instead of source locations. */\n    // \"mapRoot\": \"\",                         /* Specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlineSourceMap\": true,               /* Emit a single file with source maps instead of having a separate file. */\n    // \"inlineSources\": true,                 /* Emit the source alongside the sourcemaps within a single file; requires '--inlineSourceMap' or '--sourceMap' to be set. */\n\n    /* Experimental Options */\n    // \"experimentalDecorators\": true,        /* 启用s experimental support for ES7 decorators. */\n    // \"emitDecoratorMetadata\": true,         /* 启用s experimental support for emitting type metadata for decorators. */\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n",normalizedContent:"# typescript 学习笔记\n\ntypescript 的类型校验是给程序员看的，在编译后不会存在ts代码。\n\n\n# 类型注解\n\nfunction fn(person: string):void{ // 参数类型是字符串，没有返回值\n    ///...\n}\nfn('str') // 如传递参数非字符串，vscode编辑器中或在编译时将给出错误提示\n\nconst test:number = 1\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 有哪些基础类型注解？\n\n// 基础类型\n:string\n:number\n:boolean\n\n:null  // 只能是null值\n:undefined // 只能是undefined值\n\n:symbol\n\n// 引用类型\n:object // 不常用，多使用接口来给对象进行类型注解\n\n// 其他\n:any  // 任意类型\n:void  // 空，用于函数的无返回值的注解\n:never // 用于标注函数代码永远执行不完（如抛出错误的函数，死循环函数）\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 什么是类型注解和类型推断、类型断言？\n\n类型注解 是显式的标注类型\n\n类型推断 是编辑器根据值来自动推断出类型 (编辑器中鼠标移到变量会显示类型的提示)。\n\n类型断言 是告诉编译器，“相信我，它就是这个类型”。\n\n// 类型注解就是显式的写出类型\nconst mynumber: number = 123\n\n// 类型推断是根据值来推断类型 (鼠标移到变量会显示类型(或直接显示值)的提示)\nconst mystring = 'test'\n\n// 类型断言（开发者明确知道是什么类型）\nconst somevalue:any = 'abc'\nconst strlength:number = (somevalue as string).length // 断言somevalue是字符串类型\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 对象的类型\n\n// 对象字面量的类型检查\nconst xiaojiejie: {\n  name: string,\n  age: number\n} = {\n  name: '小红',\n  age: 18\n}\n\n// 标注:object\nconst obj:object = {}\n\n// 使用接口\ninterface person{\n    name: string\n    age: number\n}\nconst xjj: person = {\n    name: 'xh',\n    age: 18\n}\n\n// class类的类型检查\nclass parson { }\nconst xiaobai: parson = new parson()\n\n// 函数和返回值的类型检查\nconst fn: ()=> string = () => '123'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# 函数的类型注解\n\n// 函数返回值的类型注解 fn(): number {}\nfunction gettotal2(one: number, two: number): number {\n  return one + two\n}\ngettotal2(1,2)\n\n\n// 无返回值: void\nfunction sayhello(): void {\n  console.log(\"hello\")\n}\n\n// 永远执行不玩的函数\nfunction settimer():never {\n  throw new error()\n  console.log(123)\n}\n\n// 参数是对象时的注解 （也可以用接口）\nfunction add({ one, two }: {one: number, two: number}) {\n  return  one + two\n}\n\nconst total = add({one: 1, two: 2})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 数组的类型注解\n\nconst numberarr: number[] = [1, 2, 3]\nconst stringarr: string[] = ['a', 'b']\nconst undefinedarr: undefined[] = [undefined, undefined]\nconst arr: (number | string | boolean)[] = [1, 'a', true, false] // 用到联合类型\n\n// 类型别名 type alias\ntype lady = { name: string, age: number }\n\nconst xiaojj: lady[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n// 或用类的方式\nclass ady2 {\n  name: string;\n  age: number;\n}\n\nconst xiaojj2: ady2[] = [\n  {\n    name: 'xiaojj',\n    age: 90\n  },\n  {\n    name: 'j',\n    age: 30\n  }\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 元组\n\n元组，可以理解为：已知元素数量和类型的数组\n\n// 联合类型\nconst xjj:(string | number)[] = ['a',22,'b'] // 规定整个数组当中可以有string或number\n\n// 元组注解 注意这里的注解只有一个中括号\nconst xjj1: [string, number, number] = ['a', 22, 33] // 规定了数组每个元素对应位置的类型\n\n// note: 在开发中元祖的使用在相对少\n\n\n// csv的方式定义数据格式； （二维数组时需要多加一个中括号）\nconst xjj2: [string, number, number][] = [\n  ['a', 22, 33],\n  ['a', 22, 33]\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 接口\n\n接口，可以理解为对象属性的类型描述。和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如type girl = string\n\ninterface girl { // 接口 （理解：对象属性的类型描述）\n  readonly name: string; // 只读属性 （定义之后不能再修改）\n  age: number;\n  waistline?: number; // 加个问号表示是可选值\n  [propname: string]: any; // 表示可以有不限制属性名的属性，但属性名需要是字符串，值可以是任意类型\n  say(): string; // 函数类型，返回值是string (如无返回值时是 void)。  say()也可以加入参数类型检查，如say(p:number)\n}\n// 和类型别名类似，不同的是 接口必须是一个对象，而别名可以直接是一个类型，如 type girl = string\n\n// 接口的继承\ninterface teacher extends girl {\n  teach(): string;\n}\n\n\nconst girl = {\n  name: '大脚',\n  age: 18,\n  sex: '女',\n  say() {\n    return '欢迎光临'\n  },\n  teach() {\n    return '教'\n  }\n}\n\n\nconst screenresume = ({ name, age, bust, sex }: girl) => {\n  console.log(name, age, bust, sex)\n}\nconst getresume = ({ name, age, bust, teach}: teacher) => {\n  teach();\n  console.log(name, age, bust)\n}\nscreenresume(girl)\ngetresume(girl)\n\n\n// 接口在class类中的使用\nclass xiaojjj implements girl {\n  name = \"xiaojj\"\n  age = 18\n  bust = 98\n  sex = '女'\n  say() {\n    return '欢迎光临'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n可索引的类型\n\ninterface arr {\n    [index: number]:string   // 表示通过索引访问数据时返回的类型是string\n}\n\nconst myarr:arr = ['1','2','3']\nconst mystr:string = myarr[1]\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# es6 class类中应用ts\n\n\n# class类的修饰器\n\n// 类的修饰器：\n// public (公共) 允许内外部使用\n// protected (受保护的) 允许在内部和继承内使用\n// private (私有) 允许在内部使用，但不能在继承中使用\n\n// 类的内部和外部，{}内属于内部，外面是外部\nclass person {\n   // public 内外都可以使用，可省略，不写时默认public。 protected只允许内部使用\n  name: string // 这里的string注释是ts使用的\n  private age: 18\n  public sayhello() {\n    console.log(this.name + this.age + 'say hello')\n  }\n}\n\nclass teacher2 extends person {\n  public saybye() {\n    console.log(this.name + ' say bye') // protected 可以在继承中使用到\n  }\n}\n\nconst person = new person();\nperson.name = 'test' // 在类的外部定义\nconsole.log(person.name)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# class类的构造函数中使用类型校验\n\nclass person2 {\n  constructor(public name: string) {\n    this.name = name\n  }\n}\n\nclass teacher3 extends person2{\n  constructor(public age: number) {\n    super('test-name') // 这里传的值是给person2的构造函数。即使父类没有构造函数，子类的构造函数内也要写super()\n  }\n}\nconst teacher3 = new teacher3(18)\nconsole.log(teacher3.name)\nconsole.log(teacher3.age)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# class类的getter、setter和static\n\nclass xjj {\n  constructor(private _age: number) { }\n  get age() {\n    return this._age - 10;\n  }  // 访问器属性，以属性的形式访问age，并可以对属性进行包装\n  set age(age: number) {\n    this._age = age+3;\n   }\n}\n\nconst dj = new xjj(28);\ndj.age = 25\n\nconsole.log(dj.age)\n\n\n// 静态属性 static。  静态属性指不需要通过实例化，直接通过girl.prop的方式就可以访问到属性\nclass girl {\n  static saylove() {\n    return 'i love you'\n  }\n}\n\n// const girl = new girl()\nconsole.log(girl.saylove())\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# class类的只读属性\n\n// 只读属性\nclass person {\n  public readonly _name: string // 只读属性\n  constructor(name: string) {\n    this._name = name;\n  }\n}\n\nconst person = new person('testname');\n// person._name = '222'; // 不能修改只读属性\nconsole.log(person._name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 抽象类\n\n/ 抽象类\nabstract class girls {\n  abstract skill(); // 注意这里只是定义抽象方法，而不具有方法的实现\n}\n\nclass waiter extends girls{ // 继承了抽象类之后要 实现抽象类内的成员\n  skill() {\n    console.log('大爷1')\n  }\n}\n\nclass baseteacher extends girls{\n  skill() {\n    console.log('大爷2')\n  }\n}\n\nclass seniorteacher extends girls{\n  skill() {\n    console.log('大爷3')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 联合类型和类型保护\n\n联合类型 指某个参数可以是多种类型。\n\n类型保护 指参数属于某个类型才有相应的操作。\n\ninterface waiter {\n  anjiao: boolean\n  say: () => {}\n}\n\ninterface teacher {\n  anjiao: boolean\n  skill: () => {}\n}\n\nfunction judgewho(animal: (waiter | teacher)) { // 联合类型\n  // 第一种断言方法\n  if (animal.anjiao) {\n    // (animal as teacher) 的意思是：断言 animal 是 teacher类型\n    (animal as teacher).skill()\n  } else {\n    (animal as waiter).say()\n  }\n\n  // 第二种断言方法\n  if ('skill' in animal) {\n    animal.skill()\n  } else {\n    animal.say()\n  }\n\n  // 第三种类型保护方法是使用typeof来判断 (代码省略)\n}\n\n\nclass numberobj {\n  count: number\n}\nfunction addobj(first: object | numberobj, second: object | numberobj) { // 联合类型\n  if (first instanceof numberobj && second instanceof numberobj) { // 类型保护\n    return first.count + second.count;\n  }\n  return 0;\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 枚举\n\n// enum枚举类型   (个人理解枚举：约定一组可选的常量。 使用常量名表示某个值的含义，增强可读性。)\n\n// js写法\n// const status = {\n//   massage: 0,\n//   spa: 1,\n//   dabaojian: 2\n// }\n\n// ts写法\nenum status {\n  massage,  // 如果想从1开始，给massage = 1, 即可\n  spa,\n  dabaojian\n} // 默认赋值 0 、1、2\n\nconsole.log(status.massage, status[0]) // 0, massage  可以通过下标反查\n\nfunction getstatus(status: any) {\n  if (status === status.massage) {\n    return 'massage'\n  } else if (status === status.spa) {\n    return 'spa'\n  } else if (status === status.dabaojian) {\n    return 'dabaojian'\n  }\n}\n\nconst result = getstatus(status.spa)\nconsole.log(result)\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 泛型\n\n泛型，最简单的理解：泛指的类型。（类似函数中的形参与实参）\n\n\n# 函数中的泛型使用\n\n\n// function join(first: string | number, second: string | number) {\n//   return `${first}${second}`\n// }\n// join('jspang', 1); // 如果我想第一个参数是字符串，第二个也必须是字符串，这么就用到泛型\n\n\n// 泛型使用，如同定义形参，在调用时指定类型\nfunction join<jspang>(first: jspang, second: jspang) {\n  return `${first}${second}`\n}\n\njoin<string>('jspang', '123');\njoin<number>(11, 22);\n\n// 泛型中数组的使用\nfunction myfun<any>(params:any[]) { // any[] or array<any>\n  return params\n}\nmyfun<string>(['a', 'b'])\n\n\n// 两个类型参数的使用（工作中，常用t表示泛型）\nfunction join2<t,p>(first: t, second: p) {\n  return `${first}${second}`\n}\n\njoin2<string,number>('jspang', 123);\njoin2<number, string>(11, '22');\njoin2(11, '22'); // 泛型也支持类型推断 （鼠标移到函数名有提示）\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# class类中使用泛型\n\n// class selectgirl {\n//   constructor(private girls: string[] | number[]) { } // private 私有的参数，外部无法修改\n//   getgirl(index: number): string | number {\n//     return this.girls[index]\n//   }\n// }\n\n// 使用泛型\nclass selectgirl<t> {   // 泛型的约束: <t extends number | string>\n  constructor(private girls: t[]) { } // private 私有的参数，外部无法修改\n  getgirl(index: number): t {\n    return this.girls[index]\n  }\n}\n\n// const selectgirl = new selectgirl<string>(['大脚', 'xiaohong', 'xiaobai'])\nconst selectgirl = new selectgirl<number>([101, 102, 103])\nconsole.log(selectgirl.getgirl(1))\n\n\n// 泛型中的继承\ninterface girl {\n  name: string\n}\nclass selectgirl2<t extends girl> { // 泛型t中必须有一个name属性，继承自girl接口\n  constructor(private girls: t[]) { } // private 私有的参数，外部无法修改\n  getgirl(index: number): string {\n    return this.girls[index].name\n  }\n}\n\nconst selectgirl2 = new selectgirl2([\n  {name: '大脚1'},\n  {name: '大脚2'},\n  {name: '大脚3'}\n])\n\nconsole.log(selectgirl2.getgirl(1))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 配置文件tsconfig.json\n\n// 此文件由命令 tsc -init 生成\n// 直接运行 tsc 命令就会运用此配置文件\n// 选项详解：https://www.tslang.cn/docs/handbook/compiler-options.html\n{\n  // \"include\": [\"demo15-1.ts\"],              // 要编译的指定文件，不配置此项时运行tsc默认编译全部\n  // \"files\": [\"demo15-1.ts\"],                // 和include类似\n  // \"exclude\": [\"demo15-3.ts\"],              // 要排除编译的指定文件\n  \"compileroptions\": { // 编译选项\n    /* 基本选项 */\n    // \"incremental\": true,                   /* 启用增量编译 */\n    \"target\": \"es5\",                          /* 指定 ecmascript 目标版本: 'es3' (default), 'es5', 'es2015', 'es2016', 'es2017', 'es2018', 'es2019' or 'esnext'. */\n    \"module\": \"commonjs\",                     /* 指定模块代码生成: 'none', 'commonjs', 'amd', 'system', 'umd', 'es2015', or 'esnext'. */\n    // \"lib\": [],                             /* 指定要包含在编译中的库文件. */\n    // \"allowjs\": true,                       /* 允许编译javascript文件*/\n    // \"checkjs\": true,                       /* 报告.js文件中的错误。 */\n    // \"jsx\": \"preserve\",                     /* 指定 jsx代码生成: 'preserve', 'react-native', or 'react'. */\n    // \"declaration\": true,                   /* 生成相应的 .d.ts文件 */\n    // \"declarationmap\": true,                /* 为每个相应的 .d.ts文件生成一个sourcemap (编译后代码对源码的映射)*/\n    \"sourcemap\": true,                        /* 生成源文件与输出文件的映射关系文件(.map)。*/\n    // \"outfile\": \"./\",                       /* 将输出文件合并为一个文件. */\n    \"outdir\": \"./build\",                      /* 输出的js文件目录。 */\n    \"rootdir\": \"./src\",                       /* ts源文件目录。 */\n    // \"composite\": true,                     /* 启用 项目编译 */\n    // \"tsbuildinfofile\": \"./\",               /* 指定用于存储增量编译信息的文件 */\n    // \"removecomments\": true,                /* 不输出注释到编译结果.（删除所有注释，除了以 /!*开头的版权信息。） */\n    // \"noemit\": true,                        /* 不发出输出.do not emit outputs. */\n    // \"importhelpers\": true,                 /* 从“tslib”导入发出助手. import emit helpers from 'tslib'. */\n    // \"downleveliteration\": true,            /* provide full support for iterables in 'for-of', spread, and destructuring when targeting 'es5' or 'es3'. */\n    // \"isolatedmodules\": true,               /* 将每个文件作为单独的模块（与“ts.transpilemodule”类似） */\n\n    /* 严格的类型检查选项 */\n    \"strict\": true,                           /* 启用所有严格类型检查选项。 打开此选项后，下面这些选项就不需要单独设置*/\n    // \"noimplicitany\": true,                 /* 对隐含的“any”类型的表达式和声明引发错误. (为false时允许any不用特意声明)*/\n    // \"strictnullchecks\": true,              /* 启用严格的null检查. (为false时允许赋值为null)*/\n    // \"strictfunctiontypes\": true,           /* 启用严格检查函数类型. */\n    // \"strictbindcallapply\": true,           /* 启用函数上严格的“bind”、“call”和“apply”方法. */\n    // \"strictpropertyinitialization\": true,  /* 启用 严格检查类中的属性初始化. */\n    // \"noimplicitthis\": true,                /* 在隐含的“any”类型的“this”表达式上引发错误。 */\n    // \"alwaysstrict\": true,                  /* 以严格模式解析并为每个源文件发出“use strict”。 */\n\n    /* 附加检查。additional checks  */\n    // \"nounusedlocals\": true,                /* 若有未使用的局部变量则抛错 */\n    // \"nounusedparameters\": true,            /* 若有未使用的参数则抛错。 */\n    // \"noimplicitreturns\": true,             /* 不是函数的所有返回路径都有返回值时报错。*/\n    // \"nofallthroughcasesinswitch\": true,    /* 报告switch语句的fallthrough错误。（即，不允许switch的case语句贯穿） */\n\n    /* 模块解析选项 */\n    // \"moduleresolution\": \"node\",            /* 决定如何处理模块：'node' (node.js) or 'classic' (typescript pre-1.6). */\n    // \"baseurl\": \"./\",                       /* 用于解析非绝对模块名称的基础目录。 */\n    // \"paths\": {},                           /* 模块名到基于 baseurl的路径映射的列表。 */\n    // \"rootdirs\": [],                        /* list of root folders whose combined content represents the structure of the project at runtime. */\n    // \"typeroots\": [],                       /* list of folders to include type definitions from. */\n    // \"types\": [],                           /* 要包含的类型声明文件名列表 */\n    // \"allowsyntheticdefaultimports\": true,  /* allow default imports from modules with no default export. this does not affect code emit, just typechecking. */\n    \"esmoduleinterop\": true                   /* 启用s emit interoperability between commonjs and es modules via creation of namespace objects for all imports. implies 'allowsyntheticdefaultimports'. */\n    // \"preservesymlinks\": true,              /* do not resolve the real path of symlinks. */\n    // \"allowumdglobalaccess\": true,          /* allow accessing umd globals from modules. */\n\n    /* source map options */\n    // \"sourceroot\": \"\",                      /* specify the location where debugger should locate typescript files instead of source locations. */\n    // \"maproot\": \"\",                         /* specify the location where debugger should locate map files instead of generated locations. */\n    // \"inlinesourcemap\": true,               /* emit a single file with source maps instead of having a separate file. */\n    // \"inlinesources\": true,                 /* emit the source alongside the sourcemaps within a single file; requires '--inlinesourcemap' or '--sourcemap' to be set. */\n\n    /* experimental options */\n    // \"experimentaldecorators\": true,        /* 启用s experimental support for es7 decorators. */\n    // \"emitdecoratormetadata\": true,         /* 启用s experimental support for emitting type metadata for decorators. */\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"小程序笔记",frontmatter:{title:"小程序笔记",date:"2019-12-25T14:27:01.000Z",permalink:"/note/wx-miniprogram",tags:["小程序"],categories:["前端","学习笔记"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/40.%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/40.学习笔记/40.小程序笔记.md",key:"v-cfb19bce",path:"/note/wx-miniprogram/",headers:[{level:2,title:"基础课程部分",slug:"基础课程部分",normalizedTitle:"基础课程部分",charIndex:12},{level:4,title:"微信公众平台",slug:"微信公众平台",normalizedTitle:"微信公众平台",charIndex:22},{level:5,title:"小程序文档API",slug:"小程序文档api",normalizedTitle:"小程序文档api",charIndex:129},{level:5,title:"微信开放社区",slug:"微信开放社区",normalizedTitle:"微信开放社区",charIndex:150},{level:4,title:"目录说明",slug:"目录说明",normalizedTitle:"目录说明",charIndex:168},{level:4,title:"文件说明",slug:"文件说明",normalizedTitle:"文件说明",charIndex:683},{level:5,title:"阻止事件冒泡",slug:"阻止事件冒泡",normalizedTitle:"阻止事件冒泡",charIndex:1765},{level:4,title:"第三方库",slug:"第三方库",normalizedTitle:"第三方库",charIndex:1806},{level:4,title:"云开发",slug:"云开发",normalizedTitle:"云开发",charIndex:1905},{level:5,title:"云开发三大基础能力",slug:"云开发三大基础能力",normalizedTitle:"云开发三大基础能力",charIndex:2120},{level:5,title:"云函数",slug:"云函数",normalizedTitle:"云函数",charIndex:2022},{level:5,title:"云数据库",slug:"云数据库",normalizedTitle:"云数据库",charIndex:2026},{level:5,title:"云存储",slug:"云存储",normalizedTitle:"云存储",charIndex:2031},{level:4,title:"云数据库能力",slug:"云数据库能力",normalizedTitle:"云数据库能力",charIndex:2281},{level:4,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:2321},{level:4,title:"操作云数据库",slug:"操作云数据库",normalizedTitle:"操作云数据库",charIndex:2435},{level:4,title:"云数据库权限管理",slug:"云数据库权限管理",normalizedTitle:"云数据库权限管理",charIndex:2506},{level:4,title:"操作云数据库",slug:"操作云数据库-2",normalizedTitle:"操作云数据库",charIndex:2435},{level:2,title:"实战课程部分",slug:"实战课程部分",normalizedTitle:"实战课程部分",charIndex:2769},{level:4,title:"serverless（无服务）",slug:"serverless-无服务",normalizedTitle:"serverless（无服务）",charIndex:2779},{level:4,title:"云开发优势",slug:"云开发优势",normalizedTitle:"云开发优势",charIndex:2856},{level:4,title:"云开发提供能力",slug:"云开发提供能力",normalizedTitle:"云开发提供能力",charIndex:2935},{level:4,title:"appID",slug:"appid",normalizedTitle:"appid",charIndex:3164},{level:4,title:"云开发项目默认目录结构",slug:"云开发项目默认目录结构",normalizedTitle:"云开发项目默认目录结构",charIndex:3185},{level:4,title:"云开发环境",slug:"云开发环境",normalizedTitle:"云开发环境",charIndex:4020},{level:4,title:"开发前的准备",slug:"开发前的准备",normalizedTitle:"开发前的准备",charIndex:4059},{level:4,title:"project.config.json 文件说明",slug:"project-config-json-文件说明",normalizedTitle:"project.config.json 文件说明",charIndex:4143},{level:4,title:"app.json",slug:"app-json",normalizedTitle:"app.json",charIndex:418},{level:4,title:"代码规范",slug:"代码规范",normalizedTitle:"代码规范",charIndex:5056},{level:4,title:"《音乐》页面开发",slug:"《音乐》页面开发",normalizedTitle:"《音乐》页面开发",charIndex:5114},{level:4,title:"自定义组件",slug:"自定义组件",normalizedTitle:"自定义组件",charIndex:5504},{level:5,title:"引入组件",slug:"引入组件",normalizedTitle:"引入组件",charIndex:5562},{level:5,title:"组件传值",slug:"组件传值",normalizedTitle:"组件传值",charIndex:5768},{level:4,title:"wx:key 的使用",slug:"wx-key-的使用",normalizedTitle:"wx:key 的使用",charIndex:6083},{level:4,title:"async/await 语法",slug:"async-await-语法",normalizedTitle:"async/await 语法",charIndex:6578},{level:4,title:"云函数的使用",slug:"云函数的使用",normalizedTitle:"云函数的使用",charIndex:6892},{level:5,title:"数据库操作",slug:"数据库操作",normalizedTitle:"数据库操作",charIndex:7668},{level:5,title:"查询数据库",slug:"查询数据库",normalizedTitle:"查询数据库",charIndex:10079},{level:5,title:"云函数调试",slug:"云函数调试",normalizedTitle:"云函数调试",charIndex:10806},{level:4,title:"定时触发云函数",slug:"定时触发云函数",normalizedTitle:"定时触发云函数",charIndex:10854},{level:4,title:"配置云函数超时时间",slug:"配置云函数超时时间",normalizedTitle:"配置云函数超时时间",charIndex:11183},{level:4,title:"上拉加载与下拉刷新",slug:"上拉加载与下拉刷新",normalizedTitle:"上拉加载与下拉刷新",charIndex:11269},{level:4,title:"云函数路由优化tcb-router",slug:"云函数路由优化tcb-router",normalizedTitle:"云函数路由优化tcb-router",charIndex:11708},{level:4,title:"本地存储（缓存）",slug:"本地存储-缓存",normalizedTitle:"本地存储（缓存）",charIndex:14135},{level:4,title:"api设置title",slug:"api设置title",normalizedTitle:"api设置title",charIndex:14356},{level:4,title:"背景播放音",slug:"背景播放音",normalizedTitle:"背景播放音",charIndex:14427},{level:4,title:"createSelectorQuery查询节点信息",slug:"createselectorquery查询节点信息",normalizedTitle:"createselectorquery查询节点信息",charIndex:14735},{level:4,title:"组件内的方法",slug:"组件内的方法",normalizedTitle:"组件内的方法",charIndex:15054},{level:4,title:"组件生命周期",slug:"组件生命周期",normalizedTitle:"组件生命周期",charIndex:15090},{level:5,title:"组件所在页面的生命周期",slug:"组件所在页面的生命周期",normalizedTitle:"组件所在页面的生命周期",charIndex:15198},{level:4,title:"组件对数据的监听",slug:"组件对数据的监听",normalizedTitle:"组件对数据的监听",charIndex:15426},{level:4,title:"子组件自定义事件传递给父组件",slug:"子组件自定义事件传递给父组件",normalizedTitle:"子组件自定义事件传递给父组件",charIndex:15558},{level:4,title:"父组件自定义事件传递给子组件",slug:"父组件自定义事件传递给子组件",normalizedTitle:"父组件自定义事件传递给子组件",charIndex:15788},{level:4,title:"兄弟组件间传递事件和传值",slug:"兄弟组件间传递事件和传值",normalizedTitle:"兄弟组件间传递事件和传值",charIndex:16001},{level:4,title:"获取手机信息",slug:"获取手机信息",normalizedTitle:"获取手机信息",charIndex:16425},{level:4,title:"滚动组件",slug:"滚动组件",normalizedTitle:"滚动组件",charIndex:16548},{level:4,title:"全局属性、方法（类似vuex）",slug:"全局属性、方法-类似vuex",normalizedTitle:"全局属性、方法（类似vuex）",charIndex:16671},{level:4,title:"消息提示框",slug:"消息提示框",normalizedTitle:"消息提示框",charIndex:17116},{level:2,title:"《发现》页面",slug:"《发现》页面",normalizedTitle:"《发现》页面",charIndex:17256},{level:4,title:"调用组件外部的样式",slug:"调用组件外部的样式",normalizedTitle:"调用组件外部的样式",charIndex:17266},{level:4,title:"组件插槽slot",slug:"组件插槽slot",normalizedTitle:"组件插槽slot",charIndex:17853},{level:4,title:"判断用户授权",slug:"判断用户授权",normalizedTitle:"判断用户授权",charIndex:18542},{level:4,title:"button的开发能力（获取用户信息）1",slug:"button的开发能力-获取用户信息-1",normalizedTitle:"button的开发能力（获取用户信息）1",charIndex:18933},{level:4,title:"原生组件",slug:"原生组件",normalizedTitle:"原生组件",charIndex:19514},{level:4,title:"选择上传图片",slug:"选择上传图片",normalizedTitle:"选择上传图片",charIndex:19756},{level:4,title:"图片裁剪",slug:"图片裁剪",normalizedTitle:"图片裁剪",charIndex:20092},{level:4,title:"获取标签自定义属性data-* （删除图片的实现）",slug:"获取标签自定义属性data-删除图片的实现",normalizedTitle:"获取标签自定义属性data-* （删除图片的实现）",charIndex:20216},{level:4,title:"全屏预览图片(点击图片放大预览)",slug:"全屏预览图片-点击图片放大预览",normalizedTitle:"全屏预览图片(点击图片放大预览)",charIndex:20858},{level:4,title:"文件上传云存储（发布博客例子）",slug:"文件上传云存储-发布博客例子",normalizedTitle:"文件上传云存储（发布博客例子）",charIndex:21069},{level:4,title:"js模块化 （时间格式化）",slug:"js模块化-时间格式化",normalizedTitle:"js模块化 （时间格式化）",charIndex:23073},{level:4,title:"阻止事件冒泡",slug:"阻止事件冒泡-2",normalizedTitle:"阻止事件冒泡",charIndex:1765},{level:4,title:"返回上一个页面并执行方法",slug:"返回上一个页面并执行方法",normalizedTitle:"返回上一个页面并执行方法",charIndex:23980},{level:4,title:"图片懒加载",slug:"图片懒加载",normalizedTitle:"图片懒加载",charIndex:24209},{level:4,title:"模糊查询",slug:"模糊查询",normalizedTitle:"模糊查询",charIndex:24382},{level:4,title:"提升模糊查询的效率 （添加索引，对数据量大的查询效果明显）",slug:"提升模糊查询的效率-添加索引-对数据量大的查询效果明显",normalizedTitle:"提升模糊查询的效率 （添加索引，对数据量大的查询效果明显）",charIndex:24996},{level:4,title:"小程序端调用云数据库",slug:"小程序端调用云数据库",normalizedTitle:"小程序端调用云数据库",charIndex:25103},{level:4,title:"云数据库权限管理",slug:"云数据库权限管理-2",normalizedTitle:"云数据库权限管理",charIndex:2506},{level:4,title:"数据库中1对N关系的三种设计方式",slug:"数据库中1对n关系的三种设计方式",normalizedTitle:"数据库中1对n关系的三种设计方式",charIndex:25551},{level:5,title:"第一种：N的数量较少 几十个以内",slug:"第一种-n的数量较少-几十个以内",normalizedTitle:"第一种：n的数量较少 几十个以内",charIndex:25571},{level:5,title:"第二种：N的数量较多  几十到几百个",slug:"第二种-n的数量较多-几十到几百个",normalizedTitle:"第二种：n的数量较多  几十到几百个",charIndex:null},{level:5,title:"第三种：N的数量巨大  几百成千上万个",slug:"第三种-n的数量巨大-几百成千上万个",normalizedTitle:"第三种：n的数量巨大  几百成千上万个",charIndex:null},{level:4,title:"云调用",slug:"云调用",normalizedTitle:"云调用",charIndex:3046},{level:4,title:"模板消息推送",slug:"模板消息推送",normalizedTitle:"模板消息推送",charIndex:26659},{level:4,title:"云函数多集合查询数据库",slug:"云函数多集合查询数据库",normalizedTitle:"云函数多集合查询数据库",charIndex:28211},{level:4,title:"分享功能",slug:"分享功能",normalizedTitle:"分享功能",charIndex:29361},{level:4,title:"不同场景获取用户信息的方式",slug:"不同场景获取用户信息的方式",normalizedTitle:"不同场景获取用户信息的方式",charIndex:29980},{level:5,title:"场景一：只想在界面上显示自己的昵称和头像",slug:"场景一-只想在界面上显示自己的昵称和头像",normalizedTitle:"场景一：只想在界面上显示自己的昵称和头像",charIndex:29997},{level:5,title:"场景二：在JS中获取用户信息",slug:"场景二-在js中获取用户信息",normalizedTitle:"场景二：在js中获取用户信息",charIndex:30187},{level:5,title:"场景三：获取openId",slug:"场景三-获取openid",normalizedTitle:"场景三：获取openid",charIndex:31526},{level:2,title:"《我的》页面",slug:"《我的》页面",normalizedTitle:"《我的》页面",charIndex:32263},{level:4,title:"导航页面链接跳转",slug:"导航页面链接跳转",normalizedTitle:"导航页面链接跳转",charIndex:32357},{level:4,title:"背景图片",slug:"背景图片",normalizedTitle:"背景图片",charIndex:32380},{level:4,title:"每个页面都有的page标签",slug:"每个页面都有的page标签",normalizedTitle:"每个页面都有的page标签",charIndex:32453},{level:4,title:"播放历史与本地存储",slug:"播放历史与本地存储",normalizedTitle:"播放历史与本地存储",charIndex:32518},{level:4,title:"我的发现",slug:"我的发现",normalizedTitle:"我的发现",charIndex:34189},{level:4,title:"小程序码",slug:"小程序码",normalizedTitle:"小程序码",charIndex:26668},{level:5,title:"判断是从扫码小程序码进入，以及参数获取",slug:"判断是从扫码小程序码进入-以及参数获取",normalizedTitle:"判断是从扫码小程序码进入，以及参数获取",charIndex:35155},{level:3,title:"版本更新检测",slug:"版本更新检测",normalizedTitle:"版本更新检测",charIndex:35297},{level:3,title:"性能优化",slug:"性能优化",normalizedTitle:"性能优化",charIndex:35892},{level:3,title:"场景值scene的作用与应用场景",slug:"场景值scene的作用与应用场景",normalizedTitle:"场景值scene的作用与应用场景",charIndex:35951},{level:3,title:'小程序的"SEO"---页面收录sitemap',slug:"小程序的-seo-页面收录sitemap",normalizedTitle:"小程序的&quot;seo&quot;---页面收录sitemap",charIndex:null},{level:3,title:"小程序上线审核流程",slug:"小程序上线审核流程",normalizedTitle:"小程序上线审核流程",charIndex:36998},{level:2,title:"后台管理系统",slug:"后台管理系统",normalizedTitle:"后台管理系统",charIndex:37044},{level:4,title:"架构示意图",slug:"架构示意图",normalizedTitle:"架构示意图",charIndex:37054},{level:4,title:"vue-admin-template构建管理系统前端",slug:"vue-admin-template构建管理系统前端",normalizedTitle:"vue-admin-template构建管理系统前端",charIndex:37164},{level:4,title:"Koa2构建管理系统后端",slug:"koa2构建管理系统后端",normalizedTitle:"koa2构建管理系统后端",charIndex:37289},{level:4,title:"接口调用凭证 access_token 的缓存与更新",slug:"接口调用凭证-access-token-的缓存与更新",normalizedTitle:"接口调用凭证 access_token 的缓存与更新",charIndex:37926},{level:4,title:"后端代码通过HTTP API 触发云函数获取数据",slug:"后端代码通过http-api-触发云函数获取数据",normalizedTitle:"后端代码通过http api 触发云函数获取数据",charIndex:40173},{level:4,title:"产生跨域和后端解决跨域问题",slug:"产生跨域和后端解决跨域问题",normalizedTitle:"产生跨域和后端解决跨域问题",charIndex:40217},{level:4,title:"云数据库的增删改查接口",slug:"云数据库的增删改查接口",normalizedTitle:"云数据库的增删改查接口",charIndex:40733},{level:4,title:"后端获取前端post请求传来的数据",slug:"后端获取前端post请求传来的数据",normalizedTitle:"后端获取前端post请求传来的数据",charIndex:40757},{level:4,title:"后端获取云存储图片",slug:"后端获取云存储图片",normalizedTitle:"后端获取云存储图片",charIndex:41145},{level:4,title:"后端上传图片到云存储",slug:"后端上传图片到云存储",normalizedTitle:"后端上传图片到云存储",charIndex:41505}],headersStr:'基础课程部分 微信公众平台 小程序文档API 微信开放社区 目录说明 文件说明 阻止事件冒泡 第三方库 云开发 云开发三大基础能力 云函数 云数据库 云存储 云数据库能力 数据类型 操作云数据库 云数据库权限管理 操作云数据库 实战课程部分 serverless（无服务） 云开发优势 云开发提供能力 appID 云开发项目默认目录结构 云开发环境 开发前的准备 project.config.json 文件说明 app.json 代码规范 《音乐》页面开发 自定义组件 引入组件 组件传值 wx:key 的使用 async/await 语法 云函数的使用 数据库操作 查询数据库 云函数调试 定时触发云函数 配置云函数超时时间 上拉加载与下拉刷新 云函数路由优化tcb-router 本地存储（缓存） api设置title 背景播放音 createSelectorQuery查询节点信息 组件内的方法 组件生命周期 组件所在页面的生命周期 组件对数据的监听 子组件自定义事件传递给父组件 父组件自定义事件传递给子组件 兄弟组件间传递事件和传值 获取手机信息 滚动组件 全局属性、方法（类似vuex） 消息提示框 《发现》页面 调用组件外部的样式 组件插槽slot 判断用户授权 button的开发能力（获取用户信息）1 原生组件 选择上传图片 图片裁剪 获取标签自定义属性data-* （删除图片的实现） 全屏预览图片(点击图片放大预览) 文件上传云存储（发布博客例子） js模块化 （时间格式化） 阻止事件冒泡 返回上一个页面并执行方法 图片懒加载 模糊查询 提升模糊查询的效率 （添加索引，对数据量大的查询效果明显） 小程序端调用云数据库 云数据库权限管理 数据库中1对N关系的三种设计方式 第一种：N的数量较少 几十个以内 第二种：N的数量较多  几十到几百个 第三种：N的数量巨大  几百成千上万个 云调用 模板消息推送 云函数多集合查询数据库 分享功能 不同场景获取用户信息的方式 场景一：只想在界面上显示自己的昵称和头像 场景二：在JS中获取用户信息 场景三：获取openId 《我的》页面 导航页面链接跳转 背景图片 每个页面都有的page标签 播放历史与本地存储 我的发现 小程序码 判断是从扫码小程序码进入，以及参数获取 版本更新检测 性能优化 场景值scene的作用与应用场景 小程序的"SEO"---页面收录sitemap 小程序上线审核流程 后台管理系统 架构示意图 vue-admin-template构建管理系统前端 Koa2构建管理系统后端 接口调用凭证 access_token 的缓存与更新 后端代码通过HTTP API 触发云函数获取数据 产生跨域和后端解决跨域问题 云数据库的增删改查接口 后端获取前端post请求传来的数据 后端获取云存储图片 后端上传图片到云存储',content:'# 小程序笔记\n\n\n# 基础课程部分\n\n# 微信公众平台\n\nhttps://mp.weixin.qq.com/\n\n注册时可选择类型：订阅号、服务号、小程序、企业微信\n\n每个邮箱仅能注册一个小程序。\n\n个人类型小程序：无法使用微信支付、无法使用卡包功能\n\n# 小程序文档API\n\n小程序开发文档\n\n# 微信开放社区\n\n微信开发社区\n\n# 目录说明\n\n默认目录\n\npages-----------------------页面相关\n\nindex ----------------- 首页文件夹\n\nindex.js ------------首页js\n\nindex.json---------首页配置\n\nindex.wxml-------首页html\n\nindex.wxss--------首页css\n\nutils------------------------工具相关\n\napp.js ----------------------项目总js\n\napp.json-------------------全局配置( 页面路由以及头部、底部导航的配置等)\n\napp.wxss -----------------项目总样式css\n\nproject.config.json ----项目配置\n\n代码构成\n\n.json ：配置文件，以json格式存储配置\n\n项目中有三种配置：项目配置（project.config.json）、全局配置（app.json）、页面配置（index.json）\n\n.wxml: 相当于html文件\n\n.wxss: 相当于css\n\n.js : 就是js\n\n# 文件说明\n\nproject.config.json项目配置 部分代码说明\n\nsetting：{\n\nurlCheck 是否检测安全的域名\n\nes6 是否把es6转es5\n\npostcss 是否把css样式自动补全\n\nminified 是否压缩\n\n}\n\napp.json 全局配置\n\n全局配置API\n\nwxml 相关介绍\n\nwxmlAPI\n\n<view>{{motto}}</view>\n\n循环渲染\n<view wx:for="{{list}}" wx:key="{{index}}">\n      {{index}} {{item}}\n</view>\n\n改变for循环item和index的名称\n<block wx:for="{{list}}" wx:for-item="data" wx:for-index="inx">\n\t{{inx}} {{data}}\n</block>\n\n条件渲染 (类似vue的v-if、v-else)\n<view wx:if="{{isLogin}}">已登录</view>\n<view wx:else>请登录</view>\n\n条件显示（类似vue的v-show）\n<view hidden="{{isLogin}}">显示内容</view>\n\n绑定点击事件\n<button bindtap=“tapName”>按钮</button>\n\nPage({\n  tapName: function(event) {\n    console.log(event)\n  }\n})\n...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nwxss 相关介绍\n\nwxssAPI\n\n尺寸单位：rpx，根据屏幕宽度自适应。\n\n引入外部wxss：@import ’...‘\n\njs相关介绍\n\nWXS（WeiXin Script）是小程序的一套脚本语言\n\nwxsAPI\n\n绑定点击事件\n\n<button bindtap=“onTapHandler”>点我+1</button>\n<view>{{count}}</view>\n\n\n1\n2\n\n\nPage({\n  data: {\n    count: 0\n  },\n  onTapHandler: function() {\n  \tthis.setData({\n  \t\tcount: this.data.count++\n  \t})\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 阻止事件冒泡\n\n把绑定方式 bindtap 换成 catchtap 即可。\n\n# 第三方库\n\nWeUI\n\nweUI是一套同微信原生视觉体验一致的基础样式库\n\niView Weapp\n\n一套高质量的微信小程序UI组件库\n\nVant Weapp\n\n轻量、可靠的小程序UI组件库\n\n# 云开发\n\n小程序传统开发模式\n\n客户端 -----\x3e 服务端（后端代码、数据库）------\x3e 运维（DB维护、文件存储、内容加速、网络防护、容器服务、负载均衡、安全加固等...）\n\n小程序云开发模式\n\n客户端 -----\x3e 云开发（云函数、云数据库、云存储）\n\n传统开发 VS 云开发\n\n开发效率低 Serverless（无服务）\n\n运维成本高 开发者更关注业务逻辑\n\n无服务（Serverless）开发是未来的发展趋势\n\n# 云开发三大基础能力\n\n# 云函数\n\n（相当于传统开发中的后台接口）\n\n获取appid、获取openid、生成分享图、调用腾讯云SDK ...\n\n# 云数据库\n\n数据的增、删、改、查 ...\n\n# 云存储\n\n管理文件、上传文件、下载文件、分享文件 ...\n\n每个小程序账号可免费创建两个环境，建议：开发环境、生成环境\n\n# 云数据库能力\n\n云开发提供了一个json数据库，提供2GB免费存储空间。\n\n# 数据类型\n\nString 字符串\n\nNumber 数字\n\nObject 对象\n\nArray 数组\n\nBoolean 布尔值\n\nGeoPoint 地理位置点\n\nDate 时间 （精确到毫秒ms，客户端时间）\n\nNull 空\n\n# 操作云数据库\n\n小程序控制（读写数据库受权限限制）\n\n云函数控制（拥有所有读写数据库的权限）\n\n控制台控制（拥有所有读写数据库的权限）\n\n# 云数据库权限管理\n\n仅创建者可写，所有人可读 （适合于文章）\n\n仅创建者可读写 (适用于私密内容)\n\n仅管理端可写，所有人可读（适用于商品信息）\n\n仅管理端可读写（适用于后台敏感数据）\n\n# 操作云数据库\n\n//初始化数据库\nconst db = wx.cloud.database() // 小程序端初始化数据库，如果在云函数端不需要加wx\n\n//切换环境(开发环境/生产环境)\nconst testDB = wx.cloud.database({\n\tenv: \'test\'\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 实战课程部分\n\n# serverless（无服务）\n\n概念：函数即服务，当需要后端服务的时候，不需要关心后端的IP地址、域名，只需要像调用普通函数一样既可以实现调用。\n\n# 云开发优势\n\n快速上线、专注核心业务、独立开发一个完整的微信小程序、不需要学习新的语言，只需要会javascript、无需运维， 节约成本、数据安全、\n\n# 云开发提供能力\n\n云函数：在云端运行的代码，微信私有协议天然鉴权 （理解：相当于后端部分）\n\n云数据库：一个既可以在小程序端操作又可以在云函数中操作的JSON数据库\n\n云存储：在云端存储文件，可以在云端控制台可视化管理\n\n云调用：基于云函数免鉴权使用小程序开放接口的能力（比如说给用户推送消息等）\n\nHTTP API：使用HTTP API开发者可在已有服务器上访问云资源，实现与云开发的互通（作用：对原有传统模式下开发的小程序，可以与云开发进行互通）\n\n# appID\n\n每个小程序唯一的id\n\n# 云开发项目默认目录结构\n\ncloudfunctions ----------------------------云函数\n\ncallback ---------------------------------- 回调函数\n\nconfig.json ---------------------------\n\nindex.js --------------------------------\n\npackage.json ------------------------\n\necho ----------------------------------------\n\nlogin ----------------------------------------\n\nopenapi -----------------------------------\n\nminiprogram ------------------------------- 小程序\n\nimages ------------------------------------- 图片\n\npages --------------------------------------- 页面\n\nstyle ----------------------------------------- 样式\n\napp.js --------------------------------------- 项目js\n\napp.json ----------------------------------- 全局配置\n\napp.wxss ---------------------------------- 项目样式\n\nsitemap.json ----------------------------- （小程序SEO相关）\n\nproject.config.json ----------------------- 项目配置\n\n# 云开发环境\n\n云开发可创建两个环境，建议一个为开发环境，一个为生产环境\n\n# 开发前的准备\n\n开发工具 > 右上角详情 > 本地设置 > 调试基础库 设置为最新版本\n\napp.js > wx.cloud.init > env 设置环境ID\n\n# project.config.json 文件说明\n\nminiprogramRoot 小程序前端代码目录\n\ncloudfunctionRoot 云函数代码目录\n\n# app.json\n\npages 设置页面 ，设置后会自动在pages目录下生成相应的目录和文件\n\n设置底部导航按钮：\n\n"tabBar": {\n    "color": "#474747", // 文字颜色\n    "selectedColor": "#d43c43", // 文字选中颜色\n    "list": [{ // 按钮列表，2-5项\n      "pagePath": "pages/playlist/playlist", // 按钮对应页面\n      "text": "音乐", // 文字\n      "iconPath": "images/music.png", // 图标路径\n      "selectedIconPath": "images/music-actived.png" // 选中图标的路径\n    },\n    {\n      "pagePath": "pages/blog/blog",\n      "text": "发现",\n      "iconPath": "images/blog.png",\n      "selectedIconPath": "images/blog-actived.png"\n    },\n    {\n      "pagePath": "pages/profile/profile",\n      "text": "我的",\n      "iconPath": "images/profile.png",\n      "selectedIconPath": "images/profile-actived.png"\n    }]\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 图标来自于 https://www.iconfont.cn\n> \n> 阿里巴巴图标库，包含矢量图标、字体图标、字体等\n\n# 代码规范\n\n很多公司借鉴的代码规范：https://github.com/airbnb/javascript\n\n# 《音乐》页面开发\n\n \x3c!-- 轮播图组件 参数：indicator-dots 小圆点，autoplay 自动播放, interval 间隔时间，duration 动画时长 --\x3e\n<swiper indicator-dots="true" circular="true" interval="3000" duration="500">\n  <block wx:for="{{swiperImgUrls}}" wx:key="{{index}}"> \x3c!-- 空节点 --\x3e\n    <swiper-item>\n      <image src="{{item.url}}" mode="widthFix" class="img"></image>\n    </swiper-item>\n  </block>\n</swiper>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 自定义组件\n\n创建组件\n\n创建目录 components > 组件目录名称 > 右键 新建Component\n\n# 引入组件\n\n在page的json文件中：\n\n{\n  "usingComponents": {\n    "x-playlist":"/components/playlist/playlist"\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n在page的wxml中：\n\n<x-playlist> </x-playlist>\n\n\n1\n\n\n页面引入组件以及组件内部在引用子组件的方法是一样的，同样需要设置json文件。\n\n# 组件传值\n\n父组件中：在引入组件的时候自定义属性名称，并把数据传入子组件\n\n\x3c!-- 参数：playlist 自定义名称，传入组件的数据 --\x3e\n<x-playlist playlist="{{传入的数据}}"></x-playlist>\n\n\n1\n2\n\n\n子组件中： 子组件的js文件：\n\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    playlist:{ // 接收父组件传输的数据\n      type: Object // 数据类型\n    }\n   },\n\n //子组件的wxml文件可直接引入数据{{playlist}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# wx:key 的使用\n\nkey的值不建议使用index，因为当数据发生变化会dom结构产生变化时，使用index的地方不会随之变化。\n\n可以使用数据内部每项不一样的一个数值，如id\n\n<block wx:for="{{swiperImgUrls}}" wx:key="url"> 这里url不需要双大括号，如使用index则需要{{}}\n    <view>\n      <image src="{{item.url}}" mode="widthFix" class="img"></image>\n    </view>\n</block>\n\n<view class="playlist-container">\n  <block wx:for="{{playlist}}" wx:key="_id">\n    \x3c!-- 参数：playlist 自定义名称，传入组件的数据 --\x3e\n    <x-playlist playlist="{{item}}"></x-playlist>\n  </block>\n</view>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# async/await 语法\n\n目前，在云函数里，由于 Node 版本最低是 8.9，因此是天然支持 async/await 语法的。而在小程序端则不然。在微信开发者工具里，以及 Android 端手机（浏览器内核是 QQ浏览器的 X5），async/await是天然支持的，但 iOS 端手机在较低版本则不支持，因此需要引入额外的 文件。\n\n可把这个 runtime.js 文件引用到有使用 async/await 的文件当中。\n\n// 注意，必须命名为 regeneratorRuntime\nimport regeneratorRuntime from \'../../utils/runtime.js\'\n\n\n1\n2\n\n\n# 云函数的使用\n\ncloudfunctions目录 右键 新建 Node.js 云函数 > 输入目录名 getPlaylist\n\n在云函数中向第三方服务器发送请求要依赖第三方库\n\n安装依赖包\n\n云函数目录 getPlaylist 右键 在终端打开 打开命令行 输入命令：\n\nnpm install --save request\nnpm install --save request-promise\n\n\n1\n2\n\n\ngithub request-promise：https://github.com/request/request-promise\n\n然后写相应代码\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst rp = require(\'request-promise\') // 需安装依赖包\n\nconst URL = \'http://musicapi.xiecheng.live/personalized\'\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const playlist = await rp(URL).then((res) => {\n    return JSON.parse(res).result\n  })\n  console.log(playlist)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n写完代码，云函数目录 getPlaylist 右键 上传并部署：云端安装依赖（不上传node_modules） 进行上传部署代码到云端，等待上传成功，打开云开发控制台即可看到已经上传的云函数，并可对云函数进行测试。\n\n# 数据库操作\n\n数据库> 创建集合 > playlist\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst db = cloud.database() // 初始化数据库,如果在小程序端初始化数据库需要在前面加wx.\n\nconst rp = require(\'request-promise\') // 需安装依赖包\n\nconst URL = \'http://musicapi.xiecheng.live/personalized\' // 第三方服务器地址（老师从网易云获取的数据部署在其服务器，每天的数据会更新）\n\nconst playlistCollection = db.collection(\'playlist\') // 获取到数据库playlist集合\n\nconst MAX_LIMIT = 10 // 定义常量，获取数据库条数最大的限制\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  /**\n   * 注：\n   * - 关于数据库的操作都是异步操作，都需添加await关键字\n   * - console.log 打印在云开发控制台 云函数测试内查看\n   * - 单次获取数据库数据有条数限制，云函数端最多获取100条，小程序端最多获取20条\n   */\n\n  // const list = await playlistCollection.get() // 获取数据库集合的数据 （因为有条数限制，不直接用此方法）\n\n  // 突破条数限制 （为了读取到全部数据然后与第三方服务器获取的数据进行对比去重）\n  const countResult = await playlistCollection.count() // 获取数据总条数 返回为对象\n  const total = countResult.total // 取得总条数\n  const batchTimes = Math.ceil(total / MAX_LIMIT)\n  const tasks = []\n  for(let i = 0; i < batchTimes; i++) {\n    let promise = playlistCollection.skip(i * MAX_LIMIT).limit(MAX_LIMIT).get() // 从第 skip 条开始取，最多取 limit 条数据\n    tasks.push(promise)\n  }\n  let list = {\n    data: []\n  }\n  if (tasks.length > 0) {\n    list = (await Promise.all(tasks)).reduce((acc, cur) => { // reduce数组方法 累积拼接\n      return {\n        data: acc.data.concat(cur.data)\n      }\n    })\n  }\n\n  // 获取第三方服务器端数据\n  const playlist = await rp(URL).then((res) => {\n    return JSON.parse(res).result\n  })\n\n  // 数据库与服务器数据对比去重（数据已存在数据库的无需再重复添加）\n  const newData = []\n  for(let i = 0, len1 = playlist.length; i < len1; i++) {\n    let flag = true\n    for(let j = 0, len2 = list.data.length; j < len2; j++) {\n      if(playlist[i].id === list.data[j].id){\n        flag = false\n        break\n      }\n    }\n    if(flag){\n      newData.push(playlist[i])\n    }\n  }\n\n  // 把数据插入数据库，需要单条插入\n  for (let i = 0, len = newData.length; i < len; i++) {\n    await playlistCollection.add({ // 给数据库集合添加数据\n      data: {\n        ...newData[i],\n        createTime: db.serverDate(), // db.serverDate() 获取服务器时间\n      }\n    }).then((res) => { // 数据添加成功\n      console.log(\'数据添加成功\')\n    }).catch((err) => { // 失败\n      console.error(err)\n    })\n  }\n  return newData.length // 插入多少条数据\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n# 查询数据库\n\n//云函数中查询数据库的例子：\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst TcbRouter = require(\'tcb-router\')\nconst db = cloud.database() // 初始化数据库\nconst blogCollection = db.collection(\'blog\') // 博客的数据库集合\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const app = new TcbRouter({ event }) // 初始化TcbRouter\n\n  app.router(\'list\', async (ctx, next) => {\n    // skip 从第几条开始查，limit 查几条数据，orderBy(排序字段，排序方式) 排序，排序方式desc降序/asc升序\n    ctx.body =  await blogCollection.skip(event.start).limit(event.count)\n    .orderBy(\'createTime\', \'desc\').get().then((res) => {\n      return res.data\n    })\n\n  })\n\n\n  return app.serve() // 必需返回\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 云函数调试\n\n云控制台中可会云函数进行云端测试\n\n在小程序调用云函数后，可查看云函数日志\n\n# 定时触发云函数\n\n如果云函数需要定时 / 定期执行，也就是定时触发，我们可以使用云函数定时触发器。配置了定时触发器的云函数，会在相应时间点被自动触发，函数的返回结果不会返回给调用方\n\n云函数目录下新建 config.json\n\nAPI\n\n{\n  "triggers": [\n    {\n      "name": "myTriggers",\n      "type": "timer",\n      "config":"0 0 10,14,16,20 * * * *" //表示每天的10点、14点、16点、20点触发一次\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n编辑好触发器之后，要在云函数目录 > 右键 > 上传触发器\n\n# 配置云函数超时时间\n\n当云函数比较复杂的时候，默认的超时时间3秒可能不能够满足需求，可以适当的设置更为合理的时间\n\n云开发控制台 > 云函数 > 配置 > 超时时间\n\n# 上拉加载与下拉刷新\n\npage页面json中：\n"enablePullDownRefresh": true\n\n\npage页面js中有这两个函数：\n\n /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onPullDownRefresh: function() {\n\t this.setData({\n      playlist: []\n    })\n    this._getPlaylist()\n  },\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onReachBottom: function() {\n    this._getPlaylist()\n  },\n\n\n\n 下拉刷新请求完数据后\n wx.stopPullDownRefresh() // 停止下拉刷新动画\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 云函数路由优化tcb-router\n\n一个用户在一个云环境只能创建50个云函数\n\n假如小程序非常复杂，50个云函数不能够满足业务需求怎么办？\n\n相似的请求归类到同一个云函数处理\n\ntcb-router是一个koa风格的云函数路由库\n\n通俗理解就是可以把很多个接口归类到同一个云函数内。\n\ngithub-tcb-router: https://github.com/TencentCloudBase/tcb-router\n\nkoa洋葱模型...\n\n安装：\n\n在使用到tcb-router的云函数目录下打开命令行，输入命令进行安装\nnpm install --save tcb-router\n\n\n1\n2\n\n\n// 云函数的 index.js\nconst TcbRouter = require(\'router\'); // 必需\n\nexports.main = (event, context) => {\n    const app = new TcbRouter({ event });// 必需\n\n    // app.use 表示该中间件会适用于所有的路由(全局中间件) 非必需\n    app.use(async (ctx, next) => { // 这个中间件表示所有路由都会调用到，而路由中间件为单独调用\n        ctx.data = {}; // 获取要传给小程序端的数据\n        ctx.data.openId = event.userInfo.openId // 这里获取到的openId将分布到所有路由\n        await next(); // 执行下一中间件\n    });\n\n    // 路由为数组表示，该中间件适用于 user 和 timer 两个路由\n    app.router([\'user\', \'timer\'], async (ctx, next) => {\n        ctx.data.company = \'Tencent\'; // 这里获取到的数据将分布到 user 和 timer 两个路由\n        await next(); // 执行下一中间件\n    });\n\n    // 路由为字符串，该中间件只适用于 user 路由\n    app.router(\'user\', async (ctx, next) => {\n        ctx.data.name = \'heyli\';  // 获取要传给小程序端的数据\n        await next(); // 执行下一中间件\n    }, async (ctx, next) => {\n        ctx.data.sex = \'male\'; // 获取要传给小程序端的数据\n        await next(); // 执行下一中间件\n    }, async (ctx) => {\n        ctx.data.city = \'Foshan\'; // 获取要传给小程序端的数据\n        // ctx.body 返回数据到小程序端\n        ctx.body = { code: 0, data: ctx.data};  // 要传给小程序端的数据\n    });\n\n    // 路由为字符串，该中间件只适用于 timer 路由\n    app.router(\'timer\', async (ctx, next) => {\n        ctx.data.name = \'flytam\';\n        await next(); // 执行下一中间件\n    }, async (ctx, next) => {\n        ctx.data.sex = await new Promise(resolve => {\n        // 等待500ms，再执行下一中间件\n        setTimeout(() => {\n            resolve(\'male\');\n        }, 500);\n        });\n        await next(); // 执行下一中间件\n    }, async (ctx)=>  {\n        ctx.data.city = \'Taishan\';\n\n        // ctx.body 返回数据到小程序端\n        ctx.body = { code: 0, data: ctx.data };\n    });\n\n    return app.serve(); // 必需\n\n}\n\n\n小程序端：\n\n// 调用名为 router 的云函数，路由名为 user\nwx.cloud.callFunction({\n    // 要调用的云函数名称\n    name: "router",\n    // 传递给云函数的参数\n    data: {\n        $url: "user", // 要调用的路由的路径，传入准确路径或者通配符*\n        other: "xxx"\n    }\n}).then((res) => {\n\tconsole.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n上面tcb-router代码会按照洋葱模型执行，即先从上往下逐个进入中间件，再从下往上逐个退出中间件。\n\n# 本地存储（缓存）\n\n// 存储：\nwx.setStorageSync(key, data) // 同步存储（存储成功再继续下一步操作）\nwx.setStorage(key, data) // 异步存储（即使存储没成功也会执行下一步代码）、\n\n// 读取：\nwx.getStorageSync(key) // 同步 （读取到数据在进行下一步操作）\nwx.setStorage(key) // 异步\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# api设置title\n\nwx.setNavigationBarTitle({\n      title: \'\',\n})\n\n\n1\n2\n3\n\n\n# 背景播放音\n\nBackgroundAudioManager 全局唯一的背景音频管理器\n\n// 需要在app.json配置，才能使用后台音乐播放的能力\n\n"requiredBackgroundModes": ["audio", "location"]\n\n\n1\n2\n3\n\n\n// 获取全局唯一的背景音频管理器\nconst backgroundAudioManager = wx.getBackgroundAudioManager()\n\n\nbackgroundAudioManager.src = 音频链接\nbackgroundAudioManager.title = 音频标题\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# createSelectorQuery查询节点信息\n\ncreateSelectorQuery 小程序的方法，用于查询节点等操作\n\nconst query = wx.createSelectorQuery()\nquery.select(\'#the-id\').boundingClientRect() // 节点的布局信息\nquery.selectViewport().scrollOffset()\nquery.exec(function(res){\n  res[0].top       // #the-id节点的上边界坐标\n  res[1].scrollTop // 显示区域的竖直滚动位置\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 组件内的方法\n\nComponent(Object object)\n\n# 组件生命周期\n\nlifetimes\n\n// 生命周期\nlifetimes: {\n    ready() { // 在组件在视图层布局完成后执行\n   \t ...\n    }\n},\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 组件所在页面的生命周期\n\nComponent({\n  pageLifetimes: {\n    show: function() {\n      // 页面被展示\n    },\n    hide: function() {\n      // 页面被隐藏\n    },\n    resize: function(size) {\n      // 页面尺寸变化\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 组件对数据的监听\n\nobservers\n\nobservers: { // 对数据的监听(数据初次加载完成也会执行)\n    监听的数据对象(newData){\n      console.log(newData)\n    }\n},\n\n\n1\n2\n3\n4\n5\n\n\n# 子组件自定义事件传递给父组件\n\n子组件js：\n// 触发自定义事件 向父组件传值， 参数x（可选，传递给父组件的参数，可以是对象或其他）\nthis.triggerEvent(\'自定义事件名\', 参数x)\n\n\n父组件wxml：\n<子组件标签 bind:自定义事件名="执行的事件" />\n\n父组件js：\n执行的事件(event) {\n\tconsole.log(event.detil.参数)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 父组件自定义事件传递给子组件\n\n父组件wxml：\n<子组件标签 class="子组件类名">\n\n父组件JS：\n// 选择组件，并传入事件和参数\nthis.selectComponent(\'.子组件类名\').自定义事件名(传入参数)\n\n子组件js：\nmethods: {\n\t自定义事件名(参数x){\n\t\tconsole.log(参数x)\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 兄弟组件间传递事件和传值\n\n例子：子组件1向子组件2传递参数\n\n父组件wxml中：\n<子组件标签1 bind:自定义事件名1="执行的事件">\n<子组件标签2 class="子组件2类名">\n\n父组件js：\n执行的事件(event) {\n\tthis.selectComponent(\'.子组件2类名\').自定义事件名2(event.detil.参数x) // 向子组件2传值\n}\n\n子组件1js：\n// 触发自定义事件 向父组件传值， 参数x（可选，传递给父组件的参数，可以是对象或其他）\nthis.triggerEvent(\'自定义事件名1\', 参数x)\n\n\n\n子组件2js：\nmethods: {\n\t自定义事件名2(参数x){\n\t\tconsole.log(参数x)  // 接收父组件传入的值\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 获取手机信息\n\nwx.getSystemInfo(Object object)\n\nwx.getSystemInfo({\n\tsuccess(res){\n\t\tconsole.log(res) //手机信息\n\t}\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 滚动组件\n\nscroll-view\n\n<scroll-view scroll-y scroll-top="{{scrollTop}}" scroll-with-animation="true">\n</scroll-view>\n\n\n1\n2\n\n\n# 全局属性、方法（类似vuex）\n\n在app.js中：\n\nonLaunch: function () {\n\tthis.globalData = {// 设置全局属性、方法\n\t\ttest: 0\n\t}\n},\nsetGlobalData(dataItem, val) { // 设置全局属性\n\tthis.globalData[dataItem] = val\n},\ngetGlobalData(dataItem) { // 获取全局属性\n\treturn this.globalData[dataItem]\n}\n\n\n在需要调用的页面js中：\nconst app = getApp() // 在最顶部先调用app方法\n\n// 设置全局属性\napp.setGlobalData(\'test\', 1)\n\n// 获取全局属性\napp.getGlobalData(\'test\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 消息提示框\n\nshowToast\n\nwx.showToast({\n  title: \'成功\',\n  icon: \'success\', //图标： success 成功、loading 加载中、none 无\n  duration: 2000\n})\n\n\n1\n2\n3\n4\n5\n\n\n\n# 《发现》页面\n\n# 调用组件外部的样式\n\ncomponents内部的组件无法直接调用外部的样式。可通过以下方式调用组件外部样式：\n\n方法一：\n\n父组件wxml：\n\x3c!-- iconfont 和 icon-sousuo 是传入组件内部的样式名称，iconfont（自定义名称）="iconfont（外部样式文件中定义的样式名）"  --\x3e\n<x-search iconfont="iconfont" icon-sousuo="icon-sousuo"/>\n\n\n子组件js:\n// 组件外部样式\n  externalClasses: [\n    \'iconfont\', // 对应的是上面等号前面的名称\n    \'icon-sousuo\'\n  ],\n\n 子组件wxml： 即可实现调用组件外的样式\n <i class="iconfont icon-sousuo" />\n\n\n  注意：如果想在组件内部再次修改样式，不能够引用外部传进来的class名称进行修改，可以另起一个class名称进行修改。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n方法二：\n\n消除样式隔离\n\n组件内:\nComponent({\n  options: {\n    styleIsolation: \'apply-shared\'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 组件插槽slot\n\n单个插槽\n\n父组件调用传入插槽内容:\n<组件标签>\n    <view>\n      <view>插槽内容</view>\n      <view>插槽内容</view>\n    </view>\n</组件标签>\n\n 组件内部定义slot标签:\n <view>\n    \x3c!-- slot插槽 --\x3e\n    <slot></slot>\n</view>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果需要实现多个插槽\n\n\n父组件调用传入插槽内容:\n<组件标签>\n    <view slot="slot2">\n      <view>插槽1内容</view>\n      <view>插槽1内容</view>\n    </view>\n\n     <view slot="slot1">\n      <view>插槽2内容</view>\n      <view>插槽2内容</view>\n    </view>\n</组件标签>\n\n组件js :\noptions: {// 设置\n    multipleSlots: true // 打开多个插槽功能\n},\n\n\n组件内部定义slot标签:\n<view>\n    \x3c!-- slot插槽 具名插槽--\x3e\n    <slot name="slot1"></slot>\n    <slot name="slot2"></slot>\n</view>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 判断用户授权\n\n授权\n\n// 判断用户是否授权\n    wx.getSetting({\n      success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n        console.log(res)\n        if (res.authSetting[\'scope.userInfo\']) { // 已授权\n         wx.getUserInfo({ // 获取用户信息\n           success(res) {\n             console.log(res)\n           }\n         })\n        } else { // 未授权\n\n        }\n      }\n    })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# button的开发能力（获取用户信息）1\n\n<button class="login"\n    open-type="getUserInfo"\n    bindgetuserinfo="onGetUserInfo"     // bindgetuserinfo 为固定的\n>\n\t获取微信授权信息\n</button>\n\n\nbindgetuserinfo 事件会询问用户是否同意授权\n\n\njs中：\n    onGetUserInfo(event) { // 获取用户信息\n      const userInfo = event.detail.userInfo\n      if (userInfo) { // 用户允许授权\n        this.setData({\n          modalShow: false\n        })\n        this.triggerEvent(\'loginSuccess\', userInfo) // 给父组件传用户数据\n      } else { // 用户拒绝授权\n        this.triggerEvent(\'loginFail\')\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 原生组件\n\n原生组件\n\n\nauto-focus 自动获取焦点\n\n<textarea\n    class="content"\n    placeholder="分享新鲜事..."\n    maxlength="140"\n    auto-focus\n    bindinput="onInput"\n    bindfocus="onFocus"\n    bindblur="onBlur"\n  ></textarea>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 选择上传图片\n\n上传图片\n\nlet max = 9 - this.data.images.length // 还能再选几张图片\nwx.chooseImage({\n      count: max, // 还能再选几张图片\n      sizeType: [\'original\', \'compressed\'], // 初始值 and 压缩过的\n      sourceType: [\'album\', \'camera\'], // 手机相册选择 and 拍照选择\n      success: (res) => { // 箭头函数改变this指向\n        console.log(res)\n      },\n    })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 图片裁剪\n\n图片裁剪\n\n\x3c!-- mode 图片裁剪 aspectFill 保证短边完整显示 --\x3e\n<image class="image" src="{{item}}" mode="aspectFill"></image>\n\n\n1\n2\n\n\n# 获取标签自定义属性data-* （删除图片的实现）\n\n\x3c!-- 显示图片 --\x3e\n    <block wx:for="{{images}}" wx:key="*this">\n      <view class="image-wrap">\n        \x3c!-- mode 图片裁剪 aspectFill 保证短边完整显示 --\x3e\n        <image class="image" src="{{item}}" mode="aspectFill"></image>\n        <icon class="iconfont icon-shanchu" bindtap="onDelImage" data-index="{{index}}"></icon>\n      </view>\n    </block>\n\n\n    // 删除图片\n  onDelImage(event) {\n  \t// event.target.dataset.index 获取标签属性data-index的值\n    this.data.images.splice(event.target.dataset.index, 1) // splice会改变原有数组\n    this.setData({\n      images: this.data.images\n    })\n  },\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 全屏预览图片(点击图片放大预览)\n\n全屏预览图片\n\n// 全屏预览图片\n  onPreviewImage(event) {\n    wx.previewImage({\n      urls: this.data.images, // 图片地址列表\n      current: event.target.dataset.imgsrc // 当前预览图片地址\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 文件上传云存储（发布博客例子）\n\n文件上传云存储\n\n //  结合\'发布\'的例子：\n  send() {\n    // 验证是否输入内容\n    if (content.trim() === \'\') { // trim() 去掉字符串空格\n      wx.showToast({\n        title: \'请输入内容\',\n        icon: \'none\'\n      })\n      return\n    }\n    wx.showLoading({\n      title: \'发布中\',\n    })\n    /**\n     * 实现思路及步骤：\n     * 1、图片 -> 上传 云存储  -> 生成 图片fineID（云文件ID）\n     * 2、数据 -> 录入 云数据库\n     *    数据包括：文字内容、图片fineID、昵称、头像、发布时间、openId(用户唯一标识，在插入数据库是系统会自动添加_openId字段，不需要另外插入)\n     */\n    let promiseArr = []\n    let fileIds = []\n    // 图片上传云存储\n    this.data.images.forEach((item) => {\n      let p = new Promise((resolve, reject) => {\n        let suffix = /\\.\\w+$/.exec(item)[0] // 文件扩展名(文件后缀)\n        wx.cloud.uploadFile({ // 每次只能上传一个文件\n          /**\n           * cloudPath 云路径。如果路径相同，后上传的文件会覆盖原文件\n           * 路径：blog/云存储中的文件夹 + Date.now()时间戳 + Math.random()*1000000随机数 + 文件后缀\n           */\n          cloudPath: \'blog/\' + Date.now() + \'-\' + Math.random() * 1000000 + suffix,\n          filePath: item, // 文件本地临时路径\n          success: (res) => {\n            fileIds.push(res.fileID)\n            resolve()\n          },\n          fail: (err) => {\n            console.error(err)\n            reject()\n          }\n        })\n      })\n      promiseArr.push(p)\n    })\n\n    // 存入云数据库\n    Promise.all(promiseArr).then((res) => {\n      db.collection(\'blog\').add({\n        data: {\n          ...userInfo, // 昵称、头像\n          content, // 内容\n          img: fileIds, // 图片fileID列表\n          createTime: db.serverDate() // 创建时间，取服务端时间\n        }\n      }).then((res) => {\n        wx.hideLoading()\n        wx.showToast({\n          title: \'发布成功\',\n        })\n        // 返回博客页面，并刷新\n        wx.navigateBack()\n\n      })\n    }).catch((err) => {\n      wx.hideLoading()\n      wx.showToast({\n        title: \'抱歉，发布失败\',\n        icon: \'none\'\n      })\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n# js模块化 （时间格式化）\n\n在目录utils 中新建formatTime.js文件\n\n// 时间格式化 模块封装\nmodule.exports = (date) => { // date 数据格式为 date\n  let fmt = \'yyyy-MM-dd hh:mm:ss\' // 预定格式\n  const o = {\n    // + 正则中的1个或多个\n    \'M+\': date.getMonth() + 1,\n    \'d+\': date.getDate(),\n    \'h+\': date.getHours(),\n    \'m+\': date.getMinutes(),\n    \'s+\': date.getSeconds()\n  }\n\n  if (/(y+)/.test(fmt)) {\n    // $1 表示正则中的第一个，即(y+)\n    fmt = fmt.replace(RegExp.$1, date.getFullYear()) // replace 替换\n  }\n\n  for (let k in o) {\n    if (new RegExp(\'(\'+ k +\')\').test(fmt)) {\n      fmt = fmt.replace(RegExp.$1, o[k].toString().length === 1 ? \'0\' + o[k] : o[k])\n    }\n  }\n\n  return fmt\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n在组件引入js模块\n\nimport formatTime from \'../../utils/formatTime.js\'\n\n使用：\nformatTime(new Date(\'Wed Aug 28 2019 16:23:06 GMT+0800 (中国标准时间)\'))\n\n\n1\n2\n3\n4\n\n\n# 阻止事件冒泡\n\nbind 和 catch 都可以绑定事件，它们的区别是 bind 有事件冒泡，而 catch 没有\n\n# 返回上一个页面并执行方法\n\nAPI\n\n // 返回博客页面，并刷新\n wx.navigateBack()\n const pages = getCurrentPages() // 获取当前页面栈\n const prevPage = pages[pages.length - 2]  // 取到上一个页面\n prevPage.onPullDownRefresh() // 执行上一个页面的方法 onPullDownRefresh\n\n\n1\n2\n3\n4\n5\n\n\n# 图片懒加载\n\nAPI\n\n给image标签设置 lazy-load 为 true\n<image class="img" src="{{item}}" lazy-load="true"></image>\n\n.img {\n  background: #eee;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n懒加载占位图可以给image设置背景图或背景色\n\n# 模糊查询\n\n// 获取博客列表\n  app.router(\'blogList\', async (ctx, next) => {\n    const keyword = event.keyword // 搜索关键字 调用接口时传递来的数据\n    let w = {}\n    if (keyword.trim() != \'\') {\n      w = {\n        content: db.RegExp({ // 正则\n          regexp: keyword,\n          options: \'i\' // i表示忽略大小写\n        })\n      }\n    }\n\n    // where查询条件 skip 从第几条开始查，limit 查几条数据，orderBy(排序字段，排序方式) 排序，排序方式desc降序/asc升序\n    ctx.body =  await blogCollection.where(w).skip(event.start).limit(event.count)\n    .orderBy(\'createTime\', \'desc\').get().then((res) => {\n      return res.data\n    })\n\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 提升模糊查询的效率 （添加索引，对数据量大的查询效果明显）\n\n云开发控制台 > 数据库相应的集合 > 索引管理 > 添加索引 > 输入自定义索引名称、该字段的值是否唯一、被查询的字段名、升序/降序 > ok\n\n# 小程序端调用云数据库\n\n一般调用云数据库的操作都写在云函数内，其实小程序端也可以对数据库进行操作。\n\n小程序端一次最多只能查询20条数据，云函数端最多可查询100条数据，可使用多次查询拼接的方式突破限制。\n\n// 小程序端调用云数据库示例\n    const db = wx.cloud.database() // 初始化数据库\n    db.collection(\'blog\').orderBy(\'createTime\',\'deac\').get().then((res) => {\n      console.log(res)\n    })\n\n\n1\n2\n3\n4\n5\n\n\n# 云数据库权限管理\n\n注意：云控制台和服务端（云函数）始终有所有数据读写权限，\n\n但权限的管理仅对小程序端发起的请求有效。\n\n * 仅创建者可写，所有人可读 （适合于文章）\n\n * 仅创建者可读写 (适用于私密内容)\n\n * 仅管理端可写，所有人可读（适用于商品信息）\n\n * 仅管理端可读写（适用于后台敏感数据）\n\n# 数据库中1对N关系的三种设计方式\n\n# 第一种：N的数量较少 几十个以内\n\n1 条记录存储 N 个子数据\n\n如一条博客中，最多有9张图片，这9张图片可和其他数据放在一个记录中。\n\n[\n\t{\n\t\tid:...\n\t\timg:[\n\t\t\'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\'\n\t\t]\n\t}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 第二种：N的数量较多 几十到几百个\n\n1 存储 每个N的 id\n\n可分两个数据库集合，\n\n一个为 \'目录\' 集合，存放 \'详情\' 集合下的每条数据的 id 目录\n\n一个为 \'详情\' 集合，每条数据对应一个单独的 id 和 详细数据\n\n目录集合：\n[\n\t{\n\t\t\'id\':"11",\n\t\t\'name\': \'产品1\',\n\t\t\'xqs\': [\'111\',\'222\',\'333\', ... ]  // 存放 详情集合 中的每条数据 id\n\t}\n]\n\n\n\n详情集合：\n[\n{\'id\':"111",name:\'零件1\',title:\'...\' ...},\n{\'id\':"222",name:\'零件2\',title:\'...\' ...},\n{\'id\':"333",name:\'零件3\',title:\'...\' ...},\n...\n]\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如歌单列表，与歌曲详情的数据组合设计。\n\n# 第三种：N的数量巨大 几百成千上万个\n\n每个 N 都存储 1 的 id\n\n如新浪博客中的一条博客下面有几千条评论\n\n一条新浪博客：\n[{\n\t\'id\':\'11\',\n\t\'content\':\'博客内容\'\n\t...\n}]\n\n\n上千条评价：\n[\n{\n\t\'id\':\'111111\'\n\t\'blogId\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容1\'\n},\n{\n\t\'id\':\'222222\'\n\t\'blogId\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容2\'\n},\n{\n\t\'id\':\'33333\'\n\t\'blogId\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容3\'\n},\n...\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 云调用\n\n通过云函数调用服务端的开发接口\n\n这些接口如：模板消息推送、生成小程序码...\n\n# 模板消息推送\n\n1、使用from表单才能触发消息推送，并设置report-submit="true"\n\n\n<form slot="modal-content" report-submit="true" bind:submit="onSend">\n    <textarea name="content" class="comment-content" placeholder="写评论" value="{{content}}" fixed="true"></textarea>\n    <button class="send" form-type="submit">发送</button>\n  </form>\n\n\n1\n2\n3\n4\n5\n\n\n2、需要到微信公众平台做相应的设置：\n\n微信公众平台 > 功能 > 模板消息 > 添加模板 > 选择相应的模板> 添加成功后会有一个模板ID\n\n3、新建一个云函数，用于云调用。在该云函数下新建配置文件：config.json ，用于配置权限\n\nconfig.json ：\n\n{\n  "permissions": {\n    "openapi": [\n      "templateMessage.send"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n云函数设置消息推送：\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  // 获取openid\n  const { OPENID } = cloud.getWXContext()\n\n  // 模板推送消息\n  const result = await cloud.openapi.templateMessage.send({\n    touser: OPENID,\n    page: `/pages/blog-comment/blog-comment?blogId=${event.blogId}`, // 用户点击推送消息打开的页面\n    data: { // 模板的内容，keyword为在公众平台设置模板时对应的字段\n      keyword1: { // 评价内容\n        value: event.context\n      },\n      keyword2: { // 评价时间\n        value: event.time\n      }\n    },\n    templateId: \'LNwKMcYwlz-0HabgBhmZi6CWZrlNSBiNJ2h0SMorcxQ\', // 模板id，到公众平台模板消息上获取\n    formId: event.formId // 触发消息推送的form表单的id\n  })\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n4、在提交表单事件完成后调用消息推送云函数\n\n wx.cloud.callFunction({\n          name: \'sendMessage\',\n          data: {\n            content,\n            formId,\n            blogId: this.properties.blogId\n          }\n        }).then((res) => {\n          console.log(res)\n        })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 云函数多集合查询数据库\n\n// 博客详情(博客内容、评论)\n  app.router(\'blogDetail\', async(ctx, next) => {\n    let blogId = event.blogId\n\n    // 博客内容\n    let detail = await blogCollection.where({\n      _id: blogId\n    }).get().then((res) => {\n      return res.data\n    })\n\n    // 评论查询\n    const countResult = await blogCollection.count()\n    const total = countResult.total\n    let commentList = {\n      data: []\n    }\n    if (total > 0) {\n      // 突破100条限制\n      const batchTimes = Math.ceil(total / MAX_LIMIT)\n      const tasks = []\n      for (let i = 0; i < batchTimes; i++) {\n        let promise = db.collection(\'blog-comment\').skip(i * MAX_LIMIT)\n          .limit(MAX_LIMIT).where({\n            blogId\n          }).orderBy(\'createTime\', \'desc\').get()\n        tasks.push(promise)\n      }\n      if (tasks.length > 0) {\n        commentList = (await Promise.all(tasks)).reduce((acc, cur) => {\n          return {\n            data: acc.data.concat(cur.data)\n          }\n        })\n      }\n\n    }\n    ctx.body = {\n      detail,\n      commentList\n    }\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# 分享功能\n\n分享功能需要button标签，设置open-type="share"\n\n\n<button open-type="share" data-blogid="{{blogId}}" data-blog="{{blog}}" class="share-btn" hover-class="share-hover">\n      <i class="iconfont icon-fenxiang icon"></i>\n      <text>分享</text>\n    </button>\n\n\n1\n2\n3\n4\n5\n\n\n在js中有onShareAppMessage方法，点击button会自动执行此方法\n\nonShareAppMessage: function (event) {\n    console.log(event)\n\n    // 对分享卡片的设置\n    let blogObj = event.target.dataset.blog\n    return {\n      title: blogObj.content,\n      path: `/pages/blog-comment/blog-comment?blogId=${blogObj._id}`,\n      // imageUrl: \'\' // 自定义图片，不支持云存储的图片\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 不同场景获取用户信息的方式\n\n# 场景一：只想在界面上显示自己的昵称和头像\n\n以组件的方式：根据type类型获取不同用户数据\n\n该方式不需要授权，只能用于在wxml显示自己的信息\n\nopen-data\n\n<open-data type="userAvatarUrl"></open-data>\n<open-data type="userNickName"></open-data>\n...\n\n\n1\n2\n3\n\n\n# 场景二：在JS中获取用户信息\n\n该方式要在用户授权以后才能获取用户信息\n\nwx.getUserInfo\n\nwx.getUserInfo({\n      success: (res) => {\n        console.log(res)\n      }\n    })\n\n\n1\n2\n3\n4\n5\n\n\n在未授权的情况下需要用户先授权：\n\n// 判断用户是否授权\n      wx.getSetting({\n        success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n          if (res.authSetting[\'scope.userInfo\']) { // 已授权\n            wx.getUserInfo({ // 获取用户信息\n              success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n\n                app.setGlobalData(\'userInfo\', res.userInfo) // 设置app全局属性\n\n                this.onLoginSuccess({\n                  detail: res.userInfo\n                })\n              }\n            })\n          } else { // 未授权\n            this.setData({ // 打开弹出层，显示获取用户信息按钮\n              modalShow: true\n            })\n          }\n        }\n      })\n\n\n  授权按钮\n <button class="login" open-type="getUserInfo" bindgetuserinfo="onGetUserInfo">获取微信授权信息</button>\n\n\n    onGetUserInfo(event) { // 获取用户信息\n      const userInfo = event.detail.userInfo\n      if (userInfo) { // 用户允许授权\n        this.setData({\n          modalShow: false\n        })\n        this.triggerEvent(\'loginSuccess\', userInfo) // 给父组件传用户数据\n      } else { // 用户拒绝授权\n        this.triggerEvent(\'loginFail\')\n      }\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n> 注意：上面这种方式没有获取到openId\n\n# 场景三：获取openId\n\n获取openId不需要用户授权\n\n1、传统开发方式获取openId，后台服务器由自己开发，没使用云开发\n\n小程序端 微信服务器 后端服务器\n\n步骤：\n\n小程序端 调用 wx.login 向微信服务器 获取code\n\n小程序端 调用 wx.request 将 code 传递给 后端服务器\n\n后端服务器 使用code 向微信服务器 换取openid和session_key\n\n后端服务器 将openid 发送给 小程序端\n\n2、云开发方式获取openId\n\n云函数login中\n\n// 获取 WX Context (微信调用上下文)，包括 OPENID、APPID、及 UNIONID（需满足 UNIONID 获取条件）\n  const wxContext = cloud.getWXContext()\n\n  return {\n    event,\n    openid: wxContext.OPENID,\n    appid: wxContext.APPID,\n    unionid: wxContext.UNIONID,\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n普通按钮\n<button bindtap="getOpenid">获取openid</button>\n\ngetOpenid() {\n\twx.cloud.callFunction({\n\t\tname: \'login\'\n\t}).then((res) => {\n\t\tconsole.log(res)\n\t})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> openid 在小程序和公众号下是不一样的\n> \n> unionid 在小程序和公众号下都是一样的\n\n\n# 《我的》页面\n\njson文件\n\n"navigationBarTitleText": "我的",\n  "disableScroll": true  // 使页面无法滚动\n\n\n1\n2\n\n\n# 导航页面链接跳转\n\nnavigator\n\n# 背景图片\n\nwxss背景图片不支持本地相对路径的图片，只支持网络图片和base64图片\n\n建议使用base64图片，图片文件最好不要太大。\n\n# 每个页面都有的page标签\n\npage {\n  background-color: #f1f1f1;\n}\n\n\n1\n2\n3\n\n\n# 播放历史与本地存储\n\n方案一：播放历史存储在数据库当中，这样在不同设备访问都可查看播放历史。读取速度相对较慢\n\n方案二：播放历史存储在本地，仅当前设备可查看播放历史。读取速度较快\n\n本项目采用本地存储：\n\n使用openid作为本地存储的key，播放历史存入value\n\n在app.js中获取openid，即打开小程序就获取openid。\n\n// app.js\nonLaunch: function () {\n\tthis.getOpenid() // 获取openid并存储\n},\ngetOpenid() { // 获取openid并存储\n    wx.cloud.callFunction({\n      name: \'login\'\n    }).then((res) => {\n      const openid = res.result.openid\n      this.globalData.openid = openid // 保存到全局变量\n      if (wx.getStorageSync(openid) == \'\') { // 该用户从未打开过小程序，未存储过openid在本地\n        wx.setStorageSync(openid, []) // 存储openid到本地\n      }\n    })\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n歌曲播放时\n\n// 保存播放历史到本地存储\n  savePlayHistory() {\n    const currentSong = musiclist[nowPlayingIndex] // 当前播放歌曲\n    const openid = app.globalData.openid // 从全局属性获取openid\n    const playHistory = wx.getStorageSync(openid) // 从本地存储获取播放历史数组\n\n    for (let i = 0, len = playHistory.length; i < len; i++) {\n      if (playHistory[i].id === currentSong.id) { // 当前播放歌曲已存在播放历史中\n        playHistory.splice(i, 1) // 删除原纪录\n        break\n      }\n    }\n\n    playHistory.unshift(currentSong) // 在数组开头插入\n    wx.setStorage({ // 存入本地\n      key: openid,\n      data: playHistory\n    })\n\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n播放历史页面获取\n\nonLoad: function (options) {\n\n    const openid = app.globalData.openid //从全局属性获取openid\n    const playHistory = wx.getStorageSync(openid) // 读取本地播放历史数据\n\n    if (playHistory.length !== 0) { // 有播放历史\n      this.setData({\n        playHistory\n      })\n      wx.setStorage({ // storage里把musiclist（播放列表）的内容换成播放历史的列表\n        key: \'musiclist\',\n        data: playHistory,\n      })\n    }\n\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 我的发现\n\n代码分别演示了从云函数和小程序端获取数据，从小程序端获取数据享有权限管理的能力，不需要传openid。\n\n# 小程序码\n\n获取小程序码\n\n本项目演示使用接口 B：适用于需要的码数量极多的业务场景 云调用 的方式。\n\n步骤：\n\n * 创建云函数 gteQRCode\n\n * gteQRCode云函数下创建config.json配置权限，代码如下：\n\n{\n  "permissions":{\n    "openapi":[\n      "wxacode.getUnlimited"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const wxContext = cloud.getWXContext()\n\n  const result = await cloud.openapi.wxacode.getUnlimited({\n    scene: wxContext.OPENID, // 链接参数 不一定传openid，可传其他任意数据，然后通过此数据，在别人扫码进入时就可用于判断\n    // page: "pages/blog/blog" // 默认进入主页\n    // lineColor: { // 线条颜色\n    //   \'r\': 211,\n    //   \'g\': 60,\n    //   \'b\': 57\n    // },\n    // isHyaline: true // 是否透明\n  })\n\n  // result为二进制数据, 先上传到云存储\n\n  // 上传云存储\n  const upload = await cloud.uploadFile({\n    cloudPath: \'qrcode/qrcode\' + Date.now() + Math.random() + \'.png\',\n    fileContent: result.buffer\n  })\n\n  return upload.fileID\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 判断是从扫码小程序码进入，以及参数获取\n\n// 在从小程序码进入的页面js，onLoad方法中，\n\nonLoad: function (options) {\n\tconsole.log(options.scene) // 获取到小程序码进入的参数\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 版本更新检测\n\n// app.js\nonLaunch: function(options) {\n    this.checkUpate()\n},\ncheckUpate(){\n    const updateManager = wx.getUpdateManager()\n    // 检测版本更新\n    updateManager.onCheckForUpdate((res)=>{\n      if (res.hasUpdate){\n        updateManager.onUpdateReady(()=>{\n          wx.showModal({\n            title: \'更新提示\',\n            content: \'新版本已经准备好，是否重启应用\',\n            success(res){\n              if(res.confirm){\n                updateManager.applyUpdate()\n              }\n            }\n          })\n        })\n      }\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 性能优化\n\n官网文档优化建议\n\n使用开发者工具的调试器，Audits进行评分，然后根据提示针对项目进行优化。\n\n\n# 场景值scene的作用与应用场景\n\n场景值\n\n场景值用来描述用户进入小程序的路径。完整场景值的含义请查看场景值列表。\n\n可根据不同场景进入实现不同业务处理，比如一个点餐小程序，店家内贴了小程序码，用户通过扫码进入，可立即进入点餐页面，等等\n\n在app.js中的onLaunch(options) 、onShow(options)，options包含scene场景值\n\n开发者工具中，切后台，可模拟进入场景。\n\n\n# 小程序的"SEO"---页面收录sitemap\n\n在app.js的同级目录下有sitemap.json文件，用于配置收录规则\n\nstiemap配置\n\n作用：\n\n使小程序搜索可根据小程序的内容进行搜索到\n\n使用方法：\n\n1、在微信公众平台，小程序信息 > 页面收录设置 > 打开 (默认是已开启)\n\n2、打开sitemap.json文件，配置收录规则\n\n{\n  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",\n  "rules": [{ // 收录规则\n  "action": "allow",// 是否被收录，allow允许被收录，disallow不允许\n  "page": "*" // *星号表示所有页面都被收录\n  }]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n{\n  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",\n  "rules": [{ // 收录规则，可添加多条\n  "action": "allow", // 是否被收录\n  "page":"pages/player/player",  // 页面\n  "params": ["musicId","index"], // 链接的动态参数\n   "matching":\'exact\' // 表示params的参数是否要准确的匹配\n  }，{\n  "action": "disallow", // 是否被收录\n  "page":"*",  /\n  }]\n}\n\n// 上面配置规则表示除了player页面被收录外，其他页面不被收录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 小程序上线审核流程\n\n微信公众平台，版本管理>把小程序上传为体验版》提交审核》上线\n\n\n# 后台管理系统\n\n# 架构示意图\n\n前端 后台 小程序云开发\n\nvue-admin-template <---通过ajax--\x3e 基于Koa2；HTTP API 或 tcb-admin-node ----\x3e云函数、云数据库、云存储\n\n\n\n# vue-admin-template构建管理系统前端\n\nvue-element-admin 基于element的后台管理系统模板\n\nvue-admin-template 是 vue-element-admin的简化版\n\n使用方法查看官方文档。\n\n# Koa2构建管理系统后端\n\n官网： https://koa.bootcss.com/\n\n新建空文件夹wx-music-admin-backend，打开终端：\n\n# 生成package.json文件，-y 表示默认的配置\nnpm init -y\n\n# 安装koa\nnpm install koa\n\n# 新建app.js文件 (win10系统命令)，作为项目入口文件\ntype nul > app.js\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\napp.js:\n\nconst Koa = require(\'koa\')\nconst chalk = require(\'chalk\') // 使console.log打印文字有颜色的插件，需: npm i chalk\nconst app = new Koa()\n\napp.use(async (ctx) => {\n  ctx.body = \'Hello Wolrd\'\n})\nconst port = 3000\napp.listen(port, () => { // 端口号，开启服务后的回调函数\n  console.log(chalk.green(`> 服务已开启，访问：http://localhost:${port}`))\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n终端：\n\n# node启动项目\nnode app.js\n\n# 访问：http://localhost:3000\n\n\n1\n2\n3\n4\n\n\n# 接口调用凭证 access_token 的缓存与更新\n\naccess_token，微信的接口调用凭证，详情：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\n\n回到项目wx-music-admin-backend，打开终端：\n\n# HTTP 请求 插件\nnpm i request\nnpm i request-promise\n\n\n1\n2\n3\n\n\n/**\n * 获取微信接口调用凭证\n * 详情：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getAccessToken.html\n */\n\n\nconst rp = require(\'request-promise\') // node发送http请求的插件\nconst fs = require(\'fs\') // node文件模块\nconst path = require(\'path\') // node 路径模块\n\n//fileName = __dirname 当前文件所在目录的绝对路径, 加上 \'./access_token.json\'\nconst fileName = path.resolve(__dirname, \'./access_token.json\')\n\n// 这两个参数的获取：微信公众平台>开发>开发设置\nconst APPID = \'wxc4e0b2d98063b103\'\nconst APPSECRET = \'xxx\' //小程序密钥，注意保密!\n\n// 微信 access_token 请求地址\nconst URL = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${APPID}&secret=${APPSECRET}`\n\n// 发送请求获取AccessToken\nconst updateAccessToken = async () => {\n  const resStr = await rp(URL)\n  const res = JSON.parse(resStr)\n\n  if (res.access_token) {\n    // node写文件,参数：1 文件路径，2 文件内容, 首次写文件为新建，往后为覆盖\n    fs.writeFileSync(fileName, JSON.stringify({\n      access_token: res.access_token,\n      createTime: new Date()\n    }))\n  } else { // 如获取不到，再次获取\n    await updateAccessToken()\n  }\n}\n\n// 读取access_token\nconst getAccessToken = async () => {\n  try {\n     // node读取文件,参数：1 读取的文件，2 字符集\n    const readRes = fs.readFileSync(fileName, \'utf8\')\n    const readObj = JSON.parse(readRes)\n\n    // 如果服务器宕机导致setInterval无法定时更新，这里需要再次判断access_token的有效性\n    const createTime = new Date(readObj.createTime).getTime()\n    const nowTime = new Date().getTime()\n    if((nowTime - createTime) / 1000 / 60 / 60 >= 2) {\n      await updateAccessToken()\n      await getAccessToken()\n      return\n    }\n    return readObj.access_token\n\n  } catch (error) { //捕获异常，在未创建文件时，先创建文件\n    await updateAccessToken()\n    await getAccessToken()\n  }\n}\n\n// access_token有效期为2个小时，定时更新\nsetInterval(async () => {\n  await updateAccessToken()\n}, (7200 - 300) * 1000)\n\nmodule.exports = getAccessToken\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 后端代码通过HTTP API 触发云函数获取数据\n\nHTTP API 触发云函数\n\n# 产生跨域和后端解决跨域问题\n\n管理系统前端向管理系统后端请求数据，产生了跨域问题\n\n  // 产生跨域的几种情况\n  // http://www.a.com  https://www.a.com 协议不同\n  // http://www.a.com  http://www.b.com 域名不同\n  // http://www.a.com  http://news.a.com 主域与子域不同\n  // http://www.a.com:8080  http://www.a.com:3000 端口不同\n\n// 解决跨域的几种方法\n// jsonp\n// iframe\n// postMessage跨域\n// 跨域资源共享（CORS）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n管理系统后端，安装\n\n// 解决跨域问题的koa包\nnpm i koa2-cors\n\n\n1\n2\n\n\napp.js\n\n//处理跨域\napp.use(cors({\n  origin: [\'http://localhost:9528\'], // 允许访问本服务的域\n  credentials: true\n}))\n\n\n1\n2\n3\n4\n5\n\n\n# 云数据库的增删改查接口\n\n数据库查询记录\n\n# 后端获取前端post请求传来的数据\n\nget请求可以直接通过ctx.request.query获取，但是post请求需要安装koa-body\n\nnpm i koa-body\n\n\n1\n\n\napp.js\n\nconst koaBody = require(\'koa-body\') // 对post请求前端传来的数据的获取，需要此依赖\n\n// 接收post参数解析\napp.use(koaBody({\n  multipart: true\n}))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接口.js\n\nrouter.post(\'/updatePlaylist\', async (ctx, next) => {\n\n  const params = ctx.request.body // post请求获取前端传来的数据，需安装和配置koa-body\n\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 后端获取云存储图片\n\n云存储中上传图片，云数据库中新建图片的集合，并添加数据字段，字段包含云文件的fileid。\n\n后端项目通过调用云数据库的方式获取数据\n\nrouter.get(\'/list\', async (ctx, next) => {\n  // 接口中读取数据库默认最多10条数据\n  const query = `db.collection(\'swiper\').get()`\n  const res = await callCloudDB(ctx, \'databasequery\', query)\n  console.log(res)\n\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但获取到的数据为fileid，并不能用于显示图片，需要通过微信HTTP API获取云存储的接口来获取图片地址\n\n获取云存储\n\n# 后端上传图片到云存储\n\n文件上传',normalizedContent:'# 小程序笔记\n\n\n# 基础课程部分\n\n# 微信公众平台\n\nhttps://mp.weixin.qq.com/\n\n注册时可选择类型：订阅号、服务号、小程序、企业微信\n\n每个邮箱仅能注册一个小程序。\n\n个人类型小程序：无法使用微信支付、无法使用卡包功能\n\n# 小程序文档api\n\n小程序开发文档\n\n# 微信开放社区\n\n微信开发社区\n\n# 目录说明\n\n默认目录\n\npages-----------------------页面相关\n\nindex ----------------- 首页文件夹\n\nindex.js ------------首页js\n\nindex.json---------首页配置\n\nindex.wxml-------首页html\n\nindex.wxss--------首页css\n\nutils------------------------工具相关\n\napp.js ----------------------项目总js\n\napp.json-------------------全局配置( 页面路由以及头部、底部导航的配置等)\n\napp.wxss -----------------项目总样式css\n\nproject.config.json ----项目配置\n\n代码构成\n\n.json ：配置文件，以json格式存储配置\n\n项目中有三种配置：项目配置（project.config.json）、全局配置（app.json）、页面配置（index.json）\n\n.wxml: 相当于html文件\n\n.wxss: 相当于css\n\n.js : 就是js\n\n# 文件说明\n\nproject.config.json项目配置 部分代码说明\n\nsetting：{\n\nurlcheck 是否检测安全的域名\n\nes6 是否把es6转es5\n\npostcss 是否把css样式自动补全\n\nminified 是否压缩\n\n}\n\napp.json 全局配置\n\n全局配置api\n\nwxml 相关介绍\n\nwxmlapi\n\n<view>{{motto}}</view>\n\n循环渲染\n<view wx:for="{{list}}" wx:key="{{index}}">\n      {{index}} {{item}}\n</view>\n\n改变for循环item和index的名称\n<block wx:for="{{list}}" wx:for-item="data" wx:for-index="inx">\n\t{{inx}} {{data}}\n</block>\n\n条件渲染 (类似vue的v-if、v-else)\n<view wx:if="{{islogin}}">已登录</view>\n<view wx:else>请登录</view>\n\n条件显示（类似vue的v-show）\n<view hidden="{{islogin}}">显示内容</view>\n\n绑定点击事件\n<button bindtap=“tapname”>按钮</button>\n\npage({\n  tapname: function(event) {\n    console.log(event)\n  }\n})\n...\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nwxss 相关介绍\n\nwxssapi\n\n尺寸单位：rpx，根据屏幕宽度自适应。\n\n引入外部wxss：@import ’...‘\n\njs相关介绍\n\nwxs（weixin script）是小程序的一套脚本语言\n\nwxsapi\n\n绑定点击事件\n\n<button bindtap=“ontaphandler”>点我+1</button>\n<view>{{count}}</view>\n\n\n1\n2\n\n\npage({\n  data: {\n    count: 0\n  },\n  ontaphandler: function() {\n  \tthis.setdata({\n  \t\tcount: this.data.count++\n  \t})\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 阻止事件冒泡\n\n把绑定方式 bindtap 换成 catchtap 即可。\n\n# 第三方库\n\nweui\n\nweui是一套同微信原生视觉体验一致的基础样式库\n\niview weapp\n\n一套高质量的微信小程序ui组件库\n\nvant weapp\n\n轻量、可靠的小程序ui组件库\n\n# 云开发\n\n小程序传统开发模式\n\n客户端 -----\x3e 服务端（后端代码、数据库）------\x3e 运维（db维护、文件存储、内容加速、网络防护、容器服务、负载均衡、安全加固等...）\n\n小程序云开发模式\n\n客户端 -----\x3e 云开发（云函数、云数据库、云存储）\n\n传统开发 vs 云开发\n\n开发效率低 serverless（无服务）\n\n运维成本高 开发者更关注业务逻辑\n\n无服务（serverless）开发是未来的发展趋势\n\n# 云开发三大基础能力\n\n# 云函数\n\n（相当于传统开发中的后台接口）\n\n获取appid、获取openid、生成分享图、调用腾讯云sdk ...\n\n# 云数据库\n\n数据的增、删、改、查 ...\n\n# 云存储\n\n管理文件、上传文件、下载文件、分享文件 ...\n\n每个小程序账号可免费创建两个环境，建议：开发环境、生成环境\n\n# 云数据库能力\n\n云开发提供了一个json数据库，提供2gb免费存储空间。\n\n# 数据类型\n\nstring 字符串\n\nnumber 数字\n\nobject 对象\n\narray 数组\n\nboolean 布尔值\n\ngeopoint 地理位置点\n\ndate 时间 （精确到毫秒ms，客户端时间）\n\nnull 空\n\n# 操作云数据库\n\n小程序控制（读写数据库受权限限制）\n\n云函数控制（拥有所有读写数据库的权限）\n\n控制台控制（拥有所有读写数据库的权限）\n\n# 云数据库权限管理\n\n仅创建者可写，所有人可读 （适合于文章）\n\n仅创建者可读写 (适用于私密内容)\n\n仅管理端可写，所有人可读（适用于商品信息）\n\n仅管理端可读写（适用于后台敏感数据）\n\n# 操作云数据库\n\n//初始化数据库\nconst db = wx.cloud.database() // 小程序端初始化数据库，如果在云函数端不需要加wx\n\n//切换环境(开发环境/生产环境)\nconst testdb = wx.cloud.database({\n\tenv: \'test\'\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 实战课程部分\n\n# serverless（无服务）\n\n概念：函数即服务，当需要后端服务的时候，不需要关心后端的ip地址、域名，只需要像调用普通函数一样既可以实现调用。\n\n# 云开发优势\n\n快速上线、专注核心业务、独立开发一个完整的微信小程序、不需要学习新的语言，只需要会javascript、无需运维， 节约成本、数据安全、\n\n# 云开发提供能力\n\n云函数：在云端运行的代码，微信私有协议天然鉴权 （理解：相当于后端部分）\n\n云数据库：一个既可以在小程序端操作又可以在云函数中操作的json数据库\n\n云存储：在云端存储文件，可以在云端控制台可视化管理\n\n云调用：基于云函数免鉴权使用小程序开放接口的能力（比如说给用户推送消息等）\n\nhttp api：使用http api开发者可在已有服务器上访问云资源，实现与云开发的互通（作用：对原有传统模式下开发的小程序，可以与云开发进行互通）\n\n# appid\n\n每个小程序唯一的id\n\n# 云开发项目默认目录结构\n\ncloudfunctions ----------------------------云函数\n\ncallback ---------------------------------- 回调函数\n\nconfig.json ---------------------------\n\nindex.js --------------------------------\n\npackage.json ------------------------\n\necho ----------------------------------------\n\nlogin ----------------------------------------\n\nopenapi -----------------------------------\n\nminiprogram ------------------------------- 小程序\n\nimages ------------------------------------- 图片\n\npages --------------------------------------- 页面\n\nstyle ----------------------------------------- 样式\n\napp.js --------------------------------------- 项目js\n\napp.json ----------------------------------- 全局配置\n\napp.wxss ---------------------------------- 项目样式\n\nsitemap.json ----------------------------- （小程序seo相关）\n\nproject.config.json ----------------------- 项目配置\n\n# 云开发环境\n\n云开发可创建两个环境，建议一个为开发环境，一个为生产环境\n\n# 开发前的准备\n\n开发工具 > 右上角详情 > 本地设置 > 调试基础库 设置为最新版本\n\napp.js > wx.cloud.init > env 设置环境id\n\n# project.config.json 文件说明\n\nminiprogramroot 小程序前端代码目录\n\ncloudfunctionroot 云函数代码目录\n\n# app.json\n\npages 设置页面 ，设置后会自动在pages目录下生成相应的目录和文件\n\n设置底部导航按钮：\n\n"tabbar": {\n    "color": "#474747", // 文字颜色\n    "selectedcolor": "#d43c43", // 文字选中颜色\n    "list": [{ // 按钮列表，2-5项\n      "pagepath": "pages/playlist/playlist", // 按钮对应页面\n      "text": "音乐", // 文字\n      "iconpath": "images/music.png", // 图标路径\n      "selectediconpath": "images/music-actived.png" // 选中图标的路径\n    },\n    {\n      "pagepath": "pages/blog/blog",\n      "text": "发现",\n      "iconpath": "images/blog.png",\n      "selectediconpath": "images/blog-actived.png"\n    },\n    {\n      "pagepath": "pages/profile/profile",\n      "text": "我的",\n      "iconpath": "images/profile.png",\n      "selectediconpath": "images/profile-actived.png"\n    }]\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n> 图标来自于 https://www.iconfont.cn\n> \n> 阿里巴巴图标库，包含矢量图标、字体图标、字体等\n\n# 代码规范\n\n很多公司借鉴的代码规范：https://github.com/airbnb/javascript\n\n# 《音乐》页面开发\n\n \x3c!-- 轮播图组件 参数：indicator-dots 小圆点，autoplay 自动播放, interval 间隔时间，duration 动画时长 --\x3e\n<swiper indicator-dots="true" circular="true" interval="3000" duration="500">\n  <block wx:for="{{swiperimgurls}}" wx:key="{{index}}"> \x3c!-- 空节点 --\x3e\n    <swiper-item>\n      <image src="{{item.url}}" mode="widthfix" class="img"></image>\n    </swiper-item>\n  </block>\n</swiper>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 自定义组件\n\n创建组件\n\n创建目录 components > 组件目录名称 > 右键 新建component\n\n# 引入组件\n\n在page的json文件中：\n\n{\n  "usingcomponents": {\n    "x-playlist":"/components/playlist/playlist"\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n在page的wxml中：\n\n<x-playlist> </x-playlist>\n\n\n1\n\n\n页面引入组件以及组件内部在引用子组件的方法是一样的，同样需要设置json文件。\n\n# 组件传值\n\n父组件中：在引入组件的时候自定义属性名称，并把数据传入子组件\n\n\x3c!-- 参数：playlist 自定义名称，传入组件的数据 --\x3e\n<x-playlist playlist="{{传入的数据}}"></x-playlist>\n\n\n1\n2\n\n\n子组件中： 子组件的js文件：\n\n  /**\n   * 组件的属性列表\n   */\n  properties: {\n    playlist:{ // 接收父组件传输的数据\n      type: object // 数据类型\n    }\n   },\n\n //子组件的wxml文件可直接引入数据{{playlist}}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# wx:key 的使用\n\nkey的值不建议使用index，因为当数据发生变化会dom结构产生变化时，使用index的地方不会随之变化。\n\n可以使用数据内部每项不一样的一个数值，如id\n\n<block wx:for="{{swiperimgurls}}" wx:key="url"> 这里url不需要双大括号，如使用index则需要{{}}\n    <view>\n      <image src="{{item.url}}" mode="widthfix" class="img"></image>\n    </view>\n</block>\n\n<view class="playlist-container">\n  <block wx:for="{{playlist}}" wx:key="_id">\n    \x3c!-- 参数：playlist 自定义名称，传入组件的数据 --\x3e\n    <x-playlist playlist="{{item}}"></x-playlist>\n  </block>\n</view>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# async/await 语法\n\n目前，在云函数里，由于 node 版本最低是 8.9，因此是天然支持 async/await 语法的。而在小程序端则不然。在微信开发者工具里，以及 android 端手机（浏览器内核是 qq浏览器的 x5），async/await是天然支持的，但 ios 端手机在较低版本则不支持，因此需要引入额外的 文件。\n\n可把这个 runtime.js 文件引用到有使用 async/await 的文件当中。\n\n// 注意，必须命名为 regeneratorruntime\nimport regeneratorruntime from \'../../utils/runtime.js\'\n\n\n1\n2\n\n\n# 云函数的使用\n\ncloudfunctions目录 右键 新建 node.js 云函数 > 输入目录名 getplaylist\n\n在云函数中向第三方服务器发送请求要依赖第三方库\n\n安装依赖包\n\n云函数目录 getplaylist 右键 在终端打开 打开命令行 输入命令：\n\nnpm install --save request\nnpm install --save request-promise\n\n\n1\n2\n\n\ngithub request-promise：https://github.com/request/request-promise\n\n然后写相应代码\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst rp = require(\'request-promise\') // 需安装依赖包\n\nconst url = \'http://musicapi.xiecheng.live/personalized\'\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const playlist = await rp(url).then((res) => {\n    return json.parse(res).result\n  })\n  console.log(playlist)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n写完代码，云函数目录 getplaylist 右键 上传并部署：云端安装依赖（不上传node_modules） 进行上传部署代码到云端，等待上传成功，打开云开发控制台即可看到已经上传的云函数，并可对云函数进行测试。\n\n# 数据库操作\n\n数据库> 创建集合 > playlist\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst db = cloud.database() // 初始化数据库,如果在小程序端初始化数据库需要在前面加wx.\n\nconst rp = require(\'request-promise\') // 需安装依赖包\n\nconst url = \'http://musicapi.xiecheng.live/personalized\' // 第三方服务器地址（老师从网易云获取的数据部署在其服务器，每天的数据会更新）\n\nconst playlistcollection = db.collection(\'playlist\') // 获取到数据库playlist集合\n\nconst max_limit = 10 // 定义常量，获取数据库条数最大的限制\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  /**\n   * 注：\n   * - 关于数据库的操作都是异步操作，都需添加await关键字\n   * - console.log 打印在云开发控制台 云函数测试内查看\n   * - 单次获取数据库数据有条数限制，云函数端最多获取100条，小程序端最多获取20条\n   */\n\n  // const list = await playlistcollection.get() // 获取数据库集合的数据 （因为有条数限制，不直接用此方法）\n\n  // 突破条数限制 （为了读取到全部数据然后与第三方服务器获取的数据进行对比去重）\n  const countresult = await playlistcollection.count() // 获取数据总条数 返回为对象\n  const total = countresult.total // 取得总条数\n  const batchtimes = math.ceil(total / max_limit)\n  const tasks = []\n  for(let i = 0; i < batchtimes; i++) {\n    let promise = playlistcollection.skip(i * max_limit).limit(max_limit).get() // 从第 skip 条开始取，最多取 limit 条数据\n    tasks.push(promise)\n  }\n  let list = {\n    data: []\n  }\n  if (tasks.length > 0) {\n    list = (await promise.all(tasks)).reduce((acc, cur) => { // reduce数组方法 累积拼接\n      return {\n        data: acc.data.concat(cur.data)\n      }\n    })\n  }\n\n  // 获取第三方服务器端数据\n  const playlist = await rp(url).then((res) => {\n    return json.parse(res).result\n  })\n\n  // 数据库与服务器数据对比去重（数据已存在数据库的无需再重复添加）\n  const newdata = []\n  for(let i = 0, len1 = playlist.length; i < len1; i++) {\n    let flag = true\n    for(let j = 0, len2 = list.data.length; j < len2; j++) {\n      if(playlist[i].id === list.data[j].id){\n        flag = false\n        break\n      }\n    }\n    if(flag){\n      newdata.push(playlist[i])\n    }\n  }\n\n  // 把数据插入数据库，需要单条插入\n  for (let i = 0, len = newdata.length; i < len; i++) {\n    await playlistcollection.add({ // 给数据库集合添加数据\n      data: {\n        ...newdata[i],\n        createtime: db.serverdate(), // db.serverdate() 获取服务器时间\n      }\n    }).then((res) => { // 数据添加成功\n      console.log(\'数据添加成功\')\n    }).catch((err) => { // 失败\n      console.error(err)\n    })\n  }\n  return newdata.length // 插入多少条数据\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n\n\n# 查询数据库\n\n//云函数中查询数据库的例子：\n\n// 云函数入口文件\nconst cloud = require(\'wx-server-sdk\')\n\ncloud.init()\n\nconst tcbrouter = require(\'tcb-router\')\nconst db = cloud.database() // 初始化数据库\nconst blogcollection = db.collection(\'blog\') // 博客的数据库集合\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const app = new tcbrouter({ event }) // 初始化tcbrouter\n\n  app.router(\'list\', async (ctx, next) => {\n    // skip 从第几条开始查，limit 查几条数据，orderby(排序字段，排序方式) 排序，排序方式desc降序/asc升序\n    ctx.body =  await blogcollection.skip(event.start).limit(event.count)\n    .orderby(\'createtime\', \'desc\').get().then((res) => {\n      return res.data\n    })\n\n  })\n\n\n  return app.serve() // 必需返回\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 云函数调试\n\n云控制台中可会云函数进行云端测试\n\n在小程序调用云函数后，可查看云函数日志\n\n# 定时触发云函数\n\n如果云函数需要定时 / 定期执行，也就是定时触发，我们可以使用云函数定时触发器。配置了定时触发器的云函数，会在相应时间点被自动触发，函数的返回结果不会返回给调用方\n\n云函数目录下新建 config.json\n\napi\n\n{\n  "triggers": [\n    {\n      "name": "mytriggers",\n      "type": "timer",\n      "config":"0 0 10,14,16,20 * * * *" //表示每天的10点、14点、16点、20点触发一次\n    }\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n编辑好触发器之后，要在云函数目录 > 右键 > 上传触发器\n\n# 配置云函数超时时间\n\n当云函数比较复杂的时候，默认的超时时间3秒可能不能够满足需求，可以适当的设置更为合理的时间\n\n云开发控制台 > 云函数 > 配置 > 超时时间\n\n# 上拉加载与下拉刷新\n\npage页面json中：\n"enablepulldownrefresh": true\n\n\npage页面js中有这两个函数：\n\n /**\n   * 页面相关事件处理函数--监听用户下拉动作\n   */\n  onpulldownrefresh: function() {\n\t this.setdata({\n      playlist: []\n    })\n    this._getplaylist()\n  },\n\n  /**\n   * 页面上拉触底事件的处理函数\n   */\n  onreachbottom: function() {\n    this._getplaylist()\n  },\n\n\n\n 下拉刷新请求完数据后\n wx.stoppulldownrefresh() // 停止下拉刷新动画\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 云函数路由优化tcb-router\n\n一个用户在一个云环境只能创建50个云函数\n\n假如小程序非常复杂，50个云函数不能够满足业务需求怎么办？\n\n相似的请求归类到同一个云函数处理\n\ntcb-router是一个koa风格的云函数路由库\n\n通俗理解就是可以把很多个接口归类到同一个云函数内。\n\ngithub-tcb-router: https://github.com/tencentcloudbase/tcb-router\n\nkoa洋葱模型...\n\n安装：\n\n在使用到tcb-router的云函数目录下打开命令行，输入命令进行安装\nnpm install --save tcb-router\n\n\n1\n2\n\n\n// 云函数的 index.js\nconst tcbrouter = require(\'router\'); // 必需\n\nexports.main = (event, context) => {\n    const app = new tcbrouter({ event });// 必需\n\n    // app.use 表示该中间件会适用于所有的路由(全局中间件) 非必需\n    app.use(async (ctx, next) => { // 这个中间件表示所有路由都会调用到，而路由中间件为单独调用\n        ctx.data = {}; // 获取要传给小程序端的数据\n        ctx.data.openid = event.userinfo.openid // 这里获取到的openid将分布到所有路由\n        await next(); // 执行下一中间件\n    });\n\n    // 路由为数组表示，该中间件适用于 user 和 timer 两个路由\n    app.router([\'user\', \'timer\'], async (ctx, next) => {\n        ctx.data.company = \'tencent\'; // 这里获取到的数据将分布到 user 和 timer 两个路由\n        await next(); // 执行下一中间件\n    });\n\n    // 路由为字符串，该中间件只适用于 user 路由\n    app.router(\'user\', async (ctx, next) => {\n        ctx.data.name = \'heyli\';  // 获取要传给小程序端的数据\n        await next(); // 执行下一中间件\n    }, async (ctx, next) => {\n        ctx.data.sex = \'male\'; // 获取要传给小程序端的数据\n        await next(); // 执行下一中间件\n    }, async (ctx) => {\n        ctx.data.city = \'foshan\'; // 获取要传给小程序端的数据\n        // ctx.body 返回数据到小程序端\n        ctx.body = { code: 0, data: ctx.data};  // 要传给小程序端的数据\n    });\n\n    // 路由为字符串，该中间件只适用于 timer 路由\n    app.router(\'timer\', async (ctx, next) => {\n        ctx.data.name = \'flytam\';\n        await next(); // 执行下一中间件\n    }, async (ctx, next) => {\n        ctx.data.sex = await new promise(resolve => {\n        // 等待500ms，再执行下一中间件\n        settimeout(() => {\n            resolve(\'male\');\n        }, 500);\n        });\n        await next(); // 执行下一中间件\n    }, async (ctx)=>  {\n        ctx.data.city = \'taishan\';\n\n        // ctx.body 返回数据到小程序端\n        ctx.body = { code: 0, data: ctx.data };\n    });\n\n    return app.serve(); // 必需\n\n}\n\n\n小程序端：\n\n// 调用名为 router 的云函数，路由名为 user\nwx.cloud.callfunction({\n    // 要调用的云函数名称\n    name: "router",\n    // 传递给云函数的参数\n    data: {\n        $url: "user", // 要调用的路由的路径，传入准确路径或者通配符*\n        other: "xxx"\n    }\n}).then((res) => {\n\tconsole.log(res)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n\n\n上面tcb-router代码会按照洋葱模型执行，即先从上往下逐个进入中间件，再从下往上逐个退出中间件。\n\n# 本地存储（缓存）\n\n// 存储：\nwx.setstoragesync(key, data) // 同步存储（存储成功再继续下一步操作）\nwx.setstorage(key, data) // 异步存储（即使存储没成功也会执行下一步代码）、\n\n// 读取：\nwx.getstoragesync(key) // 同步 （读取到数据在进行下一步操作）\nwx.setstorage(key) // 异步\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# api设置title\n\nwx.setnavigationbartitle({\n      title: \'\',\n})\n\n\n1\n2\n3\n\n\n# 背景播放音\n\nbackgroundaudiomanager 全局唯一的背景音频管理器\n\n// 需要在app.json配置，才能使用后台音乐播放的能力\n\n"requiredbackgroundmodes": ["audio", "location"]\n\n\n1\n2\n3\n\n\n// 获取全局唯一的背景音频管理器\nconst backgroundaudiomanager = wx.getbackgroundaudiomanager()\n\n\nbackgroundaudiomanager.src = 音频链接\nbackgroundaudiomanager.title = 音频标题\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# createselectorquery查询节点信息\n\ncreateselectorquery 小程序的方法，用于查询节点等操作\n\nconst query = wx.createselectorquery()\nquery.select(\'#the-id\').boundingclientrect() // 节点的布局信息\nquery.selectviewport().scrolloffset()\nquery.exec(function(res){\n  res[0].top       // #the-id节点的上边界坐标\n  res[1].scrolltop // 显示区域的竖直滚动位置\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 组件内的方法\n\ncomponent(object object)\n\n# 组件生命周期\n\nlifetimes\n\n// 生命周期\nlifetimes: {\n    ready() { // 在组件在视图层布局完成后执行\n   \t ...\n    }\n},\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 组件所在页面的生命周期\n\ncomponent({\n  pagelifetimes: {\n    show: function() {\n      // 页面被展示\n    },\n    hide: function() {\n      // 页面被隐藏\n    },\n    resize: function(size) {\n      // 页面尺寸变化\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 组件对数据的监听\n\nobservers\n\nobservers: { // 对数据的监听(数据初次加载完成也会执行)\n    监听的数据对象(newdata){\n      console.log(newdata)\n    }\n},\n\n\n1\n2\n3\n4\n5\n\n\n# 子组件自定义事件传递给父组件\n\n子组件js：\n// 触发自定义事件 向父组件传值， 参数x（可选，传递给父组件的参数，可以是对象或其他）\nthis.triggerevent(\'自定义事件名\', 参数x)\n\n\n父组件wxml：\n<子组件标签 bind:自定义事件名="执行的事件" />\n\n父组件js：\n执行的事件(event) {\n\tconsole.log(event.detil.参数)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 父组件自定义事件传递给子组件\n\n父组件wxml：\n<子组件标签 class="子组件类名">\n\n父组件js：\n// 选择组件，并传入事件和参数\nthis.selectcomponent(\'.子组件类名\').自定义事件名(传入参数)\n\n子组件js：\nmethods: {\n\t自定义事件名(参数x){\n\t\tconsole.log(参数x)\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n# 兄弟组件间传递事件和传值\n\n例子：子组件1向子组件2传递参数\n\n父组件wxml中：\n<子组件标签1 bind:自定义事件名1="执行的事件">\n<子组件标签2 class="子组件2类名">\n\n父组件js：\n执行的事件(event) {\n\tthis.selectcomponent(\'.子组件2类名\').自定义事件名2(event.detil.参数x) // 向子组件2传值\n}\n\n子组件1js：\n// 触发自定义事件 向父组件传值， 参数x（可选，传递给父组件的参数，可以是对象或其他）\nthis.triggerevent(\'自定义事件名1\', 参数x)\n\n\n\n子组件2js：\nmethods: {\n\t自定义事件名2(参数x){\n\t\tconsole.log(参数x)  // 接收父组件传入的值\n\t}\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n# 获取手机信息\n\nwx.getsysteminfo(object object)\n\nwx.getsysteminfo({\n\tsuccess(res){\n\t\tconsole.log(res) //手机信息\n\t}\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 滚动组件\n\nscroll-view\n\n<scroll-view scroll-y scroll-top="{{scrolltop}}" scroll-with-animation="true">\n</scroll-view>\n\n\n1\n2\n\n\n# 全局属性、方法（类似vuex）\n\n在app.js中：\n\nonlaunch: function () {\n\tthis.globaldata = {// 设置全局属性、方法\n\t\ttest: 0\n\t}\n},\nsetglobaldata(dataitem, val) { // 设置全局属性\n\tthis.globaldata[dataitem] = val\n},\ngetglobaldata(dataitem) { // 获取全局属性\n\treturn this.globaldata[dataitem]\n}\n\n\n在需要调用的页面js中：\nconst app = getapp() // 在最顶部先调用app方法\n\n// 设置全局属性\napp.setglobaldata(\'test\', 1)\n\n// 获取全局属性\napp.getglobaldata(\'test\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 消息提示框\n\nshowtoast\n\nwx.showtoast({\n  title: \'成功\',\n  icon: \'success\', //图标： success 成功、loading 加载中、none 无\n  duration: 2000\n})\n\n\n1\n2\n3\n4\n5\n\n\n\n# 《发现》页面\n\n# 调用组件外部的样式\n\ncomponents内部的组件无法直接调用外部的样式。可通过以下方式调用组件外部样式：\n\n方法一：\n\n父组件wxml：\n\x3c!-- iconfont 和 icon-sousuo 是传入组件内部的样式名称，iconfont（自定义名称）="iconfont（外部样式文件中定义的样式名）"  --\x3e\n<x-search iconfont="iconfont" icon-sousuo="icon-sousuo"/>\n\n\n子组件js:\n// 组件外部样式\n  externalclasses: [\n    \'iconfont\', // 对应的是上面等号前面的名称\n    \'icon-sousuo\'\n  ],\n\n 子组件wxml： 即可实现调用组件外的样式\n <i class="iconfont icon-sousuo" />\n\n\n  注意：如果想在组件内部再次修改样式，不能够引用外部传进来的class名称进行修改，可以另起一个class名称进行修改。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n方法二：\n\n消除样式隔离\n\n组件内:\ncomponent({\n  options: {\n    styleisolation: \'apply-shared\'\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 组件插槽slot\n\n单个插槽\n\n父组件调用传入插槽内容:\n<组件标签>\n    <view>\n      <view>插槽内容</view>\n      <view>插槽内容</view>\n    </view>\n</组件标签>\n\n 组件内部定义slot标签:\n <view>\n    \x3c!-- slot插槽 --\x3e\n    <slot></slot>\n</view>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如果需要实现多个插槽\n\n\n父组件调用传入插槽内容:\n<组件标签>\n    <view slot="slot2">\n      <view>插槽1内容</view>\n      <view>插槽1内容</view>\n    </view>\n\n     <view slot="slot1">\n      <view>插槽2内容</view>\n      <view>插槽2内容</view>\n    </view>\n</组件标签>\n\n组件js :\noptions: {// 设置\n    multipleslots: true // 打开多个插槽功能\n},\n\n\n组件内部定义slot标签:\n<view>\n    \x3c!-- slot插槽 具名插槽--\x3e\n    <slot name="slot1"></slot>\n    <slot name="slot2"></slot>\n</view>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n# 判断用户授权\n\n授权\n\n// 判断用户是否授权\n    wx.getsetting({\n      success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n        console.log(res)\n        if (res.authsetting[\'scope.userinfo\']) { // 已授权\n         wx.getuserinfo({ // 获取用户信息\n           success(res) {\n             console.log(res)\n           }\n         })\n        } else { // 未授权\n\n        }\n      }\n    })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n# button的开发能力（获取用户信息）1\n\n<button class="login"\n    open-type="getuserinfo"\n    bindgetuserinfo="ongetuserinfo"     // bindgetuserinfo 为固定的\n>\n\t获取微信授权信息\n</button>\n\n\nbindgetuserinfo 事件会询问用户是否同意授权\n\n\njs中：\n    ongetuserinfo(event) { // 获取用户信息\n      const userinfo = event.detail.userinfo\n      if (userinfo) { // 用户允许授权\n        this.setdata({\n          modalshow: false\n        })\n        this.triggerevent(\'loginsuccess\', userinfo) // 给父组件传用户数据\n      } else { // 用户拒绝授权\n        this.triggerevent(\'loginfail\')\n      }\n    }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 原生组件\n\n原生组件\n\n\nauto-focus 自动获取焦点\n\n<textarea\n    class="content"\n    placeholder="分享新鲜事..."\n    maxlength="140"\n    auto-focus\n    bindinput="oninput"\n    bindfocus="onfocus"\n    bindblur="onblur"\n  ></textarea>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 选择上传图片\n\n上传图片\n\nlet max = 9 - this.data.images.length // 还能再选几张图片\nwx.chooseimage({\n      count: max, // 还能再选几张图片\n      sizetype: [\'original\', \'compressed\'], // 初始值 and 压缩过的\n      sourcetype: [\'album\', \'camera\'], // 手机相册选择 and 拍照选择\n      success: (res) => { // 箭头函数改变this指向\n        console.log(res)\n      },\n    })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 图片裁剪\n\n图片裁剪\n\n\x3c!-- mode 图片裁剪 aspectfill 保证短边完整显示 --\x3e\n<image class="image" src="{{item}}" mode="aspectfill"></image>\n\n\n1\n2\n\n\n# 获取标签自定义属性data-* （删除图片的实现）\n\n\x3c!-- 显示图片 --\x3e\n    <block wx:for="{{images}}" wx:key="*this">\n      <view class="image-wrap">\n        \x3c!-- mode 图片裁剪 aspectfill 保证短边完整显示 --\x3e\n        <image class="image" src="{{item}}" mode="aspectfill"></image>\n        <icon class="iconfont icon-shanchu" bindtap="ondelimage" data-index="{{index}}"></icon>\n      </view>\n    </block>\n\n\n    // 删除图片\n  ondelimage(event) {\n  \t// event.target.dataset.index 获取标签属性data-index的值\n    this.data.images.splice(event.target.dataset.index, 1) // splice会改变原有数组\n    this.setdata({\n      images: this.data.images\n    })\n  },\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n# 全屏预览图片(点击图片放大预览)\n\n全屏预览图片\n\n// 全屏预览图片\n  onpreviewimage(event) {\n    wx.previewimage({\n      urls: this.data.images, // 图片地址列表\n      current: event.target.dataset.imgsrc // 当前预览图片地址\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 文件上传云存储（发布博客例子）\n\n文件上传云存储\n\n //  结合\'发布\'的例子：\n  send() {\n    // 验证是否输入内容\n    if (content.trim() === \'\') { // trim() 去掉字符串空格\n      wx.showtoast({\n        title: \'请输入内容\',\n        icon: \'none\'\n      })\n      return\n    }\n    wx.showloading({\n      title: \'发布中\',\n    })\n    /**\n     * 实现思路及步骤：\n     * 1、图片 -> 上传 云存储  -> 生成 图片fineid（云文件id）\n     * 2、数据 -> 录入 云数据库\n     *    数据包括：文字内容、图片fineid、昵称、头像、发布时间、openid(用户唯一标识，在插入数据库是系统会自动添加_openid字段，不需要另外插入)\n     */\n    let promisearr = []\n    let fileids = []\n    // 图片上传云存储\n    this.data.images.foreach((item) => {\n      let p = new promise((resolve, reject) => {\n        let suffix = /\\.\\w+$/.exec(item)[0] // 文件扩展名(文件后缀)\n        wx.cloud.uploadfile({ // 每次只能上传一个文件\n          /**\n           * cloudpath 云路径。如果路径相同，后上传的文件会覆盖原文件\n           * 路径：blog/云存储中的文件夹 + date.now()时间戳 + math.random()*1000000随机数 + 文件后缀\n           */\n          cloudpath: \'blog/\' + date.now() + \'-\' + math.random() * 1000000 + suffix,\n          filepath: item, // 文件本地临时路径\n          success: (res) => {\n            fileids.push(res.fileid)\n            resolve()\n          },\n          fail: (err) => {\n            console.error(err)\n            reject()\n          }\n        })\n      })\n      promisearr.push(p)\n    })\n\n    // 存入云数据库\n    promise.all(promisearr).then((res) => {\n      db.collection(\'blog\').add({\n        data: {\n          ...userinfo, // 昵称、头像\n          content, // 内容\n          img: fileids, // 图片fileid列表\n          createtime: db.serverdate() // 创建时间，取服务端时间\n        }\n      }).then((res) => {\n        wx.hideloading()\n        wx.showtoast({\n          title: \'发布成功\',\n        })\n        // 返回博客页面，并刷新\n        wx.navigateback()\n\n      })\n    }).catch((err) => {\n      wx.hideloading()\n      wx.showtoast({\n        title: \'抱歉，发布失败\',\n        icon: \'none\'\n      })\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n# js模块化 （时间格式化）\n\n在目录utils 中新建formattime.js文件\n\n// 时间格式化 模块封装\nmodule.exports = (date) => { // date 数据格式为 date\n  let fmt = \'yyyy-mm-dd hh:mm:ss\' // 预定格式\n  const o = {\n    // + 正则中的1个或多个\n    \'m+\': date.getmonth() + 1,\n    \'d+\': date.getdate(),\n    \'h+\': date.gethours(),\n    \'m+\': date.getminutes(),\n    \'s+\': date.getseconds()\n  }\n\n  if (/(y+)/.test(fmt)) {\n    // $1 表示正则中的第一个，即(y+)\n    fmt = fmt.replace(regexp.$1, date.getfullyear()) // replace 替换\n  }\n\n  for (let k in o) {\n    if (new regexp(\'(\'+ k +\')\').test(fmt)) {\n      fmt = fmt.replace(regexp.$1, o[k].tostring().length === 1 ? \'0\' + o[k] : o[k])\n    }\n  }\n\n  return fmt\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n在组件引入js模块\n\nimport formattime from \'../../utils/formattime.js\'\n\n使用：\nformattime(new date(\'wed aug 28 2019 16:23:06 gmt+0800 (中国标准时间)\'))\n\n\n1\n2\n3\n4\n\n\n# 阻止事件冒泡\n\nbind 和 catch 都可以绑定事件，它们的区别是 bind 有事件冒泡，而 catch 没有\n\n# 返回上一个页面并执行方法\n\napi\n\n // 返回博客页面，并刷新\n wx.navigateback()\n const pages = getcurrentpages() // 获取当前页面栈\n const prevpage = pages[pages.length - 2]  // 取到上一个页面\n prevpage.onpulldownrefresh() // 执行上一个页面的方法 onpulldownrefresh\n\n\n1\n2\n3\n4\n5\n\n\n# 图片懒加载\n\napi\n\n给image标签设置 lazy-load 为 true\n<image class="img" src="{{item}}" lazy-load="true"></image>\n\n.img {\n  background: #eee;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n懒加载占位图可以给image设置背景图或背景色\n\n# 模糊查询\n\n// 获取博客列表\n  app.router(\'bloglist\', async (ctx, next) => {\n    const keyword = event.keyword // 搜索关键字 调用接口时传递来的数据\n    let w = {}\n    if (keyword.trim() != \'\') {\n      w = {\n        content: db.regexp({ // 正则\n          regexp: keyword,\n          options: \'i\' // i表示忽略大小写\n        })\n      }\n    }\n\n    // where查询条件 skip 从第几条开始查，limit 查几条数据，orderby(排序字段，排序方式) 排序，排序方式desc降序/asc升序\n    ctx.body =  await blogcollection.where(w).skip(event.start).limit(event.count)\n    .orderby(\'createtime\', \'desc\').get().then((res) => {\n      return res.data\n    })\n\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 提升模糊查询的效率 （添加索引，对数据量大的查询效果明显）\n\n云开发控制台 > 数据库相应的集合 > 索引管理 > 添加索引 > 输入自定义索引名称、该字段的值是否唯一、被查询的字段名、升序/降序 > ok\n\n# 小程序端调用云数据库\n\n一般调用云数据库的操作都写在云函数内，其实小程序端也可以对数据库进行操作。\n\n小程序端一次最多只能查询20条数据，云函数端最多可查询100条数据，可使用多次查询拼接的方式突破限制。\n\n// 小程序端调用云数据库示例\n    const db = wx.cloud.database() // 初始化数据库\n    db.collection(\'blog\').orderby(\'createtime\',\'deac\').get().then((res) => {\n      console.log(res)\n    })\n\n\n1\n2\n3\n4\n5\n\n\n# 云数据库权限管理\n\n注意：云控制台和服务端（云函数）始终有所有数据读写权限，\n\n但权限的管理仅对小程序端发起的请求有效。\n\n * 仅创建者可写，所有人可读 （适合于文章）\n\n * 仅创建者可读写 (适用于私密内容)\n\n * 仅管理端可写，所有人可读（适用于商品信息）\n\n * 仅管理端可读写（适用于后台敏感数据）\n\n# 数据库中1对n关系的三种设计方式\n\n# 第一种：n的数量较少 几十个以内\n\n1 条记录存储 n 个子数据\n\n如一条博客中，最多有9张图片，这9张图片可和其他数据放在一个记录中。\n\n[\n\t{\n\t\tid:...\n\t\timg:[\n\t\t\'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\', \'...\'\n\t\t]\n\t}\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 第二种：n的数量较多 几十到几百个\n\n1 存储 每个n的 id\n\n可分两个数据库集合，\n\n一个为 \'目录\' 集合，存放 \'详情\' 集合下的每条数据的 id 目录\n\n一个为 \'详情\' 集合，每条数据对应一个单独的 id 和 详细数据\n\n目录集合：\n[\n\t{\n\t\t\'id\':"11",\n\t\t\'name\': \'产品1\',\n\t\t\'xqs\': [\'111\',\'222\',\'333\', ... ]  // 存放 详情集合 中的每条数据 id\n\t}\n]\n\n\n\n详情集合：\n[\n{\'id\':"111",name:\'零件1\',title:\'...\' ...},\n{\'id\':"222",name:\'零件2\',title:\'...\' ...},\n{\'id\':"333",name:\'零件3\',title:\'...\' ...},\n...\n]\n\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n如歌单列表，与歌曲详情的数据组合设计。\n\n# 第三种：n的数量巨大 几百成千上万个\n\n每个 n 都存储 1 的 id\n\n如新浪博客中的一条博客下面有几千条评论\n\n一条新浪博客：\n[{\n\t\'id\':\'11\',\n\t\'content\':\'博客内容\'\n\t...\n}]\n\n\n上千条评价：\n[\n{\n\t\'id\':\'111111\'\n\t\'blogid\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容1\'\n},\n{\n\t\'id\':\'222222\'\n\t\'blogid\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容2\'\n},\n{\n\t\'id\':\'33333\'\n\t\'blogid\':\'11\', // 这个id对应的是那一条博客的id\n\t\'content\': \'评价内容3\'\n},\n...\n]\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n# 云调用\n\n通过云函数调用服务端的开发接口\n\n这些接口如：模板消息推送、生成小程序码...\n\n# 模板消息推送\n\n1、使用from表单才能触发消息推送，并设置report-submit="true"\n\n\n<form slot="modal-content" report-submit="true" bind:submit="onsend">\n    <textarea name="content" class="comment-content" placeholder="写评论" value="{{content}}" fixed="true"></textarea>\n    <button class="send" form-type="submit">发送</button>\n  </form>\n\n\n1\n2\n3\n4\n5\n\n\n2、需要到微信公众平台做相应的设置：\n\n微信公众平台 > 功能 > 模板消息 > 添加模板 > 选择相应的模板> 添加成功后会有一个模板id\n\n3、新建一个云函数，用于云调用。在该云函数下新建配置文件：config.json ，用于配置权限\n\nconfig.json ：\n\n{\n  "permissions": {\n    "openapi": [\n      "templatemessage.send"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n云函数设置消息推送：\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  // 获取openid\n  const { openid } = cloud.getwxcontext()\n\n  // 模板推送消息\n  const result = await cloud.openapi.templatemessage.send({\n    touser: openid,\n    page: `/pages/blog-comment/blog-comment?blogid=${event.blogid}`, // 用户点击推送消息打开的页面\n    data: { // 模板的内容，keyword为在公众平台设置模板时对应的字段\n      keyword1: { // 评价内容\n        value: event.context\n      },\n      keyword2: { // 评价时间\n        value: event.time\n      }\n    },\n    templateid: \'lnwkmcywlz-0habgbhmzi6cwzrlnsbinj2h0smorcxq\', // 模板id，到公众平台模板消息上获取\n    formid: event.formid // 触发消息推送的form表单的id\n  })\n\n  return result\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n4、在提交表单事件完成后调用消息推送云函数\n\n wx.cloud.callfunction({\n          name: \'sendmessage\',\n          data: {\n            content,\n            formid,\n            blogid: this.properties.blogid\n          }\n        }).then((res) => {\n          console.log(res)\n        })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n# 云函数多集合查询数据库\n\n// 博客详情(博客内容、评论)\n  app.router(\'blogdetail\', async(ctx, next) => {\n    let blogid = event.blogid\n\n    // 博客内容\n    let detail = await blogcollection.where({\n      _id: blogid\n    }).get().then((res) => {\n      return res.data\n    })\n\n    // 评论查询\n    const countresult = await blogcollection.count()\n    const total = countresult.total\n    let commentlist = {\n      data: []\n    }\n    if (total > 0) {\n      // 突破100条限制\n      const batchtimes = math.ceil(total / max_limit)\n      const tasks = []\n      for (let i = 0; i < batchtimes; i++) {\n        let promise = db.collection(\'blog-comment\').skip(i * max_limit)\n          .limit(max_limit).where({\n            blogid\n          }).orderby(\'createtime\', \'desc\').get()\n        tasks.push(promise)\n      }\n      if (tasks.length > 0) {\n        commentlist = (await promise.all(tasks)).reduce((acc, cur) => {\n          return {\n            data: acc.data.concat(cur.data)\n          }\n        })\n      }\n\n    }\n    ctx.body = {\n      detail,\n      commentlist\n    }\n  })\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n# 分享功能\n\n分享功能需要button标签，设置open-type="share"\n\n\n<button open-type="share" data-blogid="{{blogid}}" data-blog="{{blog}}" class="share-btn" hover-class="share-hover">\n      <i class="iconfont icon-fenxiang icon"></i>\n      <text>分享</text>\n    </button>\n\n\n1\n2\n3\n4\n5\n\n\n在js中有onshareappmessage方法，点击button会自动执行此方法\n\nonshareappmessage: function (event) {\n    console.log(event)\n\n    // 对分享卡片的设置\n    let blogobj = event.target.dataset.blog\n    return {\n      title: blogobj.content,\n      path: `/pages/blog-comment/blog-comment?blogid=${blogobj._id}`,\n      // imageurl: \'\' // 自定义图片，不支持云存储的图片\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# 不同场景获取用户信息的方式\n\n# 场景一：只想在界面上显示自己的昵称和头像\n\n以组件的方式：根据type类型获取不同用户数据\n\n该方式不需要授权，只能用于在wxml显示自己的信息\n\nopen-data\n\n<open-data type="useravatarurl"></open-data>\n<open-data type="usernickname"></open-data>\n...\n\n\n1\n2\n3\n\n\n# 场景二：在js中获取用户信息\n\n该方式要在用户授权以后才能获取用户信息\n\nwx.getuserinfo\n\nwx.getuserinfo({\n      success: (res) => {\n        console.log(res)\n      }\n    })\n\n\n1\n2\n3\n4\n5\n\n\n在未授权的情况下需要用户先授权：\n\n// 判断用户是否授权\n      wx.getsetting({\n        success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n          if (res.authsetting[\'scope.userinfo\']) { // 已授权\n            wx.getuserinfo({ // 获取用户信息\n              success: (res) => { // 这里使用箭头函数可改变内部this指向为外部的this\n\n                app.setglobaldata(\'userinfo\', res.userinfo) // 设置app全局属性\n\n                this.onloginsuccess({\n                  detail: res.userinfo\n                })\n              }\n            })\n          } else { // 未授权\n            this.setdata({ // 打开弹出层，显示获取用户信息按钮\n              modalshow: true\n            })\n          }\n        }\n      })\n\n\n  授权按钮\n <button class="login" open-type="getuserinfo" bindgetuserinfo="ongetuserinfo">获取微信授权信息</button>\n\n\n    ongetuserinfo(event) { // 获取用户信息\n      const userinfo = event.detail.userinfo\n      if (userinfo) { // 用户允许授权\n        this.setdata({\n          modalshow: false\n        })\n        this.triggerevent(\'loginsuccess\', userinfo) // 给父组件传用户数据\n      } else { // 用户拒绝授权\n        this.triggerevent(\'loginfail\')\n      }\n    }\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n> 注意：上面这种方式没有获取到openid\n\n# 场景三：获取openid\n\n获取openid不需要用户授权\n\n1、传统开发方式获取openid，后台服务器由自己开发，没使用云开发\n\n小程序端 微信服务器 后端服务器\n\n步骤：\n\n小程序端 调用 wx.login 向微信服务器 获取code\n\n小程序端 调用 wx.request 将 code 传递给 后端服务器\n\n后端服务器 使用code 向微信服务器 换取openid和session_key\n\n后端服务器 将openid 发送给 小程序端\n\n2、云开发方式获取openid\n\n云函数login中\n\n// 获取 wx context (微信调用上下文)，包括 openid、appid、及 unionid（需满足 unionid 获取条件）\n  const wxcontext = cloud.getwxcontext()\n\n  return {\n    event,\n    openid: wxcontext.openid,\n    appid: wxcontext.appid,\n    unionid: wxcontext.unionid,\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n普通按钮\n<button bindtap="getopenid">获取openid</button>\n\ngetopenid() {\n\twx.cloud.callfunction({\n\t\tname: \'login\'\n\t}).then((res) => {\n\t\tconsole.log(res)\n\t})\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> openid 在小程序和公众号下是不一样的\n> \n> unionid 在小程序和公众号下都是一样的\n\n\n# 《我的》页面\n\njson文件\n\n"navigationbartitletext": "我的",\n  "disablescroll": true  // 使页面无法滚动\n\n\n1\n2\n\n\n# 导航页面链接跳转\n\nnavigator\n\n# 背景图片\n\nwxss背景图片不支持本地相对路径的图片，只支持网络图片和base64图片\n\n建议使用base64图片，图片文件最好不要太大。\n\n# 每个页面都有的page标签\n\npage {\n  background-color: #f1f1f1;\n}\n\n\n1\n2\n3\n\n\n# 播放历史与本地存储\n\n方案一：播放历史存储在数据库当中，这样在不同设备访问都可查看播放历史。读取速度相对较慢\n\n方案二：播放历史存储在本地，仅当前设备可查看播放历史。读取速度较快\n\n本项目采用本地存储：\n\n使用openid作为本地存储的key，播放历史存入value\n\n在app.js中获取openid，即打开小程序就获取openid。\n\n// app.js\nonlaunch: function () {\n\tthis.getopenid() // 获取openid并存储\n},\ngetopenid() { // 获取openid并存储\n    wx.cloud.callfunction({\n      name: \'login\'\n    }).then((res) => {\n      const openid = res.result.openid\n      this.globaldata.openid = openid // 保存到全局变量\n      if (wx.getstoragesync(openid) == \'\') { // 该用户从未打开过小程序，未存储过openid在本地\n        wx.setstoragesync(openid, []) // 存储openid到本地\n      }\n    })\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n歌曲播放时\n\n// 保存播放历史到本地存储\n  saveplayhistory() {\n    const currentsong = musiclist[nowplayingindex] // 当前播放歌曲\n    const openid = app.globaldata.openid // 从全局属性获取openid\n    const playhistory = wx.getstoragesync(openid) // 从本地存储获取播放历史数组\n\n    for (let i = 0, len = playhistory.length; i < len; i++) {\n      if (playhistory[i].id === currentsong.id) { // 当前播放歌曲已存在播放历史中\n        playhistory.splice(i, 1) // 删除原纪录\n        break\n      }\n    }\n\n    playhistory.unshift(currentsong) // 在数组开头插入\n    wx.setstorage({ // 存入本地\n      key: openid,\n      data: playhistory\n    })\n\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n播放历史页面获取\n\nonload: function (options) {\n\n    const openid = app.globaldata.openid //从全局属性获取openid\n    const playhistory = wx.getstoragesync(openid) // 读取本地播放历史数据\n\n    if (playhistory.length !== 0) { // 有播放历史\n      this.setdata({\n        playhistory\n      })\n      wx.setstorage({ // storage里把musiclist（播放列表）的内容换成播放历史的列表\n        key: \'musiclist\',\n        data: playhistory,\n      })\n    }\n\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 我的发现\n\n代码分别演示了从云函数和小程序端获取数据，从小程序端获取数据享有权限管理的能力，不需要传openid。\n\n# 小程序码\n\n获取小程序码\n\n本项目演示使用接口 b：适用于需要的码数量极多的业务场景 云调用 的方式。\n\n步骤：\n\n * 创建云函数 gteqrcode\n\n * gteqrcode云函数下创建config.json配置权限，代码如下：\n\n{\n  "permissions":{\n    "openapi":[\n      "wxacode.getunlimited"\n    ]\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n// 云函数入口函数\nexports.main = async (event, context) => {\n  const wxcontext = cloud.getwxcontext()\n\n  const result = await cloud.openapi.wxacode.getunlimited({\n    scene: wxcontext.openid, // 链接参数 不一定传openid，可传其他任意数据，然后通过此数据，在别人扫码进入时就可用于判断\n    // page: "pages/blog/blog" // 默认进入主页\n    // linecolor: { // 线条颜色\n    //   \'r\': 211,\n    //   \'g\': 60,\n    //   \'b\': 57\n    // },\n    // ishyaline: true // 是否透明\n  })\n\n  // result为二进制数据, 先上传到云存储\n\n  // 上传云存储\n  const upload = await cloud.uploadfile({\n    cloudpath: \'qrcode/qrcode\' + date.now() + math.random() + \'.png\',\n    filecontent: result.buffer\n  })\n\n  return upload.fileid\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n# 判断是从扫码小程序码进入，以及参数获取\n\n// 在从小程序码进入的页面js，onload方法中，\n\nonload: function (options) {\n\tconsole.log(options.scene) // 获取到小程序码进入的参数\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 版本更新检测\n\n// app.js\nonlaunch: function(options) {\n    this.checkupate()\n},\ncheckupate(){\n    const updatemanager = wx.getupdatemanager()\n    // 检测版本更新\n    updatemanager.oncheckforupdate((res)=>{\n      if (res.hasupdate){\n        updatemanager.onupdateready(()=>{\n          wx.showmodal({\n            title: \'更新提示\',\n            content: \'新版本已经准备好，是否重启应用\',\n            success(res){\n              if(res.confirm){\n                updatemanager.applyupdate()\n              }\n            }\n          })\n        })\n      }\n    })\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 性能优化\n\n官网文档优化建议\n\n使用开发者工具的调试器，audits进行评分，然后根据提示针对项目进行优化。\n\n\n# 场景值scene的作用与应用场景\n\n场景值\n\n场景值用来描述用户进入小程序的路径。完整场景值的含义请查看场景值列表。\n\n可根据不同场景进入实现不同业务处理，比如一个点餐小程序，店家内贴了小程序码，用户通过扫码进入，可立即进入点餐页面，等等\n\n在app.js中的onlaunch(options) 、onshow(options)，options包含scene场景值\n\n开发者工具中，切后台，可模拟进入场景。\n\n\n# 小程序的"seo"---页面收录sitemap\n\n在app.js的同级目录下有sitemap.json文件，用于配置收录规则\n\nstiemap配置\n\n作用：\n\n使小程序搜索可根据小程序的内容进行搜索到\n\n使用方法：\n\n1、在微信公众平台，小程序信息 > 页面收录设置 > 打开 (默认是已开启)\n\n2、打开sitemap.json文件，配置收录规则\n\n{\n  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",\n  "rules": [{ // 收录规则\n  "action": "allow",// 是否被收录，allow允许被收录，disallow不允许\n  "page": "*" // *星号表示所有页面都被收录\n  }]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n{\n  "desc": "关于本文件的更多信息，请参考文档 https://developers.weixin.qq.com/miniprogram/dev/framework/sitemap.html",\n  "rules": [{ // 收录规则，可添加多条\n  "action": "allow", // 是否被收录\n  "page":"pages/player/player",  // 页面\n  "params": ["musicid","index"], // 链接的动态参数\n   "matching":\'exact\' // 表示params的参数是否要准确的匹配\n  }，{\n  "action": "disallow", // 是否被收录\n  "page":"*",  /\n  }]\n}\n\n// 上面配置规则表示除了player页面被收录外，其他页面不被收录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 小程序上线审核流程\n\n微信公众平台，版本管理>把小程序上传为体验版》提交审核》上线\n\n\n# 后台管理系统\n\n# 架构示意图\n\n前端 后台 小程序云开发\n\nvue-admin-template <---通过ajax--\x3e 基于koa2；http api 或 tcb-admin-node ----\x3e云函数、云数据库、云存储\n\n\n\n# vue-admin-template构建管理系统前端\n\nvue-element-admin 基于element的后台管理系统模板\n\nvue-admin-template 是 vue-element-admin的简化版\n\n使用方法查看官方文档。\n\n# koa2构建管理系统后端\n\n官网： https://koa.bootcss.com/\n\n新建空文件夹wx-music-admin-backend，打开终端：\n\n# 生成package.json文件，-y 表示默认的配置\nnpm init -y\n\n# 安装koa\nnpm install koa\n\n# 新建app.js文件 (win10系统命令)，作为项目入口文件\ntype nul > app.js\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\napp.js:\n\nconst koa = require(\'koa\')\nconst chalk = require(\'chalk\') // 使console.log打印文字有颜色的插件，需: npm i chalk\nconst app = new koa()\n\napp.use(async (ctx) => {\n  ctx.body = \'hello wolrd\'\n})\nconst port = 3000\napp.listen(port, () => { // 端口号，开启服务后的回调函数\n  console.log(chalk.green(`> 服务已开启，访问：http://localhost:${port}`))\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n终端：\n\n# node启动项目\nnode app.js\n\n# 访问：http://localhost:3000\n\n\n1\n2\n3\n4\n\n\n# 接口调用凭证 access_token 的缓存与更新\n\naccess_token，微信的接口调用凭证，详情：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getaccesstoken.html\n\n回到项目wx-music-admin-backend，打开终端：\n\n# http 请求 插件\nnpm i request\nnpm i request-promise\n\n\n1\n2\n3\n\n\n/**\n * 获取微信接口调用凭证\n * 详情：https://developers.weixin.qq.com/miniprogram/dev/api-backend/open-api/access-token/auth.getaccesstoken.html\n */\n\n\nconst rp = require(\'request-promise\') // node发送http请求的插件\nconst fs = require(\'fs\') // node文件模块\nconst path = require(\'path\') // node 路径模块\n\n//filename = __dirname 当前文件所在目录的绝对路径, 加上 \'./access_token.json\'\nconst filename = path.resolve(__dirname, \'./access_token.json\')\n\n// 这两个参数的获取：微信公众平台>开发>开发设置\nconst appid = \'wxc4e0b2d98063b103\'\nconst appsecret = \'xxx\' //小程序密钥，注意保密!\n\n// 微信 access_token 请求地址\nconst url = `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=${appid}&secret=${appsecret}`\n\n// 发送请求获取accesstoken\nconst updateaccesstoken = async () => {\n  const resstr = await rp(url)\n  const res = json.parse(resstr)\n\n  if (res.access_token) {\n    // node写文件,参数：1 文件路径，2 文件内容, 首次写文件为新建，往后为覆盖\n    fs.writefilesync(filename, json.stringify({\n      access_token: res.access_token,\n      createtime: new date()\n    }))\n  } else { // 如获取不到，再次获取\n    await updateaccesstoken()\n  }\n}\n\n// 读取access_token\nconst getaccesstoken = async () => {\n  try {\n     // node读取文件,参数：1 读取的文件，2 字符集\n    const readres = fs.readfilesync(filename, \'utf8\')\n    const readobj = json.parse(readres)\n\n    // 如果服务器宕机导致setinterval无法定时更新，这里需要再次判断access_token的有效性\n    const createtime = new date(readobj.createtime).gettime()\n    const nowtime = new date().gettime()\n    if((nowtime - createtime) / 1000 / 60 / 60 >= 2) {\n      await updateaccesstoken()\n      await getaccesstoken()\n      return\n    }\n    return readobj.access_token\n\n  } catch (error) { //捕获异常，在未创建文件时，先创建文件\n    await updateaccesstoken()\n    await getaccesstoken()\n  }\n}\n\n// access_token有效期为2个小时，定时更新\nsetinterval(async () => {\n  await updateaccesstoken()\n}, (7200 - 300) * 1000)\n\nmodule.exports = getaccesstoken\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n\n\n# 后端代码通过http api 触发云函数获取数据\n\nhttp api 触发云函数\n\n# 产生跨域和后端解决跨域问题\n\n管理系统前端向管理系统后端请求数据，产生了跨域问题\n\n  // 产生跨域的几种情况\n  // http://www.a.com  https://www.a.com 协议不同\n  // http://www.a.com  http://www.b.com 域名不同\n  // http://www.a.com  http://news.a.com 主域与子域不同\n  // http://www.a.com:8080  http://www.a.com:3000 端口不同\n\n// 解决跨域的几种方法\n// jsonp\n// iframe\n// postmessage跨域\n// 跨域资源共享（cors）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n管理系统后端，安装\n\n// 解决跨域问题的koa包\nnpm i koa2-cors\n\n\n1\n2\n\n\napp.js\n\n//处理跨域\napp.use(cors({\n  origin: [\'http://localhost:9528\'], // 允许访问本服务的域\n  credentials: true\n}))\n\n\n1\n2\n3\n4\n5\n\n\n# 云数据库的增删改查接口\n\n数据库查询记录\n\n# 后端获取前端post请求传来的数据\n\nget请求可以直接通过ctx.request.query获取，但是post请求需要安装koa-body\n\nnpm i koa-body\n\n\n1\n\n\napp.js\n\nconst koabody = require(\'koa-body\') // 对post请求前端传来的数据的获取，需要此依赖\n\n// 接收post参数解析\napp.use(koabody({\n  multipart: true\n}))\n\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n接口.js\n\nrouter.post(\'/updateplaylist\', async (ctx, next) => {\n\n  const params = ctx.request.body // post请求获取前端传来的数据，需安装和配置koa-body\n\n})\n\n\n1\n2\n3\n4\n5\n\n\n# 后端获取云存储图片\n\n云存储中上传图片，云数据库中新建图片的集合，并添加数据字段，字段包含云文件的fileid。\n\n后端项目通过调用云数据库的方式获取数据\n\nrouter.get(\'/list\', async (ctx, next) => {\n  // 接口中读取数据库默认最多10条数据\n  const query = `db.collection(\'swiper\').get()`\n  const res = await callclouddb(ctx, \'databasequery\', query)\n  console.log(res)\n\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n但获取到的数据为fileid，并不能用于显示图片，需要通过微信http api获取云存储的接口来获取图片地址\n\n获取云存储\n\n# 后端上传图片到云存储\n\n文件上传',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"JS设计模式总结笔记",frontmatter:{title:"JS设计模式总结笔记",date:"2021-02-27T20:01:18.000Z",permalink:"/pages/4643cd/",categories:["前端","学习笔记"],tags:["设计模式"]},regularPath:"/01.%E5%89%8D%E7%AB%AF/40.%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/50.JS%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93%E7%AC%94%E8%AE%B0.html",relativePath:"01.前端/40.学习笔记/50.JS设计模式总结笔记.md",key:"v-89224ada",path:"/pages/4643cd/",headers:[{level:2,title:"开篇：前端工程师的成长论",slug:"开篇-前端工程师的成长论",normalizedTitle:"开篇：前端工程师的成长论",charIndex:17},{level:2,title:"设计模式之“道”",slug:"设计模式之-道",normalizedTitle:"设计模式之“道”",charIndex:302},{level:3,title:"核心思想",slug:"核心思想",normalizedTitle:"核心思想",charIndex:351},{level:2,title:"设计模式之“术”",slug:"设计模式之-术",normalizedTitle:"设计模式之“术”",charIndex:442},{level:3,title:"创建型",slug:"创建型",normalizedTitle:"创建型",charIndex:466},{level:3,title:"结构型",slug:"结构型",normalizedTitle:"结构型",charIndex:470},{level:3,title:"行为型",slug:"行为型",normalizedTitle:"行为型",charIndex:474},{level:2,title:"小结：",slug:"小结",normalizedTitle:"小结：",charIndex:733},{level:2,title:"创建型：工厂模式-简单工厂——区分“变与不变”",slug:"创建型-工厂模式-简单工厂-区分-变与不变",normalizedTitle:"创建型：工厂模式-简单工厂——区分“变与不变”",charIndex:847},{level:3,title:"构造器模式",slug:"构造器模式",normalizedTitle:"构造器模式",charIndex:512},{level:3,title:"简单工厂模式",slug:"简单工厂模式",normalizedTitle:"简单工厂模式",charIndex:1126}],headersStr:"开篇：前端工程师的成长论 设计模式之“道” 核心思想 设计模式之“术” 创建型 结构型 行为型 小结： 创建型：工厂模式-简单工厂——区分“变与不变” 构造器模式 简单工厂模式",content:"# JS设计模式总结笔记\n\n\n# 开篇：前端工程师的成长论\n\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\n\n所谓“不变的东西”，就是驾驭技术的能力。\n\n具体来说，它分为以下三个层次：\n\n * 能用健壮的代码去解决具体的问题；\n * 能用抽象的思维去应对复杂的系统；\n * 能用工程化的思想去规划更大规模的业务。\n\n> 基础理论知识是一个人的基线，理论越强基线越高。再为自己定一个目标和向上攀附的阶梯，那么达到目标就是时间问题，而很多野路子工程师搞了半辈子也未达到优秀工程师的基线，很多他们绞尽脑汁得出的高深学问，不过是正规工程师看起来很自然的东西。—— 吴军\n\n\n# 设计模式之“道”\n\n * 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\n\n\n# 核心思想\n\n * 设计模式的核心思想——封装变化\n * 保证可维护性、可扩展性。\n * 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\n\n\n# 设计模式之“术”\n\n即最经典的23种设计模式。按创建型、结构型、行为型划分。\n\n\n# 创建型\n\n 1. 单例模式\n 2. 原型模式\n 3. 构造器模式\n 4. 工厂模式\n 5. 抽象工厂模式\n\n\n# 结构型\n\n 1. 桥接模式\n 2. 外观模式\n 3. 组合模式\n 4. 装饰器模式\n 5. 适配器模式\n 6. 代理模式\n 7. 享元模式\n\n\n# 行为型\n\n 1.  迭代器模式\n 2.  解释器模式\n 3.  观察者模式\n 4.  访问者模式\n 5.  状态模式\n 6.  备忘录模式\n 7.  策略模式\n 8.  模板方法模式\n 9.  职责链模式\n 10. 命令模式\n\n\n# 小结：\n\n * 创建型模型封装了创建对象过程中的变化。\n\n * 结构型模式封装了对象之间组合方式的变化。目的在于灵活的表达对象间的配合与依赖关系。\n\n * 行为型模式将对象千变万化的行为进行抽离，确保安全、方便的更改。\n\n\n# 创建型：工厂模式-简单工厂——区分“变与不变”\n\n先了解构造器模式，在JS中的构造函数即构造器。使用构造函数，即使用构造器模式。\n\n\n# 构造器模式\n\nfunction User(name, age, career){\n  this.name = name\n  this.age = age\n  this.career = career\n}\nconst user = New User('张三', 18, '前端工程师')\n\n\n1\n2\n3\n4\n5\n6\n\n\n变与不变：user的属性(name, age, car)不变，即共性。变的是属性值，即个性。\n\n\n# 简单工厂模式\n\nfunction User(name , age, career, work) {\n    this.name = name\n    this.age = age\n    this.career = career\n    this.work = work\n}\n\n// 工厂函数 （将变的部分抽离出一个函数）\nfunction Factory(name, age, career) {\n    let work\n    switch(career) {\n        case 'coder':\n            work =  ['写代码','写系分', '修Bug']\n            break\n        case 'product manager':\n            work = ['订会议室', '写PRD', '催更']\n            break\n        case 'boss':\n            work = ['喝茶', '看报', '见客户']\n\n        // 其它工种的职责分配\n        //case 'xxx':\n            //...\n\n    return new User(name, age, career, work)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n工厂模式就是将创建对象的过程单独封装。",normalizedContent:"# js设计模式总结笔记\n\n\n# 开篇：前端工程师的成长论\n\n能够决定一个前端工程师的本质的，不是那些瞬息万变的技术点，而是那些不变的东西。\n\n所谓“不变的东西”，就是驾驭技术的能力。\n\n具体来说，它分为以下三个层次：\n\n * 能用健壮的代码去解决具体的问题；\n * 能用抽象的思维去应对复杂的系统；\n * 能用工程化的思想去规划更大规模的业务。\n\n> 基础理论知识是一个人的基线，理论越强基线越高。再为自己定一个目标和向上攀附的阶梯，那么达到目标就是时间问题，而很多野路子工程师搞了半辈子也未达到优秀工程师的基线，很多他们绞尽脑汁得出的高深学问，不过是正规工程师看起来很自然的东西。—— 吴军\n\n\n# 设计模式之“道”\n\n * 设计模式是“拿来主义”。如使用数学公式，不会从头推导一个公式。\n\n\n# 核心思想\n\n * 设计模式的核心思想——封装变化\n * 保证可维护性、可扩展性。\n * 将变与不变分离，确保变化的部分灵活，不变的部分稳定。——这就是所谓的“健壮”的代码。\n\n\n# 设计模式之“术”\n\n即最经典的23种设计模式。按创建型、结构型、行为型划分。\n\n\n# 创建型\n\n 1. 单例模式\n 2. 原型模式\n 3. 构造器模式\n 4. 工厂模式\n 5. 抽象工厂模式\n\n\n# 结构型\n\n 1. 桥接模式\n 2. 外观模式\n 3. 组合模式\n 4. 装饰器模式\n 5. 适配器模式\n 6. 代理模式\n 7. 享元模式\n\n\n# 行为型\n\n 1.  迭代器模式\n 2.  解释器模式\n 3.  观察者模式\n 4.  访问者模式\n 5.  状态模式\n 6.  备忘录模式\n 7.  策略模式\n 8.  模板方法模式\n 9.  职责链模式\n 10. 命令模式\n\n\n# 小结：\n\n * 创建型模型封装了创建对象过程中的变化。\n\n * 结构型模式封装了对象之间组合方式的变化。目的在于灵活的表达对象间的配合与依赖关系。\n\n * 行为型模式将对象千变万化的行为进行抽离，确保安全、方便的更改。\n\n\n# 创建型：工厂模式-简单工厂——区分“变与不变”\n\n先了解构造器模式，在js中的构造函数即构造器。使用构造函数，即使用构造器模式。\n\n\n# 构造器模式\n\nfunction user(name, age, career){\n  this.name = name\n  this.age = age\n  this.career = career\n}\nconst user = new user('张三', 18, '前端工程师')\n\n\n1\n2\n3\n4\n5\n6\n\n\n变与不变：user的属性(name, age, car)不变，即共性。变的是属性值，即个性。\n\n\n# 简单工厂模式\n\nfunction user(name , age, career, work) {\n    this.name = name\n    this.age = age\n    this.career = career\n    this.work = work\n}\n\n// 工厂函数 （将变的部分抽离出一个函数）\nfunction factory(name, age, career) {\n    let work\n    switch(career) {\n        case 'coder':\n            work =  ['写代码','写系分', '修bug']\n            break\n        case 'product manager':\n            work = ['订会议室', '写prd', '催更']\n            break\n        case 'boss':\n            work = ['喝茶', '看报', '见客户']\n\n        // 其它工种的职责分配\n        //case 'xxx':\n            //...\n\n    return new user(name, age, career, work)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n工厂模式就是将创建对象的过程单独封装。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"常用meta整理",frontmatter:{title:"常用meta整理",date:"2020-02-21T12:20:10.000Z",permalink:"/pages/8309a5b876fc95e3",categories:["页面","HTML"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/10.HTML/10.%E5%B8%B8%E7%94%A8meta%E6%95%B4%E7%90%86.html",relativePath:"02.页面/10.HTML/10.常用meta整理.md",key:"v-1f5da569",path:"/pages/8309a5b876fc95e3/",headers:[{level:2,title:"元素",slug:"meta-元素",normalizedTitle:"元素",charIndex:22},{level:3,title:"概要",slug:"概要",normalizedTitle:"概要",charIndex:29},{level:3,title:"网页相关",slug:"网页相关",normalizedTitle:"网页相关",charIndex:588},{level:3,title:"SEO优化",slug:"seo优化",normalizedTitle:"seo优化",charIndex:1948},{level:3,title:"移动设备",slug:"移动设备",normalizedTitle:"移动设备",charIndex:2933},{level:3,title:"一个常用的移动端页面meta设置",slug:"一个常用的移动端页面meta设置",normalizedTitle:"一个常用的移动端页面meta设置",charIndex:4976}],excerpt:'<h1 id="常用meta整理"><a class="header-anchor" href="#常用meta整理">#</a> 常用meta整理</h1>\n<h2 id="meta-元素"><a class="header-anchor" href="#meta-元素">#</a> &lt;meta&gt; 元素</h2>\n<h3 id="概要"><a class="header-anchor" href="#概要">#</a> 概要</h3>\n<p>meta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。</p>\n',headersStr:"元素 概要 网页相关 SEO优化 移动设备 一个常用的移动端页面meta设置",content:'# 常用meta整理\n\n\n# <meta> 元素\n\n\n# 概要\n\nmeta标签提供关于HTML文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\n\n必要属性\n\n属性        值           描述\ncontent   some text   定义与http-equiv或name属性相关的元信息\n\n可选属性\n\n属性           值                                                         描述\nhttp-equiv   content-type / expire / refresh / set-cookie              把content属性关联到HTTP头部。\nname         author / description / keywords / generator / revised /   把 content 属性关联到一个name。\n             others\ncontent      some text                                                 定义用于翻译 content 属性值的格式。\n\n\n# 网页相关\n\n * 申明编码\n\n<meta charset=\'utf-8\' />\n\n\n1\n\n * 优先使用 IE 最新版本和 Chrome\n\n\x3c!-- 关于X-UA-Compatible --\x3e\n<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /> \x3c!-- 推荐 --\x3e\n\n<meta http-equiv="X-UA-Compatible" content="IE=6" >\x3c!-- 使用IE6 --\x3e\n<meta http-equiv="X-UA-Compatible" content="IE=7" >\x3c!-- 使用IE7 --\x3e\n<meta http-equiv="X-UA-Compatible" content="IE=8" >\x3c!-- 使用IE8 --\x3e\n\n\n1\n2\n3\n4\n5\n6\n\n * 浏览器内核控制：国内浏览器很多都是双内核（webkit和Trident），webkit内核高速浏览，IE内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。参考文档\n\n默认用极速核(Chrome)：<meta name="renderer" content="webkit"> \n默认用ie兼容内核（IE6/7）：<meta name="renderer" content="ie-comp"> \n默认用ie标准内核（IE9/IE10/IE11/取决于用户的IE）：<meta name="renderer" content="ie-stand"> \n\n\n1\n2\n3\n\n\n国内双核浏览器默认内核模式如下：\n\n 1. 搜狗高速浏览器、QQ浏览器：IE内核（兼容模式）\n 2. 360极速浏览器、遨游浏览器：Webkit内核（极速模式）\n\n * 禁止浏览器从本地计算机的缓存中访问页面内容：这样设定，访问者将无法脱机浏览。\n\n<meta http-equiv="Pragma" content="no-cache">\n\n\n1\n\n * Windows 8\n\n<meta name="msapplication-TileColor" content="#000"/> \x3c!-- Windows 8 磁贴颜色 --\x3e\n<meta name="msapplication-TileImage" content="icon.png"/> \x3c!-- Windows 8 磁贴图标 --\x3e\n\n\n1\n2\n\n * 站点适配：主要用于PC-手机页的对应关系。\n\n<meta name="mobile-agent"content="format=[wml|xhtml|html5]; url=url">\n\x3c!--\n[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；\nurl="url" 后者代表当前PC页所对应的手机页URL，两者必须是一一对应关系。\n --\x3e\n\n\n1\n2\n3\n4\n5\n\n * 转码申明：用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下meta。\n\n<meta http-equiv="Cache-Control" content="no-siteapp" />\n\n\n1\n\n\n\n# SEO优化\n\n参考文档\n\n * 页面关键词，每个网页应具有描述该网页内容的一组唯一的关键字。 使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。\n\n<meta name="keywords" content="your tags" />\n\n\n1\n\n * 页面描述，每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。\n\n<meta name="description" content="150 words" />\n\n\n1\n\n * 搜索引擎索引方式，robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。\n\n<meta name="robots" content="index,follow" />\n\x3c!--\n    all：文件将被检索，且页面上的链接可以被查询；\n    none：文件将不被检索，且页面上的链接不可以被查询；\n    index：文件将被检索；\n    follow：页面上的链接可以被查询；\n    noindex：文件将不被检索；\n    nofollow：页面上的链接不可以被查询。\n --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 页面重定向和刷新：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。\n\n<meta http-equiv="refresh" content="0;url=" />\n\n\n1\n\n * 其他\n\n<meta name="author" content="author name" /> \x3c!-- 定义网页作者 --\x3e\n<meta name="google" content="index,follow" />\n<meta name="googlebot" content="index,follow" />\n<meta name="verify" content="index,follow" />\n\n\n1\n2\n3\n4\n\n\n\n# 移动设备\n\n * viewport：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。\n\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no"/>\n\x3c!--这是常用的移动meta设置--\x3e\n\n\n1\n2\n\n 1. width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素）\n 2. height：高度（数值 / device-height）（范围从223 到10,000）\n 3. initial-scale：初始的缩放比例 （范围从>0 到10）\n 4. minimum-scale：允许用户缩放到的最小比例\n 5. maximum-scale：允许用户缩放到的最大比例\n 6. user-scalable：用户是否可以手动缩 (no,yes)\n\n注意，很多人使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果和initial-scale=1同时使用user-scalable=no或maximum-scale=1，则用户将不能放大/缩小网页来看到全部的内容。\n\n * WebApp全屏模式：伪装app，离线应用。\n\n<meta name="apple-mobile-web-app-capable" content="yes" /> \x3c!-- 启用 WebApp 全屏模式 --\x3e\n\n\n1\n\n * 主题颜色\n\n<meta name="theme-color" content="#11a8cd">\n\n\n1\n\n\n\n\n * 隐藏状态栏/设置状态栏颜色：只有在开启WebApp全屏模式时才生效。content的值为default | black | black-translucent 。\n\n<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />\n\n\n1\n\n * 添加到主屏后的标题\n\n<meta name="apple-mobile-web-app-title" content="标题">\n\n\n1\n\n * 忽略数字自动识别为电话号码\n\n<meta content="telephone=no" name="format-detection" />\n\n\n1\n\n * 忽略识别邮箱\n\n<meta content="email=no" name="format-detection" />\n\n\n1\n\n * 添加智能 App 广告条 Smart App Banner：告诉浏览器这个网站对应的app，并在页面上显示下载banner(如下图)。参考文档\n\n<meta name="apple-itunes-app" content="app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL">\n\n\n1\n\n\n\n\n * 其他 参考文档\n\n\x3c!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --\x3e\n<meta name="HandheldFriendly" content="true">\n\x3c!-- 微软的老式浏览器 --\x3e\n<meta name="MobileOptimized" content="320">\n\x3c!-- uc强制竖屏 --\x3e\n<meta name="screen-orientation" content="portrait">\n\x3c!-- QQ强制竖屏 --\x3e\n<meta name="x5-orientation" content="portrait">\n\x3c!-- UC强制全屏 --\x3e\n<meta name="full-screen" content="yes">\n\x3c!-- QQ强制全屏 --\x3e\n<meta name="x5-fullscreen" content="true">\n\x3c!-- UC应用模式 --\x3e\n<meta name="browsermode" content="application">\n\x3c!-- QQ应用模式 --\x3e\n<meta name="x5-page-mode" content="app">\n\x3c!-- windows phone 点击无高光 --\x3e\n<meta name="msapplication-tap-highlight" content="no">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 一个常用的移动端页面meta设置\n\n<meta charset="utf-8">\n<meta http-equiv="X-UA-Compatible" content="IE=edge">\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no">\n\n\n1\n2\n3\n',normalizedContent:'# 常用meta整理\n\n\n# <meta> 元素\n\n\n# 概要\n\nmeta标签提供关于html文档的元数据。元数据不会显示在页面上，但是对于机器是可读的。它可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。\n\n必要属性\n\n属性        值           描述\ncontent   some text   定义与http-equiv或name属性相关的元信息\n\n可选属性\n\n属性           值                                                         描述\nhttp-equiv   content-type / expire / refresh / set-cookie              把content属性关联到http头部。\nname         author / description / keywords / generator / revised /   把 content 属性关联到一个name。\n             others\ncontent      some text                                                 定义用于翻译 content 属性值的格式。\n\n\n# 网页相关\n\n * 申明编码\n\n<meta charset=\'utf-8\' />\n\n\n1\n\n * 优先使用 ie 最新版本和 chrome\n\n\x3c!-- 关于x-ua-compatible --\x3e\n<meta http-equiv="x-ua-compatible" content="ie=edge,chrome=1" /> \x3c!-- 推荐 --\x3e\n\n<meta http-equiv="x-ua-compatible" content="ie=6" >\x3c!-- 使用ie6 --\x3e\n<meta http-equiv="x-ua-compatible" content="ie=7" >\x3c!-- 使用ie7 --\x3e\n<meta http-equiv="x-ua-compatible" content="ie=8" >\x3c!-- 使用ie8 --\x3e\n\n\n1\n2\n3\n4\n5\n6\n\n * 浏览器内核控制：国内浏览器很多都是双内核（webkit和trident），webkit内核高速浏览，ie内核兼容网页和旧版网站。而添加meta标签的网站可以控制浏览器选择何种内核渲染。参考文档\n\n默认用极速核(chrome)：<meta name="renderer" content="webkit"> \n默认用ie兼容内核（ie6/7）：<meta name="renderer" content="ie-comp"> \n默认用ie标准内核（ie9/ie10/ie11/取决于用户的ie）：<meta name="renderer" content="ie-stand"> \n\n\n1\n2\n3\n\n\n国内双核浏览器默认内核模式如下：\n\n 1. 搜狗高速浏览器、qq浏览器：ie内核（兼容模式）\n 2. 360极速浏览器、遨游浏览器：webkit内核（极速模式）\n\n * 禁止浏览器从本地计算机的缓存中访问页面内容：这样设定，访问者将无法脱机浏览。\n\n<meta http-equiv="pragma" content="no-cache">\n\n\n1\n\n * windows 8\n\n<meta name="msapplication-tilecolor" content="#000"/> \x3c!-- windows 8 磁贴颜色 --\x3e\n<meta name="msapplication-tileimage" content="icon.png"/> \x3c!-- windows 8 磁贴图标 --\x3e\n\n\n1\n2\n\n * 站点适配：主要用于pc-手机页的对应关系。\n\n<meta name="mobile-agent"content="format=[wml|xhtml|html5]; url=url">\n\x3c!--\n[wml|xhtml|html5]根据手机页的协议语言，选择其中一种；\nurl="url" 后者代表当前pc页所对应的手机页url，两者必须是一一对应关系。\n --\x3e\n\n\n1\n2\n3\n4\n5\n\n * 转码申明：用百度打开网页可能会对其进行转码（比如贴广告），避免转码可添加如下meta。\n\n<meta http-equiv="cache-control" content="no-siteapp" />\n\n\n1\n\n\n\n# seo优化\n\n参考文档\n\n * 页面关键词，每个网页应具有描述该网页内容的一组唯一的关键字。 使用人们可能会搜索，并准确描述网页上所提供信息的描述性和代表性关键字及短语。标记内容太短，则搜索引擎可能不会认为这些内容相关。另外标记不应超过 874 个字符。\n\n<meta name="keywords" content="your tags" />\n\n\n1\n\n * 页面描述，每个网页都应有一个不超过 150 个字符且能准确反映网页内容的描述标签。\n\n<meta name="description" content="150 words" />\n\n\n1\n\n * 搜索引擎索引方式，robotterms是一组使用逗号(,)分割的值，通常有如下几种取值：none，noindex，nofollow，all，index和follow。确保正确使用nofollow和noindex属性值。\n\n<meta name="robots" content="index,follow" />\n\x3c!--\n    all：文件将被检索，且页面上的链接可以被查询；\n    none：文件将不被检索，且页面上的链接不可以被查询；\n    index：文件将被检索；\n    follow：页面上的链接可以被查询；\n    noindex：文件将不被检索；\n    nofollow：页面上的链接不可以被查询。\n --\x3e\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n * 页面重定向和刷新：content内的数字代表时间（秒），既多少时间后刷新。如果加url,则会重定向到指定网页（搜索引擎能够自动检测，也很容易被引擎视作误导而受到惩罚）。\n\n<meta http-equiv="refresh" content="0;url=" />\n\n\n1\n\n * 其他\n\n<meta name="author" content="author name" /> \x3c!-- 定义网页作者 --\x3e\n<meta name="google" content="index,follow" />\n<meta name="googlebot" content="index,follow" />\n<meta name="verify" content="index,follow" />\n\n\n1\n2\n3\n4\n\n\n\n# 移动设备\n\n * viewport：能优化移动浏览器的显示。如果不是响应式网站，不要使用initial-scale或者禁用缩放。\n\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no"/>\n\x3c!--这是常用的移动meta设置--\x3e\n\n\n1\n2\n\n 1. width：宽度（数值 / device-width）（范围从200 到10,000，默认为980 像素）\n 2. height：高度（数值 / device-height）（范围从223 到10,000）\n 3. initial-scale：初始的缩放比例 （范围从>0 到10）\n 4. minimum-scale：允许用户缩放到的最小比例\n 5. maximum-scale：允许用户缩放到的最大比例\n 6. user-scalable：用户是否可以手动缩 (no,yes)\n\n注意，很多人使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染，用户需要手动移动页面或者缩放。如果和initial-scale=1同时使用user-scalable=no或maximum-scale=1，则用户将不能放大/缩小网页来看到全部的内容。\n\n * webapp全屏模式：伪装app，离线应用。\n\n<meta name="apple-mobile-web-app-capable" content="yes" /> \x3c!-- 启用 webapp 全屏模式 --\x3e\n\n\n1\n\n * 主题颜色\n\n<meta name="theme-color" content="#11a8cd">\n\n\n1\n\n\n\n\n * 隐藏状态栏/设置状态栏颜色：只有在开启webapp全屏模式时才生效。content的值为default | black | black-translucent 。\n\n<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />\n\n\n1\n\n * 添加到主屏后的标题\n\n<meta name="apple-mobile-web-app-title" content="标题">\n\n\n1\n\n * 忽略数字自动识别为电话号码\n\n<meta content="telephone=no" name="format-detection" />\n\n\n1\n\n * 忽略识别邮箱\n\n<meta content="email=no" name="format-detection" />\n\n\n1\n\n * 添加智能 app 广告条 smart app banner：告诉浏览器这个网站对应的app，并在页面上显示下载banner(如下图)。参考文档\n\n<meta name="apple-itunes-app" content="app-id=myappstoreid, affiliate-data=myaffiliatedata, app-argument=myurl">\n\n\n1\n\n\n\n\n * 其他 参考文档\n\n\x3c!-- 针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓 --\x3e\n<meta name="handheldfriendly" content="true">\n\x3c!-- 微软的老式浏览器 --\x3e\n<meta name="mobileoptimized" content="320">\n\x3c!-- uc强制竖屏 --\x3e\n<meta name="screen-orientation" content="portrait">\n\x3c!-- qq强制竖屏 --\x3e\n<meta name="x5-orientation" content="portrait">\n\x3c!-- uc强制全屏 --\x3e\n<meta name="full-screen" content="yes">\n\x3c!-- qq强制全屏 --\x3e\n<meta name="x5-fullscreen" content="true">\n\x3c!-- uc应用模式 --\x3e\n<meta name="browsermode" content="application">\n\x3c!-- qq应用模式 --\x3e\n<meta name="x5-page-mode" content="app">\n\x3c!-- windows phone 点击无高光 --\x3e\n<meta name="msapplication-tap-highlight" content="no">\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 一个常用的移动端页面meta设置\n\n<meta charset="utf-8">\n<meta http-equiv="x-ua-compatible" content="ie=edge">\n<meta name="viewport" content="width=device-width,initial-scale=1.0,minimun-scale=1.0,maximum-scale=1.0,user-scalable=no">\n\n\n1\n2\n3\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"CSS教程和技巧收藏",frontmatter:{title:"CSS教程和技巧收藏",date:"2020-08-11T17:13:52.000Z",permalink:"/pages/c8f128/",categories:["页面","CSS"],tags:[null]},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/00.CSS%E6%95%99%E7%A8%8B%E5%92%8C%E6%8A%80%E5%B7%A7%E6%94%B6%E8%97%8F.html",relativePath:"02.页面/20.CSS/00.CSS教程和技巧收藏.md",key:"v-1400beac",path:"/pages/c8f128/",headers:[{level:2,title:"Flex 布局教程：语法篇",slug:"flex-布局教程-语法篇",normalizedTitle:"flex 布局教程：语法篇",charIndex:2},{level:2,title:"CSS Grid 网格布局教程",slug:"css-grid-网格布局教程",normalizedTitle:"css grid 网格布局教程",charIndex:78},{level:2,title:"只要一行代码，实现五种 CSS 经典布局",slug:"只要一行代码-实现五种-css-经典布局",normalizedTitle:"只要一行代码，实现五种 css 经典布局",charIndex:164}],headersStr:"Flex 布局教程：语法篇 CSS Grid 网格布局教程 只要一行代码，实现五种 CSS 经典布局",content:"# Flex 布局教程：语法篇\n\nhttp://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n\n\n# CSS Grid 网格布局教程\n\nhttp://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\n\n\n# 只要一行代码，实现五种 CSS 经典布局\n\nhttp://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html\n\n * 空间居中布局\n   \n   > 不管容器的大小，项目总是占据中心点\n\n * 并列式布局\n   \n   > 多个项目并列，如果宽度不够，放不下的项目就自动折行\n\n * 两栏式布局\n   \n   > 一个边栏，一个主栏。边栏始终存在，主栏根据设备宽度，变宽或者变窄\n\n * 三明治布局\n   \n   > 页面在垂直方向上，分成三部分：页眉、内容区、页脚。\n\n * 圣杯布局\n   \n   > 最常用的布局，所以被比喻为圣杯。它将页面分成五个部分，除了页眉和页脚，内容区分成左边栏、主栏、右边栏。",normalizedContent:"# flex 布局教程：语法篇\n\nhttp://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n\n\n# css grid 网格布局教程\n\nhttp://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\n\n\n# 只要一行代码，实现五种 css 经典布局\n\nhttp://www.ruanyifeng.com/blog/2020/08/five-css-layouts-in-one-line.html\n\n * 空间居中布局\n   \n   > 不管容器的大小，项目总是占据中心点\n\n * 并列式布局\n   \n   > 多个项目并列，如果宽度不够，放不下的项目就自动折行\n\n * 两栏式布局\n   \n   > 一个边栏，一个主栏。边栏始终存在，主栏根据设备宽度，变宽或者变窄\n\n * 三明治布局\n   \n   > 页面在垂直方向上，分成三部分：页眉、内容区、页脚。\n\n * 圣杯布局\n   \n   > 最常用的布局，所以被比喻为圣杯。它将页面分成五个部分，除了页眉和页脚，内容区分成左边栏、主栏、右边栏。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"flex布局语法",frontmatter:{title:"flex布局语法",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/0a83b083bdf257cb",author:{name:"阮一峰"},categories:["页面","CSS"],tags:[null]},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/01.flex%E5%B8%83%E5%B1%80%E8%AF%AD%E6%B3%95.html",relativePath:"02.页面/20.CSS/01.flex布局语法.md",key:"v-829901ca",path:"/pages/0a83b083bdf257cb/",headers:[{level:2,title:"一、flex 布局是什么？",slug:"一、flex-布局是什么",normalizedTitle:"一、flex 布局是什么？",charIndex:15},{level:2,title:"二、基本概念",slug:"二、基本概念",normalizedTitle:"二、基本概念",charIndex:364},{level:2,title:"三、容器的属性",slug:"三、容器的属性",normalizedTitle:"三、容器的属性",charIndex:668},{level:3,title:"3.1 flex-direction属性",slug:"_3-1-flex-direction属性",normalizedTitle:"3.1 flex-direction属性",charIndex:893},{level:3,title:"3.2 flex-wrap属性",slug:"_3-2-flex-wrap属性",normalizedTitle:"3.2 flex-wrap属性",charIndex:1187},{level:3,title:"3.3 flex-flow",slug:"_3-3-flex-flow",normalizedTitle:"3.3 flex-flow",charIndex:1432},{level:3,title:"3.4 justify-content属性",slug:"_3-4-justify-content属性",normalizedTitle:"3.4 justify-content属性",charIndex:1593},{level:3,title:"3.5 align-items属性",slug:"_3-5-align-items属性",normalizedTitle:"3.5 align-items属性",charIndex:1957},{level:3,title:"3.6 align-content属性",slug:"_3-6-align-content属性",normalizedTitle:"3.6 align-content属性",charIndex:2301},{level:2,title:"四、项目的属性",slug:"四、项目的属性",normalizedTitle:"四、项目的属性",charIndex:2724},{level:3,title:"4.1 order属性",slug:"_4-1-order属性",normalizedTitle:"4.1 order属性",charIndex:2876},{level:3,title:"4.2 flex-grow属性",slug:"_4-2-flex-grow属性",normalizedTitle:"4.2 flex-grow属性",charIndex:2984},{level:3,title:"4.3 flex-shrink属性",slug:"_4-3-flex-shrink属性",normalizedTitle:"4.3 flex-shrink属性",charIndex:3213},{level:3,title:"4.4 flex-basis属性",slug:"_4-4-flex-basis属性",normalizedTitle:"4.4 flex-basis属性",charIndex:3455},{level:3,title:"4.5 flex属性",slug:"_4-5-flex属性",normalizedTitle:"4.5 flex属性",charIndex:3698},{level:3,title:"4.6 align-self属性",slug:"_4-6-align-self属性",normalizedTitle:"4.6 align-self属性",charIndex:3970}],excerpt:'<h1 id="flex布局语法"><a class="header-anchor" href="#flex布局语法">#</a> flex布局语法</h1>\n<h2 id="一、flex-布局是什么"><a class="header-anchor" href="#一、flex-布局是什么">#</a> 一、flex 布局是什么？</h2>\n<p>Flex是 Flexible Box 的缩写，意为&quot;弹性布局&quot;，用来为盒状模型提供最大的灵活性。</p>\n<p><strong>任何一个容器</strong> 都可以指定为 Flex 布局。</p>\n',headersStr:"一、flex 布局是什么？ 二、基本概念 三、容器的属性 3.1 flex-direction属性 3.2 flex-wrap属性 3.3 flex-flow 3.4 justify-content属性 3.5 align-items属性 3.6 align-content属性 四、项目的属性 4.1 order属性 4.2 flex-grow属性 4.3 flex-shrink属性 4.4 flex-basis属性 4.5 flex属性 4.6 align-self属性",content:'# flex布局语法\n\n\n# 一、flex 布局是什么？\n\nFlex是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。\n\n任何一个容器 都可以指定为 Flex 布局。\n\n.box{\n  display: flex;\n}\n\n\n1\n2\n3\n\n\n行内元素 也可以使用 Flex 布局。\n\n.box{\n  display: inline-flex;\n}\n\n\n1\n2\n3\n\n\nWebkit 内核的浏览器，必须加上-webkit前缀。\n\n.box{\n  display: -webkit-flex; /* Safari */\n  display: flex;\n}\n\n\n1\n2\n3\n4\n\n\n注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。\n\n\n# 二、基本概念\n\n采用 Flex 布局的元素，称为 Flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称"项目"。\n\n\n\n容器默认存在两根轴：水平的主轴（或x轴）（main axis）和垂直的交叉轴（或y轴）（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n\n# 三、容器的属性\n\n以下6个属性设置在容器上。(即设置在 display: flex; 的元素上)\n\n>  * flex-direction 方向 决定项目的排列方向\n> \n>  * flex-wrap 换行\n> \n>  * flex-flow 方向和换行的简写\n> \n>  * justify-content 主轴对齐方式\n> \n>  * align-items 交叉轴对齐方式\n> \n>  * align-content 多轴线的对齐方式\n\n\n# 3.1 flex-direction属性\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n\n> .box {\n>   flex-direction: row | row-reverse | column | column-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它可能有4个值。\n\n>  * row（默认值）：主轴为水平方向，起点在左端。\n>  * row-reverse：主轴为水平方向，起点在右端。\n>  * column：主轴为垂直方向，起点在上沿。\n>  * column-reverse：主轴为垂直方向，起点在下沿。\n\n\n# 3.2 flex-wrap属性\n\n默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n\n\n\n> .box{\n>   flex-wrap: nowrap | wrap | wrap-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n它可能取三个值。\n\n（1）nowrap（默认）：不换行。会压缩项目的宽度\n\n\n\n（2）wrap：换行，第一行在上方。\n\n\n\n（3）wrap-reverse：换行，第一行在下方。\n\n\n\n\n# 3.3 flex-flow\n\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n> .box {\n>   flex-flow: <flex-direction> || <flex-wrap>;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n# 3.4 justify-content属性\n\njustify-content属性定义了项目在主轴上的对齐方式。\n\n> .box {\n>   justify-content: flex-start | flex-end | center | space-between | space-around;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n>  * flex-start（默认值）：左对齐\n>  * flex-end：右对齐\n>  * center： 居中\n>  * space-between：两端对齐，项目之间的间隔都相等。\n>  * space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n\n# 3.5 align-items属性\n\nalign-items属性定义项目在交叉轴上如何对齐。\n\n> .box {\n>   align-items: flex-start | flex-end | center | baseline | stretch;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n>  * flex-start：交叉轴的起点对齐。\n>  * flex-end：交叉轴的终点对齐。\n>  * center：交叉轴的中点对齐。\n>  * baseline: 项目的第一行文字的基线对齐。\n>  * stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n\n# 3.6 align-content属性\n\nalign-content属性定义了多根轴线的对齐方式（一排项目为一根轴线）。如果项目只有一根轴线，该属性不起作用。\n\n> .box {\n>   align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n该属性可能取6个值。\n\n>  * flex-start：与交叉轴的起点对齐。\n>  * flex-end：与交叉轴的终点对齐。\n>  * center：与交叉轴的中点对齐。\n>  * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n>  * space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n>  * stretch（默认值）：轴线占满整个交叉轴。\n\n\n# 四、项目的属性\n\n以下6个属性设置在项目上。\n\n>  * order\n>  * flex-grow\n>  * flex-shrink\n>  * flex-basis\n>  * flex flex-grow, flex-shrink 和 flex-basis的简写\n>  * align-self\n\n\n# 4.1 order属性\n\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n> .item {\n>   order: <integer>;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n\n# 4.2 flex-grow属性\n\nflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n\n> .item {\n>   flex-grow: <number>; /* default 0 */\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n\n# 4.3 flex-shrink属性\n\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n> .item {\n>   flex-shrink: <number>; /* default 1 */\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n\n# 4.4 flex-basis属性\n\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n> .item {\n>   flex-basis: <length> | auto; /* default auto */\n> }\n> \n> \n> 1\n> 2\n> 3\n\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n\n# 4.5 flex属性\n\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n> .item {\n>   flex: none | [ <\'flex-grow\'> <\'flex-shrink\'>? || <\'flex-basis\'> ]\n> }\n> \n> \n> 1\n> 2\n> 3\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n\n# 4.6 align-self属性\n\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n> .item {\n>   align-self: auto | flex-start | flex-end | center | baseline | stretch;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n\n（完）\n\n> 来源：\n> \n> http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n> \n> http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\n\n',normalizedContent:'# flex布局语法\n\n\n# 一、flex 布局是什么？\n\nflex是 flexible box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。\n\n任何一个容器 都可以指定为 flex 布局。\n\n.box{\n  display: flex;\n}\n\n\n1\n2\n3\n\n\n行内元素 也可以使用 flex 布局。\n\n.box{\n  display: inline-flex;\n}\n\n\n1\n2\n3\n\n\nwebkit 内核的浏览器，必须加上-webkit前缀。\n\n.box{\n  display: -webkit-flex; /* safari */\n  display: flex;\n}\n\n\n1\n2\n3\n4\n\n\n注意，设为 flex 布局以后，子元素的float、clear和vertical-align属性将失效。\n\n\n# 二、基本概念\n\n采用 flex 布局的元素，称为 flex 容器（flex container），简称"容器"。它的所有子元素自动成为容器成员，称为 flex 项目（flex item），简称"项目"。\n\n\n\n容器默认存在两根轴：水平的主轴（或x轴）（main axis）和垂直的交叉轴（或y轴）（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。\n\n\n# 三、容器的属性\n\n以下6个属性设置在容器上。(即设置在 display: flex; 的元素上)\n\n>  * flex-direction 方向 决定项目的排列方向\n> \n>  * flex-wrap 换行\n> \n>  * flex-flow 方向和换行的简写\n> \n>  * justify-content 主轴对齐方式\n> \n>  * align-items 交叉轴对齐方式\n> \n>  * align-content 多轴线的对齐方式\n\n\n# 3.1 flex-direction属性\n\nflex-direction属性决定主轴的方向（即项目的排列方向）。\n\n> .box {\n>   flex-direction: row | row-reverse | column | column-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它可能有4个值。\n\n>  * row（默认值）：主轴为水平方向，起点在左端。\n>  * row-reverse：主轴为水平方向，起点在右端。\n>  * column：主轴为垂直方向，起点在上沿。\n>  * column-reverse：主轴为垂直方向，起点在下沿。\n\n\n# 3.2 flex-wrap属性\n\n默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n\n\n\n> .box{\n>   flex-wrap: nowrap | wrap | wrap-reverse;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n它可能取三个值。\n\n（1）nowrap（默认）：不换行。会压缩项目的宽度\n\n\n\n（2）wrap：换行，第一行在上方。\n\n\n\n（3）wrap-reverse：换行，第一行在下方。\n\n\n\n\n# 3.3 flex-flow\n\nflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。\n\n> .box {\n>   flex-flow: <flex-direction> || <flex-wrap>;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n# 3.4 justify-content属性\n\njustify-content属性定义了项目在主轴上的对齐方式。\n\n> .box {\n>   justify-content: flex-start | flex-end | center | space-between | space-around;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n>  * flex-start（默认值）：左对齐\n>  * flex-end：右对齐\n>  * center： 居中\n>  * space-between：两端对齐，项目之间的间隔都相等。\n>  * space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n\n# 3.5 align-items属性\n\nalign-items属性定义项目在交叉轴上如何对齐。\n\n> .box {\n>   align-items: flex-start | flex-end | center | baseline | stretch;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n>  * flex-start：交叉轴的起点对齐。\n>  * flex-end：交叉轴的终点对齐。\n>  * center：交叉轴的中点对齐。\n>  * baseline: 项目的第一行文字的基线对齐。\n>  * stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n\n# 3.6 align-content属性\n\nalign-content属性定义了多根轴线的对齐方式（一排项目为一根轴线）。如果项目只有一根轴线，该属性不起作用。\n\n> .box {\n>   align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n该属性可能取6个值。\n\n>  * flex-start：与交叉轴的起点对齐。\n>  * flex-end：与交叉轴的终点对齐。\n>  * center：与交叉轴的中点对齐。\n>  * space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。\n>  * space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n>  * stretch（默认值）：轴线占满整个交叉轴。\n\n\n# 四、项目的属性\n\n以下6个属性设置在项目上。\n\n>  * order\n>  * flex-grow\n>  * flex-shrink\n>  * flex-basis\n>  * flex flex-grow, flex-shrink 和 flex-basis的简写\n>  * align-self\n\n\n# 4.1 order属性\n\norder属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n> .item {\n>   order: <integer>;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n\n# 4.2 flex-grow属性\n\nflex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。\n\n> .item {\n>   flex-grow: <number>; /* default 0 */\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n\n# 4.3 flex-shrink属性\n\nflex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n> .item {\n>   flex-shrink: <number>; /* default 1 */\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n\n# 4.4 flex-basis属性\n\nflex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。\n\n> .item {\n>   flex-basis: <length> | auto; /* default auto */\n> }\n> \n> \n> 1\n> 2\n> 3\n\n它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。\n\n\n# 4.5 flex属性\n\nflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。\n\n> .item {\n>   flex: none | [ <\'flex-grow\'> <\'flex-shrink\'>? || <\'flex-basis\'> ]\n> }\n> \n> \n> 1\n> 2\n> 3\n\n该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n\n# 4.6 align-self属性\n\nalign-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n\n> .item {\n>   align-self: auto | flex-start | flex-end | center | baseline | stretch;\n> }\n> \n> \n> 1\n> 2\n> 3\n\n\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。\n\n（完）\n\n> 来源：\n> \n> http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html\n> \n> http://www.ruanyifeng.com/blog/2015/07/flex-examples.html\n\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"flex布局案例-基础",frontmatter:{title:"flex布局案例-基础",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/ea6db1530c42ad51",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/02.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E5%9F%BA%E7%A1%80.html",relativePath:"02.页面/20.CSS/02.flex布局案例-基础.md",key:"v-a9f47444",path:"/pages/ea6db1530c42ad51/",headersStr:null,content:'# flex布局案例-基础\n\n> 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="box">\n    <span>1</span>\n    <span>2</span>\n    <span>3</span>\n    <span>4</span>\n    <span>5</span>\n    <span>6</span>\n    <span>7</span>\n  </div>\n</html>\n<style>\n/* 父元素上定义弹性盒模型，称之为 “容器” */\n.box{\n  width: 350px;\n  height: 300px;\n  background: #eee;\n  /* 基本概念：.box为容器，.box下的span为项目；.box的x轴为主轴，y轴为交叉轴 */\n  /* flex 定义为弹性盒模型 */\n  display: flex;\n  /*flex-direction 排列方向： row 行（默认） | row-reverse 行-反转  | column 列 | column-reverse 列-反转 */\n  flex-direction: row; \n  /*flex-wrap 是否换行： nowrap 不换行（默认，可能会压缩项目宽度） | wrap 换行 | wrap-reverse 换行-反转，第一行在下方 */\n  flex-wrap: wrap;\n  /* flex-flow  方向和换行的简写：默认值为row nowrap，方向 和 是否换行 的取值 */\n  flex-flow: row wrap;\n  /* justify-content 项目在主轴上的对齐方式: flex-start 左对齐（默认） | flex-end 右对齐 | center 居中 | space-between 两端对齐 | space-around 项目两侧的间隔相等*/\n  justify-content: space-around;\n  /* align-items 项目在交叉轴上的对齐方式：stretch（默认）伸展，如果项目未设置高度或设为auto，将占满整个容器的高度 | \n  flex-start 交叉轴的起点对齐 | flex-end 交叉轴的终点对齐 | center 交叉轴的中心点对齐 | baseline 项目的第一行文字的基线对齐（适用于每个项目高度不一致，以项目中的文字为基准对齐） */\n  align-items: center\n  /* align-content 多根轴线的对齐方式（一排项目为一根轴线，只有一根轴线时此样式不起作用）: \n  stretch（默认）伸展，轴线占满整个交叉轴 | flex-start 容器顶部对齐 | flex-end 容器底部对齐 | center 与交叉轴的中点对齐 |\n  space-between 与交叉轴两端对齐，轴线之间的间隔平均分布| space-around 每根轴线两侧的间隔都相等*/\n  align-content：flex-start\n  /* 代码单词中文含义 ：\n  flex 弹性； direction 方向； wrap 外套、包； flow 流动\n  justify 对齐； content 内容；space 空间、距离；between 在...之间；around 周围的\n  align 排列；stretch 伸展；\n  */\n}\n/* 子元素称之为 “项目” */\n.box span{\n  display:block;width: 50px;height: 50px;background: mediumspringgreen;margin: 10px;text-align: center;line-height: 50px;\n  /* flex-grow 项目的放大比例，默认为0，即如果存在剩余空间，也不放大;\n  如果所有为1时，则它们将等分剩余空间（如果有的话）。\n  如果其中一个项目为2，其他项目都为1，则为2的占据的剩余空间将比其他项多一倍。\n  */\n  flex-grow: 0; /* grow 扩大 */\n  /* flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 \n  如果所有项目都为1，当空间不足时，都将等比例缩小。\n  如果其中一个项目为0，其他项目都为1，则空间不足时，为0的不缩小*/\n  flex-shrink: 1; /* shrink 缩小 */\n  /* flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（宽度）。\n  浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n  它可以设为跟`width`或`height`属性一样的值（比如50px），则项目将占据固定空间*/\n  flex-basis: auto; /* basis 基础 */\n  /* flex属性是flex-grow,flex-shrink 和 flex-basis的简写，默认值为`0 1 auto`。后两个属性可选。\n  该属性有两个快捷值：auto (1 1 auto)，即放大 和 none (0 0 auto)，即缩小。\n  建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。*/\n  flex:0 1 auto; /* flex: 0放大 1缩小 auto原本宽度*/\n}\n.box span:nth-child(2){\n  /* order 项目的排列顺序。数值越小，排列越靠前，默认为0 ; 取值：正负整数。*/\n  order: -1;\n  background: red;\n}\n.box span:nth-child(7){\n  /* align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。\n  默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n  取值：auto（默认） | flex-start | flex-end | center | baseline | stretch。\n  */\n  align-self: flex-end;\n  background: blue;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html',normalizedContent:'# flex布局案例-基础\n\n> 可用f12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="box">\n    <span>1</span>\n    <span>2</span>\n    <span>3</span>\n    <span>4</span>\n    <span>5</span>\n    <span>6</span>\n    <span>7</span>\n  </div>\n</html>\n<style>\n/* 父元素上定义弹性盒模型，称之为 “容器” */\n.box{\n  width: 350px;\n  height: 300px;\n  background: #eee;\n  /* 基本概念：.box为容器，.box下的span为项目；.box的x轴为主轴，y轴为交叉轴 */\n  /* flex 定义为弹性盒模型 */\n  display: flex;\n  /*flex-direction 排列方向： row 行（默认） | row-reverse 行-反转  | column 列 | column-reverse 列-反转 */\n  flex-direction: row; \n  /*flex-wrap 是否换行： nowrap 不换行（默认，可能会压缩项目宽度） | wrap 换行 | wrap-reverse 换行-反转，第一行在下方 */\n  flex-wrap: wrap;\n  /* flex-flow  方向和换行的简写：默认值为row nowrap，方向 和 是否换行 的取值 */\n  flex-flow: row wrap;\n  /* justify-content 项目在主轴上的对齐方式: flex-start 左对齐（默认） | flex-end 右对齐 | center 居中 | space-between 两端对齐 | space-around 项目两侧的间隔相等*/\n  justify-content: space-around;\n  /* align-items 项目在交叉轴上的对齐方式：stretch（默认）伸展，如果项目未设置高度或设为auto，将占满整个容器的高度 | \n  flex-start 交叉轴的起点对齐 | flex-end 交叉轴的终点对齐 | center 交叉轴的中心点对齐 | baseline 项目的第一行文字的基线对齐（适用于每个项目高度不一致，以项目中的文字为基准对齐） */\n  align-items: center\n  /* align-content 多根轴线的对齐方式（一排项目为一根轴线，只有一根轴线时此样式不起作用）: \n  stretch（默认）伸展，轴线占满整个交叉轴 | flex-start 容器顶部对齐 | flex-end 容器底部对齐 | center 与交叉轴的中点对齐 |\n  space-between 与交叉轴两端对齐，轴线之间的间隔平均分布| space-around 每根轴线两侧的间隔都相等*/\n  align-content：flex-start\n  /* 代码单词中文含义 ：\n  flex 弹性； direction 方向； wrap 外套、包； flow 流动\n  justify 对齐； content 内容；space 空间、距离；between 在...之间；around 周围的\n  align 排列；stretch 伸展；\n  */\n}\n/* 子元素称之为 “项目” */\n.box span{\n  display:block;width: 50px;height: 50px;background: mediumspringgreen;margin: 10px;text-align: center;line-height: 50px;\n  /* flex-grow 项目的放大比例，默认为0，即如果存在剩余空间，也不放大;\n  如果所有为1时，则它们将等分剩余空间（如果有的话）。\n  如果其中一个项目为2，其他项目都为1，则为2的占据的剩余空间将比其他项多一倍。\n  */\n  flex-grow: 0; /* grow 扩大 */\n  /* flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 \n  如果所有项目都为1，当空间不足时，都将等比例缩小。\n  如果其中一个项目为0，其他项目都为1，则空间不足时，为0的不缩小*/\n  flex-shrink: 1; /* shrink 缩小 */\n  /* flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（宽度）。\n  浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n  它可以设为跟`width`或`height`属性一样的值（比如50px），则项目将占据固定空间*/\n  flex-basis: auto; /* basis 基础 */\n  /* flex属性是flex-grow,flex-shrink 和 flex-basis的简写，默认值为`0 1 auto`。后两个属性可选。\n  该属性有两个快捷值：auto (1 1 auto)，即放大 和 none (0 0 auto)，即缩小。\n  建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。*/\n  flex:0 1 auto; /* flex: 0放大 1缩小 auto原本宽度*/\n}\n.box span:nth-child(2){\n  /* order 项目的排列顺序。数值越小，排列越靠前，默认为0 ; 取值：正负整数。*/\n  order: -1;\n  background: red;\n}\n.box span:nth-child(7){\n  /* align-self 属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。\n  默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n  取值：auto（默认） | flex-start | flex-end | center | baseline | stretch。\n  */\n  align-self: flex-end;\n  background: blue;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"flex布局案例-骰子",frontmatter:{title:"flex布局案例-骰子",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/eff61bc8b4f4695d",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/03.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E9%AA%B0%E5%AD%90.html",relativePath:"02.页面/20.CSS/03.flex布局案例-骰子.md",key:"v-7bd1ca64",path:"/pages/eff61bc8b4f4695d/",headersStr:null,content:'# flex布局案例-骰子\n\n> 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="box2">\n    <div class="first-face">\n      <span class="pip"></span>\n    </div>\n    <div class="second-face">\n      <span class="pip"></span>\n      <span class="pip"></span>\n    </div>\n    <div class="third-face">\n      <span class="pip"></span>\n      <span class="pip"></span>\n      <span class="pip"></span>\n    </div>\n    <div class="fourth-face">\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n    </div>\n    <div class="fifth-face">\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n      <div class="column">\n        <span class="pip"></span>\n      </div>\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n    </div>\n    <div class="sixth-face">\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n    </div>\n  </div>\n</html>\n<style>\n  /* 一 */\n  .first-face { /* 形成上下左右居中 */\n    display: flex;\n    /* 项目在主轴上居中 */\n    justify-content: center;\n    /* 项目在交叉轴上居中 */\n    align-items: center;\n  }\n  /* 二 */\n  .second-face {\n    display: flex;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .second-face .pip:nth-of-type(2) {\n    /* 居下 */\n    align-self: flex-end;\n  }/* 三 */\n  .third-face {\n    display: flex;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .third-face .pip:nth-of-type(2) {\n    /* 居中 */\n    align-self: center;\n  }\n  .third-face .pip:nth-of-type(3) {\n    /* 居下 */\n    align-self: flex-end;\n  }\n  /* 四 、六*/\n  .fourth-face,\n  .sixth-face {\n    display: flex;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .fourth-face .column,\n  .sixth-face .column {\n    display: flex;\n    /* 纵向排列 */\n    flex-direction: column;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  /* 五 */\n  .fifth-face {\n    display: flex;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .fifth-face .column {\n    display: flex;\n    /* 纵向排列 */\n    flex-direction: column;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .fifth-face .column:nth-of-type(2) {\n    /* 居中对齐 */\n    justify-content: center;\n  }\n/* 基础样式 */\n.box2 {\n  display: flex;\n  /* 项目在交叉轴上居中 */\n  align-items: center;\n  /* 项目在主轴上居中 */\n  justify-content: center;\n  vertical-align: center;\n  /* 允许项目换行 */\n  flex-wrap: wrap;  /* 项目是多行时以交叉轴中心对齐 */\n  align-content: center;\n  font-family: \'Open Sans\', sans-serif;\n}\n/* 类名包含face的元素 */\n[class$="face"] {\n  margin: 5px;\n  padding: 4px;  background-color: #e7e7e7;\n  width: 104px;\n  height: 104px;\n  object-fit: contain;  box-shadow:\n    inset 0 5px white,\n    inset 0 -5px #bbb,\n    inset 5px 0 #d7d7d7,\n    inset -5px 0 #d7d7d7;  border-radius: 10%;\n}\n.pip {\n  display: block;\n  width: 24px;\n  height: 24px;\n  border-radius: 50%;\n  margin: 4px;  background-color: #333;\n  box-shadow: inset 0 3px #111, inset 0 -3px #555;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html',normalizedContent:'# flex布局案例-骰子\n\n> 可用f12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="box2">\n    <div class="first-face">\n      <span class="pip"></span>\n    </div>\n    <div class="second-face">\n      <span class="pip"></span>\n      <span class="pip"></span>\n    </div>\n    <div class="third-face">\n      <span class="pip"></span>\n      <span class="pip"></span>\n      <span class="pip"></span>\n    </div>\n    <div class="fourth-face">\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n    </div>\n    <div class="fifth-face">\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n      <div class="column">\n        <span class="pip"></span>\n      </div>\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n    </div>\n    <div class="sixth-face">\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n      <div class="column">\n        <span class="pip"></span>\n        <span class="pip"></span>\n        <span class="pip"></span>\n      </div>\n    </div>\n  </div>\n</html>\n<style>\n  /* 一 */\n  .first-face { /* 形成上下左右居中 */\n    display: flex;\n    /* 项目在主轴上居中 */\n    justify-content: center;\n    /* 项目在交叉轴上居中 */\n    align-items: center;\n  }\n  /* 二 */\n  .second-face {\n    display: flex;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .second-face .pip:nth-of-type(2) {\n    /* 居下 */\n    align-self: flex-end;\n  }/* 三 */\n  .third-face {\n    display: flex;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .third-face .pip:nth-of-type(2) {\n    /* 居中 */\n    align-self: center;\n  }\n  .third-face .pip:nth-of-type(3) {\n    /* 居下 */\n    align-self: flex-end;\n  }\n  /* 四 、六*/\n  .fourth-face,\n  .sixth-face {\n    display: flex;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .fourth-face .column,\n  .sixth-face .column {\n    display: flex;\n    /* 纵向排列 */\n    flex-direction: column;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  /* 五 */\n  .fifth-face {\n    display: flex;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .fifth-face .column {\n    display: flex;\n    /* 纵向排列 */\n    flex-direction: column;\n    /* 两侧对齐 */\n    justify-content: space-between;\n  }\n  .fifth-face .column:nth-of-type(2) {\n    /* 居中对齐 */\n    justify-content: center;\n  }\n/* 基础样式 */\n.box2 {\n  display: flex;\n  /* 项目在交叉轴上居中 */\n  align-items: center;\n  /* 项目在主轴上居中 */\n  justify-content: center;\n  vertical-align: center;\n  /* 允许项目换行 */\n  flex-wrap: wrap;  /* 项目是多行时以交叉轴中心对齐 */\n  align-content: center;\n  font-family: \'open sans\', sans-serif;\n}\n/* 类名包含face的元素 */\n[class$="face"] {\n  margin: 5px;\n  padding: 4px;  background-color: #e7e7e7;\n  width: 104px;\n  height: 104px;\n  object-fit: contain;  box-shadow:\n    inset 0 5px white,\n    inset 0 -5px #bbb,\n    inset 5px 0 #d7d7d7,\n    inset -5px 0 #d7d7d7;  border-radius: 10%;\n}\n.pip {\n  display: block;\n  width: 24px;\n  height: 24px;\n  border-radius: 50%;\n  margin: 4px;  background-color: #333;\n  box-shadow: inset 0 3px #111, inset 0 -3px #555;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"flex布局案例-圣杯布局",frontmatter:{title:"flex布局案例-圣杯布局",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/df9e7c7214fa5046",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/04.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80.html",relativePath:"02.页面/20.CSS/04.flex布局案例-圣杯布局.md",key:"v-1732d362",path:"/pages/df9e7c7214fa5046/",headersStr:null,content:'# flex布局案例-圣杯布局\n\n> 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="HolyGrail">\n    <header>#header</header>\n    <div class="wrap">\n      <nav class="left">left 宽度固定200px</nav>\n      <main class="content">center 宽度自适应</main>\n      <aside class="right">right 宽度固定200px</aside>\n    </div>\n    <footer>#footer</footer>\n  </div>\n</html>\n<style>\n  .HolyGrail {\n    text-align: center;\n    display: flex;\n    min-height: 40vh;\n    flex-direction: column;\n  }\n  .HolyGrail .wrap {\n    display: flex;\n    flex: 1;\n  }\n  .HolyGrail .content {\n    background: #eee;\n    flex: 1;\n  }\n  .HolyGrail .left,.HolyGrail .right {\n    background:lightgreen;\n    flex: 0 0 200px;\n  }\n  .HolyGrail header,.HolyGrail footer{\n    background:#999;\n    height: 50px;\n    line-height: 50px;\n  }\n  .HolyGrail .left {\n    background:salmon;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html',normalizedContent:'# flex布局案例-圣杯布局\n\n> 可用f12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="holygrail">\n    <header>#header</header>\n    <div class="wrap">\n      <nav class="left">left 宽度固定200px</nav>\n      <main class="content">center 宽度自适应</main>\n      <aside class="right">right 宽度固定200px</aside>\n    </div>\n    <footer>#footer</footer>\n  </div>\n</html>\n<style>\n  .holygrail {\n    text-align: center;\n    display: flex;\n    min-height: 40vh;\n    flex-direction: column;\n  }\n  .holygrail .wrap {\n    display: flex;\n    flex: 1;\n  }\n  .holygrail .content {\n    background: #eee;\n    flex: 1;\n  }\n  .holygrail .left,.holygrail .right {\n    background:lightgreen;\n    flex: 0 0 200px;\n  }\n  .holygrail header,.holygrail footer{\n    background:#999;\n    height: 50px;\n    line-height: 50px;\n  }\n  .holygrail .left {\n    background:salmon;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"flex布局案例-网格布局",frontmatter:{title:"flex布局案例-网格布局",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/85b5a3fe218a34b7",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/05.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E7%BD%91%E6%A0%BC%E5%B8%83%E5%B1%80.html",relativePath:"02.页面/20.CSS/05.flex布局案例-网格布局.md",key:"v-86f0ff4e",path:"/pages/85b5a3fe218a34b7/",headersStr:null,content:'# flex布局案例-网格布局\n\n> 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="grid">\n    <div class="grid-cell">1/2</div>\n    <div class="grid-cell">1/2</div>\n  </div>\n\n  <div class="grid">\n    <div class="grid-cell">1/3</div>\n    <div class="grid-cell">1/3</div>\n    <div class="grid-cell">1/3</div>\n  </div>\n\n  <div class="grid">\n    <div class="grid-cell">1/4</div>\n    <div class="grid-cell">1/4</div>\n    <div class="grid-cell">1/4</div>\n    <div class="grid-cell">1/4</div>\n  </div>\n\n  <div class="grid text">\n    <div class="grid-cell">\n      高度会跟随右侧元素变化\n    </div>\n    <div class="grid-cell">\n      内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充\n    </div>\n  </div>\n\n  <h4>某个网格设置百分比宽度</h4>\n  <div class="grid">\n      <div class="grid-cell u-full">100%</div>\n  </div>\n  <div class="grid">\n      <div class="grid-cell u-1of2">50%</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n  </div>\n  <div class="grid">\n      <div class="grid-cell u-1of3">33.33%</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n  </div>\n  <div class="grid">\n      <div class="grid-cell u-1of4">25%</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n  </div>\n</html>\n<style>\n  .grid {\n    display: flex;\n  }\n  .grid-cell {\n    flex: 1;\n  }\n  .grid-cell.u-full {\n    flex: 0 0 100%;\n  }\n  .grid-cell.u-1of2 {\n    flex: 0 0 50%;\n  }\n  .grid-cell.u-1of3 {\n    flex: 0 0 33.3333%;\n  }\n  .grid-cell.u-1of4 {\n    flex: 0 0 25%;\n  }\n  /* 基础样式 */\n  .grid-cell {\n    background: #eee;\n    text-align: center;\n    margin: 5px;\n    padding: 10px 0;\n  }\n  .text .grid-cell {\n    text-align: left\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html',normalizedContent:'# flex布局案例-网格布局\n\n> 可用f12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="grid">\n    <div class="grid-cell">1/2</div>\n    <div class="grid-cell">1/2</div>\n  </div>\n\n  <div class="grid">\n    <div class="grid-cell">1/3</div>\n    <div class="grid-cell">1/3</div>\n    <div class="grid-cell">1/3</div>\n  </div>\n\n  <div class="grid">\n    <div class="grid-cell">1/4</div>\n    <div class="grid-cell">1/4</div>\n    <div class="grid-cell">1/4</div>\n    <div class="grid-cell">1/4</div>\n  </div>\n\n  <div class="grid text">\n    <div class="grid-cell">\n      高度会跟随右侧元素变化\n    </div>\n    <div class="grid-cell">\n      内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充内容填充\n    </div>\n  </div>\n\n  <h4>某个网格设置百分比宽度</h4>\n  <div class="grid">\n      <div class="grid-cell u-full">100%</div>\n  </div>\n  <div class="grid">\n      <div class="grid-cell u-1of2">50%</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n  </div>\n  <div class="grid">\n      <div class="grid-cell u-1of3">33.33%</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n  </div>\n  <div class="grid">\n      <div class="grid-cell u-1of4">25%</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n      <div class="grid-cell">auto</div>\n  </div>\n</html>\n<style>\n  .grid {\n    display: flex;\n  }\n  .grid-cell {\n    flex: 1;\n  }\n  .grid-cell.u-full {\n    flex: 0 0 100%;\n  }\n  .grid-cell.u-1of2 {\n    flex: 0 0 50%;\n  }\n  .grid-cell.u-1of3 {\n    flex: 0 0 33.3333%;\n  }\n  .grid-cell.u-1of4 {\n    flex: 0 0 25%;\n  }\n  /* 基础样式 */\n  .grid-cell {\n    background: #eee;\n    text-align: center;\n    margin: 5px;\n    padding: 10px 0;\n  }\n  .text .grid-cell {\n    text-align: left\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"flex布局案例-输入框布局",frontmatter:{title:"flex布局案例-输入框布局",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/05cc577fb51c7998",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/06.flex%E5%B8%83%E5%B1%80%E6%A1%88%E4%BE%8B-%E8%BE%93%E5%85%A5%E6%A1%86%E5%B8%83%E5%B1%80.html",relativePath:"02.页面/20.CSS/06.flex布局案例-输入框布局.md",key:"v-0cc7563e",path:"/pages/05cc577fb51c7998/",headersStr:null,content:'# flex布局案例-输入框布局\n\n> 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="InputAddOn">\n    <span class="InputAddOn-item">icon</span>\n    <input class="InputAddOn-field" placeholder="input宽度自适应">\n    <button class="InputAddOn-item">提交</button>\n  </div>\n  <br/>\n  <div class="Media">\n    <div class="Media-figure">左侧固定</div>\n    <p class="Media-body">右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应</p>\n  </div>\n</html>\n<style>\n  .InputAddOn {\n    display: flex;\n  }\n  .InputAddOn-field {\n    flex: 1;\n  }\n  .Media {\n    display: flex;\n    align-items: flex-start;\n  }\n  .Media-figure {\n    width: 100px;\n    height: 100px;\n    background: #eee;\n    margin-right: 1em;\n  }\n  .Media-body {\n    flex: 1;\n  }\n  /* 基础样式 */\n  input:-webkit-autofill,\n  select:-webkit-autofill {\n    -webkit-box-shadow: 0 0 0px 1000px white inset !important;\n  }\n  input {\n    outline-color: invert;\n    outline-style: none;\n    outline-width: 0px;\n    text-shadow: none;\n    -webkit-appearance: none;\n    -webkit-user-select: text;\n    outline-color: transparent;\n    box-shadow: none;\n  }\n  .InputAddOn-item {\n    width: 100px;\n    text-align: center;\n    line-height: 30px;\n    border: 1px solid #ccc;\n    background: #eee\n  }\n  .InputAddOn-field {\n    height: 30px;\n    padding: 1px 6px;\n    border: 1px solid #ccc;\n    border-left: none;\n    border-right: none;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html',normalizedContent:'# flex布局案例-输入框布局\n\n> 可用f12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="inputaddon">\n    <span class="inputaddon-item">icon</span>\n    <input class="inputaddon-field" placeholder="input宽度自适应">\n    <button class="inputaddon-item">提交</button>\n  </div>\n  <br/>\n  <div class="media">\n    <div class="media-figure">左侧固定</div>\n    <p class="media-body">右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应右侧自适应</p>\n  </div>\n</html>\n<style>\n  .inputaddon {\n    display: flex;\n  }\n  .inputaddon-field {\n    flex: 1;\n  }\n  .media {\n    display: flex;\n    align-items: flex-start;\n  }\n  .media-figure {\n    width: 100px;\n    height: 100px;\n    background: #eee;\n    margin-right: 1em;\n  }\n  .media-body {\n    flex: 1;\n  }\n  /* 基础样式 */\n  input:-webkit-autofill,\n  select:-webkit-autofill {\n    -webkit-box-shadow: 0 0 0px 1000px white inset !important;\n  }\n  input {\n    outline-color: invert;\n    outline-style: none;\n    outline-width: 0px;\n    text-shadow: none;\n    -webkit-appearance: none;\n    -webkit-user-select: text;\n    outline-color: transparent;\n    box-shadow: none;\n  }\n  .inputaddon-item {\n    width: 100px;\n    text-align: center;\n    line-height: 30px;\n    border: 1px solid #ccc;\n    background: #eee\n  }\n  .inputaddon-field {\n    height: 30px;\n    padding: 1px 6px;\n    border: 1px solid #ccc;\n    border-left: none;\n    border-right: none;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n> 参考：http://www.ruanyifeng.com/blog/2015/07/flex-examples.html',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"CSS3之transition过渡",frontmatter:{title:"CSS3之transition过渡",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/02d7f59d98d87409",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/07.CSS3%E4%B9%8Btransition%E8%BF%87%E6%B8%A1.html",relativePath:"02.页面/20.CSS/07.CSS3之transition过渡.md",key:"v-8a33a710",path:"/pages/02d7f59d98d87409/",headersStr:null,content:'# CSS3之transition过渡\n\nhtml结构\n\n<div class="box1">  \n  <div class="div1"></div>\n  <div class="div2"></div>\n  <div class="div3"></div>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\n\n.box1>div{\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\n  transition: all .3s;\n}\n\n\n1\n2\n3\n4\n\n\n> 鼠标经过元素测试效果\n\n宽度过渡\n\n\n.div1:hover{width: 150px;}\n\n\n1\n\n\n背景色过渡\n\n\n\n.div2:hover{background: #999;}\n\n\n1\n\n\n\n\n按贝塞尔曲线设置的过渡\n\n\n\n/贝塞尔曲线过渡/\n.div3{transition-timing-function: cubic-bezier(.39,.62,.74,1.39)}\n.div3:hover{transform: translate3d(-25px, -25px, 0)}\n\n\n1\n2\n3\n\n\n\n\n\n# 贝塞尔曲线 cubic-bezier(x1,y1,x2,y2)\n\n通过调整贝塞尔曲线可以设置出多种动画效果，比如反弹效果等 X轴的范围是0~1，Y轴的取值没有规定，但是也不宜过大。 如：直线linear，即cubic-bezier(0,0,1,1)\n\n贝塞尔曲线在线工具：https://cubic-bezier.com/#.17,.67,.83,.67\n\n参考：https://www.w3school.com.cn/css3/index.asp',normalizedContent:'# css3之transition过渡\n\nhtml结构\n\n<div class="box1">  \n  <div class="div1"></div>\n  <div class="div2"></div>\n  <div class="div3"></div>\n</div>\n\n\n1\n2\n3\n4\n5\n\n\n先给元素设置transition过渡，指定样式和时间，这里设置all全部样式都采用0.3s的过渡\n\n.box1>div{\n  /* 给元素所有变化都添加过渡动画, 也可以指定唯一的过渡样式属性*/\n  transition: all .3s;\n}\n\n\n1\n2\n3\n4\n\n\n> 鼠标经过元素测试效果\n\n宽度过渡\n\n\n.div1:hover{width: 150px;}\n\n\n1\n\n\n背景色过渡\n\n\n\n.div2:hover{background: #999;}\n\n\n1\n\n\n\n\n按贝塞尔曲线设置的过渡\n\n\n\n/贝塞尔曲线过渡/\n.div3{transition-timing-function: cubic-bezier(.39,.62,.74,1.39)}\n.div3:hover{transform: translate3d(-25px, -25px, 0)}\n\n\n1\n2\n3\n\n\n\n\n\n# 贝塞尔曲线 cubic-bezier(x1,y1,x2,y2)\n\n通过调整贝塞尔曲线可以设置出多种动画效果，比如反弹效果等 x轴的范围是0~1，y轴的取值没有规定，但是也不宜过大。 如：直线linear，即cubic-bezier(0,0,1,1)\n\n贝塞尔曲线在线工具：https://cubic-bezier.com/#.17,.67,.83,.67\n\n参考：https://www.w3school.com.cn/css3/index.asp',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"CSS3之animation动画",frontmatter:{title:"CSS3之animation动画",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/c2c0432138f6e042",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/08.CSS3%E4%B9%8Banimation%E5%8A%A8%E7%94%BB.html",relativePath:"02.页面/20.CSS/08.CSS3之animation动画.md",key:"v-bec52126",path:"/pages/c2c0432138f6e042/",headers:[{level:3,title:"贝塞尔曲线 cubic-bezier(x1,y1,x2,y2)",slug:"贝塞尔曲线-cubic-bezier-x1-y1-x2-y2",normalizedTitle:"贝塞尔曲线 cubic-bezier(x1,y1,x2,y2)",charIndex:2232}],headersStr:"贝塞尔曲线 cubic-bezier(x1,y1,x2,y2)",content:'# CSS3之animation动画\n\n> 可用F12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="animationBox">\n    <div class="rotate">旋转动画1</div>\n    <div class="play">\n      <div class="img">旋转动画2</div>\n      <span><p class="p2"></p></span>\n      <span><p></p></span>\n      <span><p></p></span>\n      <span><p class="p2"></p></span>\n    </div>\n    <div class="elasticity">弹性动画</div>\n    <div class="elasticity2">曲线弹性</div>\n  </div>\n</html>\n\n<style>\n  .animationBox{overflow: hidden;}\n  .animationBox>div{\n    width: 100px;height: 100px;background: #eee;border-radius: 50%;text-align: center;line-height: 100px;margin: 30px;float:left;\n  }\n  .rotate{\n    animation: rotate 5s linear infinite\n  }\n  .rotate:hover{ animation-play-state: paused}\n  @keyframes rotate {\n    0%{transform: rotate(0);}\n  100%{transform: rotate(360deg);}\n  }\n  .animationBox>.play {\n    position: relative;\n    margin: 50px 30px;\n    background:none;\n  }\n  .play .img{\n    position: absolute;\n    top: 0;\n    left:0;\n    z-index: 1;\n    width: 100px;height: 100px; background: #eee;\n    border-radius: 50%;\n\n    animation: rotate 5s linear infinite\n  }\n  .play span {\n    position: absolute;\n    top: 1px;\n    left:1px;\n    z-index: 0;\n    display: block;\n    width: 96px;\n    height: 96px;\n    border: 1px solid #999;\n    border-radius: 50%;\n  }\n  .play span p{display: block;width: 4px;height: 4px;background: #000;margin: -2px 0 0 50%;border-radius: 50%;opacity: 0.5;}\n  .play span .p2{margin: 50% 0 0 -2px;}\n  .play span{\n    animation: wave 5s linear infinite\n  }\n  .play>span:nth-child(3){\n    /* 延迟时间 */\n    animation-delay:1s; \n  }\n  .play>span:nth-child(4){\n    animation-delay:2.2s;\n  }\n  .play>span:nth-child(5){\n    animation-delay:3.8s;\n  }\n  \n  @keyframes wave {\n    0%\n    {\n      transform:scale(1) rotate(360deg);\n      opacity: 0.8;\n    }\n  100%\n    {\n      transform:scale(1.8) rotate(0deg);\n      opacity: 0;\n    }\n  }\n\n\n  .elasticity{\n    /* 参数说明\n      动画名称 花费时间 贝塞尔曲线 延迟开始时间 播放次数n|infinite  是否反向播放动画\n    */\n    animation: elasticity 1s linear 2s infinite\n  }\n  \n  @keyframes elasticity{\n    0%{\n      transform: scale(0);\n    }\n    60%{\n      transform: scale(1.1);\n    }\n    90%{\n      transform: scale(1);\n    }\n  }\n  \n\n  .elasticity2{\n    /**\n    贝塞尔曲线 cubic-bezier(x1,y1,x2,y2)\n\n    通过调整贝塞尔曲线可以设置出多种动画效果，比如反弹效果等\n    X轴的范围是0~1，Y轴的取值没有规定，但是也不宜过大\n    直线：linear，即cubic-bezier(0,0,1,1)\n\n    贝塞尔曲线在线工具：https://cubic-bezier.com/#.17,.67,.83,.67\n      */\n    animation: elasticity2 1s cubic-bezier(.39,.62,.74,1.39) 2s infinite\n  }\n  @keyframes elasticity2{\n    0%{\n      transform: scale(0);\n    }\n    90%{\n      transform: scale(1);\n    }\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n\n\n# 贝塞尔曲线 cubic-bezier(x1,y1,x2,y2)\n\n通过调整贝塞尔曲线可以设置出多种动画效果，比如反弹效果等 X轴的范围是0~1，Y轴的取值没有规定，但是也不宜过大。 如：直线linear，即cubic-bezier(0,0,1,1)\n\n贝塞尔曲线在线工具：https://cubic-bezier.com/#.17,.67,.83,.67\n\n> 参考：https://www.w3school.com.cn/css3/index.asp',normalizedContent:'# css3之animation动画\n\n> 可用f12开发者工具查看元素及样式，可打开codepen在线编辑代码。\n\n<html>\n  <div class="animationbox">\n    <div class="rotate">旋转动画1</div>\n    <div class="play">\n      <div class="img">旋转动画2</div>\n      <span><p class="p2"></p></span>\n      <span><p></p></span>\n      <span><p></p></span>\n      <span><p class="p2"></p></span>\n    </div>\n    <div class="elasticity">弹性动画</div>\n    <div class="elasticity2">曲线弹性</div>\n  </div>\n</html>\n\n<style>\n  .animationbox{overflow: hidden;}\n  .animationbox>div{\n    width: 100px;height: 100px;background: #eee;border-radius: 50%;text-align: center;line-height: 100px;margin: 30px;float:left;\n  }\n  .rotate{\n    animation: rotate 5s linear infinite\n  }\n  .rotate:hover{ animation-play-state: paused}\n  @keyframes rotate {\n    0%{transform: rotate(0);}\n  100%{transform: rotate(360deg);}\n  }\n  .animationbox>.play {\n    position: relative;\n    margin: 50px 30px;\n    background:none;\n  }\n  .play .img{\n    position: absolute;\n    top: 0;\n    left:0;\n    z-index: 1;\n    width: 100px;height: 100px; background: #eee;\n    border-radius: 50%;\n\n    animation: rotate 5s linear infinite\n  }\n  .play span {\n    position: absolute;\n    top: 1px;\n    left:1px;\n    z-index: 0;\n    display: block;\n    width: 96px;\n    height: 96px;\n    border: 1px solid #999;\n    border-radius: 50%;\n  }\n  .play span p{display: block;width: 4px;height: 4px;background: #000;margin: -2px 0 0 50%;border-radius: 50%;opacity: 0.5;}\n  .play span .p2{margin: 50% 0 0 -2px;}\n  .play span{\n    animation: wave 5s linear infinite\n  }\n  .play>span:nth-child(3){\n    /* 延迟时间 */\n    animation-delay:1s; \n  }\n  .play>span:nth-child(4){\n    animation-delay:2.2s;\n  }\n  .play>span:nth-child(5){\n    animation-delay:3.8s;\n  }\n  \n  @keyframes wave {\n    0%\n    {\n      transform:scale(1) rotate(360deg);\n      opacity: 0.8;\n    }\n  100%\n    {\n      transform:scale(1.8) rotate(0deg);\n      opacity: 0;\n    }\n  }\n\n\n  .elasticity{\n    /* 参数说明\n      动画名称 花费时间 贝塞尔曲线 延迟开始时间 播放次数n|infinite  是否反向播放动画\n    */\n    animation: elasticity 1s linear 2s infinite\n  }\n  \n  @keyframes elasticity{\n    0%{\n      transform: scale(0);\n    }\n    60%{\n      transform: scale(1.1);\n    }\n    90%{\n      transform: scale(1);\n    }\n  }\n  \n\n  .elasticity2{\n    /**\n    贝塞尔曲线 cubic-bezier(x1,y1,x2,y2)\n\n    通过调整贝塞尔曲线可以设置出多种动画效果，比如反弹效果等\n    x轴的范围是0~1，y轴的取值没有规定，但是也不宜过大\n    直线：linear，即cubic-bezier(0,0,1,1)\n\n    贝塞尔曲线在线工具：https://cubic-bezier.com/#.17,.67,.83,.67\n      */\n    animation: elasticity2 1s cubic-bezier(.39,.62,.74,1.39) 2s infinite\n  }\n  @keyframes elasticity2{\n    0%{\n      transform: scale(0);\n    }\n    90%{\n      transform: scale(1);\n    }\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n\n\n\n\n# 贝塞尔曲线 cubic-bezier(x1,y1,x2,y2)\n\n通过调整贝塞尔曲线可以设置出多种动画效果，比如反弹效果等 x轴的范围是0~1，y轴的取值没有规定，但是也不宜过大。 如：直线linear，即cubic-bezier(0,0,1,1)\n\n贝塞尔曲线在线工具：https://cubic-bezier.com/#.17,.67,.83,.67\n\n> 参考：https://www.w3school.com.cn/css3/index.asp',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"「布局技巧」图片未加载前自动撑开元素高度",frontmatter:{title:"「布局技巧」图片未加载前自动撑开元素高度",date:"2020-02-22T16:37:10.000Z",permalink:"/pages/3d52574260725aea",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/20.%E3%80%8C%E5%B8%83%E5%B1%80%E6%8A%80%E5%B7%A7%E3%80%8D%E5%9B%BE%E7%89%87%E6%9C%AA%E5%8A%A0%E8%BD%BD%E5%89%8D%E8%87%AA%E5%8A%A8%E6%92%91%E5%BC%80%E5%85%83%E7%B4%A0%E9%AB%98%E5%BA%A6.html",relativePath:"02.页面/20.CSS/20.「布局技巧」图片未加载前自动撑开元素高度.md",key:"v-ceb0edd0",path:"/pages/3d52574260725aea/",excerpt:'<h1 id="「布局技巧」图片未加载前自动撑开元素高度"><a class="header-anchor" href="#「布局技巧」图片未加载前自动撑开元素高度">#</a> 「布局技巧」图片未加载前自动撑开元素高度</h1>\n<p>在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。</p>\n',headersStr:null,content:"# 「布局技巧」图片未加载前自动撑开元素高度\n\n在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。 这种情况我们可以设置如下样式来设置该元素的高度：\n\n.wrapper\n  overflow hidden\n  width 100%\n  height 0\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\n  background #eee\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，padding-bottom 的取值是图片的高宽比（即，高/宽），它会根据 width值的26.66%计算，最终元素的高度会和图片加载完成后的高度一致。\n\n也可以使用vw的方法，但在一些浏览器可能有兼容性问题：\n\n.wrapper\n  width 100%\n  height 26.66vw\n  background #eee\n\n\n1\n2\n3\n4\n\n\n> vw，viewpoint width，视窗宽度，1vw=视窗宽度的1%\n> \n> vh，viewpoint height，视窗高度，1vh=视窗高度的1%\n> \n> 更多 CSS单位。",normalizedContent:"# 「布局技巧」图片未加载前自动撑开元素高度\n\n在移动端开发中，有一些元素是根据图片高度来自动撑开的 ，高度不能写死（如轮播图的外层元素）。在网络较慢的情况下，图片加载需要一些时间，此时该元素的高度没有被撑开，在网页布局上会有一些不想看到的效果。 这种情况我们可以设置如下样式来设置该元素的高度：\n\n.wrapper\n  overflow hidden\n  width 100%\n  height 0\n  padding-bottom 26.66% // 这个数值是图片的高宽比，即 高/宽\n  background #eee\n\n\n1\n2\n3\n4\n5\n6\n\n\n上面代码中，padding-bottom 的取值是图片的高宽比（即，高/宽），它会根据 width值的26.66%计算，最终元素的高度会和图片加载完成后的高度一致。\n\n也可以使用vw的方法，但在一些浏览器可能有兼容性问题：\n\n.wrapper\n  width 100%\n  height 26.66vw\n  background #eee\n\n\n1\n2\n3\n4\n\n\n> vw，viewpoint width，视窗宽度，1vw=视窗宽度的1%\n> \n> vh，viewpoint height，视窗高度，1vh=视窗高度的1%\n> \n> 更多 css单位。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"文字在一行或多行时超出显示省略号",frontmatter:{title:"文字在一行或多行时超出显示省略号",date:"2020-02-23T15:07:08.000Z",permalink:"/pages/42b66999cc27dc25",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/30.%E6%96%87%E5%AD%97%E5%9C%A8%E4%B8%80%E8%A1%8C%E6%88%96%E5%A4%9A%E8%A1%8C%E6%97%B6%E8%B6%85%E5%87%BA%E6%98%BE%E7%A4%BA%E7%9C%81%E7%95%A5%E5%8F%B7.html",relativePath:"02.页面/20.CSS/30.文字在一行或多行时超出显示省略号.md",key:"v-9fb14a2c",path:"/pages/42b66999cc27dc25/",headers:[{level:2,title:"一行超出显示省略",slug:"一行超出显示省略",normalizedTitle:"一行超出显示省略",charIndex:23},{level:2,title:"两行（多行）超出显示省略号",slug:"两行-多行-超出显示省略号",normalizedTitle:"两行（多行）超出显示省略号",charIndex:441},{level:2,title:"JS判断是否显示了省略号",slug:"js判断是否显示了省略号",normalizedTitle:"js判断是否显示了省略号",charIndex:1086},{level:4,title:"知识点拓展",slug:"知识点拓展",normalizedTitle:"知识点拓展",charIndex:1374}],excerpt:'<h1 id="文字在一行或多行时超出显示省略号"><a class="header-anchor" href="#文字在一行或多行时超出显示省略号">#</a> 文字在一行或多行时超出显示省略号</h1>\n<h2 id="一行超出显示省略"><a class="header-anchor" href="#一行超出显示省略">#</a> 一行超出显示省略</h2>\n\x3c!--beforebegin--\x3e<div class="language-css line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-css"><code><span class="token property">overflow</span><span class="token punctuation">:</span> hidden<span class="token punctuation">;</span>\n<span class="token property">white-space</span><span class="token punctuation">:</span> nowrap<span class="token punctuation">;</span>\n<span class="token property">text-overflow</span><span class="token punctuation">:</span> ellipsis<span class="token punctuation">;</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e',headersStr:"一行超出显示省略 两行（多行）超出显示省略号 JS判断是否显示了省略号 知识点拓展",content:'# 文字在一行或多行时超出显示省略号\n\n\n# 一行超出显示省略\n\noverflow: hidden;\nwhite-space: nowrap;\ntext-overflow: ellipsis;\n\n\n1\n2\n3\n\n\n<html>\n   <div class="box-42b6">演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字</div>\n</html>\n<style>\n    .box-42b6{\n        border: 1px solid #999;\n        width: 200px;\n\n        overflow: hidden;\n        white-space: nowrap;\n        text-overflow: ellipsis;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n# 两行（多行）超出显示省略号\n\noverflow: hidden;\nwhite-space: normal;\ntext-overflow: ellipsis;\ndisplay: -webkit-box;\n-webkit-line-clamp: 2;\n-webkit-box-orient: vertical;\n\n\n1\n2\n3\n4\n5\n6\n\n\n显示的行数由line-clamp样式的值决定。\n\n<html>\n   <div class="box2-42b6">演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字</div>\n</html>\n<style>\n    .box2-42b6{\n        border: 1px solid #999;\n        width: 200px;\n\n        overflow: hidden;\n        white-space: normal;\n        text-overflow: ellipsis;\n        display: -webkit-box;\n        -webkit-line-clamp: 2;\n        -webkit-box-orient: vertical;\n\n      }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n# JS判断是否显示了省略号\n\n有时候我们需要知道是否已经溢出，显示了省略号，可以用到clientHeight和scrollHeight的知识：\n\nlet cHeight = noWrapDiv.clientHeight;\nlet sHeight = noWrapDiv.scrollHeight;\nif (sHeight > cHeight) {\n      console.log("已经溢出显示省略号");\n} else {\n      console.log("没有溢出");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 这里可以用于判断是否溢出显示展开收缩按钮。\n\n# 知识点拓展\n\nscrollHeight：元素内容的高度，包括由于溢出导致的视图中不可见内容。不包含滚动条、边框和外边距。\n\nclientHeight：元素内容的可视区的高度，包含内边距，但不包括水平滚动条、边框和外边距。\n\noffsetHeight：元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。',normalizedContent:'# 文字在一行或多行时超出显示省略号\n\n\n# 一行超出显示省略\n\noverflow: hidden;\nwhite-space: nowrap;\ntext-overflow: ellipsis;\n\n\n1\n2\n3\n\n\n<html>\n   <div class="box-42b6">演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字</div>\n</html>\n<style>\n    .box-42b6{\n        border: 1px solid #999;\n        width: 200px;\n\n        overflow: hidden;\n        white-space: nowrap;\n        text-overflow: ellipsis;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n# 两行（多行）超出显示省略号\n\noverflow: hidden;\nwhite-space: normal;\ntext-overflow: ellipsis;\ndisplay: -webkit-box;\n-webkit-line-clamp: 2;\n-webkit-box-orient: vertical;\n\n\n1\n2\n3\n4\n5\n6\n\n\n显示的行数由line-clamp样式的值决定。\n\n<html>\n   <div class="box2-42b6">演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字演示文字</div>\n</html>\n<style>\n    .box2-42b6{\n        border: 1px solid #999;\n        width: 200px;\n\n        overflow: hidden;\n        white-space: normal;\n        text-overflow: ellipsis;\n        display: -webkit-box;\n        -webkit-line-clamp: 2;\n        -webkit-box-orient: vertical;\n\n      }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n\n# js判断是否显示了省略号\n\n有时候我们需要知道是否已经溢出，显示了省略号，可以用到clientheight和scrollheight的知识：\n\nlet cheight = nowrapdiv.clientheight;\nlet sheight = nowrapdiv.scrollheight;\nif (sheight > cheight) {\n      console.log("已经溢出显示省略号");\n} else {\n      console.log("没有溢出");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n> 这里可以用于判断是否溢出显示展开收缩按钮。\n\n# 知识点拓展\n\nscrollheight：元素内容的高度，包括由于溢出导致的视图中不可见内容。不包含滚动条、边框和外边距。\n\nclientheight：元素内容的可视区的高度，包含内边距，但不包括水平滚动条、边框和外边距。\n\noffsetheight：元素的像素高度，高度包含该元素的垂直内边距和边框，且是一个整数。',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"从box-sizing属性入手，了解盒子模型",frontmatter:{title:"从box-sizing属性入手，了解盒子模型",date:"2020-02-27T17:08:48.000Z",permalink:"/pages/20a978023139589d",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/35.%E4%BB%8Ebox-sizing%E5%B1%9E%E6%80%A7%E5%85%A5%E6%89%8B%EF%BC%8C%E4%BA%86%E8%A7%A3%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html",relativePath:"02.页面/20.CSS/35.从box-sizing属性入手，了解盒子模型.md",key:"v-13b23dae",path:"/pages/20a978023139589d/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:29},{level:2,title:"什么是CSS 盒模型?",slug:"什么是css-盒模型",normalizedTitle:"什么是css 盒模型?",charIndex:225},{level:2,title:"标准盒模型",slug:"标准盒模型",normalizedTitle:"标准盒模型",charIndex:183},{level:2,title:"代替（IE）盒模型",slug:"代替-ie-盒模型",normalizedTitle:"代替（ie）盒模型",charIndex:319},{level:2,title:"box-sizing属性",slug:"box-sizing属性",normalizedTitle:"box-sizing属性",charIndex:3}],excerpt:'<h1 id="从box-sizing属性入手-了解盒子模型"><a class="header-anchor" href="#从box-sizing属性入手-了解盒子模型">#</a> 从box-sizing属性入手，了解盒子模型</h1>\n<h2 id="背景"><a class="header-anchor" href="#背景">#</a> 背景</h2>\n<p>先声明一下运用的场景，假如项目布局使用的是<strong>自适应</strong>的布局方式，div给出的宽度是<strong>百分比</strong>的形式，即占窗口宽度的100%，但边框<code>border</code>和内边距<code>padding</code>是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性<code>box-sizing:border-box</code>来把 <strong>标准盒模型</strong> 变成 <strong>代替(IE)盒模型</strong> ，从而使div的总宽度依然是100%</p>\n',headersStr:"背景 什么是CSS 盒模型? 标准盒模型 代替（IE）盒模型 box-sizing属性",content:"# 从box-sizing属性入手，了解盒子模型\n\n\n# 背景\n\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框border和内边距padding是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性box-sizing:border-box来把 标准盒模型 变成 代替(IE)盒模型 ，从而使div的总宽度依然是100%\n\n\n# 什么是CSS 盒模型?\n\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（IE）盒模型。\n\n\n# 标准盒模型\n\n在标准模型中，如果你给盒设置 width 和 height，实际设置的是内容区域( content box)的宽高。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。\n\n示例：\n\n.box {\n  width: 100px;\n  height: 50px;\n  margin: 10px;\n  padding: 25px;\n  border: 5px solid black;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果使用标准模型，元素总宽度 = 160px （100+25+25+5+5），总高度 = 110px (50 + 25 + 25 + 5 + 5)，即内容区域content box加 padding 和 border 。\n\n> 注: margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。\n\n\n# 代替（IE）盒模型\n\n你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦。 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到总宽高是 width = 100px, height = 50px。\n\n默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 box-sizing: border-box 来实现。 这样就可以告诉浏览器使用 border-box 来定义区域，从而设定您想要的大小。\n\n.box { \n  box-sizing: border-box; \n} \n\n\n1\n2\n3\n\n\n\n# box-sizing属性\n\nCSS中的 box-sizing 属性用于告诉浏览器如何计算一个元素是总宽度和总高度\n\n在 CSS盒子模型 的默认定义里，你对一个元素所设置的 width 与 height 只会应用到这个元素的内容区。如果这个元素有任何的 border 或 padding ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。\n\nbox-sizing 属性可以被用来调整这些表现:\n\n * content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。\n   \n   * 尺寸计算公式：\n     \n     width = 内容的宽度\n     \n     height = 内容的高度\n\n * border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。\n   \n   * 尺寸计算公式：\n     \n     width = border + padding + 内容的宽度\n     \n     height = border + padding + 内容的高度\n\n来源：https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-sizing",normalizedContent:"# 从box-sizing属性入手，了解盒子模型\n\n\n# 背景\n\n先声明一下运用的场景，假如项目布局使用的是自适应的布局方式，div给出的宽度是百分比的形式，即占窗口宽度的100%，但边框border和内边距padding是用像素来表示的，此时就会造成一个问题是div总宽度超过窗口宽度。为了避免这种问题，可以使用属性box-sizing:border-box来把 标准盒模型 变成 代替(ie)盒模型 ，从而使div的总宽度依然是100%\n\n\n# 什么是css 盒模型?\n\n页面布局中，一个元素的外边距（margin）、 边框（border）、内边距（padding）、内容（content）组成一个盒模型。盒模型可分为标准盒模型 和 代替（ie）盒模型。\n\n\n# 标准盒模型\n\n在标准模型中，如果你给盒设置 width 和 height，实际设置的是内容区域( content box)的宽高。 padding 和 border 再加上设置的宽高一起决定整个盒子的大小。\n\n示例：\n\n.box {\n  width: 100px;\n  height: 50px;\n  margin: 10px;\n  padding: 25px;\n  border: 5px solid black;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n如果使用标准模型，元素总宽度 = 160px （100+25+25+5+5），总高度 = 110px (50 + 25 + 25 + 5 + 5)，即内容区域content box加 padding 和 border 。\n\n> 注: margin 不计入实际大小 —— 当然，它会影响盒子在页面所占空间，但是影响的是盒子外部空间。\n\n\n# 代替（ie）盒模型\n\n你可能会认为盒子的大小还要加上边框和内边距，这样很麻烦。 因为这个原因，css还有一个替代盒模型。使用这个模型，所有宽度都是可见宽度，所以内容宽度是该宽度减去边框和填充部分。使用上面相同的样式得到总宽高是 width = 100px, height = 50px。\n\n默认浏览器会使用标准模型。如果需要使用替代模型，您可以通过为其设置 box-sizing: border-box 来实现。 这样就可以告诉浏览器使用 border-box 来定义区域，从而设定您想要的大小。\n\n.box { \n  box-sizing: border-box; \n} \n\n\n1\n2\n3\n\n\n\n# box-sizing属性\n\ncss中的 box-sizing 属性用于告诉浏览器如何计算一个元素是总宽度和总高度\n\n在 css盒子模型 的默认定义里，你对一个元素所设置的 width 与 height 只会应用到这个元素的内容区。如果这个元素有任何的 border 或 padding ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。\n\nbox-sizing 属性可以被用来调整这些表现:\n\n * content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。\n   \n   * 尺寸计算公式：\n     \n     width = 内容的宽度\n     \n     height = 内容的高度\n\n * border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。\n   \n   * 尺寸计算公式：\n     \n     width = border + padding + 内容的宽度\n     \n     height = border + padding + 内容的高度\n\n来源：https://developer.mozilla.org/zh-cn/docs/web/css/box-sizing",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"水平垂直居中的几种方式-案例",frontmatter:{title:"水平垂直居中的几种方式-案例",date:"2020-03-13T16:13:43.000Z",permalink:"/pages/cb7cb251adba4bf7",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/40.%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F-%E6%A1%88%E4%BE%8B.html",relativePath:"02.页面/20.CSS/40.水平垂直居中的几种方式-案例.md",key:"v-203057c8",path:"/pages/cb7cb251adba4bf7/",headersStr:null,content:"# 水平垂直居中的几种方式-案例\n\nSee the Pen 水平垂直居中的几种方式 by xugaoyi (@xugaoyi) on CodePen.",normalizedContent:"# 水平垂直居中的几种方式-案例\n\nsee the pen 水平垂直居中的几种方式 by xugaoyi (@xugaoyi) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"如何根据系统主题自动响应CSS深色模式",frontmatter:{title:"如何根据系统主题自动响应CSS深色模式",date:"2020-03-31T14:06:26.000Z",permalink:"/pages/5dde351274f1e39d",categories:["页面","CSS"],tags:["css"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/45.%E5%A6%82%E4%BD%95%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E4%B8%BB%E9%A2%98%E8%87%AA%E5%8A%A8%E5%93%8D%E5%BA%94CSS%E6%B7%B1%E8%89%B2%E6%A8%A1%E5%BC%8F.html",relativePath:"02.页面/20.CSS/45.如何根据系统主题自动响应CSS深色模式.md",key:"v-5d8ec06d",path:"/pages/5dde351274f1e39d/",headers:[{level:2,title:"CSS 深色模式 (Dark Mode)",slug:"css-深色模式-dark-mode",normalizedTitle:"css 深色模式 (dark mode)",charIndex:123},{level:2,title:"添加深色模式自动响应",slug:"添加深色模式自动响应",normalizedTitle:"添加深色模式自动响应",charIndex:673},{level:2,title:"JS判断深色模式",slug:"js判断深色模式",normalizedTitle:"js判断深色模式",charIndex:1087},{level:2,title:"结论",slug:"结论",normalizedTitle:"结论",charIndex:1782}],excerpt:'<h1 id="如何根据系统主题自动响应css深色模式"><a class="header-anchor" href="#如何根据系统主题自动响应css深色模式">#</a> 如何根据系统主题自动响应CSS深色模式</h1>\n<p align="center">\n  <img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200427163531.jpg" width="500">\n</p>\n<p>很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。</p>\n',headersStr:"CSS 深色模式 (Dark Mode) 添加深色模式自动响应 JS判断深色模式 结论",content:"# 如何根据系统主题自动响应CSS深色模式\n\n\n\n很多人喜欢选择APP或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的CSS深色模式，根据访客的系统主题来自动响应。\n\n\n# CSS 深色模式 (Dark Mode)\n\n在:root根元素中定义变量来设置主题的颜色。我建议你也这样做，因为这样会使这个过程容易得多。我定义的变量如下:\n\n:root {\n  --bg: #fff;\n  --textColor: #004050;\n  --borderColor: rgba(0,0,0,.15);\n}\n\n\n1\n2\n3\n4\n5\n\n\n> :root 这个 CSS 伪类匹配文档树的根元素。对于 HTML 来说，:root 表示 <html>元素，除了优先级更高之外，与 html 选择器相同。\n\n如果希望在样式表中使用这些变量，可以这样做\n\nbody {\n  color: var(--bg);\n}\n\n\n1\n2\n3\n\n\n这样，如果你想改变你的主题颜色，所需要做的就是修改你定义的变量，所有使用这个变量的样式都会被更新。\n\n现在我们需要定义一组新的变量，这些变量将在调用CSS深色模式时使用。对我来说，深色模式的变量是这样的:\n\n/* 定义深色模式的颜色 */\n:root {\n  --bg: rgb(30,30,34);\n  --textColor: rgb(150,150,154);\n  --borderColor: #2C2C3A;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 添加深色模式自动响应\n\n现在我们定义了两组变量。剩下要做的一件事就是将prefers-color-scheme媒体查询添加到我们的深色模式变量中。\n\n使用您的深色模式变量并在外层添加@media查询\n\n/* 根据系统的深色模式响应深色变量 */\n@media (prefers-color-scheme: dark) {\n  :root {\n    --bg: rgb(30,30,34);\n    --textColor: rgb(150,150,154);\n    --borderColor: #2C2C3A;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> prefers-color-scheme文档\n\n这是真的! 如果有人正在使用一个深色模式的系统主题，并访问你的网站，将自动切换到深色模式。\n\n> 如果你的电脑系统不支持深色模式，可以使用手机测试，先把手机的系统主题调到深色模式，再打开你的网站。\n\n\n# JS判断深色模式\n\n如果你的需求需要js来判断系统是否处于深色模式，可以这样做：\n\nif(window.matchMedia('(prefers-color-scheme: dark)').matches){\n  //深色主题\n}\n\n\n1\n2\n3\n\n\n> matchMedia方法返回一个MediaQueryList对象，该对象具有属性matches、media，具有方法addListener、removeListener。\n\naddListener接收一个MediaQueryList对象作为参数。 为深色模式添加监听器，以响应系统切换到或切换出深色模式：\n\nlet listeners={\n  dark:(mediaQueryList )=>{\n    if(mediaQueryList.matches){\n      alert('您切换到深色模式了！')\n    }\n  },\n  light:(mediaQueryList)=>{\n    if(mediaQueryList.matches){\n      alert('您切换到浅色模式了！')\n    }\n  }\n}\n\nwindow.matchMedia('(prefers-color-scheme: dark)').addListener(listeners.dark)\nwindow.matchMedia('(prefers-color-scheme: light)').addListener(listeners.light)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 结论\n\n我们不仅可以在布局方面响应不同尺寸屏幕，还可以按系统主题响应深色模式。我相信你的深夜访客，或者那些喜欢深色模式的人，会感谢你的。",normalizedContent:"# 如何根据系统主题自动响应css深色模式\n\n\n\n很多人喜欢选择app或网站中的深色模式，也许他们更喜欢这样的外观，或者他们想让自己的眼睛免受疲劳。这篇文章将告诉你如何在网站中实现一个自动的css深色模式，根据访客的系统主题来自动响应。\n\n\n# css 深色模式 (dark mode)\n\n在:root根元素中定义变量来设置主题的颜色。我建议你也这样做，因为这样会使这个过程容易得多。我定义的变量如下:\n\n:root {\n  --bg: #fff;\n  --textcolor: #004050;\n  --bordercolor: rgba(0,0,0,.15);\n}\n\n\n1\n2\n3\n4\n5\n\n\n> :root 这个 css 伪类匹配文档树的根元素。对于 html 来说，:root 表示 <html>元素，除了优先级更高之外，与 html 选择器相同。\n\n如果希望在样式表中使用这些变量，可以这样做\n\nbody {\n  color: var(--bg);\n}\n\n\n1\n2\n3\n\n\n这样，如果你想改变你的主题颜色，所需要做的就是修改你定义的变量，所有使用这个变量的样式都会被更新。\n\n现在我们需要定义一组新的变量，这些变量将在调用css深色模式时使用。对我来说，深色模式的变量是这样的:\n\n/* 定义深色模式的颜色 */\n:root {\n  --bg: rgb(30,30,34);\n  --textcolor: rgb(150,150,154);\n  --bordercolor: #2c2c3a;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 添加深色模式自动响应\n\n现在我们定义了两组变量。剩下要做的一件事就是将prefers-color-scheme媒体查询添加到我们的深色模式变量中。\n\n使用您的深色模式变量并在外层添加@media查询\n\n/* 根据系统的深色模式响应深色变量 */\n@media (prefers-color-scheme: dark) {\n  :root {\n    --bg: rgb(30,30,34);\n    --textcolor: rgb(150,150,154);\n    --bordercolor: #2c2c3a;\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n> prefers-color-scheme文档\n\n这是真的! 如果有人正在使用一个深色模式的系统主题，并访问你的网站，将自动切换到深色模式。\n\n> 如果你的电脑系统不支持深色模式，可以使用手机测试，先把手机的系统主题调到深色模式，再打开你的网站。\n\n\n# js判断深色模式\n\n如果你的需求需要js来判断系统是否处于深色模式，可以这样做：\n\nif(window.matchmedia('(prefers-color-scheme: dark)').matches){\n  //深色主题\n}\n\n\n1\n2\n3\n\n\n> matchmedia方法返回一个mediaquerylist对象，该对象具有属性matches、media，具有方法addlistener、removelistener。\n\naddlistener接收一个mediaquerylist对象作为参数。 为深色模式添加监听器，以响应系统切换到或切换出深色模式：\n\nlet listeners={\n  dark:(mediaquerylist )=>{\n    if(mediaquerylist.matches){\n      alert('您切换到深色模式了！')\n    }\n  },\n  light:(mediaquerylist)=>{\n    if(mediaquerylist.matches){\n      alert('您切换到浅色模式了！')\n    }\n  }\n}\n\nwindow.matchmedia('(prefers-color-scheme: dark)').addlistener(listeners.dark)\nwindow.matchmedia('(prefers-color-scheme: light)').addlistener(listeners.light)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 结论\n\n我们不仅可以在布局方面响应不同尺寸屏幕，还可以按系统主题响应深色模式。我相信你的深夜访客，或者那些喜欢深色模式的人，会感谢你的。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"「css技巧」使用hover和attr()定制悬浮提示",frontmatter:{title:"「css技巧」使用hover和attr()定制悬浮提示",date:"2020-04-18T12:14:09.000Z",permalink:"/pages/941581927b4a38f8",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/50.%E3%80%8Ccss%E6%8A%80%E5%B7%A7%E3%80%8D%E4%BD%BF%E7%94%A8hover%E5%92%8Cattr()%E5%AE%9A%E5%88%B6%E6%82%AC%E6%B5%AE%E6%8F%90%E7%A4%BA.html",relativePath:"02.页面/20.CSS/50.「css技巧」使用hover和attr()定制悬浮提示.md",key:"v-5801946e",path:"/pages/941581927b4a38f8/",excerpt:'<h1 id="「css技巧」使用hover和attr-定制悬浮提示-demo"><a class="header-anchor" href="#「css技巧」使用hover和attr-定制悬浮提示-demo">#</a> 「css技巧」使用hover和attr()定制悬浮提示-demo</h1>\n<iframe height="400" style="width: 100%;" scrolling="no" title="【CSS：行为】使用:hover和attr()定制悬浮提示" src="https://codepen.io/xugaoyi/embed/vYNKNaq?height=400&theme-id=light&default-tab=css,result" frameborder="no" allowtransparency="true" allowfullscreen="true" loading="lazy">\n  See the Pen <a href=\'https://codepen.io/xugaoyi/pen/vYNKNaq\'>【CSS：行为】使用:hover和attr()定制悬浮提示</a> by xugaoyi\n  (<a href=\'https://codepen.io/xugaoyi\'>@xugaoyi</a>) on <a href=\'https://codepen.io\'>CodePen</a>.\n</iframe>\n',headersStr:null,content:"# 「css技巧」使用hover和attr()定制悬浮提示-demo\n\nSee the Pen 【CSS：行为】使用:hover和attr()定制悬浮提示 by xugaoyi (@xugaoyi) on CodePen.",normalizedContent:"# 「css技巧」使用hover和attr()定制悬浮提示-demo\n\nsee the pen 【css：行为】使用:hover和attr()定制悬浮提示 by xugaoyi (@xugaoyi) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"CSS-function汇总",frontmatter:{title:"CSS-function汇总",date:"2020-05-12T09:36:44.000Z",permalink:"/pages/3da0d7",categories:["页面","CSS"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/02.%E9%A1%B5%E9%9D%A2/20.CSS/60.CSS-function%E6%B1%87%E6%80%BB.html",relativePath:"02.页面/20.CSS/60.CSS-function汇总.md",key:"v-74664c83",path:"/pages/3da0d7/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"Git使用手册",frontmatter:{title:"Git使用手册",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/9a7ee40fc232253e",categories:["技术","技术文档"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/01.Git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C.html",relativePath:"03.技术/01.技术文档/01.Git使用手册.md",key:"v-4908690b",path:"/pages/9a7ee40fc232253e/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:14},{level:2,title:"创建版本库（仓库）",slug:"创建版本库-仓库",normalizedTitle:"创建版本库（仓库）",charIndex:296},{level:2,title:"添加文件到仓库",slug:"添加文件到仓库",normalizedTitle:"添加文件到仓库",charIndex:478},{level:4,title:"提交描述规范",slug:"提交描述规范",normalizedTitle:"提交描述规范",charIndex:795},{level:2,title:"版本管理",slug:"版本管理",normalizedTitle:"版本管理",charIndex:819},{level:4,title:"提交修改",slug:"提交修改",normalizedTitle:"提交修改",charIndex:936},{level:4,title:"查看版本记录",slug:"查看版本记录",normalizedTitle:"查看版本记录",charIndex:1105},{level:4,title:"回退版本",slug:"回退版本",normalizedTitle:"回退版本",charIndex:1204},{level:4,title:"撤销修改",slug:"撤销修改",normalizedTitle:"撤销修改",charIndex:1565},{level:4,title:"删除文件",slug:"删除文件",normalizedTitle:"删除文件",charIndex:1639},{level:2,title:"远程仓库",slug:"远程仓库",normalizedTitle:"远程仓库",charIndex:1714},{level:4,title:"SSH验证",slug:"ssh验证",normalizedTitle:"ssh验证",charIndex:1722},{level:4,title:"关联远程仓库",slug:"关联远程仓库",normalizedTitle:"关联远程仓库",charIndex:1733},{level:4,title:"查看远程仓库",slug:"查看远程仓库",normalizedTitle:"查看远程仓库",charIndex:2770},{level:4,title:"删除远程仓库",slug:"删除远程仓库",normalizedTitle:"删除远程仓库",charIndex:2811},{level:4,title:"从远程库克隆项目",slug:"从远程库克隆项目",normalizedTitle:"从远程库克隆项目",charIndex:2858},{level:5,title:"克隆指定分支",slug:"克隆指定分支",normalizedTitle:"克隆指定分支",charIndex:2906},{level:2,title:"分支管理",slug:"分支管理",normalizedTitle:"分支管理",charIndex:2960},{level:4,title:"创建分支",slug:"创建分支",normalizedTitle:"创建分支",charIndex:2968},{level:4,title:"查看分支",slug:"查看分支",normalizedTitle:"查看分支",charIndex:3013},{level:4,title:"切换分支",slug:"切换分支",normalizedTitle:"切换分支",charIndex:3072},{level:4,title:"合并分支",slug:"合并分支",normalizedTitle:"合并分支",charIndex:3114},{level:4,title:"删除分支",slug:"删除分支",normalizedTitle:"删除分支",charIndex:3263},{level:4,title:"修改分支名",slug:"修改分支名",normalizedTitle:"修改分支名",charIndex:3306},{level:2,title:"帮助命令",slug:"帮助命令",normalizedTitle:"帮助命令",charIndex:3360},{level:2,title:"参考文档",slug:"参考文档",normalizedTitle:"参考文档",charIndex:7031}],excerpt:'<h1 id="git使用手册"><a class="header-anchor" href="#git使用手册">#</a> Git使用手册</h1>\n<h2 id="安装"><a class="header-anchor" href="#安装">#</a> 安装</h2>\n<p>官网下载：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener noreferrer">https://git-scm.com/downloads<OutboundLink/></a> 下载完成后使用默认进行安装。</p>\n<p>安装完成后，在开始菜单里找到 <code>Git</code> -&gt; <code>Git Bash</code>，蹦出一个类似命令行窗口的东西，就说明Git安装成功！\n还需要最后一步设置，在命令行输入：</p>\n\x3c!--beforebegin--\x3e<div class="language-bash line-numbers-mode">\x3c!--afterbegin--\x3e<pre v-pre class="language-bash"><code><span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span>\n<span class="token function">git</span> config --global user.email <span class="token string">"email@example.com"</span>\n</code></pre>\n<div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div>\x3c!--beforeend--\x3e</div>\x3c!--afterend--\x3e<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。</p>\n',headersStr:"安装 创建版本库（仓库） 添加文件到仓库 提交描述规范 版本管理 提交修改 查看版本记录 回退版本 撤销修改 删除文件 远程仓库 SSH验证 关联远程仓库 查看远程仓库 删除远程仓库 从远程库克隆项目 克隆指定分支 分支管理 创建分支 查看分支 切换分支 合并分支 删除分支 修改分支名 帮助命令 参考文档",content:"# Git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 Git -> Git Bash，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"email@example.com\"\n\n\n1\n2\n\n\n因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成Git仓库\ngit init\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉Git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉Git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n1\n2\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n1\n2\n\n\n> 也可使用可视化工具查看Git版本历史： 在仓库目录右键 > Git BUI Here\n\n# 回退版本\n\n首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。\n\n# 回退到上一个版本\n$ git reset --hard HEAD^\n\n\n1\n2\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n1\n2\n\n\n但是不知道版本号怎么办？Git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n1\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# SSH验证\n\n使本机能关联远程仓库，首次需要SSH验证\n\n * 第1步：创建SSH Key。在用户主（C:\\Users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：\n\n# 创建SSH Key\nssh-keygen -t rsa -C \"邮件地址\"\n\n\n1\n2\n\n * 第2步：登陆GitHub，右上角头像 > settings > SSH and GPG keys >Add SSH Key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nSSH验证完成后，在github创建仓库，创建仓库时记得取消 Initialize this repository with a README的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:xugaoyi/test.git\n\n\n1\n2\n3\n4\n5\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n1\n2\n3\n4\n5\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 Initialize this repository with a README 则需先拉取README.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n1\n2\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n1\n2\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n1\n2\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n1\n2\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n1\n2\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n1\n2\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n1\n2\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n1\n2\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n1\n2\n3\n4\n5\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n1\n2\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n1\n2\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n1\n2\n\n\n$ git help\nusage: git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nThese are common Git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      Clone a repository into a new directory\n   init       Create an empty Git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        Add file contents to the index\n   mv         Move or rename a file, a directory, or a symlink\n   reset      Reset current HEAD to the specified state\n   rm         Remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     Use binary search to find the commit that introduced a bug\n   grep       Print lines matching a pattern\n   log        Show commit logs\n   show       Show various types of objects\n   status     Show the working tree status\n\ngrow, mark and tweak your common history\n   branch     List, create, or delete branches\n   checkout   Switch branches or restore working tree files\n   commit     Record changes to the repository\n   diff       Show changes between commits, commit and working tree, etc\n   merge      Join two or more development histories together\n   rebase     Reapply commits on top of another base tip\n   tag        Create, list, delete or verify a tag object signed with GPG\n\ncollaborate (see also: git help workflows)\n   fetch      Download objects and refs from another repository\n   pull       Fetch from and integrate with another repository or a local branch\n   push       Update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. See 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-C <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用Git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的Git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用GPG签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",normalizedContent:"# git使用手册\n\n\n# 安装\n\n官网下载：https://git-scm.com/downloads 下载完成后使用默认进行安装。\n\n安装完成后，在开始菜单里找到 git -> git bash，蹦出一个类似命令行窗口的东西，就说明git安装成功！ 还需要最后一步设置，在命令行输入：\n\ngit config --global user.name \"your name\"\ngit config --global user.email \"email@example.com\"\n\n\n1\n2\n\n\n因为git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和email地址。\n\n\n# 创建版本库（仓库）\n\n# 创建仓库\nmkdir <仓库name> \n\n# 进入仓库\ncd <仓库name>\n\n# 此命令用于显示当前目录\npwd\n\n# 把当前目录初始化成git仓库\ngit init\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n> 也不一定必须在空目录下创建git仓库，选择一个已经有东西的目录直接git init也是可以的。\n\n\n# 添加文件到仓库\n\n在仓库目录下放入文件，如新建一个test.txt文件，然后使用git add test.txt命令告诉git，把文件添加到缓存区，然后使用git commit -m \"提交描述\"告诉git，把文件提交到仓库。\n\n# 添加指定文件或文件夹到缓存区，文件需添加后缀\ngit add <文件或文件夹name>                   # 单个文件\ngit add <文件或文件夹name> <文件或文件夹name>  # 多个文件\n\n# 或 全部文件同时添加到缓存区\ngit add .\n\n# 把文件从缓存区提交至仓库\ngit commit -m \"提交描述\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n# 提交描述规范\n\n在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述\n\n# 新建(add)\n# 删除(rm)\n# 更新(update)\n# 改动(change)\n# 实现\n# 发布\n# 修复\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 版本管理\n\n# 提交修改\n\n如修改test.txt的内容后，运行git status命令看看被修改的文件，然后再使用git add test.txt、 git commit -m \"修改描述\"把修改后的文件提交到仓库，提交后可再次使用git status查看当前状态。\n\n# 显示 新增/删除/被改动等 的文件\ngit status\n\n\n1\n2\n\n\n# 查看版本记录\n\n# 查看版本记录\ngit log   # 显示版本号、提交时间等信息\n\n\n1\n2\n\n\n> 也可使用可视化工具查看git版本历史： 在仓库目录右键 > git bui here\n\n# 回退版本\n\n首先，git必须知道当前版本是哪个版本，在git中，用head表示当前版本，也就是最新的提交1094adb...（注意我的提交id和你的肯定不一样），上一个版本就是head^，上上一个版本就是head^^，当然往上100个版本写100个^比较容易数不过来，所以写成head~100。\n\n# 回退到上一个版本\n$ git reset --hard head^\n\n\n1\n2\n\n\n此时查看git log记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号\n\n# 跳转到指定版本\ngit reset --hard <版本号前几位>\n\n\n1\n2\n\n\n但是不知道版本号怎么办？git提供了一个命令git reflog用来记录你的每一次命令\n\ngit reflog\n\n\n1\n\n\n# 撤销修改\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/897889638509536\n\n# 删除文件\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600/900002180232448\n\n\n# 远程仓库\n\n# ssh验证\n\n使本机能关联远程仓库，首次需要ssh验证\n\n * 第1步：创建ssh key。在用户主（c:\\users\\dell）目录下，看看有没有.ssh目录， 如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。 如果没有，打开shell（windows下打开git bash），创建ssh key：\n\n# 创建ssh key\nssh-keygen -t rsa -c \"邮件地址\"\n\n\n1\n2\n\n * 第2步：登陆github，右上角头像 > settings > ssh and gpg keys >add ssh key，在key的文本框里粘贴id_rsa.pub文件的内容\n\n# 关联远程仓库\n\nssh验证完成后，在github创建仓库，创建仓库时记得取消 initialize this repository with a readme的勾选，然后在本地命令：\n\n# 关联远程仓库，仓库名一般使用origin\ngit remote add <仓库名> <远程仓库地址>\n\n# 示例\ngit remote add origin git@github.com:xugaoyi/test.git\n\n\n1\n2\n3\n4\n5\n\n\n下一步，就可以把本地库的所有内容推送到远程库上\n\n# 把文件推送到远程仓库\ngit push -u <仓库名> <分支名>\n\n# 示例\ngit push -u origin master\n\n\n1\n2\n3\n4\n5\n\n\n由于远程库是空的，我们第一次推送master分支时，加上了-u参数，git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。\n\n> 前提是目录已经git init初始化成仓库，并且git status状态是没有改动的，如果有改动则先git add .添加至缓存区，git commit -m '提交描述'提交至仓库，然后执行上面命令。\n> \n> 如创建仓库时勾选了 initialize this repository with a readme 则需先拉取readme.md文件到本地仓库git pull\n> \n> 可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。\n\n# 简化的推送命令\ngit push\n\n\n1\n2\n\n\n# 查看远程仓库\n\n# 查看远程仓库\ngit remote -v\n\n\n1\n2\n\n\n# 删除远程仓库\n\n# 删除远程仓库\ngit remote rm <仓库名>\n\n\n1\n2\n\n\n# 从远程库克隆项目\n\n# 从远程库克隆项目\ngit clone <仓库地址>\n\n\n1\n2\n\n\n# 克隆指定分支\n\n# 克隆指定分支\ngit clone -b <分支名> <仓库地址>\n\n\n1\n2\n\n\n\n# 分支管理\n\n# 创建分支\n\n# 创建分支\ngit checkout -b <分支名>\n\n\n1\n2\n\n\n# 查看分支\n\n# 查看分支\ngit branch\n\n\n1\n2\n\n\n查看分支时，在分支前带 * 号的表示当前的分支\n\n# 切换分支\n\n# 切换分支\ngit checkout <分支名>\n\n\n1\n2\n\n\n# 合并分支\n\n# 合并本地的分支\ngit merge <分支名>\n\n# 合并远程的分支\ngit merge <远程仓库名>/<分支名>\n\n\n1\n2\n3\n4\n5\n\n\n注意，是将指定分支合并到当前分支，并非当前分支合并到指定分支。\n\n一般情况下是把当前分支切换到主分支，然后把子分支合并到主分支。\n\n# 删除分支\n\n# 删除分支\ngit branch -d <分支名>\n\n\n1\n2\n\n\n# 修改分支名\n\n# 修改分支名\ngit branch -m <原分支名> <新分支名>\n\n\n1\n2\n\n\n\n# 帮助命令\n\n如对命令不清楚时，可使用git help命令显示出git命令介绍。\n\n# 帮助命令\ngit help\n\n\n1\n2\n\n\n$ git help\nusage: git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\nthese are common git commands used in various situations:\n\nstart a working area (see also: git help tutorial)\n   clone      clone a repository into a new directory\n   init       create an empty git repository or reinitialize an existing one\n\nwork on the current change (see also: git help everyday)\n   add        add file contents to the index\n   mv         move or rename a file, a directory, or a symlink\n   reset      reset current head to the specified state\n   rm         remove files from the working tree and from the index\n\nexamine the history and state (see also: git help revisions)\n   bisect     use binary search to find the commit that introduced a bug\n   grep       print lines matching a pattern\n   log        show commit logs\n   show       show various types of objects\n   status     show the working tree status\n\ngrow, mark and tweak your common history\n   branch     list, create, or delete branches\n   checkout   switch branches or restore working tree files\n   commit     record changes to the repository\n   diff       show changes between commits, commit and working tree, etc\n   merge      join two or more development histories together\n   rebase     reapply commits on top of another base tip\n   tag        create, list, delete or verify a tag object signed with gpg\n\ncollaborate (see also: git help workflows)\n   fetch      download objects and refs from another repository\n   pull       fetch from and integrate with another repository or a local branch\n   push       update remote refs along with associated objects\n\n'git help -a' and 'git help -g' list available subcommands and some\nconcept guides. see 'git help <command>' or 'git help <concept>'\nto read about a specific subcommand or concept.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n翻译工具翻译中文\n\n$ git help\n使用：git [--version] [--help] [-c <path>] [-c <name>=<value>]\n           [--exec-path[=<path>]] [--html-path] [--man-path] [--info-path]\n           [-p | --paginate | -p | --no-pager] [--no-replace-objects] [--bare]\n           [--git-dir=<path>] [--work-tree=<path>] [--namespace=<name>]\n           <command> [<args>]\n\n这些是在各种情况下使用的通用git命令：\n\nstart a working area (参见命令: git help tutorial)\n   clone      将存储库克隆到新目录中\n   init       创建一个空的git存储库或重新初始化一个现有的存储库\n\nwork on the current change (参见命令: git help everyday)\n   add        将文件内容添加到索引中\n   mv         移动或重命名文件、目录或符号链接\n   reset      将当前磁头重置为指定状态\n   rm         从工作树和索引中删除文件\n\nexamine the history and state (参见命令: git help revisions)\n   bisect     使用二分查找查找引入错误的提交\n   grep       打印与模式匹配的行\n   log        显示提交日志\n   show       显示各种类型的对象\n   status     显示工作树状态\n\ngrow, mark and tweak your common history\n   branch     列出、创建或删除分支\n   checkout   切换分支或还原工作树文件\n   commit     记录对存储库的更改\n   diff       显示提交、提交和工作树等之间的更改\n   merge      将两个或多个开发历史连接在一起\n   rebase     在另一个基本提示之上重新应用提交\n   tag        创建、列表、删除或验证用gpg签名的标记对象\n\ncollaborate (参见命令: git help workflows)\n   fetch      从另一个存储库下载对象和引用\n   pull       从另一个存储库或本地分支获取并与之集成\n   push       更新远程引用和相关对象\n\n'git help -a' 和 'git help -g' 列出可用的子命令和一些概念指导。\n命令'git help <command>' 或 'git help <concept>' 查看特定子命令或概念.\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# 参考文档\n\nhttps://www.liaoxuefeng.com/wiki/896043488029600",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"Markdown使用教程",frontmatter:{title:"Markdown使用教程",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/ad247c4332211551",categories:["技术","技术文档"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/02.Markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html",relativePath:"03.技术/01.技术文档/02.Markdown使用教程.md",key:"v-fb370f06",path:"/pages/ad247c4332211551/",headers:[{level:2,title:"一、Markdown",slug:"一、markdown",normalizedTitle:"一、markdown",charIndex:19},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:34},{level:3,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:87},{level:3,title:"编辑器",slug:"编辑器",normalizedTitle:"编辑器",charIndex:152},{level:2,title:"二、徽章",slug:"二、徽章",normalizedTitle:"二、徽章",charIndex:194},{level:4,title:"什么是徽章",slug:"什么是徽章",normalizedTitle:"什么是徽章",charIndex:202},{level:4,title:"徽章的使用",slug:"徽章的使用",normalizedTitle:"徽章的使用",charIndex:318},{level:2,title:"三、设置目录",slug:"三、设置目录",normalizedTitle:"三、设置目录",charIndex:579},{level:2,title:"四、标题",slug:"四、标题",normalizedTitle:"四、标题",charIndex:1197},{level:2,title:"二级标题",slug:"二级标题",normalizedTitle:"二级标题",charIndex:1215},{level:3,title:"三级标题",slug:"三级标题",normalizedTitle:"三级标题",charIndex:1227},{level:4,title:"四级标题",slug:"四级标题",normalizedTitle:"四级标题",charIndex:1241},{level:5,title:"五级标题",slug:"五级标题",normalizedTitle:"五级标题",charIndex:1257},{level:6,title:"六级标题",slug:"六级标题",normalizedTitle:"六级标题",charIndex:1275},{level:2,title:"五、文本",slug:"五、文本",normalizedTitle:"五、文本",charIndex:1285},{level:3,title:"段落",slug:"段落",normalizedTitle:"段落",charIndex:1297},{level:3,title:"字体",slug:"字体",normalizedTitle:"字体",charIndex:1307},{level:3,title:"删除线",slug:"删除线",normalizedTitle:"删除线",charIndex:1317},{level:3,title:"下划线",slug:"下划线",normalizedTitle:"下划线",charIndex:1328},{level:3,title:"文字高亮",slug:"文字高亮",normalizedTitle:"文字高亮",charIndex:1339},{level:3,title:"分隔线",slug:"分隔线",normalizedTitle:"分隔线",charIndex:1351},{level:3,title:"脚注",slug:"脚注",normalizedTitle:"脚注",charIndex:1362},{level:2,title:"六、列表",slug:"六、列表",normalizedTitle:"六、列表",charIndex:1370},{level:3,title:"无序列表",slug:"无序列表",normalizedTitle:"无序列表",charIndex:1382},{level:3,title:"有序列表",slug:"有序列表",normalizedTitle:"有序列表",charIndex:1394},{level:3,title:"折叠列表",slug:"折叠列表",normalizedTitle:"折叠列表",charIndex:1406},{level:3,title:"带复选框列表",slug:"带复选框列表",normalizedTitle:"带复选框列表",charIndex:1418},{level:3,title:"列表嵌套",slug:"列表嵌套",normalizedTitle:"列表嵌套",charIndex:1432},{level:2,title:"七、区块引用",slug:"七、区块引用",normalizedTitle:"七、区块引用",charIndex:1442},{level:4,title:"区块嵌套",slug:"区块嵌套",normalizedTitle:"区块嵌套",charIndex:1456},{level:4,title:"区块中使用列表",slug:"区块中使用列表",normalizedTitle:"区块中使用列表",charIndex:1468},{level:4,title:"列表中使用区块",slug:"列表中使用区块",normalizedTitle:"列表中使用区块",charIndex:1483},{level:2,title:"八、代码",slug:"八、代码",normalizedTitle:"八、代码",charIndex:1496},{level:3,title:"代码区块",slug:"代码区块",normalizedTitle:"代码区块",charIndex:1508},{level:2,title:"九、链接",slug:"九、链接",normalizedTitle:"九、链接",charIndex:1518},{level:3,title:"变量链接",slug:"变量链接",normalizedTitle:"变量链接",charIndex:1530},{level:3,title:"Github仓库中使用内部链接",slug:"github仓库中使用内部链接",normalizedTitle:"github仓库中使用内部链接",charIndex:4923},{level:3,title:"锚点链接",slug:"锚点链接",normalizedTitle:"锚点链接",charIndex:1563},{level:2,title:"十、图片",slug:"十、图片",normalizedTitle:"十、图片",charIndex:1573},{level:3,title:"图片宽高",slug:"图片宽高",normalizedTitle:"图片宽高",charIndex:1585},{level:3,title:"相对路径以及Github中使用图片",slug:"相对路径以及github中使用图片",normalizedTitle:"相对路径以及github中使用图片",charIndex:1597},{level:2,title:"十一、表格",slug:"十一、表格",normalizedTitle:"十一、表格",charIndex:1620},{level:2,title:"十二、Emoji表情包",slug:"十二、emoji表情包",normalizedTitle:"十二、emoji表情包",charIndex:1631},{level:2,title:"十三、其他技巧",slug:"十三、其他技巧",normalizedTitle:"十三、其他技巧",charIndex:1648},{level:3,title:"支持的 HTML 元素",slug:"支持的-html-元素",normalizedTitle:"支持的 html 元素",charIndex:1663},{level:3,title:"转义",slug:"转义",normalizedTitle:"转义",charIndex:1682},{level:3,title:"数学公式",slug:"数学公式",normalizedTitle:"数学公式",charIndex:1692},{level:3,title:"图表",slug:"图表",normalizedTitle:"图表",charIndex:1704},{level:3,title:"流程图",slug:"流程图",normalizedTitle:"流程图",charIndex:1714},{level:3,title:"时序图",slug:"时序图",normalizedTitle:"时序图",charIndex:1725},{level:3,title:"甘特图",slug:"甘特图",normalizedTitle:"甘特图",charIndex:1736}],excerpt:'<h1 id="markdown使用教程"><a class="header-anchor" href="#markdown使用教程">#</a> Markdown使用教程</h1>\n<h2 id="一、markdown"><a class="header-anchor" href="#一、markdown">#</a> 一、Markdown</h2>\n<h3 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h3>\n<p><img src="https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png" alt="logo"></p>\n<p><code>Markdown</code> 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>\n',headersStr:"一、Markdown 简介 应用 编辑器 二、徽章 什么是徽章 徽章的使用 三、设置目录 四、标题 二级标题 三级标题 四级标题 五级标题 六级标题 五、文本 段落 字体 删除线 下划线 文字高亮 分隔线 脚注 六、列表 无序列表 有序列表 折叠列表 带复选框列表 列表嵌套 七、区块引用 区块嵌套 区块中使用列表 列表中使用区块 八、代码 代码区块 九、链接 变量链接 Github仓库中使用内部链接 锚点链接 十、图片 图片宽高 相对路径以及Github中使用图片 十一、表格 十二、Emoji表情包 十三、其他技巧 支持的 HTML 元素 转义 数学公式 图表 流程图 时序图 甘特图",content:"# Markdown使用教程\n\n\n# 一、Markdown\n\n\n# 简介\n\n\n\nMarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 Markdown 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等\n\n\n# 编辑器\n\n推荐使用Typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)\n\n\n1\n2\n3\n4\n5\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[TOC]\n\n\n1\n\n\n> 注：github暂未支持。\n\n[TOC]\n\n在github生成TOC的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有GO语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe README.MD 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、Markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * Github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及Github中使用图片\n   * 十一、表格\n   * 十二、Emoji表情包\n   * 十三、其他技巧\n     * 支持的 HTML 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nMarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个Tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n1\n2\n3\n4\n5\n6\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~BAIDU.COM~~\n\n\n1\n\n\nBAIDU.COM\n\n\n# 下划线\n\n下划线可以通过 HTML 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n1\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\n1\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n1\n2\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   I我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n1\n2\n3\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n1\n\n\n> 区块引用\n> \n> Typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n1\n2\n3\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n1\n2\n3\n4\n5\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n1\n2\n3\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\n1\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n1\n2\n3\n4\n5\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n1\n2\n3\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n1\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\n1\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [Google][1]\n这个链接用 baidu 作为网址变量 [Baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个链接用 1 作为网址变量 Google\n\n这个链接用 baidu 作为网址变量 Baidu\n\n\n# Github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\n1\n2\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和HTML的锚点（#）类似\n\n[Markdown](#Markdown)\n\n\n1\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nMarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n1\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![RUNOOB][img]\n[img]: https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n1\n\n\n\n# 相对路径以及Github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\n1\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png)\n\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n1\n2\n3\n4\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n1\n2\n3\n4\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、Emoji表情包\n\nEmoji表情英文名的前后加冒号，Typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n1\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 HTML 元素\n\n不在 Markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n\n目前支持的 HTML 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑\n\n\n1\n\n\n使用 Ctrl+Alt+Del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nMarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n1\n2\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n*** 以下部分在Github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{V}_1 \\times \\mathbf{V}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial X}{\\partial u} &  \\frac{\\partial Y}{\\partial u} & 0 \\\\\n\\frac{\\partial X}{\\partial v} &  \\frac{\\partial Y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$$ \\mathbf{V}_1 \\times \\mathbf{V}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial X}{\\partial u} & \\frac{\\partial Y}{\\partial u} & 0 \\ \\frac{\\partial X}{\\partial v} & \\frac{\\partial Y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,Budget,Income,Expenses,Debt\nJune,5000,8000,4000,6000\nJuly,3000,1000,4000,3000\nAug,5000,7000,6000,3000\nSep,7000,2000,3000,1000\nOct,6000,5000,4000,2000\nNov,4000,3000,5000,\n\ntype: pie\ntitle: Monthly Revenue\nx.title: Amount\ny.title: Month\ny.suffix: $\n​```\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 注：在Typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph TD\nA[模块A] --\x3e|A1| B(模块B)\nB --\x3e C{判断条件C}\nC --\x3e|条件C1| D[模块D]\nC --\x3e|条件C2| E[模块E]\nC --\x3e|条件C3| F[模块F]\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequenceDiagram\nA->>B: 是否已收到消息？\nB--\x3e>A: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateFormat  YYYY-MM-DD\nsection 项目A\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目B\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n回到顶部",normalizedContent:"# markdown使用教程\n\n\n# 一、markdown\n\n\n# 简介\n\n\n\nmarkdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。\n\n\n# 应用\n\n当前许多网站都广泛使用 markdown 来撰写帮助文档或是用于论坛上发表消息。例如：github、简书、知乎等\n\n\n# 编辑器\n\n推荐使用typora，官网：https://typora.io/\n\n\n# 二、徽章\n\n# 什么是徽章\n\n徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。\n\n常见于github项目主页，但其不仅出现于 github 项目主页，凡是能够表现图片的地方都可以出现徽章。\n\n# 徽章的使用\n\n * 在markdown中使用\n\n格式:\n[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片\n\n语法：\n[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)\n\n\n1\n2\n3\n4\n5\n\n\n\n\n徽章生成网站：https://shields.io/\n\n本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 戳我 了解。\n\n\n# 三、设置目录\n\n设置之后会根据分级标题来自动生成目录。\n\n[toc]\n\n\n1\n\n\n> 注：github暂未支持。\n\n[toc]\n\n在github生成toc的方法：https://github.com/ekalinin/github-markdown-toc\n\nwindows系统需要基于golang实现的工具：https://github.com/ekalinin/github-markdown-toc.go\n\n> 如果你有go语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。\n> \n> 如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）\n> \n> 下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。\n> \n> 使用方法：\n> \n>  1. 首先将.md文档复制到gh-md-toc.exe的根目录下\n>  2. 在该目录下打开系统命令行，输入命令：gh-md-toc.exe readme.md 生成目录\n>  3. 把生成的目录复制到.md文件即可。\n\n这是gh-md-toc生成的目录：\n\n * 一、markdown\n   * 简介\n   * 应用\n   * 编辑器\n * 二、徽章\n   * 什么是徽章\n   * 徽章的使用\n * 三、设置目录\n * 四、标题\n * 一级标题\n   * 二级标题\n     * 三级标题\n       * 四级标题\n         * 五级标题\n           * 六级标题\n   * 五、文本\n     * 段落\n     * 字体\n     * 删除线\n     * 下划线\n     * 文字高亮\n     * 分隔线\n     * 脚注\n   * 六、列表\n     * 无序列表\n     * 有序列表\n     * 折叠列表\n     * 带复选框列表\n     * 列表嵌套\n   * 七、区块引用\n     * 区块嵌套\n     * 区块中使用列表\n     * 列表中使用区块\n   * 八、代码\n     * 代码区块\n   * 九、链接\n     * 变量链接\n     * github中使用内部链接\n     * 锚点链接\n   * 十、图片\n     * 图片宽高\n     * 相对路径以及github中使用图片\n   * 十一、表格\n   * 十二、emoji表情包\n   * 十三、其他技巧\n     * 支持的 html 元素\n     * 转义\n     * 数学公式\n     * 图表\n     * 流程图\n     * 时序图\n     * 甘特图\n\n\n# 四、标题\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 一级标题\n\n\n# 二级标题\n\n\n# 三级标题\n\n# 四级标题\n\n# 五级标题\n\n# 六级标题\n\n\n# 五、文本\n\n\n# 段落\n\nmarkdown 段落没有特殊的格式，直接编写文字，需要段落缩进时使用2个tab\n\n\n# 字体\n\n*斜体文本*\n或 _斜体文本_\n**粗体文本**\n或  __粗体文本__\n***粗斜体文本***\n或 ___粗斜体文本___\n\n\n1\n2\n3\n4\n5\n6\n\n\n斜体文本\n\n斜体文本\n\n粗体文本\n\n粗体文本\n\n粗斜体文本\n\n粗斜体文本\n\n\n# 删除线\n\n如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：\n\n~~baidu.com~~\n\n\n1\n\n\nbaidu.com\n\n\n# 下划线\n\n下划线可以通过 html 的<u> 标签来实现：\n\n<u>带下划线的文本</u>\n\n\n1\n\n\n带下划线的文本\n\n\n# 文字高亮\n\n文字高亮能使行内部分文字高亮，使用一对反引号。\n\n`html` `css` `javascript`\n\n\n1\n\n\nhtml css javascript\n\n\n# 分隔线\n\n你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：\n\n***\n\n*****\n\n- - -\n\n----------\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n----------------------------------------\n\n\n# 脚注\n\n脚注是对文本的补充说明。\n\n[^变量]\n在文档结尾或其他位置給变量赋值：\n[^变量]: 注明框内显示的内容\n\n鼠标移到这里> [^哈喽]\n[^哈喽]: 注明框内显示的内容\n\n\n1\n2\n3\n4\n5\n6\n\n\n> 注：在部分线上预览未支持\n\n鼠标移到这里> ^哈喽\n\n\n# 六、列表\n\n\n# 无序列表\n\n使用星号*、加号+或是减号-作为列表标记：\n\n* 第一项\n* 第二项\n\n+ 第一项\n+ 第二项\n\n- 第一项\n- 第二项\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n * 第一项\n * 第二项\n\n\n# 有序列表\n\n使用数字并加上. 号来表示\n\n1. 第一项\n2. 第二项\n\n\n1\n2\n\n 1. 第一项\n 2. 第二项\n\n\n# 折叠列表\n\n<details>\n<summary>点我打开关闭折叠</summary>\n 折叠内容\n <ul>\n     <li>1</li>\n     <li>2</li>\n     <li>3</li>\n </ul>\n</details>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n> 注意：<details> 标签内写markdown代码无效，可写html代码，如ul>li、table等\n\n点我打开关闭折叠 折叠内容\n * 1\n * 2\n * 3\n\n包含table的折叠\n\n分类        例词\n人称代词-主格   i我，you你，he他，she她，they他们， we我们\n人称代词-宾格   me我， you你， him他， her她， them他们， us我们\n物主代词      my我的， his他的， your你的（your你们的）， their他们的， hers她的\n指示代词      this这， that那， these这些， those 那些\n反身代词      myself我自己， himself他自己， themselves他们自己，\n          yourself你(们)自己，herself她自己\n疑问代词      who谁， what什么， which哪个\n不定代词      some一些， many许多， both两个、两个都， any许多\n关系代词      which……的物， who……的人， that……的人或物， who谁， that引导定语从句\n相互代词      each other 互相， one another互相\n连接代词      who,whom,whose,what,which,whatever,whichever,whoever,whomever\n替代词       one（单数），ones（复数）\n\n\n# 带复选框列表\n\n* [x] 第一项\n* [ ] 第二项\n* [ ] 第三项\n\n\n1\n2\n3\n\n\n> 注：在部分线上预览未支持\n\n * [x] 第一项\n\n * [ ] 第二项\n\n * [ ] 第三项\n\n\n# 列表嵌套\n\n1. 第一项：\n    - 第一项嵌套的第一个元素\n    - 第一项嵌套的第二个元素\n2. 第二项：\n    - 第二项嵌套的第一个元素\n       - 第三层嵌套\n\n\n1\n2\n3\n4\n5\n6\n\n 1. 第一项\n    * 嵌套1\n    * 嵌套2\n 2. 第二项\n    * 嵌套1\n      * 嵌套2\n\n\n# 七、区块引用\n\n区块引用是在段落开头使用 >符号 ，然后后面紧跟一个空格符号：\n\n> 区块引用\n\n\n1\n\n\n> 区块引用\n> \n> typora中回车键自动延伸区块\n\n# 区块嵌套\n\n> 第一层\n> > 第二层\n> > > 第三层\n\n\n1\n2\n3\n\n\n> 第一层\n> \n> > 第二层\n> > \n> > > 第三层\n\n# 区块中使用列表\n\n> 区块中使用列表\n> 1. 第一项\n> 2. 第二项\n> * 111\n> * 222\n\n\n1\n2\n3\n4\n5\n\n\n> 区块中使用列表\n> \n>  1. 第一项\n>  2. 第二项\n>     * 111\n>     * 222\n\n# 列表中使用区块\n\n* 第一项\n    > 区块\n* 第二项\n\n\n1\n2\n3\n\n\n * 第一项\n   \n   > 区块\n   > \n   > 区块\n\n * 第二项\n\n\n# 八、代码\n\n如果是段落上的一个代码片段可以用反引号把它包起来（`），示例：\n\n`alert()`\n\n\n1\n\n\nalert()\n\n\n# 代码区块\n\n用三个反引号 ``` 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮\n\n本代码区块为示例说明：\n\n​```javascript\nfunction test() {\n\talert('test')\n}\n​```\n\n\n1\n2\n3\n4\n5\n\n\n效果：\n\nfunction test() {\n\talert('test')\n}\n\n\n1\n2\n3\n\n\n\n# 九、链接\n\n格式：\n\n[链接名称](链接地址)\n\n[链接名称](链接地址,可选的alt)\n\n或\n\n<链接地址>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n示例：\n\n[百度](http://www.baidu.com,'百度')\n\n\n1\n\n\n百度\n\n直接显示链接地址：\n\n<http://www.baidu.com>\n\n\n1\n\n\nhttp://www.baidu.com\n\n\n# 变量链接\n\n链接可以用变量来代替，文档末尾或其他位置附带变量地址：\n\n这个链接用 1 作为网址变量 [google][1]\n这个链接用 baidu 作为网址变量 [baidu][baidu]\n\n然后在文档的结尾或其他位置给变量赋值（网址）\n  [1]: http://www.google.com/\n  [baidu]: http://www.baidu.com/\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个链接用 1 作为网址变量 google\n\n这个链接用 baidu 作为网址变量 baidu\n\n\n# github仓库中使用内部链接\n\n可使用相对路径（前提是有该路径下的文件）\n[test](test.md)\n\n\n1\n2\n\n\ntest\n\n\n# 锚点链接\n\n本文件中每一个标题都是一个锚点，和html的锚点（#）类似\n\n[markdown](#markdown)\n\n\n1\n\n\n> 注： github对含有标点符号的标题进行锚点时会忽略掉标点符号， 本页中，如果这样写则无法跳转：[链接](#九、链接) 正确写法：[链接](#九链接)\n\nmarkdown\n\n链接\n\n流程图\n\n\n# 十、图片\n\n和链接的区别是前面多一个感叹号!\n\n![图片名](图片链接)\n\n\n1\n\n\n当然，你也可以像链接那样对图片地址使用变量:\n\n这里链接用 img 作为图片地址变量\n然后在文档的结尾或其他位置给变量赋值（图片地址）\n![runoob][img]\n[img]: https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\n\n\n1\n2\n3\n4\n\n\n\n\n\n# 图片宽高\n\n如下想设置图片宽高，可以使用 <img> 标签。\n\n<img src=\"https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png\" width=\"50px\" height=\"30px\">\n\n\n1\n\n\n\n# 相对路径以及github中使用图片\n\n不管是在本地还是在github同一个仓库中，如果图片存在，可以使用相对路径。\n\n相对路径图片：\n\n![头像图片](./md-img/test.jpg)\n\n\n1\n\n\ngithub上如果引用其他github仓库中的图片则要注意地址格式：仓库地址/raw/分支名/图片路径 或 https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径\n\n![其他仓库的图片1](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)\n或\n![其他仓库的图片2](https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png)\n\n\n\n1\n2\n3\n4\n\n\n\n\n\n\n\n# 十一、表格\n\n制作表格使用 |来分隔不同的单元格，使用-来分隔表头和其他行。\n\n|  表头   | 表头  |\n|  ----  | ----  |\n| 单元格  | 单元格 |\n| 单元格  | 单元格 |\n\n\n1\n2\n3\n4\n\n\n表头    表头\n单元格   单元格\n单元格   单元格\n\n对齐方式\n\n * -: 设置内容和标题栏居右对齐\n * :- 设置内容和标题栏居左对齐\n * :-: 设置内容和标题栏居中对齐\n\n| 左对齐 | 右对齐 | 居中对齐 |\n| :-----| ----: | :----: |\n| 单元格 | 单元格 | 单元格 |\n| 单元格 | 单元格 | 单元格 |\n\n\n1\n2\n3\n4\n\n\n左对齐   右对齐   居中对齐\n单元格   单元格   单元格\n单元格   单元格   单元格\n\n\n# 十二、emoji表情包\n\nemoji表情英文名的前后加冒号，typore上先输入冒号再输入首字母有表情提示\n\n:smirk:\n\n\n1\n\n\n💋 😸🙈🐴 😏😊😃😄 ☀️\n\n更多表情名称请查看：表情包清单\n\n\n# 十三、其他技巧\n\n\n# 支持的 html 元素\n\n不在 markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 html 撰写。\n\n目前支持的 html 元素有：<kbd> <b> <i> <em> <sup> <sub> <br>等等 ，如：\n\n使用 <kbd>ctrl</kbd>+<kbd>alt</kbd>+<kbd>del</kbd> 重启电脑\n\n\n1\n\n\n使用 ctrl+alt+del 重启电脑\n\n我是使用b标签的加粗字体\n\n\n# 转义\n\nmarkdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：\n\n**未转义星号显示加粗**\n\\*\\* 转义显示星号 \\*\\*\n\n\n1\n2\n\n\n未转义星号显示加粗 ** 转义显示星号 **\n\nmarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n\n\\   反斜线\n`   反引号\n*   星号\n_   下划线\n{}  花括号\n[]  方括号\n()  小括号\n#   井字号\n+   加号\n-   减号\n.   英文句点\n!   感叹号\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n----------------------------------------\n\n*** 以下部分在github或其他在线预览中暂未支持 ***\n\n----------------------------------------\n\n\n# 数学公式\n\n当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 tex 或 latex 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 mathjax 对数学公式进行渲染。如：\n\n$$\n\\mathbf{v}_1 \\times \\mathbf{v}_2 =  \\begin{vmatrix}\n\\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\\\\n\\frac{\\partial x}{\\partial u} &  \\frac{\\partial y}{\\partial u} & 0 \\\\\n\\frac{\\partial x}{\\partial v} &  \\frac{\\partial y}{\\partial v} & 0 \\\\\n\\end{vmatrix}\n$$tep1}{\\style{visibility:hidden}{(x+1)(x+1)}}\n$$\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$$ \\mathbf{v}_1 \\times \\mathbf{v}_2 = \\begin{vmatrix} \\mathbf{i} & \\mathbf{j} & \\mathbf{k} \\ \\frac{\\partial x}{\\partial u} & \\frac{\\partial y}{\\partial u} & 0 \\ \\frac{\\partial x}{\\partial v} & \\frac{\\partial y}{\\partial v} & 0 \\ \\end{vmatrix} $$\n\n\n# 图表\n\n​```chart\n,budget,income,expenses,debt\njune,5000,8000,4000,6000\njuly,3000,1000,4000,3000\naug,5000,7000,6000,3000\nsep,7000,2000,3000,1000\noct,6000,5000,4000,2000\nnov,4000,3000,5000,\n\ntype: pie\ntitle: monthly revenue\nx.title: amount\ny.title: month\ny.suffix: $\n​```\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n> 注：在typora中未支持\n\n\n# 流程图\n\n语法：\n​```mermaid\ngraph td\na[模块a] --\x3e|a1| b(模块b)\nb --\x3e c{判断条件c}\nc --\x3e|条件c1| d[模块d]\nc --\x3e|条件c2| e[模块e]\nc --\x3e|条件c3| f[模块f]\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n流程图相关文章：\n\nhttps://www.jianshu.com/p/b421cc723da5\n\nhttp://www.imooc.com/article/292708\n\n\n# 时序图\n\n​```mermaid\nsequencediagram\na->>b: 是否已收到消息？\nb--\x3e>a: 已收到消息\n​```\n\n\n1\n2\n3\n4\n5\n\n\n\n# 甘特图\n\n​```mermaid\ngantt\ntitle 甘特图\ndateformat  yyyy-mm-dd\nsection 项目a\n任务1           :a1, 2018-06-06, 30d\n任务2     :after a1  , 20d\nsection 项目b\n任务3      :2018-06-12  , 12d\n任务4      : 24d\n​```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n回到顶部",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"npm常用命令",frontmatter:{title:"npm常用命令",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/61f2f95fd7da14fd",categories:["技术","技术文档"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/03.npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html",relativePath:"03.技术/01.技术文档/03.npm常用命令.md",key:"v-31a6a882",path:"/pages/61f2f95fd7da14fd/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:14},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:5},{level:4,title:"检测是否安装及版本",slug:"检测是否安装及版本",normalizedTitle:"检测是否安装及版本",charIndex:173},{level:4,title:"生成package.json文件",slug:"生成package-json文件",normalizedTitle:"生成package.json文件",charIndex:218},{level:4,title:"安装模块",slug:"安装模块",normalizedTitle:"安装模块",charIndex:286},{level:4,title:"查看",slug:"查看",normalizedTitle:"查看",charIndex:758},{level:4,title:"更新模块",slug:"更新模块",normalizedTitle:"更新模块",charIndex:1070},{level:4,title:"卸载模块",slug:"卸载模块",normalizedTitle:"卸载模块",charIndex:1243},{level:4,title:"清空缓存",slug:"清空缓存",normalizedTitle:"清空缓存",charIndex:1352},{level:4,title:"使用淘宝镜像",slug:"使用淘宝镜像",normalizedTitle:"使用淘宝镜像",charIndex:1394},{level:4,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:278},{level:2,title:"使用技巧",slug:"使用技巧",normalizedTitle:"使用技巧",charIndex:1761},{level:4,title:"多次安装不成功尝试先清除缓存",slug:"多次安装不成功尝试先清除缓存",normalizedTitle:"多次安装不成功尝试先清除缓存",charIndex:1769},{level:4,title:"查看已安装的依赖包版本号",slug:"查看已安装的依赖包版本号",normalizedTitle:"查看已安装的依赖包版本号",charIndex:1812},{level:2,title:"npm发布包教程",slug:"npm发布包教程",normalizedTitle:"npm发布包教程",charIndex:1912},{level:2,title:"nrm的作用与使用",slug:"nrm的作用与使用",normalizedTitle:"nrm的作用与使用",charIndex:1935},{level:4,title:"nrm是什么？",slug:"nrm是什么",normalizedTitle:"nrm是什么？",charIndex:1948},{level:4,title:"nrm的安装",slug:"nrm的安装",normalizedTitle:"nrm的安装",charIndex:2030},{level:4,title:"nrm命令",slug:"nrm命令",normalizedTitle:"nrm命令",charIndex:2065},{level:4,title:"nrm使用",slug:"nrm使用",normalizedTitle:"nrm使用",charIndex:2340}],excerpt:'<h1 id="npm常用命令"><a class="header-anchor" href="#npm常用命令">#</a> npm常用命令</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：</p>\n<ul>\n<li>允许用户从npm服务器下载别人编写的第三方包到本地使用。</li>\n<li>允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。</li>\n<li>允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。</li>\n</ul>\n',headersStr:"简介 常用命令 检测是否安装及版本 生成package.json文件 安装模块 查看 更新模块 卸载模块 清空缓存 使用淘宝镜像 其他 使用技巧 多次安装不成功尝试先清除缓存 查看已安装的依赖包版本号 npm发布包教程 nrm的作用与使用 nrm是什么？ nrm的安装 nrm命令 nrm使用",content:'# npm常用命令\n\n\n# 简介\n\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n * 允许用户从npm服务器下载别人编写的第三方包到本地使用。\n * 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n\n\n# 常用命令\n\n# 检测是否安装及版本\n\nnpm -v # 显示版本号说明已经安装相应的版本\n\n\n1\n\n\n# 生成package.json文件\n\nnpm init\n\n\n1\n\n\n> package.json用来描述项目中用到的模块和其他信息\n\n# 安装模块\n\nnpm install # 安装package.json定义好的模块，简写 npm i\n\n# 安装包指定模块\nnpm i <ModuleName>\n\n# 全局安装\nnpm i <ModuleName> -g \n\n# 安装包的同时，将信息写入到package.json中的 dependencies 配置中\nnpm i <ModuleName> --save\n\n# 安装包的同时，将信息写入到package.json中的 devDependencies 配置中\nnpm i <ModuleName> --save-dev\n\n# 安装多模块\nnpm i <ModuleName1> <ModuleName2>\n\n# 安装方式参数：\n-save # 简写-S，加入到生产依赖中\n-save-dev # 简写-D，加入到开发依赖中\n-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 查看\n\n# 查看所有全局安装的包\nnpm ls -g\n\n# 查看本地项目中安装的包\nnpm ls\n\n# 查看包的 package.json文件\nnpm view <ModuleName>\n\n# 查看包的依赖关系\nnpm view <ModuleName> dependencies\n\n# 查看包的源文件地址\nnpm view <ModuleName> repository.url\n\n# 查看包所依赖的node版本\nnpm view <ModuleName> engines\n\n# 查看帮助\nnpm help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 更新模块\n\n# 更新本地模块\nnpm update <ModuleName>\n\n# 更新全局模块\nnpm update -g <ModuleName> # 更新全局软件包。\nnpm update -g # 更新所有的全局软件包。\nnpm outdated -g --depth=0 # 找出需要更新的包。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 卸载模块\n\n# 卸载本地模块\nnpm uninstall <ModuleName>\n\n# 卸载全局模块\nnpm uninstall -g <ModuleName> # 卸载全局软件包。\n\n\n1\n2\n3\n4\n5\n\n\n# 清空缓存\n\n# 清空npm缓存\nnpm cache clear\n\n\n1\n2\n\n\n# 使用淘宝镜像\n\n# 使用淘宝镜像\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n2\n\n\n# 其他\n\n# 更改包内容后进行重建\nnpm rebuild <ModuleName>\n\n# 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新\nnpm outdated\n\n# 访问npm的json文件，此命令将会打开一个网页\nnpm help json\n\n# 发布一个包的时候，需要检验某个包名是否存在\nnpm search <ModuleName>\n\n# 撤销自己发布过的某个版本代码\nnpm unpublish <package> <version>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 使用技巧\n\n# 多次安装不成功尝试先清除缓存\n\nnpm cache clean -f\n\n\n1\n\n\n# 查看已安装的依赖包版本号\n\nnpm ls <ModuleName>\n\n\n1\n\n\n> 注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^" 符号表示大于此版本\n\n\n# npm发布包教程\n\nnpm发布包教程\n\n\n# nrm的作用与使用\n\n# nrm是什么？\n\nnrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换\n\n# nrm的安装\n\nnpm install -g nrm\n\n\n1\n\n\n# nrm命令\n\nnrm ls　#查看可用的源（有*号的表示当前所使用的源,以下<registry>表示源的名称）\nnrm use <registry> # 将npm下载源切换成指定的源\nnrm add <registry> <url> # 添加源，url为源的路径\nnrm del <registry> # 删除源\nnrm test <registry> # 测试源的响应时间，可以作为使用哪个源的参考\n\nnrm help　# 查看nrm帮助\nnrm home <registry>　# 跳转到指定源的官网\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# nrm使用\n\n如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：\n\nnrm ls # 查看可用的源\nnrm use <registry>　# 切换到指定源\n\n\n1\n2\n',normalizedContent:'# npm常用命令\n\n\n# 简介\n\nnpm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：\n\n * 允许用户从npm服务器下载别人编写的第三方包到本地使用。\n * 允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。\n * 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。\n\n\n# 常用命令\n\n# 检测是否安装及版本\n\nnpm -v # 显示版本号说明已经安装相应的版本\n\n\n1\n\n\n# 生成package.json文件\n\nnpm init\n\n\n1\n\n\n> package.json用来描述项目中用到的模块和其他信息\n\n# 安装模块\n\nnpm install # 安装package.json定义好的模块，简写 npm i\n\n# 安装包指定模块\nnpm i <modulename>\n\n# 全局安装\nnpm i <modulename> -g \n\n# 安装包的同时，将信息写入到package.json中的 dependencies 配置中\nnpm i <modulename> --save\n\n# 安装包的同时，将信息写入到package.json中的 devdependencies 配置中\nnpm i <modulename> --save-dev\n\n# 安装多模块\nnpm i <modulename1> <modulename2>\n\n# 安装方式参数：\n-save # 简写-s，加入到生产依赖中\n-save-dev # 简写-d，加入到开发依赖中\n-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n# 查看\n\n# 查看所有全局安装的包\nnpm ls -g\n\n# 查看本地项目中安装的包\nnpm ls\n\n# 查看包的 package.json文件\nnpm view <modulename>\n\n# 查看包的依赖关系\nnpm view <modulename> dependencies\n\n# 查看包的源文件地址\nnpm view <modulename> repository.url\n\n# 查看包所依赖的node版本\nnpm view <modulename> engines\n\n# 查看帮助\nnpm help\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 更新模块\n\n# 更新本地模块\nnpm update <modulename>\n\n# 更新全局模块\nnpm update -g <modulename> # 更新全局软件包。\nnpm update -g # 更新所有的全局软件包。\nnpm outdated -g --depth=0 # 找出需要更新的包。\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 卸载模块\n\n# 卸载本地模块\nnpm uninstall <modulename>\n\n# 卸载全局模块\nnpm uninstall -g <modulename> # 卸载全局软件包。\n\n\n1\n2\n3\n4\n5\n\n\n# 清空缓存\n\n# 清空npm缓存\nnpm cache clear\n\n\n1\n2\n\n\n# 使用淘宝镜像\n\n# 使用淘宝镜像\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n\n1\n2\n\n\n# 其他\n\n# 更改包内容后进行重建\nnpm rebuild <modulename>\n\n# 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新\nnpm outdated\n\n# 访问npm的json文件，此命令将会打开一个网页\nnpm help json\n\n# 发布一个包的时候，需要检验某个包名是否存在\nnpm search <modulename>\n\n# 撤销自己发布过的某个版本代码\nnpm unpublish <package> <version>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 使用技巧\n\n# 多次安装不成功尝试先清除缓存\n\nnpm cache clean -f\n\n\n1\n\n\n# 查看已安装的依赖包版本号\n\nnpm ls <modulename>\n\n\n1\n\n\n> 注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^" 符号表示大于此版本\n\n\n# npm发布包教程\n\nnpm发布包教程\n\n\n# nrm的作用与使用\n\n# nrm是什么？\n\nnrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换\n\n# nrm的安装\n\nnpm install -g nrm\n\n\n1\n\n\n# nrm命令\n\nnrm ls　#查看可用的源（有*号的表示当前所使用的源,以下<registry>表示源的名称）\nnrm use <registry> # 将npm下载源切换成指定的源\nnrm add <registry> <url> # 添加源，url为源的路径\nnrm del <registry> # 删除源\nnrm test <registry> # 测试源的响应时间，可以作为使用哪个源的参考\n\nnrm help　# 查看nrm帮助\nnrm home <registry>　# 跳转到指定源的官网\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# nrm使用\n\n如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：\n\nnrm ls # 查看可用的源\nnrm use <registry>　# 切换到指定源\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"npm packageJson属性详解",frontmatter:{author:{name:"xugaoyi",link:"https://github.com/xugaoyi"},title:"npm packageJson属性详解",date:"2020-04-08T17:16:38.000Z",permalink:"/pages/dec4f3f00e71a312",categories:["技术","技术文档"],tags:[null]},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/10.npm%20packageJson%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3.html",relativePath:"03.技术/01.技术文档/10.npm packageJson属性详解.md",key:"v-44e2ea1a",path:"/pages/dec4f3f00e71a312/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:86},{level:2,title:"name",slug:"name",normalizedTitle:"name",charIndex:160},{level:2,title:"version",slug:"version",normalizedTitle:"version",charIndex:191},{level:2,title:"description",slug:"description",normalizedTitle:"description",charIndex:1036},{level:2,title:"keywords",slug:"keywords",normalizedTitle:"keywords",charIndex:1081},{level:2,title:"homepage",slug:"homepage",normalizedTitle:"homepage",charIndex:1114},{level:2,title:"bugs",slug:"bugs",normalizedTitle:"bugs",charIndex:1266},{level:2,title:"license",slug:"license",normalizedTitle:"license",charIndex:1496},{level:2,title:"和用户相关的属性: author, contributors",slug:"和用户相关的属性-author-contributors",normalizedTitle:"和用户相关的属性: author, contributors",charIndex:1666},{level:2,title:"files",slug:"files",normalizedTitle:"files",charIndex:2037},{level:2,title:"main",slug:"main",normalizedTitle:"main",charIndex:2013},{level:2,title:"bin",slug:"bin",normalizedTitle:"bin",charIndex:2444},{level:2,title:"man",slug:"man",normalizedTitle:"man",charIndex:3180},{level:2,title:"directories",slug:"directories",normalizedTitle:"directories",charIndex:4055},{level:3,title:"directories.lib",slug:"directories-lib",normalizedTitle:"directories.lib",charIndex:4211},{level:3,title:"directories.bin",slug:"directories-bin",normalizedTitle:"directories.bin",charIndex:4282},{level:3,title:"directories.man",slug:"directories-man",normalizedTitle:"directories.man",charIndex:4383},{level:3,title:"directories.doc",slug:"directories-doc",normalizedTitle:"directories.doc",charIndex:4440},{level:3,title:"directories.example",slug:"directories-example",normalizedTitle:"directories.example",charIndex:4514},{level:2,title:"repository",slug:"repository",normalizedTitle:"repository",charIndex:4561},{level:2,title:"scripts",slug:"scripts",normalizedTitle:"scripts",charIndex:5066},{level:2,title:"config",slug:"config",normalizedTitle:"config",charIndex:146},{level:2,title:"dependencies",slug:"dependencies",normalizedTitle:"dependencies",charIndex:1017},{level:2,title:"URLs as Dependencies",slug:"urls-as-dependencies",normalizedTitle:"urls as dependencies",charIndex:6629},{level:2,title:"Git URLs as Dependencies",slug:"git-urls-as-dependencies",normalizedTitle:"git urls as dependencies",charIndex:6706},{level:2,title:"GitHub URLs",slug:"github-urls",normalizedTitle:"github urls",charIndex:7059},{level:2,title:"Local Paths",slug:"local-paths",normalizedTitle:"local paths",charIndex:7300},{level:2,title:"devDependencies",slug:"devdependencies",normalizedTitle:"devdependencies",charIndex:7631},{level:2,title:"peerDependencies",slug:"peerdependencies",normalizedTitle:"peerdependencies",charIndex:8354},{level:2,title:"bundledDependencies",slug:"bundleddependencies",normalizedTitle:"bundleddependencies",charIndex:8793},{level:2,title:"optionalDependencies",slug:"optionaldependencies",normalizedTitle:"optionaldependencies",charIndex:8870},{level:2,title:"engines",slug:"engines",normalizedTitle:"engines",charIndex:594},{level:2,title:"engineStrict",slug:"enginestrict",normalizedTitle:"enginestrict",charIndex:9646},{level:2,title:"os",slug:"os",normalizedTitle:"os",charIndex:1394},{level:2,title:"cpu",slug:"cpu",normalizedTitle:"cpu",charIndex:9846},{level:2,title:"preferGlobal",slug:"preferglobal",normalizedTitle:"preferglobal",charIndex:9962},{level:2,title:"private",slug:"private",normalizedTitle:"private",charIndex:10079},{level:2,title:"publishConfig",slug:"publishconfig",normalizedTitle:"publishconfig",charIndex:10172},{level:2,title:"DEFAULT VALUES",slug:"default-values",normalizedTitle:"default values",charIndex:10286},{level:2,title:"参考文档列表(https://docs.npmjs.com/)",slug:"参考文档列表-https-docs-npmjs-com",normalizedTitle:"参考文档列表(https://docs.npmjs.com/)",charIndex:10599}],excerpt:'<h1 id="npm-package-json属性详解"><a class="header-anchor" href="#npm-package-json属性详解">#</a> npm package.json属性详解</h1>\n<blockquote>\n<p>本文转自<a href="https://www.cnblogs.com/tzyy/p/5193811.html" target="_blank" rel="noopener noreferrer">https://www.cnblogs.com/tzyy/p/5193811.html<OutboundLink/></a>，作者：TZYY</p>\n</blockquote>\n<h2 id="概述"><a class="header-anchor" href="#概述">#</a> 概述</h2>\n<p><code>package.json</code>必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过<code>npm-config</code>来生成</p>\n',headersStr:"概述 name version description keywords homepage bugs license 和用户相关的属性: author, contributors files main bin man directories directories.lib directories.bin directories.man directories.doc directories.example repository scripts config dependencies URLs as Dependencies Git URLs as Dependencies GitHub URLs Local Paths devDependencies peerDependencies bundledDependencies optionalDependencies engines engineStrict os cpu preferGlobal private publishConfig DEFAULT VALUES 参考文档列表(https://docs.npmjs.com/)",content:'# npm package.json属性详解\n\n> 本文转自https://www.cnblogs.com/tzyy/p/5193811.html，作者：TZYY\n\n\n# 概述\n\npackage.json必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过npm-config来生成\n\n\n# name\n\npackage.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。 name属性就是你的模块名称，下面是一些命名规则:\n\n * name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\n\n * name不能以"_"或"."开头\n\n * 不能含有大写字母\n\n * name会成为url的一部分，不能含有url非法字符\n   \n   下面是官网文档的一些建议：\n\n * 不要使用和node核心模块一样的名称\n\n * name中不要含有"js"和"node"。 It\'s assumed that it\'s js, since you\'re writing a package.json file, and you can specify the engine using the "engines" field. (See below.)\n\n * name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以"_"或"."开头\n\n * name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。\n\n * 创建一个模块前可以先到后边的网址查查name是否已经被占用. https://www.npmjs.com/\n   \n   * # 发布一个包的时候，需要检验某个包名是否存在\n     npm search <ModuleName>\n     \n     \n     1\n     2\n     \n\nname属性可以有一些前缀如 e.g. @myorg/mypackage.在npm-scope(7)的文档中可以看到详细说明\n\n\n# version\n\nversion必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块\n\n\n# description\n\n一个描述，方便别人了解你的模块作用，搜索的时候也有用。\n\n\n# keywords\n\n一个字符串数组，方便别人搜索到本模块\n\n\n# homepage\n\n项目主页url 注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 （原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）\n\n\n# bugs\n\n填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：\n\n{\n    "url" : "https://github.com/owner/project/issues",\n    "email" : "project@hostname.com"\n}\n\n\n1\n2\n3\n4\n\n\nurl和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。\n\n\n# license\n\n你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用BSD-3-Clause 或 MIT之类的协议，如下：\n\n{ "license" : "MIT" }\n\n\n1\n\n\n你可以在https://spdx.org/licenses/ 这个地址查阅协议列表 。\n\n\n# 和用户相关的属性: author, contributors\n\nauthor是一个码农， contributors是一个码农数组。 person是一个有一些描述属性的对象，如下 like this:\n\n{\n    "name" : "Barney Rubble",\n    "email" : "b@rubble.com",\n    "url" : "http://barnyrubble.tumblr.com/"\n}\n\n\n1\n2\n3\n4\n5\n\n\n也可以按如下格式缩写，npm会帮着转换:\n\n"Barney Rubble b@rubble.com (http://barnyrubble.tumblr.com/)"\n\n\n1\n\n\nemail和url属性实际上都是可以省略的。描述用户信息的还有一个maintainers（维护者）属性。\n\n\n# files\n\nfiles属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了） 你也可以在模块根目录下创建一个.npmignore文件（windows下无法直接创建以"."开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法".gitignore"类似。\n\n\n# main\n\nmain属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require("foo")来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。 它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。\n\n\n# bin\n\n很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的） 如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n{\n    "bin" : { "myapp" : "./cli.js" }\n}\n\n\n1\n2\n3\n\n\n模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\\Users\\username\\AppData\\Roaming\\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。 因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。 如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n\n{ \n    "name": "my-program",\n    "version": "1.2.5", \n    "bin": "./path/to/program"\n}\n\n\n1\n2\n3\n4\n5\n\n\n作用和如下写法相同:\n\n{ \n    "name": "my-program", \n    "version": "1.2.5", \n    "bin" : { \n        "my-program" : "./path/to/program" \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# man\n\n制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。 如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:\n\n{\n    "name" : "foo",\n    "version" : "1.2.3", \n    "description" : "A packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : "./man/doc.1"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过man foo命令会得到 ./man/doc.1 文件的内容。 如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3", \n    "description" : "A packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/bar.1" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建一些文件来作为man foo和man foo-bar命令的结果。 man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3",\n    "description" : "A packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/foo.2" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n\n# directories\n\nCommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。 目前这个配置没有任何作用，将来可能会整出一些花样来。\n\n\n# directories.lib\n\n告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\n\n# directories.bin\n\n如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。\n\n\n# directories.man\n\n指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。\n\n\n# directories.doc\n\n在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）\n\n\n# directories.example\n\n放一些示例脚本，或许某一天会有用 - -！\n\n\n# repository\n\n指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：\n\n"repository" :\n  {\n      "type" : "git",\n      "url" : "https://github.com/npm/npm.git"\n  }\n\n"repository" :\n  { \n      "type" : "svn", \n      "url" : "https://v8.googlecode.com/svn/trunk/"\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n若你的模块放在GitHub, GitHub gist, Bitbucket, or GitLab的仓库里，npm install的时候可以使用缩写标记来完成：\n\n"repository": "npm/npm"\n\n"repository": "gist:11081aaa281"\n\n"repository": "bitbucket:example/repo"\n\n"repository": "gitlab:another/repo"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# scripts\n\nscripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。 具体的内容有 install start stop 等，详见 https://docs.npmjs.com/misc/scripts\n\n\n# config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。 用户用的时候可以使用如下用法：\n\nhttp.createServer(...).listen(process.env.npm_package_config_port)\n\n\n1\n\n\n可以通过npm config set foo:port 80来修改config。详见https://docs.npmjs.com/misc/config\n\n{ \n    "name" : "foo", \n    "config" : { "port" : "8080" }\n}\n\n\n1\n2\n3\n4\n\n\n\n# dependencies\n\ndependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。 dependencies也可以被指定为一个git地址或者一个压缩包地址。 不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见https://docs.npmjs.com/misc/semver\n\n * version 精确匹配版本\n * >version 必须大于某个版本\n * >=version 大于等于\n * <version 小于\n * <=versionversion 小于\n * ~version "约等于"，具体规则详见semver文档\n * ^version "兼容版本"具体规则详见semver文档\n * 1.2.x 仅一点二点几的版本\n * http://... 见下面url作为denpendencies的说明\n * * 任何版本\n * "" 空字符，和*相同\n * version1 - version2 相当于 >=version1 <=version2.\n * range1 || range2 范围1和范围2满足任意一个都行\n * git... 见下面git url作为denpendencies的说明\n * user/repo See 见下面GitHub仓库的说明\n * tag 发布的一个特殊的标签，见npm-tag的文档 https://docs.npmjs.com/getting-started/using-tags\n * path/path/path 见下面本地模块的说明 下面的写法都是可以的:\n\n{ "dependencies" :\n  { "foo" : "1.0.0 - 2.9999.9999"\n  , "bar" : ">=1.0.2 <2.1.2"\n  , "baz" : ">1.0.2 <=2.3.4"\n  , "boo" : "2.0.1"\n  , "qux" : "<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0"\n  , "asd" : "http://asdf.com/asdf.tar.gz"\n  , "til" : "~1.2"\n  , "elf" : "~1.2.3"\n  , "two" : "2.x"\n  , "thr" : "3.3.x"\n  , "lat" : "latest"\n  , "dyl" : "file:../dyl"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# URLs as Dependencies\n\n在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。\n\n\n# Git URLs as Dependencies\n\nGit url可以像下面一样:\n\ngit://github.com/user/project.git#commit-ish\ngit+ssh://user@hostname:project.git#commit-ish\ngit+ssh://user@hostname/project.git#commit-ish\ngit+http://user@hostname/project/blah.git#commit-ish\ngit+https://user@hostname/project/blah.git#commit-ish\n\n\n1\n2\n3\n4\n5\n\n\ncommit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。\n\n\n# GitHub URLs\n\n支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签：\n\n{\n  "name": "foo",\n  "version": "0.0.0",\n  "dependencies": {\n    "express": "visionmedia/express",\n    "mocha": "visionmedia/mocha#4727d357ea"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# Local Paths\n\nnpm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx --save 来安装，格式如下：\n\n../foo/bar\n~/foo/bar\n./foo/bar\n/foo/bar\n\n\n1\n2\n3\n4\n\n\npackage.json 生成的相对路径如下:\n\n{\n  "name": "baz",\n  "dependencies": {\n    "bar": "file:../foo/bar"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。\n\n\n# devDependencies\n\n如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。 在这种情况下，最好的方法是把这些依赖添加到devDependencies属性的对象中。 这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。 对于一些跨平台的构建任务，例如把CoffeeScript编译成JavaScript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devDependencies属性种。 例如:\n\n{ "name": "ethopia-waza",\n  "description": "a delightfully fruity coffee varietal",\n  "version": "1.2.3",\n  "devDependencies": {\n    "coffee-script": "~1.6.3"\n  },\n  "scripts": {\n    "prepublish": "coffee -o lib/ -c src/waza.coffee"\n  },\n  "main": "lib/waza.js"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nprepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。\n\n\n# peerDependencies\n\n有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require("grunt")这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerDependencies：\n\n{\n  "name": "tea-latte",\n  "version": "1.3.5",\n  "peerDependencies": {\n    "tea": "2.x"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的： ├── tea-latte@1.3.5 └── tea@2.2.0 这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。\n\n\n# bundledDependencies\n\n上面的单词少个d，写成bundleDependencies也可以。 指定发布的时候会被一起打包的模块。\n\n\n# optionalDependencies\n\n如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionalDependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。 当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：\n\ntry {\n  var foo = require(\'foo\')\n  var fooVersion = require(\'foo/package.json\').version\n} catch (er) {\n  foo = null\n}\nif ( notGoodFooVersion(fooVersion) ) {\n  foo = null\n}\n\n// .. then later in your program ..\n\nif (foo) {\n  foo.doFooThings()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\noptionalDependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。\n\n\n# engines\n\n你可以指定项目运行的node版本范围，如下： { "engines" : { "node" : ">=0.10.3 <0.12" } } 和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。 也可以指定一些npm版本可以正确的安装你的模块，例如： { "engines" : { "npm" : "~1.0.20" } } 要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。\n\n\n# engineStrict\n\n注意：这个属性已经弃用，将在npm 3.0.0 版本干掉。\n\n\n# os\n\n可以指定你的模块只能在哪个操作系统上跑： "os" : [ "darwin", "linux" ] 也可以指定黑名单而不是白名单： "os" : [ "!win32" ] 服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞...\n\n\n# cpu\n\n限制模块只能在某某cpu架构下运行 "cpu" : [ "x64", "ia32" ] 同样可以设置黑名单: "cpu" : [ "!arm", "!mips" ] cpu架构通过 process.arch 判断\n\n\n# preferGlobal\n\n如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。\n\n\n# private\n\n如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishConfig中配置仓库参数。\n\n\n# publishConfig\n\n这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。\n\n\n# DEFAULT VALUES\n\nnpm设置了一些默认参数，如： "scripts": {"start": "node server.js"} 如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。 "scripts":{"preinstall": "node-gyp rebuild"} 如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本 "contributors": [...] 若模块根目录下有AUTHORS 文件，则npm会按Name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释\n\n\n# 参考文档列表(https://docs.npmjs.com/)\n\nsemver(7) npm-init(1) npm-version(1) npm-config(1) npm-config(7) npm-help(1) npm-faq(7) npm-install(1) npm-publish(1) npm-rm(1)',normalizedContent:'# npm package.json属性详解\n\n> 本文转自https://www.cnblogs.com/tzyy/p/5193811.html，作者：tzyy\n\n\n# 概述\n\npackage.json必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过npm-config来生成\n\n\n# name\n\npackage.json中最重要的属性是name和version两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。 name属性就是你的模块名称，下面是一些命名规则:\n\n * name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。\n\n * name不能以"_"或"."开头\n\n * 不能含有大写字母\n\n * name会成为url的一部分，不能含有url非法字符\n   \n   下面是官网文档的一些建议：\n\n * 不要使用和node核心模块一样的名称\n\n * name中不要含有"js"和"node"。 it\'s assumed that it\'s js, since you\'re writing a package.json file, and you can specify the engine using the "engines" field. (see below.)\n\n * name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以"_"或"."开头\n\n * name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。\n\n * 创建一个模块前可以先到后边的网址查查name是否已经被占用. https://www.npmjs.com/\n   \n   * # 发布一个包的时候，需要检验某个包名是否存在\n     npm search <modulename>\n     \n     \n     1\n     2\n     \n\nname属性可以有一些前缀如 e.g. @myorg/mypackage.在npm-scope(7)的文档中可以看到详细说明\n\n\n# version\n\nversion必须可以被npm依赖的一个node-semver模块解析。具体规则见下面的dependencies模块\n\n\n# description\n\n一个描述，方便别人了解你的模块作用，搜索的时候也有用。\n\n\n# keywords\n\n一个字符串数组，方便别人搜索到本模块\n\n\n# homepage\n\n项目主页url 注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。 （原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）\n\n\n# bugs\n\n填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：\n\n{\n    "url" : "https://github.com/owner/project/issues",\n    "email" : "project@hostname.com"\n}\n\n\n1\n2\n3\n4\n\n\nurl和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。\n\n\n# license\n\n你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用bsd-3-clause 或 mit之类的协议，如下：\n\n{ "license" : "mit" }\n\n\n1\n\n\n你可以在https://spdx.org/licenses/ 这个地址查阅协议列表 。\n\n\n# 和用户相关的属性: author, contributors\n\nauthor是一个码农， contributors是一个码农数组。 person是一个有一些描述属性的对象，如下 like this:\n\n{\n    "name" : "barney rubble",\n    "email" : "b@rubble.com",\n    "url" : "http://barnyrubble.tumblr.com/"\n}\n\n\n1\n2\n3\n4\n5\n\n\n也可以按如下格式缩写，npm会帮着转换:\n\n"barney rubble b@rubble.com (http://barnyrubble.tumblr.com/)"\n\n\n1\n\n\nemail和url属性实际上都是可以省略的。描述用户信息的还有一个maintainers（维护者）属性。\n\n\n# files\n\nfiles属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了） 你也可以在模块根目录下创建一个.npmignore文件（windows下无法直接创建以"."开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法".gitignore"类似。\n\n\n# main\n\nmain属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require("foo")来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。 它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。\n\n\n# bin\n\n很多模块有一个或多个需要配置到path路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的） 如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：\n\n{\n    "bin" : { "myapp" : "./cli.js" }\n}\n\n\n1\n2\n3\n\n\n模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在c:\\users\\username\\appdata\\roaming\\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。 因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。 如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：\n\n{ \n    "name": "my-program",\n    "version": "1.2.5", \n    "bin": "./path/to/program"\n}\n\n\n1\n2\n3\n4\n5\n\n\n作用和如下写法相同:\n\n{ \n    "name": "my-program", \n    "version": "1.2.5", \n    "bin" : { \n        "my-program" : "./path/to/program" \n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# man\n\n制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。 如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:\n\n{\n    "name" : "foo",\n    "version" : "1.2.3", \n    "description" : "a packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : "./man/doc.1"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n通过man foo命令会得到 ./man/doc.1 文件的内容。 如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3", \n    "description" : "a packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/bar.1" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建一些文件来作为man foo和man foo-bar命令的结果。 man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。\n\n{ \n    "name" : "foo", \n    "version" : "1.2.3",\n    "description" : "a packaged foo fooer for fooing foos", \n    "main" : "foo.js", \n    "man" : [ "./man/foo.1", "./man/foo.2" ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n会创建 man foo 和 man 2 foo 两条命令。\n\n\n# directories\n\ncommonjs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件https://registry.npmjs.org/npm/latest ，可以发现里边有这个字段的内容。 目前这个配置没有任何作用，将来可能会整出一些花样来。\n\n\n# directories.lib\n\n告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。\n\n\n# directories.bin\n\n如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。\n\n\n# directories.man\n\n指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。\n\n\n# directories.doc\n\n在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）\n\n\n# directories.example\n\n放一些示例脚本，或许某一天会有用 - -！\n\n\n# repository\n\n指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：\n\n"repository" :\n  {\n      "type" : "git",\n      "url" : "https://github.com/npm/npm.git"\n  }\n\n"repository" :\n  { \n      "type" : "svn", \n      "url" : "https://v8.googlecode.com/svn/trunk/"\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n若你的模块放在github, github gist, bitbucket, or gitlab的仓库里，npm install的时候可以使用缩写标记来完成：\n\n"repository": "npm/npm"\n\n"repository": "gist:11081aaa281"\n\n"repository": "bitbucket:example/repo"\n\n"repository": "gitlab:another/repo"\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# scripts\n\nscripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。 具体的内容有 install start stop 等，详见 https://docs.npmjs.com/misc/scripts\n\n\n# config\n\n用来设置一些项目不怎么变化的项目配置，例如port等。 用户用的时候可以使用如下用法：\n\nhttp.createserver(...).listen(process.env.npm_package_config_port)\n\n\n1\n\n\n可以通过npm config set foo:port 80来修改config。详见https://docs.npmjs.com/misc/config\n\n{ \n    "name" : "foo", \n    "config" : { "port" : "8080" }\n}\n\n\n1\n2\n3\n4\n\n\n\n# dependencies\n\ndependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。 dependencies也可以被指定为一个git地址或者一个压缩包地址。 不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见https://docs.npmjs.com/misc/semver\n\n * version 精确匹配版本\n * >version 必须大于某个版本\n * >=version 大于等于\n * <version 小于\n * <=versionversion 小于\n * ~version "约等于"，具体规则详见semver文档\n * ^version "兼容版本"具体规则详见semver文档\n * 1.2.x 仅一点二点几的版本\n * http://... 见下面url作为denpendencies的说明\n * * 任何版本\n * "" 空字符，和*相同\n * version1 - version2 相当于 >=version1 <=version2.\n * range1 || range2 范围1和范围2满足任意一个都行\n * git... 见下面git url作为denpendencies的说明\n * user/repo see 见下面github仓库的说明\n * tag 发布的一个特殊的标签，见npm-tag的文档 https://docs.npmjs.com/getting-started/using-tags\n * path/path/path 见下面本地模块的说明 下面的写法都是可以的:\n\n{ "dependencies" :\n  { "foo" : "1.0.0 - 2.9999.9999"\n  , "bar" : ">=1.0.2 <2.1.2"\n  , "baz" : ">1.0.2 <=2.3.4"\n  , "boo" : "2.0.1"\n  , "qux" : "<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0"\n  , "asd" : "http://asdf.com/asdf.tar.gz"\n  , "til" : "~1.2"\n  , "elf" : "~1.2.3"\n  , "two" : "2.x"\n  , "thr" : "3.3.x"\n  , "lat" : "latest"\n  , "dyl" : "file:../dyl"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# urls as dependencies\n\n在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。\n\n\n# git urls as dependencies\n\ngit url可以像下面一样:\n\ngit://github.com/user/project.git#commit-ish\ngit+ssh://user@hostname:project.git#commit-ish\ngit+ssh://user@hostname/project.git#commit-ish\ngit+http://user@hostname/project/blah.git#commit-ish\ngit+https://user@hostname/project/blah.git#commit-ish\n\n\n1\n2\n3\n4\n5\n\n\ncommit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。\n\n\n# github urls\n\n支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签：\n\n{\n  "name": "foo",\n  "version": "0.0.0",\n  "dependencies": {\n    "express": "visionmedia/express",\n    "mocha": "visionmedia/mocha#4727d357ea"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# local paths\n\nnpm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx --save 来安装，格式如下：\n\n../foo/bar\n~/foo/bar\n./foo/bar\n/foo/bar\n\n\n1\n2\n3\n4\n\n\npackage.json 生成的相对路径如下:\n\n{\n  "name": "baz",\n  "dependencies": {\n    "bar": "file:../foo/bar"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。\n\n\n# devdependencies\n\n如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。 在这种情况下，最好的方法是把这些依赖添加到devdependencies属性的对象中。 这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。 对于一些跨平台的构建任务，例如把coffeescript编译成javascript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devdependencies属性种。 例如:\n\n{ "name": "ethopia-waza",\n  "description": "a delightfully fruity coffee varietal",\n  "version": "1.2.3",\n  "devdependencies": {\n    "coffee-script": "~1.6.3"\n  },\n  "scripts": {\n    "prepublish": "coffee -o lib/ -c src/waza.coffee"\n  },\n  "main": "lib/waza.js"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nprepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。\n\n\n# peerdependencies\n\n有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require("grunt")这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerdependencies：\n\n{\n  "name": "tea-latte",\n  "version": "1.3.5",\n  "peerdependencies": {\n    "tea": "2.x"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的： ├── tea-latte@1.3.5 └── tea@2.2.0 这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。\n\n\n# bundleddependencies\n\n上面的单词少个d，写成bundledependencies也可以。 指定发布的时候会被一起打包的模块。\n\n\n# optionaldependencies\n\n如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionaldependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。 当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：\n\ntry {\n  var foo = require(\'foo\')\n  var fooversion = require(\'foo/package.json\').version\n} catch (er) {\n  foo = null\n}\nif ( notgoodfooversion(fooversion) ) {\n  foo = null\n}\n\n// .. then later in your program ..\n\nif (foo) {\n  foo.dofoothings()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\noptionaldependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。\n\n\n# engines\n\n你可以指定项目运行的node版本范围，如下： { "engines" : { "node" : ">=0.10.3 <0.12" } } 和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。 也可以指定一些npm版本可以正确的安装你的模块，例如： { "engines" : { "npm" : "~1.0.20" } } 要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。\n\n\n# enginestrict\n\n注意：这个属性已经弃用，将在npm 3.0.0 版本干掉。\n\n\n# os\n\n可以指定你的模块只能在哪个操作系统上跑： "os" : [ "darwin", "linux" ] 也可以指定黑名单而不是白名单： "os" : [ "!win32" ] 服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞...\n\n\n# cpu\n\n限制模块只能在某某cpu架构下运行 "cpu" : [ "x64", "ia32" ] 同样可以设置黑名单: "cpu" : [ "!arm", "!mips" ] cpu架构通过 process.arch 判断\n\n\n# preferglobal\n\n如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。\n\n\n# private\n\n如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishconfig中配置仓库参数。\n\n\n# publishconfig\n\n这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。\n\n\n# default values\n\nnpm设置了一些默认参数，如： "scripts": {"start": "node server.js"} 如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。 "scripts":{"preinstall": "node-gyp rebuild"} 如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本 "contributors": [...] 若模块根目录下有authors 文件，则npm会按name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释\n\n\n# 参考文档列表(https://docs.npmjs.com/)\n\nsemver(7) npm-init(1) npm-version(1) npm-config(1) npm-config(7) npm-help(1) npm-faq(7) npm-install(1) npm-publish(1) npm-rm(1)',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"yaml语言教程",frontmatter:{title:"yaml语言教程",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/4e8444e2d534d14f",categories:["技术","技术文档"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/01.%E6%8A%80%E6%9C%AF%E6%96%87%E6%A1%A3/15.yaml%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B.html",relativePath:"03.技术/01.技术文档/15.yaml语言教程.md",key:"v-28146ea1",path:"/pages/4e8444e2d534d14f/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:15},{level:2,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:326},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:422},{level:2,title:"YAML 对象",slug:"yaml-对象",normalizedTitle:"yaml 对象",charIndex:576},{level:2,title:"YAML 数组",slug:"yaml-数组",normalizedTitle:"yaml 数组",charIndex:1086},{level:2,title:"复合结构（对象和数组组合）",slug:"复合结构-对象和数组组合",normalizedTitle:"复合结构（对象和数组组合）",charIndex:1594},{level:2,title:"纯量",slug:"纯量",normalizedTitle:"纯量",charIndex:549},{level:2,title:"转换数据格式",slug:"转换数据格式",normalizedTitle:"转换数据格式",charIndex:3050},{level:2,title:"锚点引用",slug:"锚点引用",normalizedTitle:"锚点引用",charIndex:3157}],excerpt:'<h1 id="yaml语言教程"><a class="header-anchor" href="#yaml语言教程">#</a> yaml语言教程</h1>\n<h2 id="简介"><a class="header-anchor" href="#简介">#</a> 简介</h2>\n<p>YAML 是 &quot;YAML Ain\'t a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。</p>\n',headersStr:"简介 基本语法 数据类型 YAML 对象 YAML 数组 复合结构（对象和数组组合） 纯量 转换数据格式 锚点引用",content:"# yaml语言教程\n\n\n# 简介\n\nYAML 是 \"YAML Ain't a Markup Language\"（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：\"Yet Another Markup Language\"（仍是一种标记语言）。\n\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。\n\nYAML 的配置文件后缀为 .yml，如：runoob.yml 。\n\n> yaml常用来用作配置文件，和json类似\n\n\n# 基本语法\n\n * 大小写敏感\n\n * 使用缩进表示层级关系\n\n * 缩进不允许使用tab，只允许空格\n\n * 缩进的空格数不重要，只要相同层级的元素左对齐即可\n\n * '#'表示注释\n\n\n# 数据类型\n\nYAML 支持以下几种数据类型：\n\n * 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n * 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n * 纯量（scalars）：单个的、不可再分的值\n\n\n# YAML 对象\n\n对象的几种表示形式：\n\n1、对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\nkey: value\n\n\n1\n\n\n2、也可以使用 key:{key1: value1, key2: value2, ...}。\n\nkey:{child-key1:value1,child-key2:value2}\n\n\n1\n\n\n3、还可以使用缩进表示层级关系；\n\nkey: \n    child-key1: value1\n    child-key2: value2\n\n\n1\n2\n3\n\n\n同2，只是表示形式不同。\n\n4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：\n\n?  \n    - complexkey1\n    - complexkey2\n:\n    - complexvalue1\n    - complexvalue2\n\n\n1\n2\n3\n4\n5\n6\n\n\n意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]\n\n\n# YAML 数组\n\n以 - 开头的行表示构成一个数组：\n\n- A\n- B\n- C\n\n\n1\n2\n3\n\n\nYAML 支持多维数组，可以使用行内表示：\n\nkey: [value1, value2, ...]\n\n\n1\n\n\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n\n-\n - A\n - B\n - C\n\n\n1\n2\n3\n4\n\n\n一个相对复杂的例子：\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200W\n    -\n        id: 2\n        name: company2\n        price: 500W\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n数组也可以使用流式(flow)的方式表示：\n\ncompanies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]\n\n\n1\n\n\n\n# 复合结构（对象和数组组合）\n\n数组和对象可以构成复合结构，例：\n\nlanguages:\n  - Ruby\n  - Perl\n  - Python \nwebsites:\n  YAML: yaml.org \n  Ruby: ruby-lang.org \n  Python: python.org \n  Perl: use.perl.org\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换为 js 为：\n\n{ \n  languages: [ 'Ruby', 'Perl', 'Python'],\n  websites: {\n    YAML: 'yaml.org',\n    Ruby: 'ruby-lang.org',\n    Python: 'python.org',\n    Perl: 'use.perl.org' \n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 纯量\n\n纯量是最基本的，不可再分的值，包括：\n\n * 字符串\n * 布尔值\n * 整数\n * 浮点数\n * Null\n * 时间\n * 日期\n\n使用一个例子来快速了解纯量的基本使用：\n\nboolean: # 布尔值\n    - TRUE  #true,True都可以\n    - FALSE  #false，False都可以\nfloat: # 浮点数\n    - 3.14\n    - 6.8523015e+5  #可以使用科学计数法\nint: # 整数\n    - 123\n    - 0b1010_0111_0100_1010_1110    #二进制表示\nnull: # Null\n    nodeName: 'node'\n    parent: ~  #使用~表示null\nstring: # 字符串\n    - 哈哈 # 字符串默认不使用引号表示\n    - 'Hello world'  #可以使用双引号或者单引号包裹特殊字符\n    - newline\n      newline2    #字符串可以拆成多行，每一行会被转化成一个空格\ndate:\n    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd\ndatetime: \n    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n多行字符串可以使用|保留换行符，也可以使用>折叠换行。\n\nthis: |\n  Foo\n  Bar\nthat: >\n  Foo\n  Bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n转为js代码如下。\n\n{ this: 'Foo\\nBar\\n', that: 'Foo Bar\\n' }\n\n\n1\n\n\n+表示保留文字块末尾的换行，-表示删除字符串末尾的换行。\n\ns1: |\n  Foo\n \ns2: |+\n  Foo\n \n \ns3: |-\n  Foo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转为json代码如下\n\n{ s1: 'Foo\\n', s2: 'Foo\\n\\n\\n', s3: 'Foo' }\n\n\n1\n\n\n字符串之中可以插入 HTML 标记。\n\nmessage: |\n  <p style=\"color: red\">\n    段落\n  </p>\n\n\n1\n2\n3\n4\n\n\n\n# 转换数据格式\n\n允许使用两个感叹号，强制转换数据类型。\n\ne: !!str 123\nf: !!str true\n\n\n1\n2\n\n\n转换js结果同：\n\n{ e: '123', f: 'true' }\n\n\n1\n\n\n\n# 锚点引用\n\n& 锚点和< span class=\"marked\">* 别名，可以用来引用:\n\ndefaults: &defaults # 添加锚点\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults # <<表示合并，*引用锚点\n\ntest:\n  database: myapp_test\n  <<: *defaults # <<表示合并，*引用锚点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n相当于:\n\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n\ntest:\n  database: myapp_test\n  adapter:  postgres\n  host:     localhost\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n& 用来建立锚点（defaults），<< 表示合并到当前数据，***** 用来引用锚点。\n\n下面是另一个例子:\n\n- &showell Steve \n- Clark \n- Brian \n- Oren \n- *showell \n\n\n1\n2\n3\n4\n5\n\n\n转为js代码如下:\n\n[ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ]\n\n\n1\n\n\n> 参考：\n> \n>  * yaml官网：https://yaml.org/\n>  * yaml与js的转换demo：http://nodeca.github.io/js-yaml/\n>  * 菜鸟教程：https://www.ruanyifeng.com/blog/2016/07/yaml.html",normalizedContent:"# yaml语言教程\n\n\n# 简介\n\nyaml 是 \"yaml ain't a markup language\"（yaml 不是一种标记语言）的递归缩写。在开发的这种语言时，yaml 的意思其实是：\"yet another markup language\"（仍是一种标记语言）。\n\nyaml 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和yaml非常接近）。\n\nyaml 的配置文件后缀为 .yml，如：runoob.yml 。\n\n> yaml常用来用作配置文件，和json类似\n\n\n# 基本语法\n\n * 大小写敏感\n\n * 使用缩进表示层级关系\n\n * 缩进不允许使用tab，只允许空格\n\n * 缩进的空格数不重要，只要相同层级的元素左对齐即可\n\n * '#'表示注释\n\n\n# 数据类型\n\nyaml 支持以下几种数据类型：\n\n * 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）\n * 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）\n * 纯量（scalars）：单个的、不可再分的值\n\n\n# yaml 对象\n\n对象的几种表示形式：\n\n1、对象键值对使用冒号结构表示 key: value，冒号后面要加一个空格。\n\nkey: value\n\n\n1\n\n\n2、也可以使用 key:{key1: value1, key2: value2, ...}。\n\nkey:{child-key1:value1,child-key2:value2}\n\n\n1\n\n\n3、还可以使用缩进表示层级关系；\n\nkey: \n    child-key1: value1\n    child-key2: value2\n\n\n1\n2\n3\n\n\n同2，只是表示形式不同。\n\n4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：\n\n?  \n    - complexkey1\n    - complexkey2\n:\n    - complexvalue1\n    - complexvalue2\n\n\n1\n2\n3\n4\n5\n6\n\n\n意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]\n\n\n# yaml 数组\n\n以 - 开头的行表示构成一个数组：\n\n- a\n- b\n- c\n\n\n1\n2\n3\n\n\nyaml 支持多维数组，可以使用行内表示：\n\nkey: [value1, value2, ...]\n\n\n1\n\n\n数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。\n\n-\n - a\n - b\n - c\n\n\n1\n2\n3\n4\n\n\n一个相对复杂的例子：\n\ncompanies:\n    -\n        id: 1\n        name: company1\n        price: 200w\n    -\n        id: 2\n        name: company2\n        price: 500w\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。\n\n数组也可以使用流式(flow)的方式表示：\n\ncompanies: [{id: 1,name: company1,price: 200w},{id: 2,name: company2,price: 500w}]\n\n\n1\n\n\n\n# 复合结构（对象和数组组合）\n\n数组和对象可以构成复合结构，例：\n\nlanguages:\n  - ruby\n  - perl\n  - python \nwebsites:\n  yaml: yaml.org \n  ruby: ruby-lang.org \n  python: python.org \n  perl: use.perl.org\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转换为 js 为：\n\n{ \n  languages: [ 'ruby', 'perl', 'python'],\n  websites: {\n    yaml: 'yaml.org',\n    ruby: 'ruby-lang.org',\n    python: 'python.org',\n    perl: 'use.perl.org' \n  } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 纯量\n\n纯量是最基本的，不可再分的值，包括：\n\n * 字符串\n * 布尔值\n * 整数\n * 浮点数\n * null\n * 时间\n * 日期\n\n使用一个例子来快速了解纯量的基本使用：\n\nboolean: # 布尔值\n    - true  #true,true都可以\n    - false  #false，false都可以\nfloat: # 浮点数\n    - 3.14\n    - 6.8523015e+5  #可以使用科学计数法\nint: # 整数\n    - 123\n    - 0b1010_0111_0100_1010_1110    #二进制表示\nnull: # null\n    nodename: 'node'\n    parent: ~  #使用~表示null\nstring: # 字符串\n    - 哈哈 # 字符串默认不使用引号表示\n    - 'hello world'  #可以使用双引号或者单引号包裹特殊字符\n    - newline\n      newline2    #字符串可以拆成多行，每一行会被转化成一个空格\ndate:\n    - 2018-02-17    #日期必须使用iso 8601格式，即yyyy-mm-dd\ndatetime: \n    -  2018-02-17t15:02:31+08:00    #时间使用iso 8601格式，时间和日期之间使用t连接，最后使用+代表时区\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n多行字符串可以使用|保留换行符，也可以使用>折叠换行。\n\nthis: |\n  foo\n  bar\nthat: >\n  foo\n  bar\n\n\n1\n2\n3\n4\n5\n6\n\n\n转为js代码如下。\n\n{ this: 'foo\\nbar\\n', that: 'foo bar\\n' }\n\n\n1\n\n\n+表示保留文字块末尾的换行，-表示删除字符串末尾的换行。\n\ns1: |\n  foo\n \ns2: |+\n  foo\n \n \ns3: |-\n  foo\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n转为json代码如下\n\n{ s1: 'foo\\n', s2: 'foo\\n\\n\\n', s3: 'foo' }\n\n\n1\n\n\n字符串之中可以插入 html 标记。\n\nmessage: |\n  <p style=\"color: red\">\n    段落\n  </p>\n\n\n1\n2\n3\n4\n\n\n\n# 转换数据格式\n\n允许使用两个感叹号，强制转换数据类型。\n\ne: !!str 123\nf: !!str true\n\n\n1\n2\n\n\n转换js结果同：\n\n{ e: '123', f: 'true' }\n\n\n1\n\n\n\n# 锚点引用\n\n& 锚点和< span class=\"marked\">* 别名，可以用来引用:\n\ndefaults: &defaults # 添加锚点\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults # <<表示合并，*引用锚点\n\ntest:\n  database: myapp_test\n  <<: *defaults # <<表示合并，*引用锚点\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n相当于:\n\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n\ntest:\n  database: myapp_test\n  adapter:  postgres\n  host:     localhost\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n& 用来建立锚点（defaults），<< 表示合并到当前数据，***** 用来引用锚点。\n\n下面是另一个例子:\n\n- &showell steve \n- clark \n- brian \n- oren \n- *showell \n\n\n1\n2\n3\n4\n5\n\n\n转为js代码如下:\n\n[ 'steve', 'clark', 'brian', 'oren', 'steve' ]\n\n\n1\n\n\n> 参考：\n> \n>  * yaml官网：https://yaml.org/\n>  * yaml与js的转换demo：http://nodeca.github.io/js-yaml/\n>  * 菜鸟教程：https://www.ruanyifeng.com/blog/2016/07/yaml.html",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"GitHub高级搜索技巧",frontmatter:{title:"GitHub高级搜索技巧",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/4c778760be26d8b3",categories:["技术","GitHub技巧"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/01.GitHub%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7.html",relativePath:"03.技术/02.GitHub技巧/01.GitHub高级搜索技巧.md",key:"v-ef2ec8a6",path:"/pages/4c778760be26d8b3/",excerpt:'<h1 id="github高级搜索技巧"><a class="header-anchor" href="#github高级搜索技巧">#</a> GitHub高级搜索技巧</h1>\n<p><code>in:name &lt;关键字&gt;</code>\n仓库名称带关键字查询</p>\n<p><code>in:description &lt;关键字&gt;</code>\n仓库描述带关键字查询</p>\n<p><code>in:readme &lt;关键字&gt;</code>\nREADME文件带关键字查询</p>\n',headersStr:null,content:'# GitHub高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> README文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000K的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> LICENSE为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为Java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',normalizedContent:'# github高级搜索技巧\n\nin:name <关键字> 仓库名称带关键字查询\n\nin:description <关键字> 仓库描述带关键字查询\n\nin:readme <关键字> readme文件带关键字查询\n\nstars(fork): >(=) <数字> <关键字> star或fork数大于(或等于)指定数字的带关键字查询\n\nstars(fork): 10..20 <关键词> star或fork数在10到20之间的带关键字查询\n\nsize:>=5000 <关键词> 限定仓库大于等于5000k的带关键字查询\n\npushed(created):>2019-11-15 <关键字> 更新 或 创建 日期在2019年11月16日之后的带关键字查询\n\nlicense:apache-2.0 <关键字> license为apache-2.0的带关键字查询\n\nlanguage:java <关键词> 仓库语言为java的带关键字查询\n\nuser:<用户名> 查询某个用户的项目\n\norg:<组织名> 查询某个组织的项目\n\n*以上查询条件可组合使用，空格隔开\n\n# 示例1：搜索仓库名包含javascript，并且stars数大于1000的项目\nin:name javascript stars:>1000\n\n# 示例2：搜索描述中包含"小程序"，并且fork大于100，并且最近更新时间在2019-11-15之后的，并且使用开发语言为vue的项目\nin:description 小程序 fork:>100 pushed:>2019-11-15 language:vue\n\n\n1\n2\n3\n4\n5\n\n\n*或使用高级搜索页搜索：\n\nhttps://github.com/search/advanced',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"GitHub Actions 实现自动部署静态博客",frontmatter:{title:"GitHub Actions 实现自动部署静态博客",date:"2019-12-27T11:44:41.000Z",permalink:"/pages/6b9d359ec5aa5019",categories:["技术","GitHub技巧"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/02.GitHub%20Actions%20%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2.html",relativePath:"03.技术/02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.md",key:"v-fb6e6346",path:"/pages/6b9d359ec5aa5019/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:32},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:17},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3449}],excerpt:'<h1 id="github-actions-实现自动部署静态博客"><a class="header-anchor" href="#github-actions-实现自动部署静态博客">#</a> GitHub Actions 实现自动部署静态博客</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p>我使用vuepress搭建了一个静态博客，挂在了Github pages和<a href="https://dev.tencent.com/" target="_blank" rel="noopener noreferrer">Coding pages<OutboundLink/></a>上面。</p>\n<p>coding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。</p>\n',headersStr:"前言 实现 相关文章",content:'# GitHub Actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了Github pages和Coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到Github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解GitHub Actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。GitHub Actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的Settings/Secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是ACCESS_TOKEN和CODING_TOKEN。\n\n\n\nGitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。GitHub 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: CI\n\n# 在master分支发生push事件时触发。\non: \n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps: \n      - name: Checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：userName/repoName。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: Use Node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          GITHUB_TOKEN: ${{ secrets.ACCESS_TOKEN }} # toKen私密变量\n          CODING_TOKEN: ${{ secrets.CODING_TOKEN }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令  \n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> ACCESS_TOKE 和 CODING_TOKEN 都是保存在github仓库的Settings/Secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.xugaoyi.com\' > CNAME\nif [ -z "$GITHUB_TOKEN" ]; then\n  msg=\'deploy\'\n  githubUrl=git@github.com:xugaoyi/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githubUrl=https://xugaoyi:${GITHUB_TOKEN}@github.com/xugaoyi/blog.git\n  git config --global user.name "xugaoyi"\n  git config --global user.email "894072666@qq.com"\nfi\ngit init\ngit add -A\ngit commit -m "${msg}"\ngit push -f $githubUrl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.xugaoyi.com\\nxugaoyi.com\' > CNAME  # 自定义域名\nif [ -z "$CODING_TOKEN" ]; then  # -z 字符串 长度为0则为true；$CODING_TOKEN来自于github仓库`Settings/Secrets`设置的私密环境变量\n  codingUrl=git@git.dev.tencent.com:xugaoyi/xugaoyi.git\nelse\n  codingUrl=https://xugaoyi:${CODING_TOKEN}@git.dev.tencent.com/xugaoyi/xugaoyi.git\nfi\ngit add -A\ngit commit -m "${msg}"\ngit push -f $codingUrl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个文件使用Shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的CNAME文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是GitHub Actions自动触发的部署，此时使用的是可以通过toKen来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * Shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建CNAME文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由GitHub Actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的Actions这一项查看。\n\n\n\n\n# 相关文章\n\n《GitHub Actions 定时运行代码：每天定时百度链接推送》',normalizedContent:'# github actions 实现自动部署静态博客\n\n\n# 前言\n\n我使用vuepress搭建了一个静态博客，挂在了github pages和coding pages上面。\n\ncoding pages在国内的访问速度比github pages要快很多，而且还可以被百度收录。\n\n一开始的部署方式是使用sh部署脚本把代码提交到这两个平台的仓库分支，虽然已经很方便了，但是我还想把博客未打包的源码提交到github主分支上。这就需要我操作两次命令，我就想能不能只需要一次操作就可以同时把源码、部署代码一次性提交到两个平台呢？\n\n\n# 实现\n\n在了解github actions最近（2019.12）刚正式发布了之后，尝试使用它发现能够满足我的需求。github actions 入门教程\n\n首先，需要获取token，后面会用到。获取方法：github获取token官方文档、coding获取token官方文档。\n\n然后，将这两个token同时储存到github仓库的settings/secrets里面。变量名可以随便取，但是注意要和后面的ci.yml文件内的变量名一致，这里取的是access_token和coding_token。\n\n\n\ngithub actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github/workflows目录。\n\nworkflow 文件采用 yaml 格式，文件名可以任意取，但是后缀名统一为.yml，比如ci.yml。一个库可以有多个 workflow 文件。github 只要发现.github/workflows目录里面有.yml文件，就会自动运行该文件。\n\n我的ci.yml文件：\n\nname: ci\n\n# 在master分支发生push事件时触发。\non: \n  push:\n    branches:\n      - master\njobs: # 工作流\n  build:\n    runs-on: ubuntu-latest #运行在虚拟机环境ubuntu-latest\n\n    strategy:\n      matrix:\n        node-version: [10.x]\n\n    steps: \n      - name: checkout # 步骤1\n        uses: actions/checkout@v1 # 使用的动作。格式：username/reponame。作用：检出仓库，获取源码。 官方actions库：https://github.com/actions\n      - name: use node.js ${{ matrix.node-version }} # 步骤2\n        uses: actions/setup-node@v1 # 作用：安装nodejs\n        with:\n          node-version: ${{ matrix.node-version }} # 版本\n      - name: run deploy.sh # 步骤3 （同时部署到github和coding）\n        env: # 设置环境变量\n          github_token: ${{ secrets.access_token }} # token私密变量\n          coding_token: ${{ secrets.coding_token }} # 腾讯云开发者平台（coding）私密token\n        run: npm install && npm run deploy # 执行的命令  \n        # package.json 中添加 "deploy": "bash deploy.sh"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n这个配置文件会在我push提交代码到主分支时触发工作，运行环境是ubuntu-latest，工作步骤：\n\n * 一，获取仓库源码\n\n * 二，安装nodejs，打包项目有用到nodejs\n\n * 三，把token设置到环境变量，安装项目依赖，并运行deploy.sh文件，\n\n> access_toke 和 coding_token 都是保存在github仓库的settings/secrets位置的私密变量，仓库代码中可以通过<secrets.变量名>来获取，保证了token的私密性。\n\n再来看看将要被运行的deploy.sh部署代码：\n\n#!/usr/bin/env sh\n# 确保脚本抛出遇到的错误\nset -e\nnpm run build # 生成静态文件\ncd docs/.vuepress/dist # 进入生成的文件夹\n\n# deploy to github\necho \'blog.xugaoyi.com\' > cname\nif [ -z "$github_token" ]; then\n  msg=\'deploy\'\n  githuburl=git@github.com:xugaoyi/blog.git\nelse\n  msg=\'来自github action的自动部署\'\n  githuburl=https://xugaoyi:${github_token}@github.com/xugaoyi/blog.git\n  git config --global user.name "xugaoyi"\n  git config --global user.email "894072666@qq.com"\nfi\ngit init\ngit add -a\ngit commit -m "${msg}"\ngit push -f $githuburl master:gh-pages # 推送到github\n\n# deploy to coding\necho \'www.xugaoyi.com\\nxugaoyi.com\' > cname  # 自定义域名\nif [ -z "$coding_token" ]; then  # -z 字符串 长度为0则为true；$coding_token来自于github仓库`settings/secrets`设置的私密环境变量\n  codingurl=git@git.dev.tencent.com:xugaoyi/xugaoyi.git\nelse\n  codingurl=https://xugaoyi:${coding_token}@git.dev.tencent.com/xugaoyi/xugaoyi.git\nfi\ngit add -a\ngit commit -m "${msg}"\ngit push -f $codingurl master # 推送到coding\n\ncd -\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n这个文件使用shell命令写的，它会先运行打包命令，进入打包好的文件，创建一个自定义域名的cname文件（如果你没有自定义域名可去掉这个命令），判断是否有token环境变量，如果没有说明是在本地自己的电脑上运行的部署，使用ssh代码仓库地址，如果有token环境变量，说明是github actions自动触发的部署，此时使用的是可以通过token来获取代码提交权限的提交地址。最后通过git命令提交到各自的仓库，完成部署。\n\n> 提示：\n> \n>  * shell 可以获取到环境变量。\n> \n>  * 我想给两个平台上部署的博客不一样的自定义域名，因此做了分开创建cname文件，分开提交。\n\n至此，我前面提到的需求就实现啦，只需要把源码push到github仓库这一个步骤，后面的博客打包、部署到github和coding等工作都由github actions来自动完成。\n\n如下你想查看部署日志，你可以到github仓库的actions这一项查看。\n\n\n\n\n# 相关文章\n\n《github actions 定时运行代码：每天定时百度链接推送》',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",frontmatter:{title:"GitHub Actions 定时运行代码：每天定时百度链接推送",date:"2019-12-30T21:23:00.000Z",permalink:"/pages/f44d2f9ad04ab8d3",categories:["技术","GitHub技巧"],tags:["github","博客"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/03.GitHub%20Actions%20%E5%AE%9A%E6%97%B6%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9A%E6%AF%8F%E5%A4%A9%E5%AE%9A%E6%97%B6%E7%99%BE%E5%BA%A6%E9%93%BE%E6%8E%A5%E6%8E%A8%E9%80%81.html",relativePath:"03.技术/02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.md",key:"v-a5baf23a",path:"/pages/f44d2f9ad04ab8d3/",headers:[{level:2,title:"百度主动链接推送",slug:"百度主动链接推送",normalizedTitle:"百度主动链接推送",charIndex:246},{level:2,title:"自动生成urls.txt",slug:"自动生成urls-txt",normalizedTitle:"自动生成urls.txt",charIndex:603},{level:2,title:"GitHub Actions 定时运行代码",slug:"github-actions-定时运行代码",normalizedTitle:"github actions 定时运行代码",charIndex:2},{level:3,title:"配置 GitHub Actions",slug:"配置-github-actions",normalizedTitle:"配置 github actions",charIndex:2071},{level:3,title:"baiduPush命令在package.json配置",slug:"baidupush命令在package-json配置",normalizedTitle:"baidupush命令在package.json配置",charIndex:2824},{level:3,title:"baiduPush.sh执行百度推送命令",slug:"baidupush-sh执行百度推送命令",normalizedTitle:"baidupush.sh执行百度推送命令",charIndex:3175},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:3659}],excerpt:'<h1 id="github-actions-定时运行代码-每天定时百度链接推送"><a class="header-anchor" href="#github-actions-定时运行代码-每天定时百度链接推送">#</a> GitHub Actions 定时运行代码：每天定时百度链接推送</h1>\n<p>博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。</p>\n<p>最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。</p>\n<p>GitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。<strong>功能非常强大，能够玩出许多花样。</strong></p>\n',headersStr:"百度主动链接推送 自动生成urls.txt GitHub Actions 定时运行代码 配置 GitHub Actions baiduPush命令在package.json配置 baiduPush.sh执行百度推送命令 相关文章",content:"# GitHub Actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到GitHub Actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=xugaoyi.com&token=T5PEAzhG*****\"\n\n\n1\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baiduPush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorConsole();\nconst matter = require('gray-matter'); // FrontMatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readFileList = require('./modules/readFileList');\nconst urlsRoot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst DOMAIN = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!DOMAIN) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baiduPush.js https://xugaoyi.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writeFileSync(urlsRoot, DOMAIN)\n  const files = readFileList(); // 读取所有md文件数据\n\n  files.forEach( file => {\n    const { data } = matter(fs.readFileSync(file.filePath, 'utf8')); \n\n    if (data.permalink) {\n      const link = `\\r\\n${DOMAIN}${data.permalink}/`;\n      console.log(link)\n      fs.appendFileSync(urlsRoot, link);\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baiduPush.js https://xugaoyi.com\n\n\n1\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# GitHub Actions 定时运行代码\n\n今天的主角GitHub Actions 要登场了。（相关：GitHub Actions 入门教程、GitHub Actions 实现自动部署静态博客）\n\nGitHub Actions 是一个 CI/CD（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 GitHub Actions\n\n触发 GitHub Actions 需要在项目仓库新建一个.github/workflows子目录，里面是 YAML 格式配置文件，文件名可以随便取。GitHub 只要发现配置文件，就会运行 Actions。\n\n配置文件的第一部分是触发条件。\n\n## baiduPush.yml\nname: 'baiduPush'\n \non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 Push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的Ubuntu\n    steps:\n      - name: 'Checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'Run baiduPush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baiduPush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baiduPush命令。完整代码看 这里\n\n\n# baiduPush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baiduPush\": \"node utils/baiduPush.js https://xugaoyi.com && bash baiduPush.sh\"\n}\n\n\n1\n2\n3\n4\n\n\n上面脚本中在node utils/baiduPush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baiduPush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baiduPush命令之所以没有放在baiduPush.yml的 run 里面是因为我想在本地也可以执行npm run baiduPush命令。\n\n\n# baiduPush.sh执行百度推送命令\n\nbaiduPush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -H 'Content-Type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://xugaoyi.com&token=T5PEAzhGa*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baiduPush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用GitHub Actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 GitHub Actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在GitHub上的静态博客的问题》",normalizedContent:"# github actions 定时运行代码：每天定时百度链接推送\n\n博客上线已经有些日子了，却发现百度迟迟没有收录我的博客页面，在百度推送工具当中除了有自动推送的代码嵌入网站之外，还有一个实时的主动推送更高效。\n\n最近刚好了解到github actions的定时运行代码功能，可以用它来每天自动运行命令生成所有博客链接并进行一次性推送给百度。\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 百度主动链接推送\n\n链接主动推送在百度站长中有介绍，如图。\n\n\n\n具体使用方法就是创建一个文件urls.txt，文件内每行一条链接的格式写入提交的多个链接，如图。\n\n\n\n运行命令\n\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=xugaoyi.com&token=t5peazhg*****\"\n\n\n1\n\n\n上面命令的地址和参数由百度站长提供。运行完命令会返回推送结果，不出意外的话就会把urls.txt内的所有链接一次性推送给百度。\n\n这个方法虽然比嵌入网站头部的自动推送更高效，但是也有它的麻烦之处，就是得自己填入链接到urls.txt文件，然后手动运行命令。\n\n\n# 自动生成urls.txt\n\n没关系，技术的本质就是让人\"偷懒\"的。于是，我写了一个nodejs工具，用于把所有的博客页面链接生成到urls.txt\n\n// baidupush.js\n\n/**\n * 生成百度链接推送文件\n */\nconst fs = require('fs');\nconst path = require('path');\nconst logger = require('tracer').colorconsole();\nconst matter = require('gray-matter'); // frontmatter解析器 https://github.com/jonschlinkert/gray-matter\nconst readfilelist = require('./modules/readfilelist');\nconst urlsroot = path.join(__dirname, '..', 'urls.txt'); // 百度链接推送文件\nconst domain = process.argv.splice(2)[0]; // 获取命令行传入的参数\n\nif (!domain) {\n  logger.error('请在运行此文件时指定一个你要进行百度推送的域名参数，例：node utils/baidupush.js https://xugaoyi.com')\n  return\n}\n\nmain();\nfunction main() {\n  fs.writefilesync(urlsroot, domain)\n  const files = readfilelist(); // 读取所有md文件数据\n\n  files.foreach( file => {\n    const { data } = matter(fs.readfilesync(file.filepath, 'utf8')); \n\n    if (data.permalink) {\n      const link = `\\r\\n${domain}${data.permalink}/`;\n      console.log(link)\n      fs.appendfilesync(urlsroot, link);\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n上面代码仅是针对我个人的博客生成链接到urls.txt文件。更多代码在 这里。\n\n运行如下命令就可以生产一个包含博客所有链接的urls.txt文件：\n\nnode utils/baidupush.js https://xugaoyi.com\n\n\n1\n\n\n哈哈，第一个麻烦解决了😏，接下来是解决第二个需要手动运行推送命令的问题。\n\n> 如果你没办法自动生成，你也可以自己手动创建一个urls.txt文件，放到github仓库。\n\n\n# github actions 定时运行代码\n\n今天的主角github actions 要登场了。（相关：github actions 入门教程、github actions 实现自动部署静态博客）\n\ngithub actions 是一个 ci/cd（持续集成/持续部署）工具，但也可用作代码运行环境。功能非常强大，能够玩出许多花样。\n\n\n# 配置 github actions\n\n触发 github actions 需要在项目仓库新建一个.github/workflows子目录，里面是 yaml 格式配置文件，文件名可以随便取。github 只要发现配置文件，就会运行 actions。\n\n配置文件的第一部分是触发条件。\n\n## baidupush.yml\nname: 'baidupush'\n \non:\n  push:\n  schedule:\n    - cron: '0 23 * * *'\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n上面代码中，name字段是配置文件的描述，on字段是触发条件。我们指定两种情况下触发，第一种是代码 push 进仓库，第二种是定时任务，每天在国际标准时间23点（北京时间+8，即早上7点）运行。\n\n> 定时设置看这里\n\n接着，就是运行流程。\n\njobs:\n  bot:\n    runs-on: ubuntu-latest # 运行环境为最新版的ubuntu\n    steps:\n      - name: 'checkout codes' # 步骤一，获取仓库代码\n        uses: actions/checkout@v1\n      - name: 'run baidupush.sh' # 步骤二，执行sh命令文件\n        run: npm install && npm run baidupush # 运行命令。（注意，运行目录是仓库根目录）\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，指定运行环境是最新的ubuntu，流程的第一步是从代码仓库获取代码，第二步运行两个命令，先安装项目依赖，再运行写在package.json的baidupush命令。完整代码看 这里\n\n\n# baidupush命令在package.json配置\n\n// package.json\n\"scripts\": {\n\t\"baidupush\": \"node utils/baidupush.js https://xugaoyi.com && bash baidupush.sh\"\n}\n\n\n1\n2\n3\n4\n\n\n上面脚本中在node utils/baidupush.js的后面加入你的域名参数。运行此命令生成urls.txt文件，然后执行baidupush.sh文件。\n\n注意，在使用window系统时，请使用git bash命令窗运行上面的脚本。\n\n> baidupush命令之所以没有放在baidupush.yml的 run 里面是因为我想在本地也可以执行npm run baidupush命令。\n\n\n# baidupush.sh执行百度推送命令\n\nbaidupush.sh文件：\n\n#!/usr/bin/env sh\n\nset -e\n\n# 百度链接推送\ncurl -h 'content-type:text/plain' --data-binary @urls.txt \"http://data.zz.baidu.com/urls?site=https://xugaoyi.com&token=t5peazhga*****\"\n\nrm -rf urls.txt # 灭迹\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面代码中，把urls.txt文件中的所有链接一次性推送。\n\n> baidupush.sh内的命令之所以没有写在package.json是因为我觉得命令太长了，不方便阅读。\n\n写好配置，推送到仓库，就会在每天的早上7点钟，自动运行命令生成一个包含博客所有页面链接的urls.txt文件，并把所有链接一次性推送到百度。麻麻再也不用担心我的网站不被收录~~😘 😘 😘\n\n在这个基础上可以扩展，使用github actions满足你自己的各种定时需求。\n\n\n# 相关文章\n\n《 github actions 实现自动部署静态博客》\n\n《解决百度无法收录搭建在github上的静态博客的问题》",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"GitHub加速下载项目的方法",frontmatter:{title:"GitHub加速下载项目的方法",date:"2020-03-09T10:28:09.000Z",permalink:"/pages/95331c6a9613faf8",categories:["技术","GitHub技巧"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/02.GitHub%E6%8A%80%E5%B7%A7/10.GitHub%E5%8A%A0%E9%80%9F%E4%B8%8B%E8%BD%BD%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%96%B9%E6%B3%95.html",relativePath:"03.技术/02.GitHub技巧/10.GitHub加速下载项目的方法.md",key:"v-62775647",path:"/pages/95331c6a9613faf8/",headers:[{level:2,title:"利用码云来转接做下载加速",slug:"利用码云来转接做下载加速",normalizedTitle:"利用码云来转接做下载加速",charIndex:109}],excerpt:'<h1 id="github加速下载项目的方法"><a class="header-anchor" href="#github加速下载项目的方法">#</a> GitHub加速下载项目的方法</h1>\n<p>国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。</p>\n',headersStr:"利用码云来转接做下载加速",content:'# GitHub加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从GitHub/GitLab导入项目\n    \n    \n\n 3. 选择从URL导入，粘贴从GitHub复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n    \n    1\n    2\n    3\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',normalizedContent:'# github加速下载项目的方法\n\n国内在github上克隆项目总是异常的慢，据我多次克隆观察，下载速度最快就20k/s左右，特别是在克隆比较大的项目时简直慢得无法忍受！下面介绍一种加载克隆项目的方法。\n\n\n\n\n# 利用码云来转接做下载加速\n\n 1. 首先你得有一个 码云 的账号\n\n 2. 登录码云之后在页面右上角的加号选择从github/gitlab导入项目\n    \n    \n\n 3. 选择从url导入，粘贴从github复制来的仓库地址，然后导入，这个导入过程一般是很快的。\n    \n    \n\n 4. 从码云克隆刚导入的这个项目，克隆速度会快很多，网速好的能达到几兆每秒（具体速度就看你的网速了，吐槽一下我家网速，总在关键时刻显示"视频加载中"....）\n    \n    \n\n 5. 另外要注意的一点，克隆下来的项目关联的是码云的仓库，如果你需要关联github仓库需要更改远程仓库。\n    \n    git remote -v # 查看关联的远程仓库\n    git remote rm <仓库名> # 删除远程仓库\n    git remote add <仓库名> <远程仓库地址> # 关联远程仓库，仓库名一般使用origin\n    \n    \n    1\n    2\n    3\n    \n\n这个方法适合用于克隆比较大的项目，如果克隆小项目，20k/s的速度好像还能将就~~',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"nodejs递归读取所有文件",frontmatter:{title:"nodejs递归读取所有文件",date:"2019-12-26T15:57:32.000Z",permalink:"/pages/117708e0af7f0bd9",categories:["技术","Nodejs"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/03.Nodejs/01.nodejs%E9%80%92%E5%BD%92%E8%AF%BB%E5%8F%96%E6%89%80%E6%9C%89%E6%96%87%E4%BB%B6.html",relativePath:"03.技术/03.Nodejs/01.nodejs递归读取所有文件.md",key:"v-7ddaa860",path:"/pages/117708e0af7f0bd9/",headersStr:null,content:"# nodejs递归读取所有文件\n\n\nvar fs = require('fs');\nvar path = require('path');\n \nfunction readFileList(dir, filesList = []) {\n    const files = fs.readdirSync(dir);\n    console.log(files);\n    files.forEach((item, index) => {\n        var fullPath = path.join(dir, item);\n        const stat = fs.statSync(fullPath);\n        if (stat.isDirectory()) {      \n            readFileList(path.join(dir, item), filesList);  //递归读取文件\n        } else {                \n            filesList.push(fullPath);                     \n        }        \n    });\n    return filesList;\n}\n \nvar filesList = [];\nreadFileList(__dirname,filesList);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",normalizedContent:"# nodejs递归读取所有文件\n\n\nvar fs = require('fs');\nvar path = require('path');\n \nfunction readfilelist(dir, fileslist = []) {\n    const files = fs.readdirsync(dir);\n    console.log(files);\n    files.foreach((item, index) => {\n        var fullpath = path.join(dir, item);\n        const stat = fs.statsync(fullpath);\n        if (stat.isdirectory()) {      \n            readfilelist(path.join(dir, item), fileslist);  //递归读取文件\n        } else {                \n            fileslist.push(fullpath);                     \n        }        \n    });\n    return fileslist;\n}\n \nvar fileslist = [];\nreadfilelist(__dirname,fileslist);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"解决百度无法收录搭建在GitHub上的个人博客的问题",frontmatter:{title:"解决百度无法收录搭建在GitHub上的个人博客的问题",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/41f87d890d0a02af",categories:["技术","博客搭建"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/01.%E8%A7%A3%E5%86%B3%E7%99%BE%E5%BA%A6%E6%97%A0%E6%B3%95%E6%94%B6%E5%BD%95%E6%90%AD%E5%BB%BA%E5%9C%A8GitHub%E4%B8%8A%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98.html",relativePath:"03.技术/04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md",key:"v-e8b0f490",path:"/pages/41f87d890d0a02af/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:74},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:172},{level:3,title:"如何知道百度有没有收录？",slug:"如何知道百度有没有收录",normalizedTitle:"如何知道百度有没有收录？",charIndex:1221},{level:2,title:"相关文章",slug:"相关文章",normalizedTitle:"相关文章",charIndex:1286}],excerpt:'<h1 id="解决百度无法收录搭建在github上的静态博客的问题"><a class="header-anchor" href="#解决百度无法收录搭建在github上的静态博客的问题">#</a> 解决百度无法收录搭建在GitHub上的静态博客的问题</h1>\n<div class="custom-block warning"><p class="custom-block-title">注意</p>\n<p>如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的<a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer">README<OutboundLink/></a>。</p>\n</div>\n<h2 id="背景"><a class="header-anchor" href="#背景">#</a> 背景</h2>\n<p>由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的<code>抓取诊断</code>再现，每次都是403 Forbidden的错误。</p>\n',headersStr:"背景 解决方案 如何知道百度有没有收录？ 相关文章",content:"# 解决百度无法收录搭建在GitHub上的静态博客的问题\n\n注意\n\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的README。\n\n\n# 背景\n\n由于GitHub禁止百度爬虫访问，造成托管在GitHub Pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 Forbidden的错误。\n\n\n# 解决方案\n\n同时将博客同时同步托管到GitHub Pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\n\n步骤：\n\n1、注册coding账号，创建仓库，把代码推送到coding仓库，并开启pages服务。\n\n> git 操作部分和使用github的差不多，不了解git操作的可以看我的另一篇文章：Git使用手册\n\n2、我的博客项目使用vuepress搭建的，使用的是如下自动部署脚本，同时将代码推送到github和conding。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# github\necho 'b.xugaoyi.com' > CNAME\ngit init\ngit add -A\ngit commit -m 'deploy'\ngit push -f git@github.com:xugaoyi/blog.git master:gh-pages # 发布到github\n\n# coding\necho 'xugaoyi.com' > CNAME\ngit add -A\ngit commit -m 'deploy'\ngit push -f git@git.dev.tencent.com:xugaoyi/xugaoyi.git master # 发布到coding\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 因为我想给两个平台上绑定不同的自定义域名，因此我分开创建了CNAME文件。\n\n3、有自定义域名的，也可以在coding pages绑定自定义域名，域名DNS解析中添加CNAME记录指向coding pages的站点地址即可。（没有自定义域名的可忽略，同时把自动部署脚本中的创建CNAME文件的脚本去掉）\n\n最后，使用百度站长的抓取诊断，发现抓取成功啦，再使用百度站长的链接提交功能，把链接提交给百度，过一段时间就可能在百度搜索中搜索到啦。\n\n\n# 如何知道百度有没有收录？\n\n在百度搜索框中使用site:<链接地址>，如：\n\nsite:xugaoyi.com\n\n\n1\n\n\n\n# 相关文章\n\n《GitHub Actions 定时运行代码：每天定时百度链接推送》",normalizedContent:"# 解决百度无法收录搭建在github上的静态博客的问题\n\n注意\n\n如果你正在寻找本博客的搭建文档，博主建议您查看这个仓库的readme。\n\n\n# 背景\n\n由于github禁止百度爬虫访问，造成托管在github pages上的博客无法被百度收录。相关问题可以通过百度站长平台的抓取诊断再现，每次都是403 forbidden的错误。\n\n\n# 解决方案\n\n同时将博客同时同步托管到github pages和coding pages上，解决百度不收录问题。最后发现在国内使用coding pages打开速度特别快，而且还会被百度收录，因此我把coding pages的站点作为主站点，原本在github pages的作为分站点。\n\n步骤：\n\n1、注册coding账号，创建仓库，把代码推送到coding仓库，并开启pages服务。\n\n> git 操作部分和使用github的差不多，不了解git操作的可以看我的另一篇文章：git使用手册\n\n2、我的博客项目使用vuepress搭建的，使用的是如下自动部署脚本，同时将代码推送到github和conding。\n\n#!/usr/bin/env sh\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件\nnpm run build\n\n# 进入生成的文件夹\ncd docs/.vuepress/dist\n\n# github\necho 'b.xugaoyi.com' > cname\ngit init\ngit add -a\ngit commit -m 'deploy'\ngit push -f git@github.com:xugaoyi/blog.git master:gh-pages # 发布到github\n\n# coding\necho 'xugaoyi.com' > cname\ngit add -a\ngit commit -m 'deploy'\ngit push -f git@git.dev.tencent.com:xugaoyi/xugaoyi.git master # 发布到coding\n\ncd - # 退回开始所在目录\nrm -rf docs/.vuepress/dist\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n> 因为我想给两个平台上绑定不同的自定义域名，因此我分开创建了cname文件。\n\n3、有自定义域名的，也可以在coding pages绑定自定义域名，域名dns解析中添加cname记录指向coding pages的站点地址即可。（没有自定义域名的可忽略，同时把自动部署脚本中的创建cname文件的脚本去掉）\n\n最后，使用百度站长的抓取诊断，发现抓取成功啦，再使用百度站长的链接提交功能，把链接提交给百度，过一段时间就可能在百度搜索中搜索到啦。\n\n\n# 如何知道百度有没有收录？\n\n在百度搜索框中使用site:<链接地址>，如：\n\nsite:xugaoyi.com\n\n\n1\n\n\n\n# 相关文章\n\n《github actions 定时运行代码：每天定时百度链接推送》",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"使用Gitalk实现静态博客无后台评论系统",frontmatter:{title:"使用Gitalk实现静态博客无后台评论系统",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/1da0bf9a988eafe5",categories:["技术","博客搭建"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/02.%E4%BD%BF%E7%94%A8Gitalk%E5%AE%9E%E7%8E%B0%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%97%A0%E5%90%8E%E5%8F%B0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F.html",relativePath:"03.技术/04.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.md",key:"v-0ae5a9bc",path:"/pages/1da0bf9a988eafe5/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:28},{level:2,title:"准备",slug:"准备",normalizedTitle:"准备",charIndex:109},{level:2,title:"实现",slug:"实现",normalizedTitle:"实现",charIndex:10},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:338},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:2},{level:3,title:"BUG修复",slug:"bug修复",normalizedTitle:"bug修复",charIndex:1603}],excerpt:'<h1 id="使用gitalk实现静态博客无后台评论系统"><a class="header-anchor" href="#使用gitalk实现静态博客无后台评论系统">#</a> 使用Gitalk实现静态博客无后台评论系统</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p>Gitalk，一个基于 Github Issue 和 Preact 开发的评论插件。</p>\n<p>下面我们来用它在vuepress搭建的博客中搭建评论区吧</p>\n',headersStr:"前言 准备 实现 安装 使用 BUG修复",content:"# 使用Gitalk实现静态博客无后台评论系统\n\n\n# 前言\n\nGitalk，一个基于 Github Issue 和 Preact 开发的评论插件。\n\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\n\n\n# 准备\n\n使用一个新的东西首先当然是要了解它\n\nGitalk demo：https://gitalk.github.io/\n\nGitalk github：https://github.com/gitalk/gitalk\n\n\n# 实现\n\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\n\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把Gitalk应用到vuepress搭建的静态博客。\n\n\n# 安装\n\nnpm install --save vuepress-plugin-comment\n\n\n1\n\n\n\n# 使用\n\noptions的配置和Gitalk的配置相同\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientID: 'GitHub Application Client ID',\n          clientSecret: 'GitHub Application Client Secret',\n          repo: 'GitHub repo',\n          owner: 'GitHub repo owner',\n          admin: ['GitHub repo owner and collaborators, only these guys can initialize github issues'],\n          distractionFreeMode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n需要 GitHub Application，如果没有 点击这里申请，Authorization callback URL 填写当前使用插件页面的域名。\n\n\n\n申请完成就会得 Client ID 和 Client Secret。然后把对应参数填写到配置中，例：\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientID: 'a6e*******4709b88b',\n          clientSecret: 'f0e***************beb8b2d54d7241',\n          repo: 'blog', // GitHub 仓库\n          owner: 'xugaoyi', // GitHub仓库所有者\n          admin: ['xugaoyi'], // 对仓库有写权限的人\n          distractionFreeMode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置好之后重启项目就发现页面上多了一个评论区，说明评论功能实现啦。但还是有一些bug，继续完善它~\n\n\n# BUG修复\n\n评论区与博客样式不匹配\n\n解决办法：新增全局样式文件.vuepress/styles/index.styl，写入样式\n\n#vuepress-plugin-comment\n  max-width $contentWidth\n  margin 0 auto\n  padding 2rem 2.5rem\n  @media (max-width: $MQNarrow)\n    padding 2rem\n  @media (max-width: $MQMobileNarrow)\n    padding 1.5rem\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n评论区出现 Error: Validation Failed.\n\n问题分析：当页面 链接过长 或 存在中文链接，导致整个链接字符串长度超过50时，会造成请求issues接口失败，出现422状态码。（中文链接会自动转码，变得很长，id参数默认取的是链接，长度不能超过50）\n\n解决办法：手动设置id取值，限制长度不超过50。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // GitHub issue 的标题\n   labels: [\"Gitalk\", \"Comment\"], // GitHub issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // GitHub issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 访问变量时，如 $frontmatter 或 window等，请使用 EJS 语法。因为在配置中不能使用回调函数，会被vuepress过滤，因此使用 EJS 语法。 ——插件作者文档说明\n\n切换页面后评论区内容还是上一个页面的评论\n\n解决：id在获取path时使用 frontmatter.to.path，插件内置了 ``frontmatter.from、frontmatter.to`。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // GitHub issue 的标题\n   labels: [\"Gitalk\", \"Comment\"], // GitHub issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // GitHub issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",normalizedContent:"# 使用gitalk实现静态博客无后台评论系统\n\n\n# 前言\n\ngitalk，一个基于 github issue 和 preact 开发的评论插件。\n\n下面我们来用它在vuepress搭建的博客中搭建评论区吧\n\n\n# 准备\n\n使用一个新的东西首先当然是要了解它\n\ngitalk demo：https://gitalk.github.io/\n\ngitalk github：https://github.com/gitalk/gitalk\n\n\n# 实现\n\n如何实现？最好的方法我认为是看官方文档，这里我只是记录一下实现的步骤。\n\n使用一个别人已经开发好的 vuepress-plugin-comment 插件来帮助我们把gitalk应用到vuepress搭建的静态博客。\n\n\n# 安装\n\nnpm install --save vuepress-plugin-comment\n\n\n1\n\n\n\n# 使用\n\noptions的配置和gitalk的配置相同\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientid: 'github application client id',\n          clientsecret: 'github application client secret',\n          repo: 'github repo',\n          owner: 'github repo owner',\n          admin: ['github repo owner and collaborators, only these guys can initialize github issues'],\n          distractionfreemode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n需要 github application，如果没有 点击这里申请，authorization callback url 填写当前使用插件页面的域名。\n\n\n\n申请完成就会得 client id 和 client secret。然后把对应参数填写到配置中，例：\n\nmodule.exports = {\n  plugins: [\n    [\n      'vuepress-plugin-comment',\n      {\n        choosen: 'gitalk', \n        options: {\n          clientid: 'a6e*******4709b88b',\n          clientsecret: 'f0e***************beb8b2d54d7241',\n          repo: 'blog', // github 仓库\n          owner: 'xugaoyi', // github仓库所有者\n          admin: ['xugaoyi'], // 对仓库有写权限的人\n          distractionfreemode: false \n        }\n      }\n    ]\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n配置好之后重启项目就发现页面上多了一个评论区，说明评论功能实现啦。但还是有一些bug，继续完善它~\n\n\n# bug修复\n\n评论区与博客样式不匹配\n\n解决办法：新增全局样式文件.vuepress/styles/index.styl，写入样式\n\n#vuepress-plugin-comment\n  max-width $contentwidth\n  margin 0 auto\n  padding 2rem 2.5rem\n  @media (max-width: $mqnarrow)\n    padding 2rem\n  @media (max-width: $mqmobilenarrow)\n    padding 1.5rem\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n评论区出现 error: validation failed.\n\n问题分析：当页面 链接过长 或 存在中文链接，导致整个链接字符串长度超过50时，会造成请求issues接口失败，出现422状态码。（中文链接会自动转码，变得很长，id参数默认取的是链接，长度不能超过50）\n\n解决办法：手动设置id取值，限制长度不超过50。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // github issue 的标题\n   labels: [\"gitalk\", \"comment\"], // github issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // github issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n> 访问变量时，如 $frontmatter 或 window等，请使用 ejs 语法。因为在配置中不能使用回调函数，会被vuepress过滤，因此使用 ejs 语法。 ——插件作者文档说明\n\n切换页面后评论区内容还是上一个页面的评论\n\n解决：id在获取path时使用 frontmatter.to.path，插件内置了 ``frontmatter.from、frontmatter.to`。\n\n{\n choosen: 'gitalk', \n options: {\n   ...\n   id: \"<%- (window.location.origin + (frontmatter.to.path || window.location.pathname)).slice(-50) %>\", //  页面的唯一标识,长度不能超过50\n   title: \"「评论」<%- document.title %>\", // github issue 的标题\n   labels: [\"gitalk\", \"comment\"], // github issue 的标签\n   body:\"<%- document.title %>：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>\" // github issue 的内容\n }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床",frontmatter:{title:"GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床",date:"2020-01-03T12:55:43.000Z",permalink:"/pages/a5f73af5185fdf0a",categories:["技术","博客搭建"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/03.GitHub%20+%20jsDelivr%20+%20TinyPNG+%20PicGo%20%E6%89%93%E9%80%A0%E7%A8%B3%E5%AE%9A%E5%BF%AB%E9%80%9F%E3%80%81%E9%AB%98%E6%95%88%E5%85%8D%E8%B4%B9%E5%9B%BE%E5%BA%8A.html",relativePath:"03.技术/04.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md",key:"v-227c81ae",path:"/pages/a5f73af5185fdf0a/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:55},{level:2,title:"图床打造",slug:"图床打造",normalizedTitle:"图床打造",charIndex:590}],excerpt:'<h1 id="github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床"><a class="header-anchor" href="#github-jsdelivr-tinypng-picgo-打造稳定快速、高效免费图床">#</a> GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床</h1>\n<h2 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h2>\n<p><strong>Q：为什么要使用图床呢？什么是图床？</strong></p>\n<p>A：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用<code>markdown+图片url</code>的方式写作文章，一次编写，到处使用~</p>\n',headersStr:"前言 图床打造",content:"# GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床\n\n\n# 前言\n\nQ：为什么要使用图床呢？什么是图床？\n\nA：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的URL，使用markdown+图片url的方式写作文章，一次编写，到处使用~\n\n更好的选择...\n\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：https://picx.xpoet.cn/ 使用方法看一下他网站的使用教程就行。 撒由那拉~~\n\n2021.07.04\n\nQ：图床的选择\n\nA：推荐使用GitHub作为图床，特点是免费、稳定，有一个小缺点是国内访问速度慢，不过没关系，可以使用jsDelivr免费CDN加速。\n\nQ：jsDelivr是什么？\n\nA：jsDelivr是国外的一家优秀的公共 CDN 服务提供商，该平台是首个「打通中国大陆与海外的免费CDN服务」，无须担心中国防火墙问题而影响使用。官网：http://www.jsdelivr.com/\n\n\n# 图床打造\n\n 1. 新建GitHub仓库，注意仓库要设置成公开\n\n 2. 参照 官方文档 生成一个token密钥\n\n 3. 在 这里 下载PicGo，安装完成后打开，图床设置 选 GitHub图床，并填写相应的信息\n    \n    * 仓库名：前面新建的仓库，格式：<用户名>/<仓库名>\n    * 分支名：填写主分支master即可\n    * Token：前面生成的token密钥\n    * 存储路径：按你自己的需求填写\n    * 自定义域名：图片上传后，PicGo 会按照 自定义域名+上传的图片名 的方式生成访问链接，此处我们填写jsDelivr的CDN加速地址，格式：https://cdn.jsdelivr.net/gh/<用户名>/<仓库名>\n\n\n\n 4. 使用https://tinypng.cn/压缩你要上传的图片（如图片已经很小或你有更好的压缩工具可省略这一步）\n 5. 在PigGo的上传区上传你的图片，到相册一键复制刚刚上传的图片URL，至此，你就可以在你的文章当中愉快的插入图片啦~， 更多功能自己去探索吧~~\n\n",normalizedContent:"# github + jsdelivr + tinypng+ picgo 打造稳定快速、高效免费图床\n\n\n# 前言\n\nq：为什么要使用图床呢？什么是图床？\n\na：写博客文章时，图片的上传和存放是一个问题，有的朋友可能会把图片放到和博客同一个仓库当中，使用相对路径来引用，这样后期维护起来会比较麻烦。还有的朋友会在不同的平台发布同一篇文章，这样一来每个平台都要上传图片，为了解决这些问题，比较推荐的做法是把图片统一上传到一个在线的第三方静态资源库中，我们把这个资源库称为图床，其返回一个图片的url，使用markdown+图片url的方式写作文章，一次编写，到处使用~\n\n更好的选择...\n\n以下内容是比较旧的，现在我发现一个更好用，配置更方便的图床工具：https://picx.xpoet.cn/ 使用方法看一下他网站的使用教程就行。 撒由那拉~~\n\n2021.07.04\n\nq：图床的选择\n\na：推荐使用github作为图床，特点是免费、稳定，有一个小缺点是国内访问速度慢，不过没关系，可以使用jsdelivr免费cdn加速。\n\nq：jsdelivr是什么？\n\na：jsdelivr是国外的一家优秀的公共 cdn 服务提供商，该平台是首个「打通中国大陆与海外的免费cdn服务」，无须担心中国防火墙问题而影响使用。官网：http://www.jsdelivr.com/\n\n\n# 图床打造\n\n 1. 新建github仓库，注意仓库要设置成公开\n\n 2. 参照 官方文档 生成一个token密钥\n\n 3. 在 这里 下载picgo，安装完成后打开，图床设置 选 github图床，并填写相应的信息\n    \n    * 仓库名：前面新建的仓库，格式：<用户名>/<仓库名>\n    * 分支名：填写主分支master即可\n    * token：前面生成的token密钥\n    * 存储路径：按你自己的需求填写\n    * 自定义域名：图片上传后，picgo 会按照 自定义域名+上传的图片名 的方式生成访问链接，此处我们填写jsdelivr的cdn加速地址，格式：https://cdn.jsdelivr.net/gh/<用户名>/<仓库名>\n\n\n\n 4. 使用https://tinypng.cn/压缩你要上传的图片（如图片已经很小或你有更好的压缩工具可省略这一步）\n 5. 在piggo的上传区上传你的图片，到相册一键复制刚刚上传的图片url，至此，你就可以在你的文章当中愉快的插入图片啦~， 更多功能自己去探索吧~~\n\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"vdoing主题效果图",frontmatter:{title:"vdoing主题效果图",date:"2020-04-08T11:27:22.000Z",permalink:"/pages/d557b9a89a215d2e",article:!1,author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/03.%E6%8A%80%E6%9C%AF/04.%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/10.vdoing%E4%B8%BB%E9%A2%98%E6%95%88%E6%9E%9C%E5%9B%BE.html",relativePath:"03.技术/04.博客搭建/10.vdoing主题效果图.md",key:"v-33de3fe1",path:"/pages/d557b9a89a215d2e/",headers:[{level:2,title:"PC端",slug:"pc端",normalizedTitle:"pc端",charIndex:18},{level:2,title:"首页个性化大图",slug:"首页个性化大图",normalizedTitle:"首页个性化大图",charIndex:53},{level:2,title:"深色模式和阅读模式",slug:"深色模式和阅读模式",normalizedTitle:"深色模式和阅读模式",charIndex:76},{level:2,title:"移动端",slug:"移动端",normalizedTitle:"移动端",charIndex:105}],headersStr:"PC端 首页个性化大图 深色模式和阅读模式 移动端",content:"# vdoing主题效果图\n\n\n# PC端\n\n\n首页 & 目录页△\n\n文章详情页 & 时间轴页△\n\n\n# 首页个性化大图\n\n\n首页个性化大图△\n\n\n# 深色模式和阅读模式\n\n\n深色模式△\n\n阅读模式△\n\n\n# 移动端\n\n\n移动端效果△",normalizedContent:"# vdoing主题效果图\n\n\n# pc端\n\n\n首页 & 目录页△\n\n文章详情页 & 时间轴页△\n\n\n# 首页个性化大图\n\n\n首页个性化大图△\n\n\n# 深色模式和阅读模式\n\n\n深色模式△\n\n阅读模式△\n\n\n# 移动端\n\n\n移动端效果△",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"费曼学习法",frontmatter:{title:"费曼学习法",date:"2020-07-16T10:04:14.000Z",permalink:"/pages/f2a556/",categories:["更多","学习"],tags:["学习方法"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/00.%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95.html",relativePath:"04.更多/01.学习/00.费曼学习法.md",key:"v-329c94d8",path:"/pages/f2a556/",headers:[{level:3,title:"步骤",slug:"步骤",normalizedTitle:"步骤",charIndex:102}],headersStr:"步骤",content:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",normalizedContent:"费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。 可以说是在通过向别讲解过程中来对自身的 查缺补漏。\n\n\n# 步骤\n\n费曼学习法分为4个步骤:\n\n 1. 确定学习目标\n\n你想学习的概念、内容、主题是什么。\n\n 2. 模拟教学学习法\n\n你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。\n\n 3. 回顾\n\n反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。\n\n 4. 简化\n\n把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。\n\n> 参考：\n> \n> 《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》\n> \n> 《费曼学习法》",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"笔记方法",frontmatter:{title:"笔记方法",date:"2020-07-16T11:00:55.000Z",permalink:"/pages/e60c81/",categories:["更多","学习"],tags:["笔记方法"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/01.%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95.html",relativePath:"04.更多/01.学习/01.笔记方法.md",key:"v-38d64c12",path:"/pages/e60c81/",headers:[{level:2,title:"康奈尔笔记法",slug:"康奈尔笔记法",normalizedTitle:"康奈尔笔记法",charIndex:2},{level:2,title:"思维导图法",slug:"思维导图法",normalizedTitle:"思维导图法",charIndex:15},{level:2,title:"金三角笔记法",slug:"金三角笔记法",normalizedTitle:"金三角笔记法",charIndex:27},{level:2,title:"曼陀罗九宫格笔记法",slug:"曼陀罗九宫格笔记法",normalizedTitle:"曼陀罗九宫格笔记法",charIndex:40},{level:2,title:"记号记录法",slug:"记号记录法",normalizedTitle:"记号记录法",charIndex:56},{level:2,title:"六色笔记法",slug:"六色笔记法",normalizedTitle:"六色笔记法",charIndex:68},{level:2,title:"加工笔记法",slug:"加工笔记法",normalizedTitle:"加工笔记法",charIndex:80},{level:2,title:"整理笔记要点1-科学标记重点",slug:"整理笔记要点1-科学标记重点",normalizedTitle:"整理笔记要点1-科学标记重点",charIndex:92},{level:2,title:"整理笔记要点2-修改不涂改",slug:"整理笔记要点2-修改不涂改",normalizedTitle:"整理笔记要点2-修改不涂改",charIndex:113}],headersStr:"康奈尔笔记法 思维导图法 金三角笔记法 曼陀罗九宫格笔记法 记号记录法 六色笔记法 加工笔记法 整理笔记要点1-科学标记重点 整理笔记要点2-修改不涂改",content:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",normalizedContent:"# 康奈尔笔记法\n\n\n\n\n# 思维导图法\n\n\n\n\n# 金三角笔记法\n\n\n\n\n# 曼陀罗九宫格笔记法\n\n\n\n\n# 记号记录法\n\n\n\n\n# 六色笔记法\n\n\n\n\n# 加工笔记法\n\n\n\n\n# 整理笔记要点1-科学标记重点\n\n\n\n\n# 整理笔记要点2-修改不涂改\n\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"提高学习效率的策略",frontmatter:{title:"提高学习效率的策略",date:"2020-01-04T11:54:14.000Z",permalink:"/pages/a8692ab3bdcb4588",categories:["更多","学习"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/02.%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5.html",relativePath:"04.更多/01.学习/02.提高学习效率的策略.md",key:"v-5b414b04",path:"/pages/a8692ab3bdcb4588/",headers:[{level:3,title:"检索式学习",slug:"检索式学习",normalizedTitle:"检索式学习",charIndex:222},{level:3,title:"频繁的集中练习只会产生短期记忆",slug:"频繁的集中练习只会产生短期记忆",normalizedTitle:"频繁的集中练习只会产生短期记忆",charIndex:634},{level:3,title:"间隔练习使知识存储更牢固",slug:"间隔练习使知识存储更牢固",normalizedTitle:"间隔练习使知识存储更牢固",charIndex:958},{level:3,title:"穿插练习有助于长期记忆",slug:"穿插练习有助于长期记忆",normalizedTitle:"穿插练习有助于长期记忆",charIndex:1346},{level:3,title:"多样化练习促进知识的活学活用",slug:"多样化练习促进知识的活学活用",normalizedTitle:"多样化练习促进知识的活学活用",charIndex:1728},{level:3,title:"小总结",slug:"小总结",normalizedTitle:"小总结",charIndex:1918},{level:3,title:"知识的“滚雪球”效应",slug:"知识的-滚雪球-效应",normalizedTitle:"知识的“滚雪球”效应",charIndex:2183}],excerpt:'<h1 id="提高学习效率的策略"><a class="header-anchor" href="#提高学习效率的策略">#</a> 提高学习效率的策略</h1>\n<p>推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的<strong>检索练习</strong>——例如小的测试和自测，<strong>间隔练习</strong>、<strong>穿插</strong>不同但相关科目或技能的练习（<strong>多样化练习</strong>），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。</p>\n',headersStr:"检索式学习 频繁的集中练习只会产生短期记忆 间隔练习使知识存储更牢固 穿插练习有助于长期记忆 多样化练习促进知识的活学活用 小总结 知识的“滚雪球”效应",content:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",normalizedContent:"# 提高学习效率的策略\n\n推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的检索练习——例如小的测试和自测，间隔练习、穿插不同但相关科目或技能的练习（多样化练习），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。\n\n\n# 检索式学习\n\n练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。\n\n那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。\n\n努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。\n\n反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。\n\n\n# 频繁的集中练习只会产生短期记忆\n\n人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。\n\n\n# 间隔练习使知识存储更牢固\n\n把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。 要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你\n\n\n# 穿插练习有助于长期记忆\n\n穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。\n\n\n# 多样化练习促进知识的活学活用\n\n与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。\n\n\n# 小总结\n\n有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）\n\n\n# 知识的“滚雪球”效应\n\n学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的编码。这时信息还没有被巩固成长期记忆中坚实的知识表征。巩固会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。检索会更新所学的东西，并让你做到学以致用。\n\n学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。\n\n长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。\n\n由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。\n\n阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。\n\n当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。\n\n重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。\n\n练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、\n\n试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。\n\n——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。\n\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"提高记忆的技巧",frontmatter:{title:"提高记忆的技巧",date:"2020-01-03T14:34:48.000Z",permalink:"/pages/996822b2a2ca6e3b",categories:["更多","学习"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/03.%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7.html",relativePath:"04.更多/01.学习/03.提高记忆的技巧.md",key:"v-f7d71be6",path:"/pages/996822b2a2ca6e3b/",excerpt:'<h1 id="提高记忆的技巧"><a class="header-anchor" href="#提高记忆的技巧">#</a> 提高记忆的技巧</h1>\n<ol>\n<li><strong>多个感官并用</strong>\n记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。</li>\n</ol>\n',headersStr:null,content:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",normalizedContent:"# 提高记忆的技巧\n\n 1. 多个感官并用 记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。\n\n 2. 重复记忆 每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。\n\n 3. 建立关联 把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。\n\n 4. 场景记忆 把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。\n\n 5. 提出问题 每学习一个知识点，试着提问，然后给出答案。用了就记住了。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"自律小建议",frontmatter:{title:"自律小建议",date:"2020-01-03T14:35:18.000Z",permalink:"/pages/c3f302a03c8daf79",categories:["更多","学习"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/04.%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE.html",relativePath:"04.更多/01.学习/04.自律小建议.md",key:"v-1aa834f7",path:"/pages/c3f302a03c8daf79/",excerpt:'<h1 id="自律小建议"><a class="header-anchor" href="#自律小建议">#</a> 自律小建议</h1>\n<ul>\n<li><strong>培养专注</strong>\n<ul>\n<li>练习冥想、瑜伽等</li>\n</ul>\n</li>\n<li><strong>排除外界干扰</strong>\n<ul>\n<li>手机调到勿扰，在图书馆学习等</li>\n</ul>\n</li>\n</ul>\n',headersStr:null,content:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>B站某位UP主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",normalizedContent:"# 自律小建议\n\n * 培养专注\n   * 练习冥想、瑜伽等\n * 排除外界干扰\n   * 手机调到勿扰，在图书馆学习等\n\n * 规定学习时间\n   \n   * 番茄时间管理——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。\n     \n     > 人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。\n     > \n     > 推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...\n     > \n     > 有好的身体可以使大脑更清醒哟~\n\n * 限制娱乐时间\n   \n   * 减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）\n   \n   * 推荐观看>b站某位up主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》\n\n * 戒网瘾（特别是游戏）\n   \n   * 除了手机、游戏以外，周围有很多美好的事物值得我们去关注。\n\n * 设定目标\n   \n   * 想要更好的薪水和职位？多花点时间在学习上吧~\n   * 潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标\n\n * 优秀的人仍在不断努力\n   \n   * 且看大神 阮一峰github 提交记录",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"处理问题的思路",frontmatter:{title:"处理问题的思路",date:"2020-01-03T14:36:02.000Z",permalink:"/pages/9ba2b8fb13de1957",categories:["更多","学习"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/05.%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF.html",relativePath:"04.更多/01.学习/05.处理问题的思路.md",key:"v-4a255ebe",path:"/pages/9ba2b8fb13de1957/",headers:[{level:2,title:"工作中遇到问题？",slug:"工作中遇到问题",normalizedTitle:"工作中遇到问题？",charIndex:14},{level:2,title:"这个问题我该怎么解决呢？",slug:"这个问题我该怎么解决呢",normalizedTitle:"这个问题我该怎么解决呢？",charIndex:86}],headersStr:"工作中遇到问题？ 这个问题我该怎么解决呢？",content:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找Boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",normalizedContent:"# 处理问题的思路\n\n\n# 工作中遇到问题？\n\n遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢\n\n\n# 这个问题我该怎么解决呢？\n\n 1. 学会搜索\n    \n    * 关键词\n    \n    * 多关键词\n    \n    * 加入时间\n    \n    * 加入特定的社区\n    \n    * site用法\n\n 2. 高阶搜索方法\n    \n    * 英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）\n    * 视频站搜索（http://www.youtube.com/、http://egghead.io）\n    * 百度盘搜索\n    * 指定文件后缀\n\n 3. 寻求帮助\n    \n    * 找同学\n    \n    * 找同事\n    \n    * 找朋友\n    \n    * 找社区\n\n 4. 开拓思路——发散性解决问题\n    \n    * 去问问原作者？\n    * 去发个邮件/twitter/facebook?\n    * 去找boss要资源？\n    * 加入公共社区参与讨论?\n    * ...",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"搜索引擎使用技巧",frontmatter:{title:"搜索引擎使用技巧",date:"2020-05-24T11:44:19.000Z",permalink:"/pages/ce818a",categories:["更多","学习"],tags:["搜索技巧"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/01.%E5%AD%A6%E4%B9%A0/10.%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.html",relativePath:"04.更多/01.学习/10.搜索引擎使用技巧.md",key:"v-3d4d4ad8",path:"/pages/ce818a/",headers:[{level:3,title:"技巧1：排除干扰项",slug:"技巧1-排除干扰项",normalizedTitle:"技巧1：排除干扰项",charIndex:117},{level:3,title:"技巧2：精确搜索",slug:"技巧2-精确搜索",normalizedTitle:"技巧2：精确搜索",charIndex:263},{level:3,title:"技巧3：指定网站内搜索",slug:"技巧3-指定网站内搜索",normalizedTitle:"技巧3：指定网站内搜索",charIndex:354},{level:3,title:"技巧4：指定文件格式",slug:"技巧4-指定文件格式",normalizedTitle:"技巧4：指定文件格式",charIndex:458},{level:3,title:"技巧5：指定在标题搜索",slug:"技巧5-指定在标题搜索",normalizedTitle:"技巧5：指定在标题搜索",charIndex:544},{level:3,title:"技巧6：指定在内容中搜索",slug:"技巧6-指定在内容中搜索",normalizedTitle:"技巧6：指定在内容中搜索",charIndex:595},{level:3,title:"技巧7：多种搜索技巧叠加使用",slug:"技巧7-多种搜索技巧叠加使用",normalizedTitle:"技巧7：多种搜索技巧叠加使用",charIndex:658},{level:3,title:"注意事项",slug:"注意事项",normalizedTitle:"注意事项",charIndex:739}],headersStr:"技巧1：排除干扰项 技巧2：精确搜索 技巧3：指定网站内搜索 技巧4：指定文件格式 技巧5：指定在标题搜索 技巧6：指定在内容中搜索 技巧7：多种搜索技巧叠加使用 注意事项",content:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n1\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n1\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n1\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n1\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n1\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',normalizedContent:'搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（\'妈~我真的是在找学习资料\'）\n\n\n# 技巧1：排除干扰项\n\n方式：关键词1+空格+减号+关键词2，即 关键词1 -关键词2\n\n功能：排除一些不想要的关键词\n\n示例：\n\n锤子 -锤子手机\n\n\n1\n\n\n示例中将在搜索结果排除与锤子手机相关的，只显示锤子本来的样子。\n\n> 经过百度搜索的测试，有的关键词能排除掉，有的并不好使\n\n\n# 技巧2：精确搜索\n\n方式：给关键词加双引号，"关键词"\n\n功能：只搜索引号里的字，少一个字或者把字拆开都不行\n\n示例：\n\n"达拉不崩吧"\n\n\n1\n\n\n> 注意是英文的双引号\n\n\n# 技巧3：指定网站内搜索\n\n方式：site:域名 关键词\n\n功能：只搜索指定域名的内容\n\n示例：\n\nsite:zhihu.com 前端\n\n\n1\n\n\n有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。\n\n\n# 技巧4：指定文件格式\n\n方式：filetype:文件格式 关键词\n\n示例：\n\nfiletype:avi 你懂的\n\n\n1\n\n\n常见文件格式有doc、pdf、ppt等\n\n\n# 技巧5：指定在标题搜索\n\n方式：intitle:关键词\n\n功能：搜索的关键词要出现在标题当中\n\n\n# 技巧6：指定在内容中搜索\n\n方式：intext:关键词、allintext:关键词1 关键词2、inurl:关键词2\n\n\n# 技巧7：多种搜索技巧叠加使用\n\n示例：\n\nsite:zhihu.com 前端 intitle:js\n\n\n1\n\n\n多种技巧和关键词叠加使用，中间空格隔开。\n\n\n# 注意事项\n\n以上搜索技巧使用的符号均是英文符号。',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"面试问题集锦",frontmatter:{title:"面试问题集锦",date:"2019-12-25T14:27:01.000Z",permalink:"/pages/aea6571b7a8bae86",categories:["更多","面试"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/03.%E9%9D%A2%E8%AF%95/01.%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E9%9B%86%E9%94%A6.html",relativePath:"04.更多/03.面试/01.面试问题集锦.md",key:"v-054e32aa",path:"/pages/aea6571b7a8bae86/",headers:[{level:2,title:"请做一下自我介绍",slug:"请做一下自我介绍",normalizedTitle:"请做一下自我介绍",charIndex:13},{level:2,title:"你最大的优点是什么？",slug:"你最大的优点是什么",normalizedTitle:"你最大的优点是什么？",charIndex:166},{level:2,title:"说说你最大的缺点？",slug:"说说你最大的缺点",normalizedTitle:"说说你最大的缺点？",charIndex:252},{level:2,title:"说说你对加班的看法？",slug:"说说你对加班的看法",normalizedTitle:"说说你对加班的看法？",charIndex:378},{level:2,title:"说说你对薪资的要求？",slug:"说说你对薪资的要求",normalizedTitle:"说说你对薪资的要求？",charIndex:513},{level:2,title:"在五年内，你的职业规划？",slug:"在五年内-你的职业规划",normalizedTitle:"在五年内，你的职业规划？",charIndex:903},{level:2,title:"你朋友对你的评价?",slug:"你朋友对你的评价",normalizedTitle:"你朋友对你的评价?",charIndex:1081},{level:2,title:"你还有什么问题要问吗?",slug:"你还有什么问题要问吗",normalizedTitle:"你还有什么问题要问吗?",charIndex:1241},{level:2,title:"录用后发现不适合这个职位，怎么办?",slug:"录用后发现不适合这个职位-怎么办",normalizedTitle:"录用后发现不适合这个职位，怎么办?",charIndex:1424},{level:2,title:"工作时跟领导意见不同怎么办?",slug:"工作时跟领导意见不同怎么办",normalizedTitle:"工作时跟领导意见不同怎么办?",charIndex:1601},{level:2,title:"工作出现失误并造成损失，你会怎么做?",slug:"工作出现失误并造成损失-你会怎么做",normalizedTitle:"工作出现失误并造成损失，你会怎么做?",charIndex:1779},{level:2,title:"谈谈你对跳槽的看法?",slug:"谈谈你对跳槽的看法",normalizedTitle:"谈谈你对跳槽的看法?",charIndex:2028},{level:2,title:"和同事、上司难以相处，你怎么办?",slug:"和同事、上司难以相处-你怎么办",normalizedTitle:"和同事、上司难以相处，你怎么办?",charIndex:2098},{level:2,title:"上级领导抢了你的功劳怎么办?",slug:"上级领导抢了你的功劳怎么办",normalizedTitle:"上级领导抢了你的功劳怎么办?",charIndex:2311},{level:2,title:"同事孤立你，你怎么办?",slug:"同事孤立你-你怎么办",normalizedTitle:"同事孤立你，你怎么办?",charIndex:2485},{level:2,title:"你最近是否参加了培训课程?",slug:"你最近是否参加了培训课程",normalizedTitle:"你最近是否参加了培训课程?",charIndex:2582},{level:2,title:"你对于我们公司了解多少?",slug:"你对于我们公司了解多少",normalizedTitle:"你对于我们公司了解多少?",charIndex:2636},{level:2,title:"你最擅长的技术方向是什么?",slug:"你最擅长的技术方向是什么",normalizedTitle:"你最擅长的技术方向是什么?",charIndex:2727},{level:2,title:"请说出你选择这份工作的动机?",slug:"请说出你选择这份工作的动机",normalizedTitle:"请说出你选择这份工作的动机?",charIndex:2784},{level:2,title:"你能为我们公司带来什么呢?",slug:"你能为我们公司带来什么呢",normalizedTitle:"你能为我们公司带来什么呢?",charIndex:2912},{level:2,title:"最能概括你自己的三个词?",slug:"最能概括你自己的三个词",normalizedTitle:"最能概括你自己的三个词?",charIndex:3159},{level:2,title:"作为被面试者给我打一下分?",slug:"作为被面试者给我打一下分",normalizedTitle:"作为被面试者给我打一下分?",charIndex:3225},{level:2,title:"你怎么理解你应聘的职位?",slug:"你怎么理解你应聘的职位",normalizedTitle:"你怎么理解你应聘的职位?",charIndex:3302},{level:2,title:"喜欢这份工作的哪一点?",slug:"喜欢这份工作的哪一点",normalizedTitle:"喜欢这份工作的哪一点?",charIndex:3346},{level:2,title:"为什么要离职?",slug:"为什么要离职",normalizedTitle:"为什么要离职?",charIndex:3497},{level:2,title:"说说你对行业、技术发展趋势的看法?",slug:"说说你对行业、技术发展趋势的看法",normalizedTitle:"说说你对行业、技术发展趋势的看法?",charIndex:3739},{level:2,title:"对工作的期望与目标何在?",slug:"对工作的期望与目标何在",normalizedTitle:"对工作的期望与目标何在?",charIndex:3923},{level:2,title:"谈谈你的家庭?",slug:"谈谈你的家庭",normalizedTitle:"谈谈你的家庭?",charIndex:4183},{level:2,title:"你认为自己申请这个职位还欠缺什么?",slug:"你认为自己申请这个职位还欠缺什么",normalizedTitle:"你认为自己申请这个职位还欠缺什么?",charIndex:4413},{level:2,title:"你欣赏哪种性格的人?",slug:"你欣赏哪种性格的人",normalizedTitle:"你欣赏哪种性格的人?",charIndex:4580},{level:2,title:"你通常如何处理别人的批评?",slug:"你通常如何处理别人的批评",normalizedTitle:"你通常如何处理别人的批评?",charIndex:4633},{level:2,title:"怎样对待自己的失败?",slug:"怎样对待自己的失败",normalizedTitle:"怎样对待自己的失败?",charIndex:4705},{level:2,title:"什么会让你有成就感?",slug:"什么会让你有成就感",normalizedTitle:"什么会让你有成就感?",charIndex:4761},{level:2,title:"眼下你生活中最重要的是什么?",slug:"眼下你生活中最重要的是什么",normalizedTitle:"眼下你生活中最重要的是什么?",charIndex:4805},{level:2,title:"你为什么愿意到我们公司来工作?",slug:"你为什么愿意到我们公司来工作",normalizedTitle:"你为什么愿意到我们公司来工作?",charIndex:4867},{level:2,title:"你和别人发生过争执吗?",slug:"你和别人发生过争执吗",normalizedTitle:"你和别人发生过争执吗?",charIndex:5043},{level:2,title:"你做过的哪件事最令自己感到骄傲?",slug:"你做过的哪件事最令自己感到骄傲",normalizedTitle:"你做过的哪件事最令自己感到骄傲?",charIndex:5234},{level:2,title:"对这项工作，你有哪些可预见的困难?",slug:"对这项工作-你有哪些可预见的困难",normalizedTitle:"对这项工作，你有哪些可预见的困难?",charIndex:5366},{level:2,title:"录用后你将怎样开展工作?",slug:"录用后你将怎样开展工作",normalizedTitle:"录用后你将怎样开展工作?",charIndex:5512},{level:2,title:"你希望与什么样的上级共事?",slug:"你希望与什么样的上级共事",normalizedTitle:"你希望与什么样的上级共事?",charIndex:5657},{level:2,title:"你工作经验欠缺，如何能胜任这项工作?",slug:"你工作经验欠缺-如何能胜任这项工作",normalizedTitle:"你工作经验欠缺，如何能胜任这项工作?",charIndex:5813},{level:2,title:"你会怎样获得同事的帮助?",slug:"你会怎样获得同事的帮助",normalizedTitle:"你会怎样获得同事的帮助?",charIndex:6093},{level:2,title:"如果你没被录用，你怎么打算?",slug:"如果你没被录用-你怎么打算",normalizedTitle:"如果你没被录用，你怎么打算?",charIndex:6229},{level:2,title:"最令你沮丧的事情?",slug:"最令你沮丧的事情",normalizedTitle:"最令你沮丧的事情?",charIndex:6671},{level:2,title:"想过创业吗?",slug:"想过创业吗",normalizedTitle:"想过创业吗?",charIndex:6868},{level:2,title:"为什么我们要在众多的面试者中选择你?",slug:"为什么我们要在众多的面试者中选择你",normalizedTitle:"为什么我们要在众多的面试者中选择你?",charIndex:6941},{level:2,title:"除了本公司外，还应聘了哪些公司?",slug:"除了本公司外-还应聘了哪些公司",normalizedTitle:"除了本公司外，还应聘了哪些公司?",charIndex:7126},{level:2,title:"你并非毕业于名牌院校?",slug:"你并非毕业于名牌院校",normalizedTitle:"你并非毕业于名牌院校?",charIndex:7255},{level:2,title:"怎样看待学历和能力?",slug:"怎样看待学历和能力",normalizedTitle:"怎样看待学历和能力?",charIndex:7379},{level:2,title:"谈谈如何适应办公室工作的新环境?",slug:"谈谈如何适应办公室工作的新环境",normalizedTitle:"谈谈如何适应办公室工作的新环境?",charIndex:7605},{level:2,title:"谈谈对这个职务的期许?",slug:"谈谈对这个职务的期许",normalizedTitle:"谈谈对这个职务的期许?",charIndex:7742},{level:2,title:"何时可以到职?",slug:"何时可以到职",normalizedTitle:"何时可以到职?",charIndex:7882}],headersStr:"请做一下自我介绍 你最大的优点是什么？ 说说你最大的缺点？ 说说你对加班的看法？ 说说你对薪资的要求？ 在五年内，你的职业规划？ 你朋友对你的评价? 你还有什么问题要问吗? 录用后发现不适合这个职位，怎么办? 工作时跟领导意见不同怎么办? 工作出现失误并造成损失，你会怎么做? 谈谈你对跳槽的看法? 和同事、上司难以相处，你怎么办? 上级领导抢了你的功劳怎么办? 同事孤立你，你怎么办? 你最近是否参加了培训课程? 你对于我们公司了解多少? 你最擅长的技术方向是什么? 请说出你选择这份工作的动机? 你能为我们公司带来什么呢? 最能概括你自己的三个词? 作为被面试者给我打一下分? 你怎么理解你应聘的职位? 喜欢这份工作的哪一点? 为什么要离职? 说说你对行业、技术发展趋势的看法? 对工作的期望与目标何在? 谈谈你的家庭? 你认为自己申请这个职位还欠缺什么? 你欣赏哪种性格的人? 你通常如何处理别人的批评? 怎样对待自己的失败? 什么会让你有成就感? 眼下你生活中最重要的是什么? 你为什么愿意到我们公司来工作? 你和别人发生过争执吗? 你做过的哪件事最令自己感到骄傲? 对这项工作，你有哪些可预见的困难? 录用后你将怎样开展工作? 你希望与什么样的上级共事? 你工作经验欠缺，如何能胜任这项工作? 你会怎样获得同事的帮助? 如果你没被录用，你怎么打算? 最令你沮丧的事情? 想过创业吗? 为什么我们要在众多的面试者中选择你? 除了本公司外，还应聘了哪些公司? 你并非毕业于名牌院校? 怎样看待学历和能力? 谈谈如何适应办公室工作的新环境? 谈谈对这个职务的期许? 何时可以到职?",content:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在XX经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是XX的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的OEM合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过XX近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、EQ上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了XX的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",normalizedContent:"# 面试问题集锦\n\n\n# 请做一下自我介绍\n\n回答提示： 一般人回答这个问题过于平常，只说姓名、年龄、工作经验，这些在简历上都有。其实，企业最希望知道的是求职者能否胜任工作，包括：最强的技能、最深入研究的知识领域、个性中最积极的部分、做过的最成功的事，主要的成就等，要突出积极的个性和做事的能力，说的合情合理企业才会相信。\n\n\n# 你最大的优点是什么？\n\n回答提示： 沉着冷静、条理清楚、立场坚定、乐于助人等，加上例子如：我在xx经过一到两年的培训及项目实战，加上实习工作，我想我适合这份工作。\n\n\n# 说说你最大的缺点？\n\n回答提示： 这个问题企业问的概率很大，通常不希望听到直接回答的缺点是什么等，如果求职者说自己小心眼、非常懒、工作效率低，企业肯定不会录用你。要从自己的优点说起，中间加一些小缺点，最后再把问答转回到优点上，突出优点的部分。\n\n\n# 说说你对加班的看法？\n\n回答提示： 实际上好多公司问这个问题，并不证明一定要加班，只是想测试你是否愿意为公司奉献。\n\n回答样本： 如果是工作需要我会义不容辞加班，我现在单身，没有任何家庭负担，可以全身心的投入工作。但同时，我也会提高工作效率，减少不必要的加班。\n\n\n# 说说你对薪资的要求？\n\n回答提示： 如果你对薪资的要求太低，那显然贬低自己的能力；如果你对薪资的要求太高，那又会显得你分量过重，公司受用不起。一些雇主通常都事先对求聘的职位定下开支预算，因而他们第一次提出的价钱往往是他们所能给予的最高价钱，他们问你只不过想证实一下这笔钱是否足以引起你对该工作的兴趣。\n\n回答样本：\n\n①我对工资没有硬性要求，我相信贵公司会友善合理。我注重的是找到工作机会，所以只要条件公平，我则不会计较太多。\n\n②我受过系统的软件编程的训练，不需要进行大量的培训，而且我本人也对编程特别感兴趣。因此，我希望公司能根据我的情况和市场标准的水平，给我合理的薪水。\n\n③如果你必须自己说出具体数目，请不要说一个宽泛的范围，那样你将只能得到最低限度的数字。最好给出一个具体的数字，这样表明你已经对当今的人才市场做了调查，知道像自己这样学历的雇员有什么样的价值。\n\n\n# 在五年内，你的职业规划？\n\n回答提示： 这是每一个应聘者都不希望被问到的问题，但是几乎每个人都会被问到，比较多的答案是“管理者”。当然，说出其他一些你感兴趣的职位也是可以的。要知道，考官总是喜欢有进取心的应聘者，此时如果说“不知道”，或许就会使你丧失一个好机会。最普通的回答应该是“我准备在技术领域有所作为”或“我希望能按照公司的管理思路发展”。\n\n\n# 你朋友对你的评价?\n\n回答提示： 想从侧面了解一下你的性格及与人相处的问题。\n\n回答样本：\n\n①我朋友都说我是一个可以信赖的人。因为，我一旦答应别人的事情，就一定会做到。如果我做不到，我就不会轻易许诺。\n\n②我觉的我是一个比较随和的人，与不同的人都可以友好相处。在我与人相处时，我总是能站在别人的角度考虑问题。\n\n\n# 你还有什么问题要问吗?\n\n回答提示： 企业的这个问题看上去可有可无，其实很关键，企业不喜欢说“没问题”的人，因为其很注重员工的个性和创新能力。企业不喜欢求职者问个人福利之类的问题，如果有人这样问：贵公司对新入公司的员工有没有什么培训项目，我可以参加吗？或者说贵公司的晋升机制是什么样的？企业将很欢迎，因为体现出你对学习的热情和对公司的忠诚度以及你的上进心。\n\n\n# 录用后发现不适合这个职位，怎么办?\n\n回答提示： 工作一段时间发现工作不适合，有两种情况：①如果你确实热爱这个职业，那就要不断学习，虚心向领导和同事学习业务知识和处事经验，了解这个职业的精神内涵和职业要求，力争减少差距；②你觉得这个职业可有可无，那还是趁早换个职业，去发现适合你的，你热爱的职业，那样你的发展前途也会大点，对单位和个人都有好处。\n\n\n# 工作时跟领导意见不同怎么办?\n\n回答样本： ①原则上我会尊重和服从领导的工作安排，同时私底下找机会以请教的口吻，婉转地表达自己的想法，看看领导是否能改变想法。②如果领导没有采纳我的建议，我也同样会按领导的要求认真地去完成这项工作。③还有一种情况，假如领导要求的方式违背原则，我会坚决提出反对意见，如领导仍固执己见，我会毫不犹豫地再向上级领导反映。\n\n\n# 工作出现失误并造成损失，你会怎么做?\n\n回答样本： ①我本意是为公司努力工作，如果造成经济损失，我认为首要的问题是想方设法去弥补或挽回经济损失。如果我无能力负责，希望单位帮助解决。\n\n②分清责任，各负其责，如果是我的责任，我甘愿受罚；如果是一个我负责的团队中别人的失误，也不能幸灾乐祸，作为一个团队，需要互相提携共同成工作，安慰同事并且帮助同事查找原因总结经验。\n\n③个人的一生不可能不犯错误，重要的是能从自己的或者是别人的错误中吸取经验教训，要检讨自己的工作方法、分析问题的深度和力度。\n\n\n# 谈谈你对跳槽的看法?\n\n回答样本： ①正常的“跳槽”能够促进人才合理流动，应该支持。②频繁的跳槽对单位和个人双方都不利，应该反对。\n\n\n# 和同事、上司难以相处，你怎么办?\n\n回答样本： ①我会服从领导的指挥，配合同事的工作。②我会从自身找原因，仔细分析是不是自己工作做得不好。还要看看是不是为人处世方面做得不好，如果是这样的话我会努力改正。③如果我找不到原因，我会找机会跟他们沟通，请他们指出我的不足，及时改正。④作为优秀的员工，应该时刻以大局为重，即使在一段时间内，领导和同事对我不理解，我也会做好本职工作，虚心向他们学习，我相信，他们会看见我的努力。\n\n\n# 上级领导抢了你的功劳怎么办?\n\n回答样本： 首先我不会找那位上级领导说明这事，我会主动找我的主管领导来沟通，因为沟通是解决人际关系的最好办法，但结果会有两种：①我的主管领导认识到自己的错误，我想我会视具体情况决定是否原谅他。②他更加变本加厉的来威胁我，那我会毫不犹豫地找我的上级领导反映此事，因为他这样做会造成负面影响，对今后的工作不利。\n\n\n# 同事孤立你，你怎么办?\n\n回答样本： ①检讨一下自己是不是对工作的热心度超过同事间交往的热心了，加强同事间的交往及共同的兴趣爱好。②工作中，切勿伤害别人的自尊心。③不在领导前拨弄是非。\n\n\n# 你最近是否参加了培训课程?\n\n回答提示： 自费参加，就是xx的培训课程（可以多谈谈自己学的技术）。\n\n\n# 你对于我们公司了解多少?\n\n回答提示： 在去公司面试前上网查一下该公司主营业务。可类似回答：贵公司有意改变策略，加强与国外大厂的oem合作，自有品牌的部分则透过海外经销商。\n\n\n# 你最擅长的技术方向是什么?\n\n回答提示： 说和你要应聘的职位相关的技术，表现一下自己的热诚没有什么坏处。\n\n\n# 请说出你选择这份工作的动机?\n\n回答提示： 这是想知道面试者对这份工作的热忱及理解度，并筛选因一时兴起而来应试的人，如果是无经验者，可以强调“就算职种不同，也希望有机会发挥之前的经验”。\n\n回答样本： 因为我很热爱这个工作，很想从事这方面的工作。\n\n\n# 你能为我们公司带来什么呢?\n\n回答提示： ①假如你可以的话，试着告诉他们你可以减低他们的费用“我已经接受过xx近两年专业的培训，立刻就可以上岗工作”。②企业很想知道未来的员工能为企业做什么，求职者应再次重复自己的优势，然后表示：“就我的能力，我可以做一个优秀的员工在组织中发挥能力，给组织带来高效率和更多的收益”。企业喜欢求职者就申请的职位表明自己的能力，比如申请营销之类的职位，可以说：“我可以开发大量的新客户，同时，对老客户做更全面周到的服务，开发老客户的新需求和消费。” 等等。\n\n\n# 最能概括你自己的三个词?\n\n回答样本： 我经常用的三个词是：适应能力强，有责任心和做事有始终，并结合具体例子向主考官解释。\n\n\n# 作为被面试者给我打一下分?\n\n回答提示： 试着列出四个优点和一个非常非常非常小的缺点（可以抱怨一下设施，没有明确责任人的缺点是不会有人介意的）。\n\n\n# 你怎么理解你应聘的职位?\n\n回答提示： 可以把岗位职责和任务及工作态度阐述下。\n\n\n# 喜欢这份工作的哪一点?\n\n回答提示： 在回答面试官这个问题时不能太直接就把自己心理的话说出来，尤其是薪资方面的问题，不过一些无伤大雅的回答是不错的考虑，如交通方便，工作性质及内容颇能符合自己的兴趣等等都是不错的答案，不过如果这时自己能仔细思考出这份工作的与众不同之处，相信在面试上会大大加分。\n\n\n# 为什么要离职?\n\n回答提示： ①回答这个问题时一定要小心，就算在前一个工作受到再大的委屈，对公司有多少的怨言都千万不要表现出来，尤其要避免对公司本身主管的批评，避免面试官的负面情绪及印象。建议此时最好的回答方式是将问题归咎在自己身上，例如觉得工作没有学习发展的空间，自己想在面试工作的相关产业中多加学习，或是前一份工作与自己的生涯规划不合等等，回答的答案最好是积极正面的。②我希望能获得一份更好的工作，如果机会来临，我会抓住。我觉得目前的工作，已经达到顶峰，即没有升迁机会。\n\n\n# 说说你对行业、技术发展趋势的看法?\n\n回答提示： 企业对这个问题很感兴趣，只有有备而来的求职者能够过关。求职者可以直接在网上查找对你所申请的行业部门的信息，只有深入了解才能产生独特的见解。企业认为最聪明的求职者是对所面试的公司预先了解很多，包括公司各个部门，发展情况，在面试回答问题的时候可以提到所了解的情况，企业欢迎进入企业的人是“知己”，而不是“盲人”。\n\n\n# 对工作的期望与目标何在?\n\n回答提示： 这是面试者用来评断求职者是否对自己有一定程度的期望、对这份工作是否了解的问题。 对于工作有确实学习目标的人通常学习较快，对于新工作自然较容易进入状况，这时建议你，最好针对工作的性质找出一个确实的答案，如业务员的工作可以这样回答：“我的目标是能成为一个超级业务员，将公司的产品广泛的推销出去，达到最好的业绩成效；为达到这个目标，我一定会努力学习，而我相信以我认真负责的态度，一定可以达到这个目标。” 其他类的工作也可以比照这个方式回答，只要在目标方面稍微修改一下就可以了。\n\n\n# 谈谈你的家庭?\n\n回答提示： 企业面试时询问家庭问题不是非要知道求职者家庭的情况，而是要了解家庭背景对求职者的塑造和影响。企业希望听到的重点也在于家庭对求职者的积极影响。\n\n回答样本： 我很爱我的家庭，我们家一向很和睦，虽然我的父亲和母亲都是普通人，但是从小，我就看到我父亲起早贪黑，每天工作特别勤劳，他的行动无形中培养了我认真负责的态度和勤劳的精神。我母亲为人善良，对人热情，特别乐于助人，所以在单位人缘很好，她的一言一行也一直在教导我做人的道理。\n\n\n# 你认为自己申请这个职位还欠缺什么?\n\n回答提示： 企业喜欢问求职者弱点，但精明的求职者一般不直接回答。\n\n回答样本： 继续重复自己的优势，然后说：“对于这个职位和我的能力来说，我相信自己是可以胜任的，只是缺乏经验，这个问题可以进入公司以后以最短的时间来解决，我的学习能力很强，我相信可以很快融入公司的企业文化，进入工作状态。\n\n\n# 你欣赏哪种性格的人?\n\n回答提示： 诚实、不死板而且容易相处的人、有实际行动的人，加上具体例子。\n\n\n# 你通常如何处理别人的批评?\n\n回答提示： ①沈默是金，不必说什么，否则情况更糟，不过我会接受建设性的批评。②我会等大家冷静下来再讨论。\n\n\n# 怎样对待自己的失败?\n\n回答提示： 大意：我们生来都不是十全十美的，我相信我有第二个机会改正我的错误。\n\n\n# 什么会让你有成就感?\n\n回答提示： 为贵公司竭力效劳，尽我所能，完成一个项目。\n\n\n# 眼下你生活中最重要的是什么?\n\n回答提示： 对我来说，能在这个领域找到工作是最重要的，能在贵公司任职对我说最重要。\n\n\n# 你为什么愿意到我们公司来工作?\n\n回答提示： 对于这个问题，你要格外小心，如果你已经对该单位作了研究，你可以回答一些详细的原因。\n\n回答样本： ①公司本身高技术开发环境很吸引我我同公司出生在同样的时代，我希望能够进入一家与我共同成长的公司。②你们公司一直都稳定发展，在近几年来在市场上有竞争力。我认为贵公司能够给我提供一个与众不同的发展道路。\n\n\n# 你和别人发生过争执吗?\n\n回答提示： 这是面试中最险恶的问题，其实是考官布下的一个陷阱，成功解决矛盾是一个协作团体中成员所必备的能力。假如你工作在一个服务行业，这个问题简直成了最重要的个环节。你是否能获得这份工作，将取决于这个问题的回答。考官希望看到你是成熟且乐于奉献的。他们通过这个问题了解你的成熟度和处世能力。在没有外界干涉的情况下，通过妥协的方式来解决才是正确答案。\n\n\n# 你做过的哪件事最令自己感到骄傲?\n\n回答提示： 这是考官给你的一个机会，让你展示自己把握命运的能力。这会体现你潜在的领导能力以及你被提升的可能性。假如你应聘于一个服务性质的单位，你很可能会被邀请去餐。记住：你的前途取决于你的知识、你的社交能力和综合表现。\n\n\n# 对这项工作，你有哪些可预见的困难?\n\n回答提示： ①不宜直接说出具体的困难，否则可能令对方怀疑应聘者不行。②可以尝试迂回战术，说出应聘者对困难所持有的态度工作中出现一些困难是正常的，也是难免的，但是只要有坚忍不拔的毅力、良好的合作精神以及事前周密而充分的准备，任何困难都是可以克服。\n\n\n# 录用后你将怎样开展工作?\n\n回答提示： ①如果应聘者对于应聘的职位缺乏足够的了解，最好不要直接说出自己开展工作的具体办法。②可以尝试采用迂回战术来回答，如“首先听取领导的指示和要求，然后就有关情况进行了解和熟悉，接下来制定一份近期的工作计划并报领导批准，最后根据计划开展工作。”。\n\n\n# 你希望与什么样的上级共事?\n\n回答提示： ①通过应聘者对上级的“希望”可以判断出应聘者对自我要求的意识，这既上一个陷阱，又是一次机会。②最好回避对上级具体的希望，多谈对自己的要求。如“做为刚步入社会的新人，我应该多要求自己尽快熟悉环境、适应环境，而不应该对环境提出什么要求，只要能发挥我的专长就可以了。\n\n\n# 你工作经验欠缺，如何能胜任这项工作?\n\n回答提示： ①如果招聘单位对应届毕业生的应聘者提出这个问题，说明招聘公司并不真正在乎经验，关键看应聘者怎样回答。②对这个问题的回答最好要体现出应聘者的诚恳、机智、果敢及敬业。\n\n回答样本： 作为应届毕业生，在工作经验方面的确会有所欠缺，因此在读书期间我一直利用各种机会在这个行业里做兼职。我也发现，实际工作远比书本知识丰富、复杂。但我有较强的责任心、适应能力和学习能力，而且比较勤奋，所以在兼职中均能圆满完成各项工作，从中获取的经验也令我受益非浅。请贵公司放心，学校所学及兼职的工作经验使我一定能胜任这个职位。\n\n\n# 你会怎样获得同事的帮助?\n\n回答提示： 每个公司都在不断变化发展的过程中，你当然希望你的员工也是这样。你希望得到那些希望并欢迎变化的人，因为这些明白，为了公司的发展，变化是公司日常生活中重要组成部分。这样的员工往往很容易适应公司的变化，并会对变化做出积极的响应。\n\n\n# 如果你没被录用，你怎么打算?\n\n回答样本： 现在的社会是一个竞争的社会，从这次面试中也可看出这一点，有竞争就必然有优劣，有成功必定就会有失败。往往成功的背后有许多的困难和挫折，如果这次失败了也仅仅是一次而已，只有经过经验经历的积累才能塑造出一个完全的成功者。我会从以下几个方面来正确看待这次失败：①要敢于面对，面对这次失败不气馁，接受已经失去了这次机会就不会回头这个现实，从心理意志和现出对这次失败的抵抗力。要有自信，相信自己经历了这次之后经过努力一定能行，能够超越自我。②善于反思，对于这次面试经验要认真总结，思考剖析，能够从自身的角度找差距正确对自己，实事求是地评价自己，辩证的看待自己的长短得失，做一个明白人。③走出阴影，克服这一次失败带给自己的心理压力，时刻牢记自己弱点，防患于未然，加强学习，提高自身素质。④认真工作，回到原单位岗位上后，要实实在在、踏踏实实地工作，三十六行行行出状元，争取在本岗位上做出一定的成绩。⑤再接再厉，以后如果有机会我仍然后再次参加竞争。\n\n\n# 最令你沮丧的事情?\n\n回答样本： 曾经接触过一个客户，原本就有耳闻他以挑剔出名，所以事前的准备功夫做得十分充分，也投入了相当多的时间与精力，最后客户虽然并没有照单全收，但是接受的程度已经出乎我们意料之外了。原以为从此可以合作愉快，却得知客户最后因为预算关系选择了另一家代理商，之前的努力因而付诸流水。尽管如此，我还是从这次的经验学到很多，如对该产业的了解，整个team的默契也更好了。\n\n\n# 想过创业吗?\n\n回答提示： 这个问题可以显示你的冲劲，但如果你的回答是“有”的话，千万小心，下一个问题可能就是：那么为什么你不这样做呢?\n\n\n# 为什么我们要在众多的面试者中选择你?\n\n回答提示： 别过度吹嘘自己的能力，或信口开河地乱开支票，例如一定会为该公司带来多少钱的业务等，这样很容易给人一种爱说大话、不切实际的感觉。\n\n回答样本： 根据我对贵公司的了解，以及我在这份工作上所累积的专业、经验及人脉，相信正是贵公司所找寻的人才。而我在工作态度、eq上，也有圆融、成熟的一面，和主管、同事都能合作愉快。\n\n\n# 除了本公司外，还应聘了哪些公司?\n\n回答提示： 这是相当多公司会问的问题，其用意是要概略知道应征者的求职志向，所以这并非绝对是负面答案，就算不便说出公司名称，也应回答“销售同种产品的公司”，如果应聘的其他公司是不同业界，容易让人产生无法信任的感觉。\n\n\n# 你并非毕业于名牌院校?\n\n回答样本： 是否毕业于名牌院校不重要，重要的是有能力完成您交给我的工作，我接受了xx的职业培训，掌握的技能完全可以胜任贵公司现在工作，而且我比一些名牌院校的应届毕业生的动手能力还要强，我想我更适合贵公司这个职位。\n\n\n# 怎样看待学历和能力?\n\n回答样本： 学历我想只要是大学专科的学历，就表明觉得我具备了根本的学习能力。剩下的，你是学士也好，还是博士也好，对于这一点的讨论，不是看你学了多少知识，而是看你在这个领域上发挥了什么，也就是所说的能力问题。一个人工作能力的高低直接决定其职场命运，而学历的高低只是进入一个企业的敲门砖，如果公司把学历卡在博士上我就无法进入贵公司，当然这不一定只是我个人的损失，如果一个专科生都能完成的工作，您又何必非要招聘一位博士生呢?\n\n\n# 谈谈如何适应办公室工作的新环境?\n\n回答样本： ①办公室里每个人都有各自的岗位与职责，不得擅离岗位。②根据领导指示和工作安排，制定工作计划，提前预备，并按计划完成。③多请示并及时汇报，遇到不明白的要虚心请教。④抓间隙时间，多学习，努力提高自己的政治素质和业务水平。\n\n\n# 谈谈对这个职务的期许?\n\n回答提示： 回答前不妨先询问公司对这项职务的责任认定及归属，因为每一家公司的状况不尽相同，以免说了一堆理想抱负却发现牛头不对马嘴。\n\n回答样本： 希望能借此发挥我的所学及专长，同时也吸收贵公司在这方面的经验，就公司、我个人而言，缔造双赢的局面。\n\n\n# 何时可以到职?\n\n回答提示： 大多数企业会关心就职时间，最好是回答：“如果被录用的话，到职日可以按公司规定上班”，但是如果还未辞去上一个工作、上班时间又太近，似乎有些强人所难，因为交接至少要一个月的时间，应进一步说明原因，录取公司应该会通融的。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"一个完美主义者的自我救赎",frontmatter:{title:"一个完美主义者的自我救赎",date:"2020-01-16T15:15:27.000Z",permalink:"/pages/2d615df9a36a98ed",categories:["更多","心情杂货"],tags:[null],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/01.%E4%B8%80%E4%B8%AA%E5%AE%8C%E7%BE%8E%E4%B8%BB%E4%B9%89%E8%80%85%E7%9A%84%E8%87%AA%E6%88%91%E6%95%91%E8%B5%8E.html",relativePath:"04.更多/05.心情杂货/01.一个完美主义者的自我救赎.md",key:"v-0c1b4099",path:"/pages/2d615df9a36a98ed/",excerpt:'<h1 id="一个完美主义者的自我救赎"><a class="header-anchor" href="#一个完美主义者的自我救赎">#</a> 一个完美主义者的自我救赎</h1>\n<p>最近，看到一个心理测试题是测试你是否有完美主义：</p>\n<blockquote>\n<p>（1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？</p>\n<p>（2）当一件事件做得不够好时，你是否有再试一次的想法？</p>\n<p>（3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？</p>\n<p>（4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？</p>\n<p>（5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？</p>\n</blockquote>\n<p>如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。</p>\n',headersStr:null,content:'# 一个完美主义者的自我救赎\n\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n> （1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n> \n> （2）当一件事件做得不够好时，你是否有再试一次的想法？\n> \n> （3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n> \n> （4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n> \n> （5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。\n\n对照自身，我就是那个完美主义者，时常会因为某件事做得不够好而感到痛苦，给我带来的后果就是：为了一件事想要达到“完美”的标准，付出了更多的成本，从而忽略真正需要优先处理的其他事情。最后，即使付出了成本，得到的结果也不一定是想要的"完美"。\n\n看过一篇文章，里面说到：\n\n> 完美主义是一种压力，它让你为自己创造不切实际的期望。你明明做到了正常水平，但是因为设定的目标太高，所以看上去距离目的地仍然很遥远。你的心态变成了：这一切还不够好，依然可以改进。\n> \n> 完美主义消耗了我们最宝贵的资源和时间，让你将注意力从真正的优先事项上移开。\n\n完美主义就是追求一个较高水平的目标，不接受一个较低水平的，但可用的结果。我一直告诫自己，改掉追求完美的毛病。\n\n完美主义已经对我造成了一些压力，还会妨碍我开始进入某些事情，总想着万事俱备之后才开始，结果是没有万事俱备，也没有东风，这事就搁置了。\n\n某个军事文章里说，他们特种部队的射击理念是：绝对快，相对准！\n\n> 玩吃鸡游戏似乎也是这样，需要你有快速的反应能力，不管打不打到人，先开枪再说，即使打不到也可以吓到敌人啊，哈哈哈\n\n这个理念似乎也适用于我这样的完美主义者，“做得快”比“做得好”要好，不要太执着于“完美”，就好像我开始写博客，我知道自己的写作水平并不好，但这并不妨碍我开始写博客，相信我会越写越好的~\n\n最后，心理医生也说过追求完美并不利于身心健康，不要追求完美，随心所欲地生活吧！',normalizedContent:'# 一个完美主义者的自我救赎\n\n最近，看到一个心理测试题是测试你是否有完美主义：\n\n> （1）你是不是经常为自己设定目标，而且最终往往达不到那些目标？\n> \n> （2）当一件事件做得不够好时，你是否有再试一次的想法？\n> \n> （3）你是否休息时仍想着学习、工作、或者其他还没有解决的事？\n> \n> （4）如果遇到别人说话或打岔，破坏了你的注意力，你是否觉得不太高兴？\n> \n> （5）你是否常常会在事后想，如果当时能换成另一种方式来解决，也许会更加理想？\n\n如果上面的问题，你的回答大部分是肯定的，那么你就有完美主义倾向。\n\n对照自身，我就是那个完美主义者，时常会因为某件事做得不够好而感到痛苦，给我带来的后果就是：为了一件事想要达到“完美”的标准，付出了更多的成本，从而忽略真正需要优先处理的其他事情。最后，即使付出了成本，得到的结果也不一定是想要的"完美"。\n\n看过一篇文章，里面说到：\n\n> 完美主义是一种压力，它让你为自己创造不切实际的期望。你明明做到了正常水平，但是因为设定的目标太高，所以看上去距离目的地仍然很遥远。你的心态变成了：这一切还不够好，依然可以改进。\n> \n> 完美主义消耗了我们最宝贵的资源和时间，让你将注意力从真正的优先事项上移开。\n\n完美主义就是追求一个较高水平的目标，不接受一个较低水平的，但可用的结果。我一直告诫自己，改掉追求完美的毛病。\n\n完美主义已经对我造成了一些压力，还会妨碍我开始进入某些事情，总想着万事俱备之后才开始，结果是没有万事俱备，也没有东风，这事就搁置了。\n\n某个军事文章里说，他们特种部队的射击理念是：绝对快，相对准！\n\n> 玩吃鸡游戏似乎也是这样，需要你有快速的反应能力，不管打不打到人，先开枪再说，即使打不到也可以吓到敌人啊，哈哈哈\n\n这个理念似乎也适用于我这样的完美主义者，“做得快”比“做得好”要好，不要太执着于“完美”，就好像我开始写博客，我知道自己的写作水平并不好，但这并不妨碍我开始写博客，相信我会越写越好的~\n\n最后，心理医生也说过追求完美并不利于身心健康，不要追求完美，随心所欲地生活吧！',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"反向拆解让人上瘾的套路，找回自律",frontmatter:{title:"反向拆解让人上瘾的套路，找回自律",date:"2020-07-22T13:05:49.000Z",permalink:"/pages/d6d331/",categories:["更多","心情杂货"],tags:["心理","自律"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/04.%E6%9B%B4%E5%A4%9A/05.%E5%BF%83%E6%83%85%E6%9D%82%E8%B4%A7/10.%E5%8F%8D%E5%90%91%E6%8B%86%E8%A7%A3%E8%AE%A9%E4%BA%BA%E4%B8%8A%E7%98%BE%E7%9A%84%E5%A5%97%E8%B7%AF%EF%BC%8C%E6%89%BE%E5%9B%9E%E8%87%AA%E5%BE%8B.html",relativePath:"04.更多/05.心情杂货/10.反向拆解让人上瘾的套路，找回自律.md",key:"v-1bd6c58a",path:"/pages/d6d331/",headers:[{level:3,title:"1.诱人的目标",slug:"_1-诱人的目标",normalizedTitle:"1.诱人的目标",charIndex:451},{level:3,title:"2.无法抵挡无法预知的积极反馈",slug:"_2-无法抵挡无法预知的积极反馈",normalizedTitle:"2.无法抵挡无法预知的积极反馈",charIndex:505},{level:3,title:"3.渐进式的进步和改善的感觉",slug:"_3-渐进式的进步和改善的感觉",normalizedTitle:"3.渐进式的进步和改善的感觉",charIndex:678},{level:3,title:"4.随着时间的推移越来越困难的任务",slug:"_4-随着时间的推移越来越困难的任务",normalizedTitle:"4.随着时间的推移越来越困难的任务",charIndex:718},{level:3,title:"5.需要解决却又暂未解决的紧张感",slug:"_5-需要解决却又暂未解决的紧张感",normalizedTitle:"5.需要解决却又暂未解决的紧张感",charIndex:760},{level:3,title:"6.强大的社会联系",slug:"_6-强大的社会联系",normalizedTitle:"6.强大的社会联系",charIndex:836},{level:2,title:"找回自律，收获积极而长久的快乐",slug:"找回自律-收获积极而长久的快乐",normalizedTitle:"找回自律，收获积极而长久的快乐",charIndex:909}],excerpt:'<h1 id="反向拆解让人上瘾的套路-找回自律"><a class="header-anchor" href="#反向拆解让人上瘾的套路-找回自律">#</a> 反向拆解让人上瘾的套路，找回自律</h1>\n<p>当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&amp;AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？</p>\n',headersStr:"1.诱人的目标 2.无法抵挡无法预知的积极反馈 3.渐进式的进步和改善的感觉 4.随着时间的推移越来越困难的任务 5.需要解决却又暂未解决的紧张感 6.强大的社会联系 找回自律，收获积极而长久的快乐",content:"# 反向拆解让人上瘾的套路，找回自律\n\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&AR体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？\n\n《欲罢不能》\n\n数字时代比人类历史上的任何时代都更容易上瘾...Facebook、Instagram、网络色情、网购在下钩... 问题不出在人缺乏意志力上，而在于“屏幕那边有数千人在努力工作，为的就是破坏你的自律”\n\n来自《欲罢不能-刷屏时代如何摆脱行为上瘾》一书\n\n我们正在被一个算法和娱乐所包裹的电子'海洛因'中却不自知，想要摆脱这些上瘾行为，第一步就是反向拆解那些让我们上瘾的产品的套路。《欲罢不能》书中总结了六个让人上瘾的钩子：\n\n\n# 1.诱人的目标\n\n * 色情片\n * 游戏中成为\"王者\"、层出不穷的高颜值皮肤...\n * ...\n\n\n# 2.无法抵挡无法预知的积极反馈\n\n * 社交中的点赞功能\n * 某音十几秒一条的视频，不需要你动脑就可以轻轻松松获得哈哈大笑的快感，有时候还有一种我学习到了的感觉，你永远猜不到下一条将会出现什么惊喜。你刷的越多算法就越精准，越知道你的情绪G点在哪里，你就越容易被俘获。\n * 直播中的打赏被主播表示的感谢和送上的'么么哒'\n * ...\n\n\n# 3.渐进式的进步和改善的感觉\n\n * 游戏中的升级策略\n\n * ...\n\n\n# 4.随着时间的推移越来越困难的任务\n\n * 游戏中的升级策略\n * ...\n\n\n# 5.需要解决却又暂未解决的紧张感\n\n * 电影或电视剧结尾有意制造的一个悬念，给你一种未完成的紧张感，你迫切想知道后面会发生什么\n * ...\n\n\n# 6.强大的社会联系\n\n * 与队友相约开黑\n\n * 游戏中能彰显地位、财富、能力等的装备（如：吃鸡游戏中的玛莎拉蒂皮肤）\n\n * ...\n\n\n# 找回自律，收获积极而长久的快乐\n\n获得快乐的方式，你可以选择沉迷在你的手机里刷视频、打游戏、煲剧，毫不费力的收货大把的快乐。你还可以选择一条更难的路：选择自律、选择延迟满足、选择会让你不那么舒服的努力和成长。\n\n收获快乐的方式没有绝对的对与错，但是，如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。过后还可能让你浪费了大把时间，该做的正事没有完成，你感觉空虚、焦躁、自责... 既然如此，我们一起选择那条更难的路吧！\n\n上瘾的案例收集\n\n想想你生活中让你上瘾的案例，对照上面让人上瘾的钩子，看看是哪个钩子吧~~欢迎留言哦~",normalizedContent:"# 反向拆解让人上瘾的套路，找回自律\n\n当你打开手机准备学习或者查个资料的时候，很有可能不知不觉的就脱离的正规... 某某app发来通知：xx明星官宣啦、xx手游重磅上线，一起开启修仙之旅吧！ xx结衣发布新番-4k画质&ar体验、99+未读信息、支付宝到账100万元.... 你心想，就看一会，就一会儿... 不知不觉两三个小时过去了，你开始焦躁、后悔、自责。第二天，你又掉进相同的坑里。你可能会纳闷，为什么我的自制力这么差？为什么对某件事欲罢不能？\n\n《欲罢不能》\n\n数字时代比人类历史上的任何时代都更容易上瘾...facebook、instagram、网络色情、网购在下钩... 问题不出在人缺乏意志力上，而在于“屏幕那边有数千人在努力工作，为的就是破坏你的自律”\n\n来自《欲罢不能-刷屏时代如何摆脱行为上瘾》一书\n\n我们正在被一个算法和娱乐所包裹的电子'海洛因'中却不自知，想要摆脱这些上瘾行为，第一步就是反向拆解那些让我们上瘾的产品的套路。《欲罢不能》书中总结了六个让人上瘾的钩子：\n\n\n# 1.诱人的目标\n\n * 色情片\n * 游戏中成为\"王者\"、层出不穷的高颜值皮肤...\n * ...\n\n\n# 2.无法抵挡无法预知的积极反馈\n\n * 社交中的点赞功能\n * 某音十几秒一条的视频，不需要你动脑就可以轻轻松松获得哈哈大笑的快感，有时候还有一种我学习到了的感觉，你永远猜不到下一条将会出现什么惊喜。你刷的越多算法就越精准，越知道你的情绪g点在哪里，你就越容易被俘获。\n * 直播中的打赏被主播表示的感谢和送上的'么么哒'\n * ...\n\n\n# 3.渐进式的进步和改善的感觉\n\n * 游戏中的升级策略\n\n * ...\n\n\n# 4.随着时间的推移越来越困难的任务\n\n * 游戏中的升级策略\n * ...\n\n\n# 5.需要解决却又暂未解决的紧张感\n\n * 电影或电视剧结尾有意制造的一个悬念，给你一种未完成的紧张感，你迫切想知道后面会发生什么\n * ...\n\n\n# 6.强大的社会联系\n\n * 与队友相约开黑\n\n * 游戏中能彰显地位、财富、能力等的装备（如：吃鸡游戏中的玛莎拉蒂皮肤）\n\n * ...\n\n\n# 找回自律，收获积极而长久的快乐\n\n获得快乐的方式，你可以选择沉迷在你的手机里刷视频、打游戏、煲剧，毫不费力的收货大把的快乐。你还可以选择一条更难的路：选择自律、选择延迟满足、选择会让你不那么舒服的努力和成长。\n\n收获快乐的方式没有绝对的对与错，但是，如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。过后还可能让你浪费了大把时间，该做的正事没有完成，你感觉空虚、焦躁、自责... 既然如此，我们一起选择那条更难的路吧！\n\n上瘾的案例收集\n\n想想你生活中让你上瘾的案例，对照上面让人上瘾的钩子，看看是哪个钩子吧~~欢迎留言哦~",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"2分钟规则",frontmatter:{title:"2分钟规则",date:"2020-11-09T11:05:29.000Z",permalink:"/pages/baaa02/",categories:["更多","实用技巧"],tags:["实用技巧","文摘"]},regularPath:"/04.%E6%9B%B4%E5%A4%9A/10.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/01.2%E5%88%86%E9%92%9F%E8%A7%84%E5%88%99.html",relativePath:"04.更多/10.实用技巧/01.2分钟规则.md",key:"v-4688d30f",path:"/pages/baaa02/",excerpt:"<p>每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。</p>\n<ul>\n<li>看一本书 → 看一页书</li>\n<li>写一篇文章 → 写一句话</li>\n<li>跑10公里 → 穿上跑鞋</li>\n<li>做100次俯卧撑 → 做1次俯卧撑</li>\n<li>多吃蔬菜水果 → 吃一个水果</li>\n<li>编写一个程序 → 编写一个函数 → 编写一行代码</li>\n</ul>\n",headersStr:null,content:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n * 看一本书 → 看一页书\n * 写一篇文章 → 写一句话\n * 跑10公里 → 穿上跑鞋\n * 做100次俯卧撑 → 做1次俯卧撑\n * 多吃蔬菜水果 → 吃一个水果\n * 编写一个程序 → 编写一个函数 → 编写一行代码\n\n这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。\n\n * 阅读一页 → 阅读10页 → 读完第一章\n * 写一个句子 → 写文章的开头 → 写出正文\n * 穿上跑鞋 → 步行5分钟 → 跑步5分钟\n\n一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。\n\n> 本文摘录自 https://hoanhan.co/2-minute-rule",normalizedContent:"每当你发现很难开始执行某项任务时，可以试试将其缩减成2分钟的版本。\n\n * 看一本书 → 看一页书\n * 写一篇文章 → 写一句话\n * 跑10公里 → 穿上跑鞋\n * 做100次俯卧撑 → 做1次俯卧撑\n * 多吃蔬菜水果 → 吃一个水果\n * 编写一个程序 → 编写一个函数 → 编写一行代码\n\n这样做的目的是使上手变得超级容易，让你先上手再说。一旦开始做了（这可能是最艰难的一步），你就会开始有动力，可能会继续做下去。\n\n * 阅读一页 → 阅读10页 → 读完第一章\n * 写一个句子 → 写文章的开头 → 写出正文\n * 穿上跑鞋 → 步行5分钟 → 跑步5分钟\n\n一旦开始，继续做下去就会容易得多。有时，你甚至会发现，自己在不知不觉间已经完成了任务。\n\n> 本文摘录自 https://hoanhan.co/2-minute-rule",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"一行代码“黑”掉任意网站",frontmatter:{title:"一行代码“黑”掉任意网站",date:"2021-11-25T14:33:51.000Z",permalink:"/pages/dcebaf/",titleTag:"原创",sticky:1,categories:["更多","实用技巧"],tags:["JavaScript","css","实用技巧"]},regularPath:"/04.%E6%9B%B4%E5%A4%9A/10.%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/10.%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E2%80%9C%E9%BB%91%E2%80%9D%E6%8E%89%E4%BB%BB%E6%84%8F%E7%BD%91%E7%AB%99.html",relativePath:"04.更多/10.实用技巧/10.一行代码“黑”掉任意网站.md",key:"v-5724ced2",path:"/pages/dcebaf/",excerpt:'<h1 id="一行代码-黑-掉任意网站"><a class="header-anchor" href="#一行代码-黑-掉任意网站">#</a> 一行代码“黑”掉任意网站</h1>\n<p>实用技巧：只需一行代码，轻轻一点就可以把任意网站变成暗黑模式。\n<p align="center"><img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/QQ20211125-163111.2tmjlvz28n80.png" width="500" style="cursor: zoom-in;"></p></p>\n',headersStr:null,content:"# 一行代码“黑”掉任意网站\n\n实用技巧：只需一行代码，轻轻一点就可以把任意网站变成暗黑模式。\n\n\n\n\n\n首先我们先做一个实验，在任意网站中，打开浏览器开发者工具(F12)，在Console控制台输入如下代码并回车：\n\ndocument.documentElement.style.filter='invert(85%) hue-rotate(180deg)'\n\n\n1\n\n\n神奇的事情发生了，当前打开的网站变成了暗黑模式。\n\n原理解释\n 1. document.documentElement 获取文档对象的根元素，即<html>元素\n 2. 给html元素的.style样式添加filter滤镜样式为invert(85%) hue-rotate(180deg)\n 3. invert() 反转图像。\n 4. hue-rotate()色相旋转。\n\n更多滤镜知识：filter。\n\n为了更方便实用，达到轻轻一点就可以对网页施加魔法🎉，\n\n我们对代码做了一点点🤏🏻改动。（修正了滤镜对图片等元素的影响）\n\njavascript: (function () {  const docStyle = document.documentElement.style;  if (!window.modeIndex) {    window.modeIndex = 0;  }  const styleList = [    '',    'invert(85%) hue-rotate(180deg)',   'invert(100%) hue-rotate(180deg)',  ];  modeIndex = modeIndex >= styleList.length - 1 ? 0 : modeIndex + 1;  docStyle.filter = styleList[modeIndex];  document.body.querySelectorAll('img, picture, video').forEach(el => el.style.filter = modeIndex ? 'invert(1) hue-rotate(180deg)' : '');})();\n\n\n1\n\n\n然后打开浏览器书签管理器，添加新书签，在网址栏粘贴这段代码并保存：\n\n\n\n\n\n以后在任意网站，只需要轻轻一点切换模式书签就可以让它变成85%的暗黑，再点一次就是100%的暗黑，再点一次变回正常模式。\n\n",normalizedContent:"# 一行代码“黑”掉任意网站\n\n实用技巧：只需一行代码，轻轻一点就可以把任意网站变成暗黑模式。\n\n\n\n\n\n首先我们先做一个实验，在任意网站中，打开浏览器开发者工具(f12)，在console控制台输入如下代码并回车：\n\ndocument.documentelement.style.filter='invert(85%) hue-rotate(180deg)'\n\n\n1\n\n\n神奇的事情发生了，当前打开的网站变成了暗黑模式。\n\n原理解释\n 1. document.documentelement 获取文档对象的根元素，即<html>元素\n 2. 给html元素的.style样式添加filter滤镜样式为invert(85%) hue-rotate(180deg)\n 3. invert() 反转图像。\n 4. hue-rotate()色相旋转。\n\n更多滤镜知识：filter。\n\n为了更方便实用，达到轻轻一点就可以对网页施加魔法🎉，\n\n我们对代码做了一点点🤏🏻改动。（修正了滤镜对图片等元素的影响）\n\njavascript: (function () {  const docstyle = document.documentelement.style;  if (!window.modeindex) {    window.modeindex = 0;  }  const stylelist = [    '',    'invert(85%) hue-rotate(180deg)',   'invert(100%) hue-rotate(180deg)',  ];  modeindex = modeindex >= stylelist.length - 1 ? 0 : modeindex + 1;  docstyle.filter = stylelist[modeindex];  document.body.queryselectorall('img, picture, video').foreach(el => el.style.filter = modeindex ? 'invert(1) hue-rotate(180deg)' : '');})();\n\n\n1\n\n\n然后打开浏览器书签管理器，添加新书签，在网址栏粘贴这段代码并保存：\n\n\n\n\n\n以后在任意网站，只需要轻轻一点切换模式书签就可以让它变成85%的暗黑，再点一次就是100%的暗黑，再点一次变回正常模式。\n\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"友情链接",frontmatter:{title:"友情链接",date:"2019-12-25T14:27:01.000Z",permalink:"/friends",article:!1,sidebar:!1},regularPath:"/04.%E6%9B%B4%E5%A4%9A/99.%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5.html",relativePath:"04.更多/99.友情链接.md",key:"v-af4c07f2",path:"/friends/",headers:[{level:3,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:5988}],headersStr:"友链申请",content:"麋鹿鲁哟\n\n大道至简，知易行难\n\nXAOXUU\n\n#IOS #Volantis主题作者\n\nlookroot的个人空间\n\n寻求理想和显示的平衡\n\n平凡的你我\n\n理想成为大牛的\n小陈同学\n\nznote\n\n荷尽已无擎雨盖，\n菊残犹有傲霜枝。\n\n全栈软件开发直通车\n\n全栈软件开发技术博客，\n从小白到大神!\n\n易良同学的博客\n\n正在努力！\n\n永远的救赎者\n\n知者减半，省者全无。\n\n辰旭博客\n\n凤鸣初阳，百鸟朝凰\n\nJokerM's Palace\n\nTake your heart\n\nSaul.J.Wu\n\n立身之本，不在高低。\n\nLake's blog\n\n不积跬步，无以至千里；不积小流，无以成江海。\n\nCubik的小站\n\nRECOMMENDED BY DR.CREATIVE\n\nx·π\n\n为开发者量身制作的技术博客和知识库管理平台。\n\n眼里有光\n\n道阻且长，行则将至\n\nHeo\n\n爱折腾的设计师\n\nChuyuxuan\n\n临渊羡鱼，不如退而结网\n\n全栈杂货站\n\n千里万里杂货站里，天青色等烟雨，而我在等你。\n\n小鱼博客\n\n总是半途而废的废柴\n\n大胡子\n\n记录你我，分享精彩。\n\n嘟先生学WebGL\n\n流水不争先，争的是滔滔不绝。\n\n嶋屿麋鹿\n\n小鹿的知识库\n\n@小右_\n\n学而不厌 不耻下问\n\n途中的树\n\n走出自己的傲慢，承认自己的局限。\n\nHaobo's Blog\n\n半只脚跨入炼丹师的大门的新人\n\n小胖墩er\n\n迟到总比不到的好，所以好好加油吧。\n\nCloudNative Operations\n\n专注于云原生运维,致敬每个爱学习的你。\n\nJoseph Z.\n\nJoseph Z.的小站\n\n二丫讲梵\n\n💻学习📝记录🔗分享\n\nYoungKbt World\n\n故事由我书写，旅程由你见证，传奇由她聆听\n\nXuHuaian,s Blog\n\n记录自己的工作学习心得，争取当一条有梦想的咸鱼\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgColor: '#CBEAFA' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n- name: XAOXUU\n  desc: '#IOS #Volantis主题作者'\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgColor: '#B9D59C'\n  textColor: '#3B551F'\n- name: lookroot的个人空间\n  desc: 寻求理想和显示的平衡\n  avatar: https://www.lookroot.cn/logo.png\n  link: https://www.lookroot.cn/\n  bgColor: '#B7DBFF'\n  textColor: '#294D71'\n- name: 平凡的你我\n  desc: 理想成为大牛的<br/>小陈同学\n  avatar: https://reinness.com/static/avatar.png\n  link: https://reinness.com\n  bgColor: '#FFE5B4'\n  textColor: '#A05F2C'\n- name: znote\n  desc: 荷尽已无擎雨盖，<br/>菊残犹有傲霜枝。\n  avatar: https://zpj80231.gitee.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.gitee.io/znote/\n  bgColor: '#FCE5BF'\n  textColor: '#7B2532'\n- name: 全栈软件开发直通车\n  desc: 全栈软件开发技术博客，<br/>从小白到大神!\n  avatar: https://gitee.com/wangshibiao/blog_picBed2/raw/master/images/20200806151030.png\n  link: https://sofineday.com\n  bgColor: '#FBEBEC'\n  textColor: '#603420'\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpeg\n  link: https://yiliang.site\n  bgColor: '#FFEFE2'\n  textColor: '#A05F2C'\n- name: 永远的救赎者\n  desc: 知者减半，省者全无。\n  avatar: https://i.loli.net/2020/08/10/PkQMGL6pATW1vBg.jpg\n  link: http://www.yuanchengcheng.vip/\n  bgColor: '#FBEBEC'\n  textColor: '#603420'\n- name: 辰旭博客\n  desc: 凤鸣初阳，百鸟朝凰\n  avatar: https://s1.ax1x.com/2020/08/09/aoLTDx.png\n  link: https://kareny.cn\n  bgColor: '#FFCEDE'\n  textColor: '#621529'\n- name: JokerM's Palace\n  desc: Take your heart\n  avatar: https://jokerm.com/wp-content/uploads/2020/09/jmflogo.png\n  link: https://jokerm.com/\n- name: Saul.J.Wu\n  desc: 立身之本，不在高低。\n  avatar: https://gitee.com/SaulJWu/blog-images/raw/master/images/20210627222322.jpg\n  link: https://sauljwu.github.io/\n- name: Lake's blog\n  desc: 不积跬步，无以至千里；不积小流，无以成江海。\n  avatar: https://cdn.jsdelivr.net/gh/taixingyiji/image_store@main/blog/logo/img.png\n  link: https://taixingyiji.com/\n- name: Cubik的小站\n  desc: RECOMMENDED BY DR.CREATIVE\n  avatar: https://cdn.jsdelivr.net/gh/Cubik65536/cubik-favicons@main/CubikLogo.png\n  link: https://www.cubik65536.top/\n- name: x·π\n  desc: 为开发者量身制作的技术博客和知识库管理平台。\n  avatar: https://cdn.jsdelivr.net/gh/Ezuy-Lee/RainzeDrawingBed/media/logo.png\n  link: https://ezuy-lee.github.io/xpai/\n- name: 眼里有光\n  desc: 道阻且长，行则将至\n  avatar: https://icooloop.gitee.io/img/logo.jpg\n  link: https://icooloop.gitee.io/\n- name: Heo\n  desc: 爱折腾的设计师\n  link: https://blog.zhheo.com/\n  avatar: https://blog.zhheo.com/img/avatar.png\n- name: Chuyuxuan\n  desc: 临渊羡鱼，不如退而结网\n  link: https://blog.chuyuxuan.top/\n  avatar: http://blog.chuyuxuan.top/img/avatar1.jpg\n- name: 全栈杂货站\n  desc: 千里万里杂货站里，天青色等烟雨，而我在等你。\n  avatar: http://cdn.tea-culture.top/tech/images/avatar/3.jpg\n  link: http://tech.tea-culture.top/\n- name: 小鱼博客\n  desc: 总是半途而废的废柴\n  avatar: https://cdn.jsdelivr.net/gh/xiaoyu-666/image_store/blog/minion.png\n  link: https://xiaoyu-666.github.io/\n- name: 大胡子\n  desc: 记录你我，分享精彩。\n  avatar: https://photo.jakehu.cn/favicon.png\n  link: https://www.jakehu.cn\n- name: 嘟先生学WebGL\n  desc: 流水不争先，争的是滔滔不绝。\n  avatar: https://joy1412.cn/img/dudu.jpeg\n  link: https://joy1412.cn\n- name: 嶋屿麋鹿\n  desc: 小鹿的知识库\n  avatar: https://www.fongloo.com/img/logo.png\n  link: https://www.fongloo.com/\n- name: '@小右_'\n  desc: 学而不厌 不耻下问\n  avatar: https://lordblog.cn/upload/2021/05/logo%20(4)-742f1f7e15db44a1b3140035104ea239.png\n  link: https://lordblog.cn/\n- name: 途中的树\n  desc: 走出自己的傲慢，承认自己的局限。\n  avatar: https://zkpeace.com/blog/img/avatar.jpg\n  link: https://zkpeace.com/\n- name: Haobo's Blog\n  link: https://discover304.top/\n  avatar: https://discover304.top/img/head.png\n  desc: 半只脚跨入炼丹师的大门的新人\n- name: 小胖墩er\n  desc: 迟到总比不到的好，所以好好加油吧。\n  avatar: https://cdn.jsdelivr.net/gh/Chubby-Duner/image-hosting@master/blog/logo.jpeg\n  link: https://chubbyduner.top\n- name: CloudNative Operations\n  desc: 专注于云原生运维,致敬每个爱学习的你。\n  avatar: https://kubesre.com/img/logo.png\n  link: https://kubesre.com/\n- name: Joseph Z.\n  desc: Joseph Z.的小站\n  avatar: https://josephz.top/res/joseph.jpg\n  link: https://josephz.top/\n- name: 二丫讲梵 # 昵称\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: https://wiki.eryajf.net/img/logo.png # 头像\n  link: https://wiki.eryajf.net/  # 链接\n- name: YoungKbt World\t# 昵称\n  desc: 故事由我书写，旅程由你见证，传奇由她聆听\t# 介绍\n  avatar: https://cdn.jsdelivr.net/gh/Kele-Bingtang/static/user/avatar2.png\t# 头像\n  link: https://notes.youngkbt.cn/\t# 链接\n- name: XuHuaian,s Blog # 昵称\n  desc: 记录自己的工作学习心得，争取当一条有梦想的咸鱼 # 介绍\n  avatar: https://dbsecurity.com.cn/images/logo.jpg # 头像\n  link: https://dbsecurity.com.cn/# 链接\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: Evan's blog # 昵称\n  desc: 积跬步以至千里，喜欢学习喜欢你。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像\n  link: https://xugaoyi.com/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",normalizedContent:"麋鹿鲁哟\n\n大道至简，知易行难\n\nxaoxuu\n\n#ios #volantis主题作者\n\nlookroot的个人空间\n\n寻求理想和显示的平衡\n\n平凡的你我\n\n理想成为大牛的\n小陈同学\n\nznote\n\n荷尽已无擎雨盖，\n菊残犹有傲霜枝。\n\n全栈软件开发直通车\n\n全栈软件开发技术博客，\n从小白到大神!\n\n易良同学的博客\n\n正在努力！\n\n永远的救赎者\n\n知者减半，省者全无。\n\n辰旭博客\n\n凤鸣初阳，百鸟朝凰\n\njokerm's palace\n\ntake your heart\n\nsaul.j.wu\n\n立身之本，不在高低。\n\nlake's blog\n\n不积跬步，无以至千里；不积小流，无以成江海。\n\ncubik的小站\n\nrecommended by dr.creative\n\nx·π\n\n为开发者量身制作的技术博客和知识库管理平台。\n\n眼里有光\n\n道阻且长，行则将至\n\nheo\n\n爱折腾的设计师\n\nchuyuxuan\n\n临渊羡鱼，不如退而结网\n\n全栈杂货站\n\n千里万里杂货站里，天青色等烟雨，而我在等你。\n\n小鱼博客\n\n总是半途而废的废柴\n\n大胡子\n\n记录你我，分享精彩。\n\n嘟先生学webgl\n\n流水不争先，争的是滔滔不绝。\n\n嶋屿麋鹿\n\n小鹿的知识库\n\n@小右_\n\n学而不厌 不耻下问\n\n途中的树\n\n走出自己的傲慢，承认自己的局限。\n\nhaobo's blog\n\n半只脚跨入炼丹师的大门的新人\n\n小胖墩er\n\n迟到总比不到的好，所以好好加油吧。\n\ncloudnative operations\n\n专注于云原生运维,致敬每个爱学习的你。\n\njoseph z.\n\njoseph z.的小站\n\n二丫讲梵\n\n💻学习📝记录🔗分享\n\nyoungkbt world\n\n故事由我书写，旅程由你见证，传奇由她聆听\n\nxuhuaian,s blog\n\n记录自己的工作学习心得，争取当一条有梦想的咸鱼\n\n- name: 麋鹿鲁哟\n  desc: 大道至简，知易行难\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200122153807.jpg # 可选\n  link: https://www.cnblogs.com/miluluyo/ # 可选\n  bgcolor: '#cbeafa' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n- name: xaoxuu\n  desc: '#ios #volantis主题作者'\n  avatar: https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png\n  link: https://xaoxuu.com\n  bgcolor: '#b9d59c'\n  textcolor: '#3b551f'\n- name: lookroot的个人空间\n  desc: 寻求理想和显示的平衡\n  avatar: https://www.lookroot.cn/logo.png\n  link: https://www.lookroot.cn/\n  bgcolor: '#b7dbff'\n  textcolor: '#294d71'\n- name: 平凡的你我\n  desc: 理想成为大牛的<br/>小陈同学\n  avatar: https://reinness.com/static/avatar.png\n  link: https://reinness.com\n  bgcolor: '#ffe5b4'\n  textcolor: '#a05f2c'\n- name: znote\n  desc: 荷尽已无擎雨盖，<br/>菊残犹有傲霜枝。\n  avatar: https://zpj80231.gitee.io/znote/vuepress/head-fish.jpg\n  link: https://zpj80231.gitee.io/znote/\n  bgcolor: '#fce5bf'\n  textcolor: '#7b2532'\n- name: 全栈软件开发直通车\n  desc: 全栈软件开发技术博客，<br/>从小白到大神!\n  avatar: https://gitee.com/wangshibiao/blog_picbed2/raw/master/images/20200806151030.png\n  link: https://sofineday.com\n  bgcolor: '#fbebec'\n  textcolor: '#603420'\n- name: 易良同学的博客\n  desc: 正在努力！\n  avatar: https://yiliang.site/assets/images/avatar.jpeg\n  link: https://yiliang.site\n  bgcolor: '#ffefe2'\n  textcolor: '#a05f2c'\n- name: 永远的救赎者\n  desc: 知者减半，省者全无。\n  avatar: https://i.loli.net/2020/08/10/pkqmgl6patw1vbg.jpg\n  link: http://www.yuanchengcheng.vip/\n  bgcolor: '#fbebec'\n  textcolor: '#603420'\n- name: 辰旭博客\n  desc: 凤鸣初阳，百鸟朝凰\n  avatar: https://s1.ax1x.com/2020/08/09/aoltdx.png\n  link: https://kareny.cn\n  bgcolor: '#ffcede'\n  textcolor: '#621529'\n- name: jokerm's palace\n  desc: take your heart\n  avatar: https://jokerm.com/wp-content/uploads/2020/09/jmflogo.png\n  link: https://jokerm.com/\n- name: saul.j.wu\n  desc: 立身之本，不在高低。\n  avatar: https://gitee.com/sauljwu/blog-images/raw/master/images/20210627222322.jpg\n  link: https://sauljwu.github.io/\n- name: lake's blog\n  desc: 不积跬步，无以至千里；不积小流，无以成江海。\n  avatar: https://cdn.jsdelivr.net/gh/taixingyiji/image_store@main/blog/logo/img.png\n  link: https://taixingyiji.com/\n- name: cubik的小站\n  desc: recommended by dr.creative\n  avatar: https://cdn.jsdelivr.net/gh/cubik65536/cubik-favicons@main/cubiklogo.png\n  link: https://www.cubik65536.top/\n- name: x·π\n  desc: 为开发者量身制作的技术博客和知识库管理平台。\n  avatar: https://cdn.jsdelivr.net/gh/ezuy-lee/rainzedrawingbed/media/logo.png\n  link: https://ezuy-lee.github.io/xpai/\n- name: 眼里有光\n  desc: 道阻且长，行则将至\n  avatar: https://icooloop.gitee.io/img/logo.jpg\n  link: https://icooloop.gitee.io/\n- name: heo\n  desc: 爱折腾的设计师\n  link: https://blog.zhheo.com/\n  avatar: https://blog.zhheo.com/img/avatar.png\n- name: chuyuxuan\n  desc: 临渊羡鱼，不如退而结网\n  link: https://blog.chuyuxuan.top/\n  avatar: http://blog.chuyuxuan.top/img/avatar1.jpg\n- name: 全栈杂货站\n  desc: 千里万里杂货站里，天青色等烟雨，而我在等你。\n  avatar: http://cdn.tea-culture.top/tech/images/avatar/3.jpg\n  link: http://tech.tea-culture.top/\n- name: 小鱼博客\n  desc: 总是半途而废的废柴\n  avatar: https://cdn.jsdelivr.net/gh/xiaoyu-666/image_store/blog/minion.png\n  link: https://xiaoyu-666.github.io/\n- name: 大胡子\n  desc: 记录你我，分享精彩。\n  avatar: https://photo.jakehu.cn/favicon.png\n  link: https://www.jakehu.cn\n- name: 嘟先生学webgl\n  desc: 流水不争先，争的是滔滔不绝。\n  avatar: https://joy1412.cn/img/dudu.jpeg\n  link: https://joy1412.cn\n- name: 嶋屿麋鹿\n  desc: 小鹿的知识库\n  avatar: https://www.fongloo.com/img/logo.png\n  link: https://www.fongloo.com/\n- name: '@小右_'\n  desc: 学而不厌 不耻下问\n  avatar: https://lordblog.cn/upload/2021/05/logo%20(4)-742f1f7e15db44a1b3140035104ea239.png\n  link: https://lordblog.cn/\n- name: 途中的树\n  desc: 走出自己的傲慢，承认自己的局限。\n  avatar: https://zkpeace.com/blog/img/avatar.jpg\n  link: https://zkpeace.com/\n- name: haobo's blog\n  link: https://discover304.top/\n  avatar: https://discover304.top/img/head.png\n  desc: 半只脚跨入炼丹师的大门的新人\n- name: 小胖墩er\n  desc: 迟到总比不到的好，所以好好加油吧。\n  avatar: https://cdn.jsdelivr.net/gh/chubby-duner/image-hosting@master/blog/logo.jpeg\n  link: https://chubbyduner.top\n- name: cloudnative operations\n  desc: 专注于云原生运维,致敬每个爱学习的你。\n  avatar: https://kubesre.com/img/logo.png\n  link: https://kubesre.com/\n- name: joseph z.\n  desc: joseph z.的小站\n  avatar: https://josephz.top/res/joseph.jpg\n  link: https://josephz.top/\n- name: 二丫讲梵 # 昵称\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: https://wiki.eryajf.net/img/logo.png # 头像\n  link: https://wiki.eryajf.net/  # 链接\n- name: youngkbt world\t# 昵称\n  desc: 故事由我书写，旅程由你见证，传奇由她聆听\t# 介绍\n  avatar: https://cdn.jsdelivr.net/gh/kele-bingtang/static/user/avatar2.png\t# 头像\n  link: https://notes.youngkbt.cn/\t# 链接\n- name: xuhuaian,s blog # 昵称\n  desc: 记录自己的工作学习心得，争取当一条有梦想的咸鱼 # 介绍\n  avatar: https://dbsecurity.com.cn/images/logo.jpg # 头像\n  link: https://dbsecurity.com.cn/# 链接\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: evan's blog # 昵称\n  desc: 积跬步以至千里，喜欢学习喜欢你。 # 介绍\n  avatar: https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg # 头像\n  link: https://xugaoyi.com/  # 链接\n\n\n1\n2\n3\n4\n\n\n申请前记得先添加本站哦~",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"关于",frontmatter:{title:"关于",date:"2019-12-25T14:27:01.000Z",permalink:"/about",sidebar:!1,article:!1},regularPath:"/05.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"05.关于/01.关于.md",key:"v-09b2f671",path:"/about/",headers:[{level:2,title:"📚Blog",slug:"📚blog",normalizedTitle:"📚blog",charIndex:2},{level:2,title:"🎨Theme",slug:"🎨theme",normalizedTitle:"🎨theme",charIndex:140},{level:2,title:"🐼Me",slug:"🐼me",normalizedTitle:"🐼me",charIndex:292},{level:3,title:"技能",slug:"技能",normalizedTitle:"技能",charIndex:311},{level:2,title:"前端学习",slug:"前端学习",normalizedTitle:"前端学习",charIndex:440},{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:479}],headersStr:"📚Blog 🎨Theme 🐼Me 技能 前端学习 ✉️ 联系",content:"# 📚Blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是Web前端技术。如果你喜欢这个博客&主题欢迎到GitHub点个Star，或者交换友链 ( •̀ ω •́ )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n更新日志\n\n\n# 🎨Theme\n\n\n\n本站主题是 Vdoing，这是一款简洁高效的VuePress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ Github地址 | 在线vscode预览源码\n\n\n# 🐼Me\n\nweb前端小学生\n\n\n# 技能\n\n * 熟悉 JavaScript、HTML、CSS、Vue、React 的拼写\n * 了解 Linux、windows、macOS 的开关机方式\n * 精通 Git 的 pull 和 push，并注册了 GitHub 帐号刷了一些 star\n\n\n# 前端学习\n\n\n关注公众号，回复前端资源，即可获取这些 前端学习资源。\n\n\n# ✉️ 联系\n\n * WeChat or QQ: {{ QQ }}\n * Email: 894072666@qq.com\n * GitHub: https://github.com/xugaoyi\n * Vdoing主题文档：https://doc.xugaoyi.com\n * Vdoing交流QQ群：694387113",normalizedContent:"# 📚blog\n\n这是一个兼具博客文章、知识管理、文档查找的个人网站，主要内容是web前端技术。如果你喜欢这个博客&主题欢迎到github点个star，或者交换友链 ( • ω • )✧\n\n提示\n\n文章内容仅是我个人的小总结，资历尚浅，如有误还请指正。\n\n更新日志\n\n\n# 🎨theme\n\n\n\n本站主题是 vdoing，这是一款简洁高效的vuepress 知识管理&博客 主题。旨在轻松打造一个结构化与碎片化并存的个人在线知识库&博客，让你的知识海洋像一本本书一样清晰易读。配合多维索引，让每一个知识点都可以快速定位！ github地址 | 在线vscode预览源码\n\n\n# 🐼me\n\nweb前端小学生\n\n\n# 技能\n\n * 熟悉 javascript、html、css、vue、react 的拼写\n * 了解 linux、windows、macos 的开关机方式\n * 精通 git 的 pull 和 push，并注册了 github 帐号刷了一些 star\n\n\n# 前端学习\n\n\n关注公众号，回复前端资源，即可获取这些 前端学习资源。\n\n\n# ✉️ 联系\n\n * wechat or qq: {{ qq }}\n * email: 894072666@qq.com\n * github: https://github.com/xugaoyi\n * vdoing主题文档：https://doc.xugaoyi.com\n * vdoing交流qq群：694387113",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"网站",frontmatter:{title:"网站",permalink:"/pages/beb6c0bd8a66cea6",date:"2020-04-19T11:33:04.000Z",article:!1},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/01.%E7%BD%91%E7%AB%99.html",relativePath:"06.收藏夹/01.网站.md",key:"v-f0e5a688",path:"/pages/beb6c0bd8a66cea6/",headers:[{level:2,title:"推荐",slug:"推荐",normalizedTitle:"推荐",charIndex:12},{level:2,title:"文档",slug:"文档",normalizedTitle:"文档",charIndex:167},{level:2,title:"社区",slug:"社区",normalizedTitle:"社区",charIndex:375},{level:3,title:"社区互动",slug:"社区互动",normalizedTitle:"社区互动",charIndex:596},{level:2,title:"技巧",slug:"技巧",normalizedTitle:"技巧",charIndex:623},{level:2,title:"博客",slug:"博客",normalizedTitle:"博客",charIndex:711},{level:2,title:"电子书",slug:"电子书",normalizedTitle:"电子书",charIndex:775},{level:2,title:"优秀文章",slug:"优秀文章",normalizedTitle:"优秀文章",charIndex:833},{level:2,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:897},{level:2,title:"Github",slug:"github",normalizedTitle:"github",charIndex:382},{level:2,title:"评论系统",slug:"评论系统",normalizedTitle:"评论系统",charIndex:1148},{level:2,title:"前端小工具",slug:"前端小工具",normalizedTitle:"前端小工具",charIndex:1197},{level:2,title:"代码编辑",slug:"代码编辑",normalizedTitle:"代码编辑",charIndex:1269},{level:2,title:"Emoji表情",slug:"emoji表情",normalizedTitle:"emoji表情",charIndex:1330},{level:2,title:"图片工具",slug:"图片工具",normalizedTitle:"图片工具",charIndex:1493},{level:2,title:"思维导图",slug:"思维导图",normalizedTitle:"思维导图",charIndex:1753},{level:2,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:875},{level:2,title:"CDN加速",slug:"cdn加速",normalizedTitle:"cdn加速",charIndex:2090},{level:2,title:"网站托管",slug:"网站托管",normalizedTitle:"网站托管",charIndex:2150},{level:2,title:"正则",slug:"正则",normalizedTitle:"正则",charIndex:2180},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:2241},{level:2,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:574},{level:2,title:"图库",slug:"图库",normalizedTitle:"图库",charIndex:3342},{level:2,title:"3D",slug:"_3d",normalizedTitle:"3d",charIndex:1967},{level:2,title:"交互",slug:"交互",normalizedTitle:"交互",charIndex:2420},{level:2,title:"有趣",slug:"有趣",normalizedTitle:"有趣",charIndex:139},{level:2,title:"生成器",slug:"生成器",normalizedTitle:"生成器",charIndex:1839},{level:2,title:"元宇宙",slug:"元宇宙",normalizedTitle:"元宇宙",charIndex:4444},{level:2,title:"教程",slug:"教程",normalizedTitle:"教程",charIndex:251},{level:2,title:"产品",slug:"产品",normalizedTitle:"产品",charIndex:3329},{level:2,title:"实用",slug:"实用",normalizedTitle:"实用",charIndex:4688},{level:2,title:"Talk",slug:"talk",normalizedTitle:"talk",charIndex:5061},{level:2,title:"算法",slug:"算法",normalizedTitle:"算法",charIndex:2330},{level:2,title:"nginx",slug:"nginx",normalizedTitle:"nginx",charIndex:5141},{level:2,title:"生活",slug:"生活",normalizedTitle:"生活",charIndex:5169}],excerpt:'<h1 id="个人收藏夹"><a class="header-anchor" href="#个人收藏夹">#</a> 个人收藏夹</h1>\n<h2 id="推荐"><a class="header-anchor" href="#推荐">#</a> 推荐</h2>\n<ul>\n<li><a href="https://panjiachen.github.io/awesome-bookmarks/" target="_blank" rel="noopener noreferrer">panjiachen<OutboundLink/></a> by 花裤衩</li>\n<li><a href="https://www.code-nav.cn/" target="_blank" rel="noopener noreferrer">编程导航<OutboundLink/></a> by 程序员鱼皮</li>\n<li><a href="https://r2coding.com/" target="_blank" rel="noopener noreferrer">编程自学之路<OutboundLink/></a> by 程序羊</li>\n<li><a href="https://gitee.com/jishupang/web_atlas" target="_blank" rel="noopener noreferrer">前端知识图谱+B站资源整合<OutboundLink/></a> by 技术胖</li>\n<li><a href="https://shengxinjing.cn/" target="_blank" rel="noopener noreferrer">大圣编程自学网<OutboundLink/></a> by 大圣</li>\n<li><a href="https://devtool.tech/" target="_blank" rel="noopener noreferrer">开发者武器库<OutboundLink/></a></li>\n<li><a href="https://www.fly63.com/tool/home.html" target="_blank" rel="noopener noreferrer">工具大全<OutboundLink/></a></li>\n</ul>\n<p align="center">\n<img src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/blog/qrcode.zdqv9mlfc0g.jpg" width="200">\n</p>\n<div class="center-container"><p>关注公众号[有趣研究社]，回复<code>前端资源</code>，获取 <a href="https://github.com/xugaoyi/blog-gitalk-comment/wiki/Front-end-Study" target="_blank" rel="noopener noreferrer">前端学习资料<OutboundLink/></a></p>\n</div>',headersStr:"推荐 文档 社区 社区互动 技巧 博客 电子书 优秀文章 视频 Github 评论系统 前端小工具 代码编辑 Emoji表情 图片工具 思维导图 CSS CDN加速 网站托管 正则 其他 设计 图库 3D 交互 有趣 生成器 元宇宙 教程 产品 实用 Talk 算法 nginx 生活",content:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+B站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * MDN | MDN-JS标准内置对象 Web技术权威文档\n * DevDocs Web 开发技术文档，非常不错的学习手册！\n * 现代JavaScript教程 以最新标准为基准的JS教程\n * ES5教程 阮一峰的JS教程\n * ES6教程 阮一峰的ES6教程\n * Bash 脚本教程 阮一峰编写\n * ECMA ECMA官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * Github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * InfoQ 促进软件开发及相关领域知识与创新的传播\n * V2EX 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * Google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * SoBooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用CSS开发技巧\n * 防御性CSS\n\n\n# 视频\n\n * bilibili B站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学MOOC 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# Github\n\n * Repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 Stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 GitHub Discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * Can I use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌VSCode的在线IDE\n\n\n# Emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> Windows系统下按Win + .\n> Mac系统下按Control + Command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * Squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线AI图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove AI抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# CSS\n\n * 各种CSS生成器和JS代码片段\n\n * CSS Tricks CSS技巧收集与演示\n * CSS生成器\n * CSS渐变生成器\n * CSS3-Box Shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3D字体\n * css-tricks css技巧文章\n * You-need-to-know-css CSS的各种DEMO，很全\n * animista CSS动画可视化工具，复制代码就能用\n * navnav 各种炫酷的CSS动画组件\n\n\n# CDN加速\n\n * jsDelivr 国外的一家优秀的公共 CDN 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * iHateRegex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * Linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove AI抠图，抠图算法很厉害\n * Manypixels 插画\n * Undraw 插画\n * storytale 插画，种类丰富，包含3D插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * Bēhance dribbble 是设计师的微博，Bēhance 是设计师的博客\n * Logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * Flat UI 色表 Flat UI 色表\n * 0to255 颜色梯度\n * Ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * Unsplash 提供免费的高清图片\n * Pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * CSS triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * Lorem Picsum 提供免费的占位图\n * Canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * beTheme\n * UI 中国\n * wallhaven 壁纸网站-\n\n\n# 3D\n\n * sketchfab 3D模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * Little Big Details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * Comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * FC在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * URL 地址播放 Emojis 动画 在地址栏里面播放 emoji\n * Can't Unsee 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * Decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * Product Hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * VideoFk VideoFk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * UzerMe 云端办公工具\n * SoBooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * ENFI 下载器 不限速下载器\n * 来画视频 像做 PPT 一样做短视频\n * Arkie 海报制作工具\n * 优品 PPT\n * 比格 PPT\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * Notion 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有\n\n\n# Talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * Ventusky 风雨气温图",normalizedContent:"# 个人收藏夹\n\n\n# 推荐\n\n * panjiachen by 花裤衩\n * 编程导航 by 程序员鱼皮\n * 编程自学之路 by 程序羊\n * 前端知识图谱+b站资源整合 by 技术胖\n * 大圣编程自学网 by 大圣\n * 开发者武器库\n * 工具大全\n\n\n\n关注公众号[有趣研究社]，回复前端资源，获取 前端学习资料\n\n\n# 文档\n\n * mdn | mdn-js标准内置对象 web技术权威文档\n * devdocs web 开发技术文档，非常不错的学习手册！\n * 现代javascript教程 以最新标准为基准的js教程\n * es5教程 阮一峰的js教程\n * es6教程 阮一峰的es6教程\n * bash 脚本教程 阮一峰编写\n * ecma ecma官网\n * 菜鸟教程 涵盖多种语言的初级教程\n * 腾讯云开发者手册\n\n\n# 社区\n\n * github 程序员同性交友社区\n * 掘金 一个帮助开发者成长的社区\n * 简书 有很多频道的创作社区\n * 思否 解决技术问题的社区\n * stack overflow 同上，外网的\n * infoq 促进软件开发及相关领域知识与创新的传播\n * v2ex 创意工作者们的社区\n * 鱼塘热榜 划水网站，收集了很多网站，当天热门文章\n * 码力全开资源库 很全很强大，独立开发者/设计干货/优质利器/工具资源...\n\n\n# 社区互动\n\n * gitter\n * 兔小巢\n\n\n# 技巧\n\n * google 趋势 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。\n * 百度指数 同上，但百度的数据仅限国内。\n\n\n# 博客\n\n * 阮一峰的网络日志\n * samanthaming 对前端小知识点的总结，并为每个知识点制作精美的小卡片。\n\n\n# 电子书\n\n * 高教书苑 高等教育出版社的书籍，包含多种学科。\n * sobooks 免费的电子书资源网站\n\n\n# 优秀文章\n\n * 我做系统架构的一些原则 作者对系统架构的方法论总结\n * 灵活运用css开发技巧\n * 防御性css\n\n\n# 视频\n\n * bilibili b站，上面很多免费教学视频\n * 慕课网 实战视频教程\n * 妙味课堂 比较系统的前端入门视频教程\n * 中国大学mooc 涵盖计算机、外语、心理学等专业免费课程\n * egghead 质量还不错的短视频教程，外网\n\n\n# github\n\n * repobeats 生成仓库的动态数据统计图\n\n * github 短域名服务\n * shields 徽章图标\n * followers 全球排名\n * star-history 展示一个项目 stars 增长曲线\n\n\n# 评论系统\n\n * giscus 由 github discussions 驱动的评论系统\n\n\n# 前端小工具\n\n * can i use 查看属性和方法的兼容性\n * 30 seconds of code 收集了许多有用的代码小片段\n\n\n# 代码编辑\n\n * codepen 在线代码编辑与演示\n * codesandbox 内嵌vscode的在线ide\n\n\n# emoji表情\n\n * emoji表情\n * emoji表情备忘录\n * 根据文本匹配emoji\n * gitmoji 通过 emoji 表达 git 的操作内容\n\n> 在任意输入框快速打开emoji表情方法：\n> windows系统下按win + .\n> mac系统下按control + command + 空格\n\n\n# 图片工具\n\n * tinypng图片压缩 压缩png很有用\n * 微图 浏览器端图片压缩，不会上传图片到服务器\n * squoosh 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）\n * waifu2x 通过卷积网络放大图片\n * vectormagic 转换矢量图\n * vectorizer 真正的 png 转 svg 神器\n * 在线ai图片处理 黑白修复、无损放大、动漫化、铅笔画等。\n * remove ai抠图\n * backgroundremover 又一个抠图的\n\n\n# 思维导图\n\n * processon在线作图 流程图、思维导图、原型图等\n * 百度脑图 思维导图\n * plectica 绘制知识图谱\n\n\n# css\n\n * 各种css生成器和js代码片段\n\n * css tricks css技巧收集与演示\n * css生成器\n * css渐变生成器\n * css3-box shadow(阴影)\n * 贝塞尔曲线生成器\n * 花纹背景生成器\n * 花纹背景-pattern.css\n * 3d字体\n * css-tricks css技巧文章\n * you-need-to-know-css css的各种demo，很全\n * animista css动画可视化工具，复制代码就能用\n * navnav 各种炫酷的css动画组件\n\n\n# cdn加速\n\n * jsdelivr 国外的一家优秀的公共 cdn 服务提供商\n * unpkg cdn 服务\n\n\n# 网站托管\n\n * vercel 好用的网站托管服务\n\n\n# 正则\n\n * 正则可视化\n * ihateregex 正则搜索，细节做得很好\n * 正则迷你书 学习正则的小手册\n\n\n# 其他\n\n * linux命令手册\n * carbon代码图片生成器 生成好看的代码图片\n\n\n# 设计\n\n * 创造师导航\n * 设计师网址导航\n * remove ai抠图，抠图算法很厉害\n * manypixels 插画\n * undraw 插画\n * storytale 插画，种类丰富，包含3d插画\n * uimovement 能从这个网站找到不少动画交互的灵感\n * awwwards是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站\n * dribbble 经常能在上面找到很多有创意好看的 gif 或者图片\n * behance dribbble 是设计师的微博，behance 是设计师的博客\n * logojoy 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。\n * brandmark 另一个在线制作 logo 网站\n * instant 又一个 logo 制作网站\n * namecheap又一个 logo 制作网站\n * logo-maker 又一个 logo 制作网站 这个更简单点 就是选模板之后微调\n * coolors 帮你在线配色的网站 你能找到不少配色灵感\n * colorhunt 另一个配色网站\n * uigradients 渐变色网站\n * designcap 在线海报设计\n * flat ui 色表 flat ui 色表\n * 0to255 颜色梯度\n * ikonate 提供免费的图标 icons\n * remixicon 又一个提供免费图标 icons\n * feather 免费的 icons\n * nord 北欧性冷淡风主题配色\n * unsplash 提供免费的高清图片\n * pexels 提供免费的高清图片\n * colorkitty 从你的图片中提取配色\n * design.youzan 有赞设计原则\n * iconfont 阿里巴巴矢量图标库\n * undraw 免费的矢量插画\n * icomoon 矢量图标库\n * cssicon 所有的 icon 都是纯 css 画的 缺点：icon 不够多\n * css triangle generator 帮你快速用 css 做出三角形\n * clippy 在线帮你使用 css clip-path 做出各种形状的图形\n * lorem picsum 提供免费的占位图\n * canva 可画 生成插画、封面、海报、头像等\n * 404页 404页素材\n * collectui 按功能组件分类的设计图\n * smartmockups 产品模板生成工具\n\n\n# 图库\n\n * uigradients 渐变色生成工具\n * freepik banner 图库\n * 觅元素一天免费下载十张 psd（免抠元素）\n * 搞定设计 可以抠图\n * vectorizer 真正的 png 转 svg 神器\n * 站酷 国内优秀的设计作品展示\n * 花瓣\n * 虎克 ps 学习教程\n * betheme\n * ui 中国\n * wallhaven 壁纸网站-\n\n\n# 3d\n\n * sketchfab 3d模型\n\n\n# 交互\n\n * 微交互 里面收集了市面上很多很好的微交互例子 值得学习\n\n * little big details 同上，一个国外微交互汇集网站\n\n * cruip 登录页的各种页面设计，可以免费下载模板\n\n * comixify 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。\n\n * taiko-web 太鼓达人网页版 只能说很 6\n\n\n# 有趣\n\n * 电脑恶搞 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等\n * neocities 上面托管了很多有趣的网站\n * 奇趣网站收藏家 收藏了很多有趣的网站\n * fc在线模拟器(小霸王游戏机) 童年回忆\n * 帮你百度一下 可以 点我测试一下-\n * 国际版 同帮我百度一下-点我测试一下-\n * url 地址播放 emojis 动画 在地址栏里面播放 emoji\n * can't unsee 强烈建议前端、客户端、ui 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样\n * ggtalk 平时一直在听的一个技术博客\n * awesome-comment 里面收集了很多有趣的代码注释\n * text-img 都将图片转化为 ascii 用来写注释\n * ascii video 使用ascii编码生成视频动画\n * weird-fonts 将普通字母转化为 特殊 unicode\n * snake 在地址栏里面玩贪吃蛇\n * zero-width-lib 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意\n * abbreviations 查看一个简写是什么意思的网站\n * magi ai 搜索神器，超屌\n * 在线取名 解决取名难问题，超多名字生成\n\n\n# 生成器\n\n * 卡通头像生成器 上传真人头像生成卡通头像\n\n * artbreeder 动漫图生成真人图像\n\n * 声音生成器 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成\n\n * 诺基亚短信图片生成器\n\n * 到账语音生成器 支付宝到账1亿元\n\n\n# 元宇宙\n\n符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：\n\n * 沙盒\n * 梦境空间\n * decentraland\n\n\n# 教程\n\n * npx 教你怎么合理的使用 npx\n * hacksplaining 网络安全学习网站\n * mobile-web-best-practice 移动 web 最佳实践\n\n\n# 产品\n\n * product hunt 好产品推荐\n\n * 产品大牛 什么有很多完整的产品原型可以借鉴\n\n * 磨刀 快速出 ui 原型\n\n\n# 实用\n\n * webden 在线网页编辑器，轻便快捷\n * browser-update 浏览器版本更新提示插件\n * typeform 一个国外的在线调查问卷网站\n * videofk videofk 视频在线解析下载\n * 全历史 历史内容聚合网站\n * uzerme 云端办公工具\n * sobooks 强大的电子书资源网站\n * 稿定设计 键式设计工具+智能抠图\n * 大力盘 百度网盘搜索\n * enfi 下载器 不限速下载器\n * 来画视频 像做 ppt 一样做短视频\n * arkie 海报制作工具\n * 优品 ppt\n * 比格 ppt\n * 高清免费图片\n * 高清免费图片 2\n * shapedivider 生成波浪分隔线\n * notion 知识库、快速笔记、tasklist、日记、读书清单，各种类型，应有尽有\n\n\n# talk\n\n * peerigon-talks 收集了不少有意思的 talks\n\n\n# 算法\n\n * leetcode 用 js 刷 leetcode\n\n\n# nginx\n\n * nginx 可视化配置工具\n\n\n# 生活\n\n * ventusky 风雨气温图",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"常用的前端轮子",frontmatter:{title:"常用的前端轮子",date:"2021-10-09T19:42:02.000Z",permalink:"/pages/47cf96/",article:!1},regularPath:"/06.%E6%94%B6%E8%97%8F%E5%A4%B9/02.%E5%B8%B8%E7%94%A8%E7%9A%84%E5%89%8D%E7%AB%AF%E8%BD%AE%E5%AD%90.html",relativePath:"06.收藏夹/02.常用的前端轮子.md",key:"v-77ef150e",path:"/pages/47cf96/",headers:[{level:2,title:"React UI 组件库",slug:"react-ui-组件库",normalizedTitle:"react ui 组件库",charIndex:2},{level:2,title:"Vue UI组件库",slug:"vue-ui组件库",normalizedTitle:"vue ui组件库",charIndex:68},{level:2,title:"常用效果组件",slug:"常用效果组件",normalizedTitle:"常用效果组件",charIndex:124},{level:2,title:"工具类",slug:"工具类",normalizedTitle:"工具类",charIndex:201},{level:2,title:"Vue工具类",slug:"vue工具类",normalizedTitle:"vue工具类",charIndex:331},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:469}],headersStr:"React UI 组件库 Vue UI组件库 常用效果组件 工具类 Vue工具类 其他",content:"# React UI 组件库\n\n * Ant Design\n * React Bootstrap\n * MATERIAL-UI\n\n\n# Vue UI组件库\n\n * Element UI PC端\n * Vant 移动端\n * View UI\n\n\n# 常用效果组件\n\n * Animate.css 动画库\n * Swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生JS\n\n\n# 工具类\n\n * Lodash.js\n * Day.js 处理日期\n * Timeago.js 相对时间，如N小时前\n * Echarts 百度图表\n * Meditor.md 开源在线 Markdown 编辑器\n * validator.js 验证库\n\n\n# Vue工具类\n\n * vue-draggable 基于Sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * H5带笔锋手写签名，支持PC端和移动端",normalizedContent:"# react ui 组件库\n\n * ant design\n * react bootstrap\n * material-ui\n\n\n# vue ui组件库\n\n * element ui pc端\n * vant 移动端\n * view ui\n\n\n# 常用效果组件\n\n * animate.css 动画库\n * swiper 轮播组件\n * mescroll 下拉刷新和上拉加载框架-基于原生js\n\n\n# 工具类\n\n * lodash.js\n * day.js 处理日期\n * timeago.js 相对时间，如n小时前\n * echarts 百度图表\n * meditor.md 开源在线 markdown 编辑器\n * validator.js 验证库\n\n\n# vue工具类\n\n * vue-draggable 基于sortable.js实现的vue拖拽插件\n * vue-qr 文本转二维码\n * vue-cropper 图片裁剪插件\n * vue-lazyload 懒加载\n * vue-simple-upload 上传组件\n\n\n# 其他\n\n * h5带笔锋手写签名，支持pc端和移动端",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"HTML",frontmatter:{title:"HTML",date:"2019-12-19T23:55:57.000Z",permalink:"/pages/fa842a/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/101.HTML.html",relativePath:"1100.H5&CSS3/101.HTML.md",key:"v-44afb06d",path:"/pages/fa842a/",headers:[{level:2,title:"引言",slug:"引言",normalizedTitle:"引言",charIndex:46},{level:3,title:"Rendering Engine",slug:"rendering-engine",normalizedTitle:"rendering engine",charIndex:53},{level:3,title:"Web 标准",slug:"web-标准",normalizedTitle:"web 标准",charIndex:787},{level:2,title:"文档类型声明",slug:"文档类型声明",normalizedTitle:"文档类型声明",charIndex:855},{level:2,title:"根元素<html>",slug:"根元素-html",normalizedTitle:"根元素<html>",charIndex:1734},{level:3,title:"lang",slug:"lang",normalizedTitle:"lang",charIndex:917},{level:3,title:"xmlns",slug:"xmlns",normalizedTitle:"xmlns",charIndex:2031},{level:2,title:"头元素<head>",slug:"头元素-head",normalizedTitle:"头元素<head>",charIndex:2103},{level:3,title:"<base>",slug:"base",normalizedTitle:"<base>",charIndex:2293},{level:3,title:"<meta>",slug:"meta",normalizedTitle:"<meta>",charIndex:2450},{level:4,title:"charset属性",slug:"charset属性",normalizedTitle:"charset属性",charIndex:2545},{level:4,title:"name content属性",slug:"name-content属性",normalizedTitle:"name content属性",charIndex:2725},{level:4,title:"http-equiv content 属性",slug:"http-equiv-content-属性",normalizedTitle:"http-equiv content 属性",charIndex:3122},{level:3,title:"<title>",slug:"title",normalizedTitle:"<title>",charIndex:1485},{level:3,title:"<link>",slug:"link",normalizedTitle:"<link>",charIndex:2491},{level:3,title:"<style>",slug:"style",normalizedTitle:"<style>",charIndex:2509},{level:2,title:"分区根元素<body>",slug:"分区根元素-body",normalizedTitle:"分区根元素<body>",charIndex:3658},{level:3,title:"内容分区（逻辑分区）",slug:"内容分区-逻辑分区",normalizedTitle:"内容分区（逻辑分区）",charIndex:3733},{level:2,title:"常用元素",slug:"常用元素",normalizedTitle:"常用元素",charIndex:3850},{level:3,title:"排版元素",slug:"排版元素",normalizedTitle:"排版元素",charIndex:3859},{level:3,title:"文本格式化元素",slug:"文本格式化元素",normalizedTitle:"文本格式化元素",charIndex:4917},{level:3,title:"字符实体",slug:"字符实体",normalizedTitle:"字符实体",charIndex:5278},{level:3,title:"列表元素",slug:"列表元素",normalizedTitle:"列表元素",charIndex:5353},{level:3,title:"表格元素",slug:"表格元素",normalizedTitle:"表格元素",charIndex:5688},{level:3,title:"超链接元素",slug:"超链接元素",normalizedTitle:"超链接元素",charIndex:8379},{level:3,title:"图片元素",slug:"图片元素",normalizedTitle:"图片元素",charIndex:10124},{level:3,title:"内联框架 iframe",slug:"内联框架-iframe",normalizedTitle:"内联框架 iframe",charIndex:10822},{level:3,title:"音频元素 radio",slug:"音频元素-radio",normalizedTitle:"音频元素 radio",charIndex:11597},{level:3,title:"视频元素 video",slug:"视频元素-video",normalizedTitle:"视频元素 video",charIndex:12302},{level:2,title:"表单元素",slug:"表单元素",normalizedTitle:"表单元素",charIndex:13359},{level:3,title:"form 表单域",slug:"form-表单域",normalizedTitle:"form 表单域",charIndex:13368},{level:3,title:"表单提交",slug:"表单提交",normalizedTitle:"表单提交",charIndex:13991},{level:3,title:"input",slug:"input",normalizedTitle:"input",charIndex:9444},{level:3,title:"label",slug:"label",normalizedTitle:"label",charIndex:17252},{level:3,title:"legend",slug:"legend",normalizedTitle:"legend",charIndex:17646},{level:3,title:"fieldset",slug:"fieldset",normalizedTitle:"fieldset",charIndex:17654},{level:3,title:"select 下拉框",slug:"select-下拉框",normalizedTitle:"select 下拉框",charIndex:17690},{level:3,title:"textarea 文本域",slug:"textarea-文本域",normalizedTitle:"textarea 文本域",charIndex:18014},{level:3,title:"综合练习",slug:"综合练习",normalizedTitle:"综合练习",charIndex:18174},{level:2,title:"共有属性",slug:"共有属性",normalizedTitle:"共有属性",charIndex:21051},{level:3,title:"title",slug:"title-2",normalizedTitle:"title",charIndex:1486}],headersStr:"引言 Rendering Engine Web 标准 文档类型声明 根元素<html> lang xmlns 头元素<head> <base> <meta> charset属性 name content属性 http-equiv content 属性 <title> <link> <style> 分区根元素<body> 内容分区（逻辑分区） 常用元素 排版元素 文本格式化元素 字符实体 列表元素 表格元素 超链接元素 图片元素 内联框架 iframe 音频元素 radio 视频元素 video 表单元素 form 表单域 表单提交 input label legend fieldset select 下拉框 textarea 文本域 综合练习 共有属性 title",content:'# HTML\n\nHyperText Markup Language：超文本标记语言\n\n\n# 引言\n\n\n# Rendering Engine\n\n内核包括：渲染引擎 + JS 引擎（如 V8）\n\nRendering Engine：排版引擎、解释引擎、渲染引擎，现在流行称为浏览器内核。负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。\n\n浏览器       内核               备注\nIE        Trident（三叉戟）     IE、猎豹安全、360 浏览器、百度浏览器、UC\nfirefox   Gecko（壁虎）        可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友 flash、神一样的对手 chrome。\nSafari    webkit           现在很多人错误地把 webkit 叫做 chrome 内核（即使 chrome 内核已经是 blink 了）。\nChrome    Chromium/Blink   在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink\n                           其实是 WebKit 的分支。大部分国产浏览器最新版都采用 Blink 内核，二次开发\nOpera     blink            现在跟随 chrome 用 blink 内核。\n\n> 移动端的浏览器内核主要说的是系统内置浏览器的内核。Android 手机而言，使用率最高的就是 Webkit 内核，大部分国产浏览器宣称的自己的内核，基本上也是属于 webkit 二次开发。iOS 以及 WP7 平台上，由于系统原因，系统大部分自带浏览器内核，一般是 Safari 或者 IE 内核 Trident 的\n\n\n# Web 标准\n\n构成： 主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面\n\n\n# 文档类型声明\n\n在 VSCode 中按下 html:5或!即可出现如下代码：\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    \x3c!--定义页面的编码方式--\x3e\n    <meta charset="UTF-8" />\n    \x3c!--viewport 为可视区域，它的宽度为设备的宽度--\x3e\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    \x3c!--没有如下两行--\x3e\n    \x3c!--http-equiv 表示执行一个命令，下面设置 HTTP 的 content-type，适配IE--\x3e\n    <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n    \x3c!--页面的描述信息，可供搜索引擎显示--\x3e\n    <meta\n      name="Keywords"\n      content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东"\n    />\n    <meta\n      name="description"\n      content="京东JD.COM-专业的综合网上购物商城...便捷、诚信的服务，为您提供愉悦的网上购物体验!"\n    />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<!DOCTYPE> 文档类型声明标签，不是一个 HTML 标签，作用就是告诉浏览器使用哪种 HTML 版本来显示网页。位于文档中的最前面的位置，必须处于 <html> 标签之前。上述代码的意思是：当前页面采取的是 HTML5 版本来显示网页。\n\n\n# 根元素<html>\n\n<html>：表示一个 HTML 文档的根（顶级元素），所有其他元素必须是此元素的后代\n\n\n# lang\n\n用来定义当前文档显示的语言。常用的有：\n\n * lang="zh-CN\n * lang="en"\n\n其实对于文档显示来说，定义成 en 的文档也可以显示中文，定义成 zh-CN 的文档也可以显示英文。这个属性对浏览器和搜索引擎有作用的\n\n * 帮助翻译工具做识别，如弹出是否翻译该页面\n * 根据根据 lang 属性来设定不同语言的 css 样式，或者字体\n * 告诉搜索引擎做精确的识别\n * 让语法检查程序做语言识别\n * 帮助网页阅读程序做识别等等\n\n\n# xmlns\n\n指派文档的 XML 命名空间。默认是http://www.w3.org/1999/xhtml，只在 XHTML 中必要。\n\n\n# 头元素<head>\n\n> 规定文档相关的配置信息（元数据），包括文档的标题，引用的文档样式和脚本等。\n> \n> 文档元数据 Metadata：元数据（Metadata），含有页面的相关信息，包括样式、脚本及数据，能帮助一些软件（例如：搜索引擎 SEO、浏览器 等等）更好地运用和渲染页面。对于样式和脚本的元数据，可以直接在网页里定义，也可以链接到包含相关信息的外部文件。\n\n\n# <base>\n\n指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个。一个文档的基本 URL，可以通过使用 document.baseURI 的 JS 脚本查询。\n\n * 必须有href属性。当具体a中的该属性设置为带协议的链接时，则不受 base 控制\n * 可选择target属性\n\n\n# <meta>\n\n该元素表示那些不能由其它 HTML 元相关元素 (<base>, <link>, <script>, <style> 或 <title>) 之一表示的任何元数据信息。\n\n# charset属性\n\n规定 HTML 文档应该使用哪种字符集。让浏览器根据编码去解码对应的 HTML 内容，文件不一定是这个编码。字符集 (Character set)是多个字符的集合。以便计算机能够识别和存储各种文字。统一使用 UTF-8，必须写。\n\n\x3c!-- In HTML5 --\x3e\n<meta charset="utf-8" />\n\n\n1\n2\n\n\n# name content属性\n\nname 常用值有：\n\n * keywords\n * description\n\n\x3c!--viewport 为可视区域，它的宽度为设备的宽度--\x3e\n<meta name="viewport" content="width=device-width, initial-scale=1.0" />\n\x3c!--页面的描述信息，可供搜索引擎显示--\x3e\n<meta\n  name="Keywords"\n  content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东"\n/>\n<meta\n  name="description"\n  content="京东JD.COM-专业的综合网上购物商城...便捷、诚信的服务，为您提供愉悦的网上购物体验!"\n/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# http-equiv content 属性\n\n\x3c!--http-equiv 表示执行一个命令，下面设置 HTTP 的 content-type，适配IE--\x3e\n<meta http-equiv="X-UA-Compatible" content="ie=edge" />\n\x3c!-- Redirect page after 3 seconds --\x3e\n<meta http-equiv="refresh" content="3;url=http://www.mozilla.org/" />\n\n\n1\n2\n3\n4\n\n\n\n# <title>\n\n该元素定义文档的标题，显示在浏览器的标题栏，标签页及超链接上。它只可以包含文本，若是包含有标签，则包含的任何标签都不会被解释。搜索引擎会根据 title 中的内容来判断网页的主要内容。\n\n\n# <link>\n\n该元素规定了外部资源与当前文档的关系。这个元素最常于链接 CSS 样式表，还能被用来创建站点图标（比如 PC 端的“favicon”图标和移动设备上用以显示在主屏幕的图标）甚至一些其他事情。\n\n\n# <style>\n\n该元素包含文档的样式信息或者文档的部分内容。默认情况下，该标签的样式信息通常是 CSS 的格式。\n\n\n# 分区根元素<body>\n\n<body>：该元素表示文档的内容。document.body属性提供了可以轻松访问文档的 body 元素的脚本。\n\n\n# 内容分区（逻辑分区）\n\n内容分区元素允许你将文档内容从逻辑上进行组织划分。使用包括页眉(header)、页脚(footer)、导航(nav)和标题(h1~h6)等分区元素，来为页面内容创建明确的大纲，以便区分各个章节的内容。\n\n\n# 常用元素\n\n\n# 排版元素\n\n<hgroup> 用来为标题分组，可以将一组相关的标题同时放入到 hgroup，H5 标签，注意兼容性\n\n<h1>标题</h1> 标题，取值 1~6 从大到小。是块元素，自动在其前后加空行，其实是段间距。有助于 SEO，H1 重要性仅次于 title 标签，建议只有一个\n\n<p>html</p> 段落，paragraph 缩写，是块元素，自动在其前后加空行，其实是段间距。不能包含任何块元素\n\n<blockquote>我周树人从没说过这话</blockquote> 长引用，有缩进，块元素，知乎常用\n\n<q>子曰：学而时习之</q> 短引用，引号引用起来，行内元素，无法被选中（可以使用伪元素实现）\n\n<hr/> 横线，horizontal 缩写\n\n<br/> 换行，break 缩写\n\n<div></div> 块元素，division 缩写，自动换行。独占一行（即使宽度比较小）\n\n<span></span> 行内元素\n\n根据元素的语义，在合适的地方给一个最为合理的元素，让结构更清晰。一般先写语义化 HTML，之后才写 CSS\n\n * 方便代码的阅读和维护\n * 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容\n * 使用语义化标签会具有更好地搜索引擎优化\n * 这些新标签页面中可以使用多次\n * 在 IE9 中，需要把这些元素转换为块级元素\n * 移动端更喜欢使用这些标签\n\n标签如下：\n\n<header>表示网页的头部</header>\n<nav>导航栏</nav>\n<aside>侧边栏</aside>\n\n<main>\n  表示网页的主体部分(一个页面中只会有一个main)\n  <article>\n    <h2>\n      标题\n    </h2>\n    <p>\n      内容\n    </p>\n  </article>\n  <figure>\n    <figcaption>figure 元素的标题</figcaption>\n    figure 元素的内容，比如图示、图表、照片、代码清单等。\n  </figure>\n  <section>\n    定义文档中的节，区域，表示一个独立的区块，上面标签都不能表示时使用section\n  </section>\n</main>\n<footer>表示网页的底部</footer>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 文本格式化元素\n\n<b>粗体</b> ；<strong>强调文本</strong> ，推荐使用带语义化的\n\n<i>斜体</i> ；<em>强调文本</em> ，推荐使用带语义化的。很多网站喜欢用i来修饰图片，类似 icon\n\n<u>下划线</u> ；<ins>下划线</ins>，推荐使用带语义化的\n\n<s>删除线</s>；<del>删除线</del> ，推荐使用带语义化的\n\n----------------------------------------\n\n\x3c!-- 注释 --\x3e 注释\n\n<pre></pre> 预格式文本，元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体，不常用\n\n<code></code> 代码格式，等宽字体显示\n\n<sup>上标</sup>\n\n<sub>下标</sub>\n\n\n# 字符实体\n\n&lt;、&gt;、&nbsp;、&amp;、&copy;、&reg; 分别为：<、>、 空格、 &、 ©、 ®\n\n其他参考文档\n\n\n# 列表元素\n\n提示\n\n块级元素。用来布局的， 因为非常整齐和自由。样式推荐使用 CSS 的list-style: none实现\n\n<ul> <ol> <li> 无序（常用）、有序、列表\n\n * li 间可以容纳所有元素\n * 无序、有序列表会自带样式，应使用 CSS 重写替代\n * reversed：列表倒序，用于有序列表\n\n * type=\'1\'或\'a\'或\'i\'或\'A\'或\'I\' 用于有序列表，请使用 CSS 替代；\n * start 用于有序列表，HTML5 不支持，请使用 CSS 替代；\n\n<dl> <dt> <dd> 定义列表（常用）带有术语或名词和描述。常见于页面下面帮助部分。\n\n * 定义列表的列表项前没有任何项目符号\n * dd 元素会有缩进\n\n\n# 表格元素\n\n提示\n\n块级元素。不是用来布局，常用显示、展示数据。样式推荐使用 CSS 的border-实现\n\n<html>\n  <table>\n    <caption>\n      表格测试\n    </caption>\n    <thead>\n      <tr>\n        <th>班级</th>\n        <th>姓名</th>\n        <th>性别</th>\n        <th colspan="2">操作</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td rowspan="2">一 班</td>\n        <td>张三</td>\n        <td>男</td>\n        <td>修改</td>\n        <td>删除</td>\n      </tr>\n      <tr>\n        <td>李四</td>\n        <td>男</td>\n        <td>修改</td>\n        <td>删除</td>\n      </tr>\n    </tbody>\n    <tfoot>\n      <tr>\n        <td colspan="5">备注</td>\n      </tr>\n    </tfoot>\n  </table>\n</html>\n<style>\n  table {\n    /* 合并细线边框 */\n    border-collapse: collapse;\n    /* 单元格之间水平、垂直距离，与 border-collapse 冲突，不常用 */\n    /*border-spacing: 10px 20px;*/\n    /* 表格居中 */\n    margin: 0 auto;\n  }\n  th,\n  td {\n    /* 边框 */\n    border: 1px solid skyblue;\n    /* 内边距 */\n    padding: 20px;\n    /* 让td居中，th本来就是居中的 */\n    text-align: center;\n    /* 默认情况下元素在th,td中是垂直居中的，也可以通过 vertical-align 来修改*/\n    /* 由此可得，对一个父元素设置 display: table-cell，可以直接使用 vertical-align 来垂直居中*/\n  }\n  /* 标题 */\n  caption {\n    font-weight: 700;\n    font-size: 24px;\n    margin-bottom: 20px;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n * 表头单元格 th 也是单元格，常用于表格第一行，突出重要性，表头单元格里面的文字会加粗居中显示\n\n * 注意：表格中占多行的只属于第一行，占多列同理\n\n * 在 HTML5 中，仅支持 "border" 属性，并且只允许使用值 "1" 或 ""。不推荐使用\n   \n   之前使用的cellspacing（单元格之间距离）、cellpadding（内容与单元格边框距离）应该使用 CSS 实现，具体在 CSS 章节体现\n   \n   table {\n     /* 合并细线边框 */\n     border-collapse: collapse;\n     /* 单元格之间水平、垂直距离，与 border-collapse 冲突，不常用 */\n     /*border-spacing: 10px 20px;*/\n     /* 表格居中 */\n     margin: 100px auto;\n   }\n   th,\n   td {\n     /* 边框 */\n     border: 1px solid skyblue;\n     /* 内边距 */\n     padding: 30px;\n     /* 默认情况下元素在th,td中是垂直居中的，也可以通过 vertical-align 来修改*/\n     /* 由此可得，对一个父元素设置 display: table-cell，可以直接使用 vertical-align 来垂直居中*/\n   }\n   caption {\n     font-weight: 700;\n     font-size: 24px;\n     margin-bottom: 20px;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\nth, td 自然垂直居中的提示（了解）\n\n默认情况下元素在 th,td 中是垂直居中的。由此可得，对一个父元素设置display: table-cell，可以直接使用 vertical-align 来使子元素垂直居中\n\n<style>\n  .box1 {\n    display: table-cell;\n    vertical-align: middle;\n    width: 400px;\n    height: 400px;\n    background-color: skyblue;\n  }\n\n  .box2 {\n    width: 100px;\n    height: 100px;\n    background-color: pink;\n    margin: 0 auto;\n  }\n</style>\n<div class="box1">\n  <div class="box2"></div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 超链接元素\n\n提示\n\nanchor [ˈæŋkə(r)] 的缩写，含义为：锚、铁锚。行内元素\n\n<a href="https://www.qq.com" target="_blank">新窗口打开QQ</a>\n\n\n1\n\n\n属性       作用\nhref     用于指定链接目标的 url 地址，（必须属性）当为标签应用 href 属性时，它就具有了超链接的功能\ntarget   用于指定链接页面的打开方式，取值：其中_self为当前页面打开，默认值，_blank为在新窗口中打开，_parent加载到当前的\n         HTML5 浏览上下文的父浏览上下文，_top加载响应进入顶层浏览上下文。\n\n可在<head>的<base>标签中设置全局href和target\n\n * 外部链接： http:// www.baidu.com，需要协议开头\n\n * 内部链接：直接链接内部页面名称即可 <a href="index.html">首页</a>\n\n * 锚点定位：当时没有确定链接目标或目标为当前页，可将href属性值定义为#，表示该链接暂时为一个空链接，默认跳转当前页。可以通过该方式来定位资源：\n   \n   <div id="top">top</div>\n   <a href="#top">returnTop</a>\n   \n   \n   1\n   2\n   \n\n * 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。如包裹<img>标签\n\n * 发送邮件\n   \n   <a href="mailto:xxx@gmail.com">联系我们</a>\n   \n   \n   1\n   \n\n * 下载链接：如果 href 里面地址是一个文件或者压缩包，会下载这个文件。\n\n * 伪链接，禁止跳转：二选一\n   \n   <a href="javascript:;">1</a>\n   \x3c!-- 好像写void，或void()，或void(0)都一样。void(0)表示计算一个表达式（此处为0）但不返回值 --\x3e\n   <a href="javascript:void(0);">1</a>\n   \n   \x3c!-- 写不写#都一样 --\x3e\n   <a href="#" onclick="return false">2</a>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   只写href="#"则跳回页面顶部\n\n * 去掉input或a或button或select或textraea的 focus 轮廓蓝线\n   \n   /* 看不到 outline 蓝色边框线。button 和 a 只有使用 tab 才可以看到 */\n   input,\n   select,\n   textarea,\n   button,\n   a {\n     outline: none;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   \x3c!-- tableindex 调整tab选择顺序，负数则不会被选择。也可以不设置 --\x3e\n   <input type="text" />111<br />\n   <select name="" id="">\n     <option value="1">1</option>\n     <option value="2">2</option>\n   </select>\n   <textarea name="aa" id="" cols="30" rows="10">222</textarea>\n   <button>111</button>\n   <a href="#">222</a>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 去掉 a 的下划线\n   \n   a {\n     text-decoration: none;\n   }\n   \n   \n   1\n   2\n   3\n   \n\n\n# 图片元素\n\n提示\n\nimage 的缩写。替换元素，有块元素和行内元素的特点\n\n<img src="test.jpg" width="400" alt="无法显示" />\n\x3c!--可嵌套在 a 标签里--\x3e\n\n\n1\n2\n\n\n属性       属性值                   描述\nsrc      URL                   图像路径\nalt      文本                    H5 推荐必加属性，图像不能显示时的替换文本，有利于 SEO\ntitle    文本                    鼠标悬停时显示的内容\nwidth    像素（XHTML 不支持%页面百分比）   设置图像宽度，一般只改一个（等比缩放），不带单位默认为 px\nheight   像素（XHTML 不支持%页面百分比）   设置图像高度，一般只改一个（等比缩放），不带单位默认为 px\nborder   数字                    设置图像边框的宽度，后续使用 CSS 完成\n\nWeb 中常见的图片格式：\n\n * PNG：静态，支持复杂透明。支持的颜色丰富，网页使用最多！\n * JPG/JPEG：静态，不支持透明。支持的颜色比较丰富。\n * GIF：动态，静态，支持简单透明，支持的颜色比较少。\n * Webp：谷歌的，比 JPG 压缩率更高，但质量比 PNG 还好，还支持动态。**优势非常明显！**但是兼容性不好。\n * Base64：将图片进行 Base64 编码，转换为字符引入，一般用于需要和网页一起加载的图片。但是字符太长。\n\n\n# 内联框架 iframe\n\n类似 img，但是 iframe 是用于网页中嵌套网页，不利于 SEO，且每次都要重新渲染\n\n<iframe\n        src="https://news.qq.com/"\n        width="1000"\n        height="800"\n        frameborder="0">\n</iframe>\n\n\n1\n2\n3\n4\n5\n6\n\n\nsrc可以是外部或内部网页， frameborder只有 0 或 1，0 代表没有边框，默认值为 1\n\n当 iframe 中网页的a标签的target=_parent时，将从当前页面打开，而不是在 iframe 中打开，_top在多层 iframe 中适用\n\n也可以指定target="a"，即在指定name="a"的 iframe 中打开\n\n框架标签，不赞成使用\n\n<frameset rows="80,*">                        //把页面划分成上下两部分\n<frame name="top" src="a.html">             //上面页面\n<frameset cols="150,*">                     //把下面部分划分成左右两部分\n\t\t<frame name="lower_left" src="b.html">  //左边的页面\n\t\t<frame name="lower_right" src="c.html"> //右边的页面\n\t</frameset>\n</frameset>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n点击左边的页面超链接，内容显示在右边的页面中\n\n<a href="01-hello.html" target="right">超链接1</a>\n\n\n1\n\n\n\n# 音频元素 radio\n\n提示\n\nHTML5 元素，支持 IE9 及以上\n\n属性         值          描述\nautoplay   autoplay   如果出现该属性，则音频在就绪后马上播放。但是目前来讲大部分浏览器都不会自动对音乐进行播放。\ncontrols   controls   如果出现该属性，则向用户显示控件，比如播放按钮。\nloop       loop       如果出现该属性，则每当音频结束时重新开始播放。\nmuted      muted      规定视频输出应该被静音。\npreload    preload    如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性。\nsrc        url        要播放的音频的 URL。\n\n<audio controls="controls" height="100" width="100">\n  <source src="song.mp3" type="audio/mp3" />\n  <source src="song.ogg" type="audio/ogg" />\n  \x3c!-- embed标签必须指定width和height，且主要用来兼容旧浏览器，不推荐使用 --\x3e\n  <embed src="song.mp3" height="100" width="100" type="audio/mp3" />\n  您的浏览器不支持\n</audio>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n一般会使用 CSS 统一样式，且使用 JS 添加控制功能！\n\n\n# 视频元素 video\n\n提示\n\nHTML5 元素，支持 IE9 及以上\n\n属性         值          描述\ncontrols   controls   如果出现该属性，则向用户显示控件，比如播放按钮。\nautoplay   autoplay   如果出现该属性，则视频在就绪后马上播放。兼容性不好，一般不会自动播放，除非 muted\nheight     pixels     设置视频播放器的高度。\nloop       loop       如果出现该属性，则当媒介文件完成播放后再次开始播放。\nmuted      muted      规定视频的音频输出应该被静音。\nposter     URL        规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。\npreload    preload    如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性。\nsrc        url        要播放的视频的 URL。\nwidth      pixels     设置视频播放器的宽度。\n\nHTML 5 + <object> + <embed>\n\n<video width="320" height="240" controls="controls">\n  <source src="movie.mp4" type="video/mp4" />\n  <source src="movie.ogg" type="video/ogg" />\n  <source src="movie.webm" type="video/webm" />\n  \x3c!-- 兼容旧浏览器 --\x3e\n  <object data="movie.mp4" width="320" height="240">\n    <embed src="movie.swf" width="320" height="240" />\n  </object>\n  您的浏览器不支持\n</video>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上例中使用了 4 中不同的视频格式。HTML 5 <video> 元素会尝试播放以 mp4、ogg 或 webm 格式中的一种来播放视频。如果均失败，则回退到 <embed>元素。\n\n一般会使用 CSS 统一样式，且使用 JS 添加控制功能！\n\n也可以使用iframe来插入视频网站的通用代码，省下服务器钱\n\n\n# 表单元素\n\n\n# form 表单域\n\n表单域是一个包含表单元素的区域。在 HTML 标签中，<form> 标签用于定义表单域，以实现用户信息的收集和传递。 <form> 会把它范围内的表单元素信息提交给服务器。\n\n<form action="url地址" method="提交方式" name="表单域名称">\n  各种表单控件\n</form>\n\n\n1\n2\n3\n\n\n * name：用于区别一个页面不同的表单域\n\n * action：用于指定接收并处理表单数据的服务器 url 地址，默认提交到当前的页面（可以是一个页面，也可以是后台 URL）\n\n * method：用于设置表单数据的提交方式，默认是 GET 请求\n   \n   GET 和 POST 区别\n   \n   1. GET 请求在地址栏会携带提交的数据（封装到请求行中），POST 请求不会在地址栏携带提交的数据（封装在请求体里面）\n   2. GET 请求数据有大小的限制，POST 没有限制\n   3. GET 请求安全级别较低， POST 较高\n\n * enctype：代表 encode 和 type 结合体，设置提交数据的类型。一般请求下不需要这个属性，做文件上传时候需要设置。此值可以被 <button>或input元素中的 formenctype 属性覆盖。\n   \n   * application/x-www-form-urlencoded\n     \n     默认的编码方式，即表单提交，将表单内的数据转换为 Key-Value\n   \n   * multipart/form-data\n     \n     此值用于一个 type="file" 的input元素，即文件上传时必须为该值，且method必须为POST。它将表单的数据组织成 Key-Value 形式，用分隔符 boundary（boundary 可任意设置）处理成一条消息。由于有 boundary 隔离，所以既可以上传文件，也可以上传参数\n   \n   * text/plain\n     \n     普通文本\n\n * target：可以控制跳转的页面打开方式，属性值同a，不使用\n\n * accept-charset：规定表单提交时使用的字符编码，默认值 unknown，和文档相同的编码。不使用！\n\nmultipart/form-data 与 x-www-form-urlencoded**区别**\n\nHTML 中的 form 表单有两种：\n\n * application/x-www-form-urlencoded是默认的 MIME 内容编码类型，它在传输比较大的二进制或者文本数据时效率极低\n   \n   MIME：简单说，MIME 类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型。服务器会将它们发送的多媒体数据的类型告诉浏览器，而通知手段就是说明该多媒体数据的 MIME 类型，服务器将 MIME 标志符放入传送的数据中来告诉浏览器使用哪种插件读取相关文件\n\n * multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息。当设置 multipart/form-data，http 会忽略 contentType 属性。\n\n小知识\n\nform 表单不支持其他请求方式（也没必要），使用时需要在 input 中添加一个**_method属性**，Ajax 方式示例：\n\n注意：Java 后端需配置HiddenHttpMethodFilter\n\n$.ajax({\n  url: \'/user\',\n  type: \'POST\',\n  data: {\n    _method: \'DELETE\',\n    body: $(\'#form1\').serialize(),\n  },\n  success: function(href) {\n    location.href = href\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 表单提交\n\n传统方式：\n\n * 所有input包裹到一个form\n * form设置action（请求服务器的地址）\n * input或button为 submit 类型（button默认为 submit 类型）\n * 点击提交后，提交有name属性的数据到服务器，\n   * 弊端一：进行页面跳转。意味着服务器必须先将一个页面写好并返回给前端，前端直接展示，即服务端渲染\n   * 弊端二：不方便进行表单数据验证\n\n前后端分离：\n\n * JS 获取所有表单内容\n * 正则验证内容\n * 发送 Ajax 请求，接收后端数据并解析\n\n\n# input\n\n单标签\n\n * text：文本，默认宽度 size 为 20 个字符。使用 action 提交后台需指定 name 属性\n\n * password：密码，字符被掩码，使用 action 提交后台需指定 name 属性\n\n * radio：单选，使用 action 提交后台需指定**相同 name **属性，value\n   \n   * checked，判断时可以通过 true 或 false\n\n * checkbox：多选，使用 action 提交后台需指定**相同 name **属性，value\n   \n   * checked，判断时可以通过 true 或 false\n   * 表单提交时数据格式为hobby=song&hobby=dance\n\n * button：普通按钮，不属于input，需指定 value 值，和 JS 使用\n\n * reset：form 中的重置按钮，默认 value 为重置（根据浏览器翻译）\n\n * submit：form 中的提交按钮，默认 value 为提交（根据浏览器翻译），点击后跳转至指定 action 或本页\n   \n   * 可以获取form，使用其submit()方法，返回 false（true 或无返回值都将跳转）！用于 Ajax 提交表单\n     \n     <a onclick="document:loginForm.submit()">登陆</a>\n     \x3c!--这样也可以提交，但是会跳转。了解--\x3e\n     \n     \n     1\n     2\n     \n   \n   * 可以使用 form 的onsubmit事件，如onsubmit = "return checkForm()"，必须加 return，并且方法返回 boolean 类型，true 提交，false 不提交\n   \n   * 可使用普通 button，配合 JS 来使用 Ajax 提交表单。type 需指定为 button，否则在<form>中 type 会被设置为 submit\n     \n     <input type="submit" />\n     \x3c!--默认为提交（中文环境）、submit（英文环境）--\x3e\n     <input type="submit" value="注册" />\n     \n     \n     1\n     2\n     3\n     \n\n * image：图片提交按钮\n\n * file：上传文件，使用 action 提交后台需指定 name 属性，需要设置enctype\n\n * hidden：隐藏域，使用 action 提交后台需指定 name 属性，value。页面看不到但数据会被提交\n\nHTML5 新添加的 type 类型\n\n * search：搜索，带有x\n * number：定义用于输入数字的字段，会用正则自动校验\n * tel：电话，会用正则自动校验\n\n * email：定义用于 e-mail 地址的字段，会用正则自动校验\n * url：定义用于输入 URL 的字段，会用正则自动校验\n * color：定义拾色器\n * range：定义用于精确值不重要的输入数字的控件（比如 slider 控件）\n * date：定义 date 控件（包括年、月、日，不包括时间）\n * month：年月\n * week：年周\n * time：定义用于输入时分秒的控件（不带时区）\n * datetime-local：定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，不带时区）\n\n其他属性\n\n * name：提交数据到服务器时，用于区分不同字段\n * placeholder：占位符\n * maxlength：允许输入的最大字符数，正整数\n * size：以字符数计的可见宽度，正整数\n * readonly：只读，表单提交时会提交该数据\n * disabled：禁用，表单提交时不会提交该数据\n * required：必填\n * checked：默认选中\n * selected：默认选择\n * autofocus：自动获得焦点\n * autocomplate：on/off，自动完成\n * multiple：文件多选\n * form：可以指定 form 的 ID，即使标签不在 form 中也可以提交数据\n\n布尔类型\n\nchecked、selected、readonly、required、autofocus、multiple、disabled 填任意（即使是空字符串）都是代表true\n\n\n# label\n\n<label> 标签为 input 元素定义标注（标签）。绑定一个表单元素，当点击<label> 标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验\n\n使用方式：\n\n * 用 label 直接包括 input 表单，适合单个表单选择\n   \n   <label>\n     用户名： <input type="radio" name="usename" value="请输入用户名" />\n   </label>\n   \n   \n   1\n   2\n   3\n   \n\n * 用 for 属性规定 label 与哪个表单元素 id 绑定\n   \n   <label for="sex">男</label> <input type="radio" name="sex" id="sex" />\n   \n   \n   1\n   \n\n\n# legend\n\nfieldset的标题\n\n\n# fieldset\n\n表单元素组\n\n\n# select 下拉框\n\n实际中使用 UI 框架，底层可能是用 div 来实现的\n\n使用 action 提交后台需指定 name 属性，option 中指定 value 属性，不指定 value 则默认为标签中数据\n\n<select name="birth" multiple="可以多选, true | false" size="可见选项数目, 2">\n  <option value="1991" selected>1991</option>\n  <option value="1992">1992</option>\n  <option value="1993">1993</option>\n</select>\n\n\n1\n2\n3\n4\n5\n\n\n\n# textarea 文本域\n\n常见于留言板，评论。使用 action 提交后台需指定 name 属性。\n\n<textarea cols="10" rows="10">我是...</textarea>\n\n\n1\n\n\n去掉其可以拖动改变大小\n\ntextarea {\n  resize: none;\n}\n\n\n1\n2\n3\n\n\n\n# 综合练习\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>表单</title>\n    <style>\n      fieldset {\n        width: 300px;\n      }\n      input,\n      textarea {\n        outline: transparent;\n      }\n    </style>\n  </head>\n  <body>\n    <form action="#" method="post">\n      <fieldset>\n        <legend>必填信息</legend>\n        <div>\n          <label for="phone">手机：</label\n          ><input id="phone" name="phone" type="tel" />\n        </div>\n        <div>\n          <label for="password">密码：</label\n          ><input id="password" name="password" type="password" />\n        </div>\n        <div>\n          <label for="verifyCode">验证码：</label\n          ><input id="verifyCode" name="verifyCode" type="text" />\n          <input type="button" value="获取验证码" />\n        </div>\n      </fieldset>\n\n      <fieldset>\n        <legend>选填信息</legend>\n        <div>\n          <label for="name">姓名：</label\n          ><input id="name" name="name" type="text" />\n        </div>\n        <div>\n          <label for="photo">照片：</label\n          ><input id="photo" name="photo" type="file" multiple />\n        </div>\n        <div>\n          <span>性别：</span>\n          <label for="man">男</label\n          ><input type="radio" id="man" name="sex" value="man" />\n          <label for="woman">女</label\n          ><input type="radio" id="woman" name="sex" value="woman" />\n        </div>\n        <div>\n          <label>爱好：</label>\n          <label for="song">唱</label>\n          <input type="checkbox" id="song" name="hobby" value="sing" />\n          <label for="dance">跳</label>\n          <input type="checkbox" id="dance" name="hobby" value="dance" />\n          <label for="rap">rap</label>\n          <input type="checkbox" id="rap" name="hobby" value="rap" />\n          <label for="basketball">篮球</label>\n          <input\n            type="checkbox"\n            id="basketball"\n            name="hobby"\n            value="basketball"\n          />\n        </div>\n        <div>\n          <span>国家：</span>\n          <select name="contry">\n            <option value="China">中国</option>\n            <option svalue="America">美国</option>\n          </select>\n        </div>\n        <div>\n          <label for="extra">备注：</label>\n          <textarea\n            id="extra"\n            name="extra"\n            cols="30"\n            rows="10"\n            placeholder="备注"\n          ></textarea>\n        </div>\n      </fieldset>\n      <input type="submit" value="提交" />\n      <input type="reset" value="重置" />\n    </form>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n\n# 共有属性\n\n\n# title\n\n鼠标放在标签上，会显示 title 中的内容。所有标签都支持',normalizedContent:'# html\n\nhypertext markup language：超文本标记语言\n\n\n# 引言\n\n\n# rendering engine\n\n内核包括：渲染引擎 + js 引擎（如 v8）\n\nrendering engine：排版引擎、解释引擎、渲染引擎，现在流行称为浏览器内核。负责读取网页内容，整理讯息，计算网页的显示方式并显示页面。\n\n浏览器       内核               备注\nie        trident（三叉戟）     ie、猎豹安全、360 浏览器、百度浏览器、uc\nfirefox   gecko（壁虎）        可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友 flash、神一样的对手 chrome。\nsafari    webkit           现在很多人错误地把 webkit 叫做 chrome 内核（即使 chrome 内核已经是 blink 了）。\nchrome    chromium/blink   在 chromium 项目中研发 blink 渲染引擎（即浏览器核心），内置于 chrome 浏览器之中。blink\n                           其实是 webkit 的分支。大部分国产浏览器最新版都采用 blink 内核，二次开发\nopera     blink            现在跟随 chrome 用 blink 内核。\n\n> 移动端的浏览器内核主要说的是系统内置浏览器的内核。android 手机而言，使用率最高的就是 webkit 内核，大部分国产浏览器宣称的自己的内核，基本上也是属于 webkit 二次开发。ios 以及 wp7 平台上，由于系统原因，系统大部分自带浏览器内核，一般是 safari 或者 ie 内核 trident 的\n\n\n# web 标准\n\n构成： 主要包括结构（structure）、表现（presentation）和行为（behavior）三个方面\n\n\n# 文档类型声明\n\n在 vscode 中按下 html:5或!即可出现如下代码：\n\n<!doctype html>\n<html lang="en">\n  <head>\n    \x3c!--定义页面的编码方式--\x3e\n    <meta charset="utf-8" />\n    \x3c!--viewport 为可视区域，它的宽度为设备的宽度--\x3e\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    \x3c!--没有如下两行--\x3e\n    \x3c!--http-equiv 表示执行一个命令，下面设置 http 的 content-type，适配ie--\x3e\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    \x3c!--页面的描述信息，可供搜索引擎显示--\x3e\n    <meta\n      name="keywords"\n      content="网上购物,网上商城,手机,笔记本,电脑,mp3,cd,vcd,dv,相机,数码,配件,手表,存储卡,京东"\n    />\n    <meta\n      name="description"\n      content="京东jd.com-专业的综合网上购物商城...便捷、诚信的服务，为您提供愉悦的网上购物体验!"\n    />\n    <title>document</title>\n  </head>\n  <body></body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<!doctype> 文档类型声明标签，不是一个 html 标签，作用就是告诉浏览器使用哪种 html 版本来显示网页。位于文档中的最前面的位置，必须处于 <html> 标签之前。上述代码的意思是：当前页面采取的是 html5 版本来显示网页。\n\n\n# 根元素<html>\n\n<html>：表示一个 html 文档的根（顶级元素），所有其他元素必须是此元素的后代\n\n\n# lang\n\n用来定义当前文档显示的语言。常用的有：\n\n * lang="zh-cn\n * lang="en"\n\n其实对于文档显示来说，定义成 en 的文档也可以显示中文，定义成 zh-cn 的文档也可以显示英文。这个属性对浏览器和搜索引擎有作用的\n\n * 帮助翻译工具做识别，如弹出是否翻译该页面\n * 根据根据 lang 属性来设定不同语言的 css 样式，或者字体\n * 告诉搜索引擎做精确的识别\n * 让语法检查程序做语言识别\n * 帮助网页阅读程序做识别等等\n\n\n# xmlns\n\n指派文档的 xml 命名空间。默认是http://www.w3.org/1999/xhtml，只在 xhtml 中必要。\n\n\n# 头元素<head>\n\n> 规定文档相关的配置信息（元数据），包括文档的标题，引用的文档样式和脚本等。\n> \n> 文档元数据 metadata：元数据（metadata），含有页面的相关信息，包括样式、脚本及数据，能帮助一些软件（例如：搜索引擎 seo、浏览器 等等）更好地运用和渲染页面。对于样式和脚本的元数据，可以直接在网页里定义，也可以链接到包含相关信息的外部文件。\n\n\n# <base>\n\n指定用于一个文档中包含的所有相对 url 的根 url。一份中只能有一个。一个文档的基本 url，可以通过使用 document.baseuri 的 js 脚本查询。\n\n * 必须有href属性。当具体a中的该属性设置为带协议的链接时，则不受 base 控制\n * 可选择target属性\n\n\n# <meta>\n\n该元素表示那些不能由其它 html 元相关元素 (<base>, <link>, <script>, <style> 或 <title>) 之一表示的任何元数据信息。\n\n# charset属性\n\n规定 html 文档应该使用哪种字符集。让浏览器根据编码去解码对应的 html 内容，文件不一定是这个编码。字符集 (character set)是多个字符的集合。以便计算机能够识别和存储各种文字。统一使用 utf-8，必须写。\n\n\x3c!-- in html5 --\x3e\n<meta charset="utf-8" />\n\n\n1\n2\n\n\n# name content属性\n\nname 常用值有：\n\n * keywords\n * description\n\n\x3c!--viewport 为可视区域，它的宽度为设备的宽度--\x3e\n<meta name="viewport" content="width=device-width, initial-scale=1.0" />\n\x3c!--页面的描述信息，可供搜索引擎显示--\x3e\n<meta\n  name="keywords"\n  content="网上购物,网上商城,手机,笔记本,电脑,mp3,cd,vcd,dv,相机,数码,配件,手表,存储卡,京东"\n/>\n<meta\n  name="description"\n  content="京东jd.com-专业的综合网上购物商城...便捷、诚信的服务，为您提供愉悦的网上购物体验!"\n/>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n# http-equiv content 属性\n\n\x3c!--http-equiv 表示执行一个命令，下面设置 http 的 content-type，适配ie--\x3e\n<meta http-equiv="x-ua-compatible" content="ie=edge" />\n\x3c!-- redirect page after 3 seconds --\x3e\n<meta http-equiv="refresh" content="3;url=http://www.mozilla.org/" />\n\n\n1\n2\n3\n4\n\n\n\n# <title>\n\n该元素定义文档的标题，显示在浏览器的标题栏，标签页及超链接上。它只可以包含文本，若是包含有标签，则包含的任何标签都不会被解释。搜索引擎会根据 title 中的内容来判断网页的主要内容。\n\n\n# <link>\n\n该元素规定了外部资源与当前文档的关系。这个元素最常于链接 css 样式表，还能被用来创建站点图标（比如 pc 端的“favicon”图标和移动设备上用以显示在主屏幕的图标）甚至一些其他事情。\n\n\n# <style>\n\n该元素包含文档的样式信息或者文档的部分内容。默认情况下，该标签的样式信息通常是 css 的格式。\n\n\n# 分区根元素<body>\n\n<body>：该元素表示文档的内容。document.body属性提供了可以轻松访问文档的 body 元素的脚本。\n\n\n# 内容分区（逻辑分区）\n\n内容分区元素允许你将文档内容从逻辑上进行组织划分。使用包括页眉(header)、页脚(footer)、导航(nav)和标题(h1~h6)等分区元素，来为页面内容创建明确的大纲，以便区分各个章节的内容。\n\n\n# 常用元素\n\n\n# 排版元素\n\n<hgroup> 用来为标题分组，可以将一组相关的标题同时放入到 hgroup，h5 标签，注意兼容性\n\n<h1>标题</h1> 标题，取值 1~6 从大到小。是块元素，自动在其前后加空行，其实是段间距。有助于 seo，h1 重要性仅次于 title 标签，建议只有一个\n\n<p>html</p> 段落，paragraph 缩写，是块元素，自动在其前后加空行，其实是段间距。不能包含任何块元素\n\n<blockquote>我周树人从没说过这话</blockquote> 长引用，有缩进，块元素，知乎常用\n\n<q>子曰：学而时习之</q> 短引用，引号引用起来，行内元素，无法被选中（可以使用伪元素实现）\n\n<hr/> 横线，horizontal 缩写\n\n<br/> 换行，break 缩写\n\n<div></div> 块元素，division 缩写，自动换行。独占一行（即使宽度比较小）\n\n<span></span> 行内元素\n\n根据元素的语义，在合适的地方给一个最为合理的元素，让结构更清晰。一般先写语义化 html，之后才写 css\n\n * 方便代码的阅读和维护\n * 同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容\n * 使用语义化标签会具有更好地搜索引擎优化\n * 这些新标签页面中可以使用多次\n * 在 ie9 中，需要把这些元素转换为块级元素\n * 移动端更喜欢使用这些标签\n\n标签如下：\n\n<header>表示网页的头部</header>\n<nav>导航栏</nav>\n<aside>侧边栏</aside>\n\n<main>\n  表示网页的主体部分(一个页面中只会有一个main)\n  <article>\n    <h2>\n      标题\n    </h2>\n    <p>\n      内容\n    </p>\n  </article>\n  <figure>\n    <figcaption>figure 元素的标题</figcaption>\n    figure 元素的内容，比如图示、图表、照片、代码清单等。\n  </figure>\n  <section>\n    定义文档中的节，区域，表示一个独立的区块，上面标签都不能表示时使用section\n  </section>\n</main>\n<footer>表示网页的底部</footer>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 文本格式化元素\n\n<b>粗体</b> ；<strong>强调文本</strong> ，推荐使用带语义化的\n\n<i>斜体</i> ；<em>强调文本</em> ，推荐使用带语义化的。很多网站喜欢用i来修饰图片，类似 icon\n\n<u>下划线</u> ；<ins>下划线</ins>，推荐使用带语义化的\n\n<s>删除线</s>；<del>删除线</del> ，推荐使用带语义化的\n\n----------------------------------------\n\n\x3c!-- 注释 --\x3e 注释\n\n<pre></pre> 预格式文本，元素中的文本通常会保留空格和换行符，而文本也会呈现为等宽字体，不常用\n\n<code></code> 代码格式，等宽字体显示\n\n<sup>上标</sup>\n\n<sub>下标</sub>\n\n\n# 字符实体\n\n&lt;、&gt;、&nbsp;、&amp;、&copy;、&reg; 分别为：<、>、 空格、 &、 ©、 ®\n\n其他参考文档\n\n\n# 列表元素\n\n提示\n\n块级元素。用来布局的， 因为非常整齐和自由。样式推荐使用 css 的list-style: none实现\n\n<ul> <ol> <li> 无序（常用）、有序、列表\n\n * li 间可以容纳所有元素\n * 无序、有序列表会自带样式，应使用 css 重写替代\n * reversed：列表倒序，用于有序列表\n\n * type=\'1\'或\'a\'或\'i\'或\'a\'或\'i\' 用于有序列表，请使用 css 替代；\n * start 用于有序列表，html5 不支持，请使用 css 替代；\n\n<dl> <dt> <dd> 定义列表（常用）带有术语或名词和描述。常见于页面下面帮助部分。\n\n * 定义列表的列表项前没有任何项目符号\n * dd 元素会有缩进\n\n\n# 表格元素\n\n提示\n\n块级元素。不是用来布局，常用显示、展示数据。样式推荐使用 css 的border-实现\n\n<html>\n  <table>\n    <caption>\n      表格测试\n    </caption>\n    <thead>\n      <tr>\n        <th>班级</th>\n        <th>姓名</th>\n        <th>性别</th>\n        <th colspan="2">操作</th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr>\n        <td rowspan="2">一 班</td>\n        <td>张三</td>\n        <td>男</td>\n        <td>修改</td>\n        <td>删除</td>\n      </tr>\n      <tr>\n        <td>李四</td>\n        <td>男</td>\n        <td>修改</td>\n        <td>删除</td>\n      </tr>\n    </tbody>\n    <tfoot>\n      <tr>\n        <td colspan="5">备注</td>\n      </tr>\n    </tfoot>\n  </table>\n</html>\n<style>\n  table {\n    /* 合并细线边框 */\n    border-collapse: collapse;\n    /* 单元格之间水平、垂直距离，与 border-collapse 冲突，不常用 */\n    /*border-spacing: 10px 20px;*/\n    /* 表格居中 */\n    margin: 0 auto;\n  }\n  th,\n  td {\n    /* 边框 */\n    border: 1px solid skyblue;\n    /* 内边距 */\n    padding: 20px;\n    /* 让td居中，th本来就是居中的 */\n    text-align: center;\n    /* 默认情况下元素在th,td中是垂直居中的，也可以通过 vertical-align 来修改*/\n    /* 由此可得，对一个父元素设置 display: table-cell，可以直接使用 vertical-align 来垂直居中*/\n  }\n  /* 标题 */\n  caption {\n    font-weight: 700;\n    font-size: 24px;\n    margin-bottom: 20px;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n\n\n\n * 表头单元格 th 也是单元格，常用于表格第一行，突出重要性，表头单元格里面的文字会加粗居中显示\n\n * 注意：表格中占多行的只属于第一行，占多列同理\n\n * 在 html5 中，仅支持 "border" 属性，并且只允许使用值 "1" 或 ""。不推荐使用\n   \n   之前使用的cellspacing（单元格之间距离）、cellpadding（内容与单元格边框距离）应该使用 css 实现，具体在 css 章节体现\n   \n   table {\n     /* 合并细线边框 */\n     border-collapse: collapse;\n     /* 单元格之间水平、垂直距离，与 border-collapse 冲突，不常用 */\n     /*border-spacing: 10px 20px;*/\n     /* 表格居中 */\n     margin: 100px auto;\n   }\n   th,\n   td {\n     /* 边框 */\n     border: 1px solid skyblue;\n     /* 内边距 */\n     padding: 30px;\n     /* 默认情况下元素在th,td中是垂直居中的，也可以通过 vertical-align 来修改*/\n     /* 由此可得，对一个父元素设置 display: table-cell，可以直接使用 vertical-align 来垂直居中*/\n   }\n   caption {\n     font-weight: 700;\n     font-size: 24px;\n     margin-bottom: 20px;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\nth, td 自然垂直居中的提示（了解）\n\n默认情况下元素在 th,td 中是垂直居中的。由此可得，对一个父元素设置display: table-cell，可以直接使用 vertical-align 来使子元素垂直居中\n\n<style>\n  .box1 {\n    display: table-cell;\n    vertical-align: middle;\n    width: 400px;\n    height: 400px;\n    background-color: skyblue;\n  }\n\n  .box2 {\n    width: 100px;\n    height: 100px;\n    background-color: pink;\n    margin: 0 auto;\n  }\n</style>\n<div class="box1">\n  <div class="box2"></div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 超链接元素\n\n提示\n\nanchor [ˈæŋkə(r)] 的缩写，含义为：锚、铁锚。行内元素\n\n<a href="https://www.qq.com" target="_blank">新窗口打开qq</a>\n\n\n1\n\n\n属性       作用\nhref     用于指定链接目标的 url 地址，（必须属性）当为标签应用 href 属性时，它就具有了超链接的功能\ntarget   用于指定链接页面的打开方式，取值：其中_self为当前页面打开，默认值，_blank为在新窗口中打开，_parent加载到当前的\n         html5 浏览上下文的父浏览上下文，_top加载响应进入顶层浏览上下文。\n\n可在<head>的<base>标签中设置全局href和target\n\n * 外部链接： http:// www.baidu.com，需要协议开头\n\n * 内部链接：直接链接内部页面名称即可 <a href="index.html">首页</a>\n\n * 锚点定位：当时没有确定链接目标或目标为当前页，可将href属性值定义为#，表示该链接暂时为一个空链接，默认跳转当前页。可以通过该方式来定位资源：\n   \n   <div id="top">top</div>\n   <a href="#top">returntop</a>\n   \n   \n   1\n   2\n   \n\n * 不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。如包裹<img>标签\n\n * 发送邮件\n   \n   <a href="mailto:xxx@gmail.com">联系我们</a>\n   \n   \n   1\n   \n\n * 下载链接：如果 href 里面地址是一个文件或者压缩包，会下载这个文件。\n\n * 伪链接，禁止跳转：二选一\n   \n   <a href="javascript:;">1</a>\n   \x3c!-- 好像写void，或void()，或void(0)都一样。void(0)表示计算一个表达式（此处为0）但不返回值 --\x3e\n   <a href="javascript:void(0);">1</a>\n   \n   \x3c!-- 写不写#都一样 --\x3e\n   <a href="#" onclick="return false">2</a>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   只写href="#"则跳回页面顶部\n\n * 去掉input或a或button或select或textraea的 focus 轮廓蓝线\n   \n   /* 看不到 outline 蓝色边框线。button 和 a 只有使用 tab 才可以看到 */\n   input,\n   select,\n   textarea,\n   button,\n   a {\n     outline: none;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   \x3c!-- tableindex 调整tab选择顺序，负数则不会被选择。也可以不设置 --\x3e\n   <input type="text" />111<br />\n   <select name="" id="">\n     <option value="1">1</option>\n     <option value="2">2</option>\n   </select>\n   <textarea name="aa" id="" cols="30" rows="10">222</textarea>\n   <button>111</button>\n   <a href="#">222</a>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 去掉 a 的下划线\n   \n   a {\n     text-decoration: none;\n   }\n   \n   \n   1\n   2\n   3\n   \n\n\n# 图片元素\n\n提示\n\nimage 的缩写。替换元素，有块元素和行内元素的特点\n\n<img src="test.jpg" width="400" alt="无法显示" />\n\x3c!--可嵌套在 a 标签里--\x3e\n\n\n1\n2\n\n\n属性       属性值                   描述\nsrc      url                   图像路径\nalt      文本                    h5 推荐必加属性，图像不能显示时的替换文本，有利于 seo\ntitle    文本                    鼠标悬停时显示的内容\nwidth    像素（xhtml 不支持%页面百分比）   设置图像宽度，一般只改一个（等比缩放），不带单位默认为 px\nheight   像素（xhtml 不支持%页面百分比）   设置图像高度，一般只改一个（等比缩放），不带单位默认为 px\nborder   数字                    设置图像边框的宽度，后续使用 css 完成\n\nweb 中常见的图片格式：\n\n * png：静态，支持复杂透明。支持的颜色丰富，网页使用最多！\n * jpg/jpeg：静态，不支持透明。支持的颜色比较丰富。\n * gif：动态，静态，支持简单透明，支持的颜色比较少。\n * webp：谷歌的，比 jpg 压缩率更高，但质量比 png 还好，还支持动态。**优势非常明显！**但是兼容性不好。\n * base64：将图片进行 base64 编码，转换为字符引入，一般用于需要和网页一起加载的图片。但是字符太长。\n\n\n# 内联框架 iframe\n\n类似 img，但是 iframe 是用于网页中嵌套网页，不利于 seo，且每次都要重新渲染\n\n<iframe\n        src="https://news.qq.com/"\n        width="1000"\n        height="800"\n        frameborder="0">\n</iframe>\n\n\n1\n2\n3\n4\n5\n6\n\n\nsrc可以是外部或内部网页， frameborder只有 0 或 1，0 代表没有边框，默认值为 1\n\n当 iframe 中网页的a标签的target=_parent时，将从当前页面打开，而不是在 iframe 中打开，_top在多层 iframe 中适用\n\n也可以指定target="a"，即在指定name="a"的 iframe 中打开\n\n框架标签，不赞成使用\n\n<frameset rows="80,*">                        //把页面划分成上下两部分\n<frame name="top" src="a.html">             //上面页面\n<frameset cols="150,*">                     //把下面部分划分成左右两部分\n\t\t<frame name="lower_left" src="b.html">  //左边的页面\n\t\t<frame name="lower_right" src="c.html"> //右边的页面\n\t</frameset>\n</frameset>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n点击左边的页面超链接，内容显示在右边的页面中\n\n<a href="01-hello.html" target="right">超链接1</a>\n\n\n1\n\n\n\n# 音频元素 radio\n\n提示\n\nhtml5 元素，支持 ie9 及以上\n\n属性         值          描述\nautoplay   autoplay   如果出现该属性，则音频在就绪后马上播放。但是目前来讲大部分浏览器都不会自动对音乐进行播放。\ncontrols   controls   如果出现该属性，则向用户显示控件，比如播放按钮。\nloop       loop       如果出现该属性，则每当音频结束时重新开始播放。\nmuted      muted      规定视频输出应该被静音。\npreload    preload    如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性。\nsrc        url        要播放的音频的 url。\n\n<audio controls="controls" height="100" width="100">\n  <source src="song.mp3" type="audio/mp3" />\n  <source src="song.ogg" type="audio/ogg" />\n  \x3c!-- embed标签必须指定width和height，且主要用来兼容旧浏览器，不推荐使用 --\x3e\n  <embed src="song.mp3" height="100" width="100" type="audio/mp3" />\n  您的浏览器不支持\n</audio>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n一般会使用 css 统一样式，且使用 js 添加控制功能！\n\n\n# 视频元素 video\n\n提示\n\nhtml5 元素，支持 ie9 及以上\n\n属性         值          描述\ncontrols   controls   如果出现该属性，则向用户显示控件，比如播放按钮。\nautoplay   autoplay   如果出现该属性，则视频在就绪后马上播放。兼容性不好，一般不会自动播放，除非 muted\nheight     pixels     设置视频播放器的高度。\nloop       loop       如果出现该属性，则当媒介文件完成播放后再次开始播放。\nmuted      muted      规定视频的音频输出应该被静音。\nposter     url        规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。\npreload    preload    如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性。\nsrc        url        要播放的视频的 url。\nwidth      pixels     设置视频播放器的宽度。\n\nhtml 5 + <object> + <embed>\n\n<video width="320" height="240" controls="controls">\n  <source src="movie.mp4" type="video/mp4" />\n  <source src="movie.ogg" type="video/ogg" />\n  <source src="movie.webm" type="video/webm" />\n  \x3c!-- 兼容旧浏览器 --\x3e\n  <object data="movie.mp4" width="320" height="240">\n    <embed src="movie.swf" width="320" height="240" />\n  </object>\n  您的浏览器不支持\n</video>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n上例中使用了 4 中不同的视频格式。html 5 <video> 元素会尝试播放以 mp4、ogg 或 webm 格式中的一种来播放视频。如果均失败，则回退到 <embed>元素。\n\n一般会使用 css 统一样式，且使用 js 添加控制功能！\n\n也可以使用iframe来插入视频网站的通用代码，省下服务器钱\n\n\n# 表单元素\n\n\n# form 表单域\n\n表单域是一个包含表单元素的区域。在 html 标签中，<form> 标签用于定义表单域，以实现用户信息的收集和传递。 <form> 会把它范围内的表单元素信息提交给服务器。\n\n<form action="url地址" method="提交方式" name="表单域名称">\n  各种表单控件\n</form>\n\n\n1\n2\n3\n\n\n * name：用于区别一个页面不同的表单域\n\n * action：用于指定接收并处理表单数据的服务器 url 地址，默认提交到当前的页面（可以是一个页面，也可以是后台 url）\n\n * method：用于设置表单数据的提交方式，默认是 get 请求\n   \n   get 和 post 区别\n   \n   1. get 请求在地址栏会携带提交的数据（封装到请求行中），post 请求不会在地址栏携带提交的数据（封装在请求体里面）\n   2. get 请求数据有大小的限制，post 没有限制\n   3. get 请求安全级别较低， post 较高\n\n * enctype：代表 encode 和 type 结合体，设置提交数据的类型。一般请求下不需要这个属性，做文件上传时候需要设置。此值可以被 <button>或input元素中的 formenctype 属性覆盖。\n   \n   * application/x-www-form-urlencoded\n     \n     默认的编码方式，即表单提交，将表单内的数据转换为 key-value\n   \n   * multipart/form-data\n     \n     此值用于一个 type="file" 的input元素，即文件上传时必须为该值，且method必须为post。它将表单的数据组织成 key-value 形式，用分隔符 boundary（boundary 可任意设置）处理成一条消息。由于有 boundary 隔离，所以既可以上传文件，也可以上传参数\n   \n   * text/plain\n     \n     普通文本\n\n * target：可以控制跳转的页面打开方式，属性值同a，不使用\n\n * accept-charset：规定表单提交时使用的字符编码，默认值 unknown，和文档相同的编码。不使用！\n\nmultipart/form-data 与 x-www-form-urlencoded**区别**\n\nhtml 中的 form 表单有两种：\n\n * application/x-www-form-urlencoded是默认的 mime 内容编码类型，它在传输比较大的二进制或者文本数据时效率极低\n   \n   mime：简单说，mime 类型就是设定某种扩展名的文件用一种应用程序来打开的方式类型。服务器会将它们发送的多媒体数据的类型告诉浏览器，而通知手段就是说明该多媒体数据的 mime 类型，服务器将 mime 标志符放入传送的数据中来告诉浏览器使用哪种插件读取相关文件\n\n * multipart/form-data：既可以上传文件等二进制数据，也可以上传表单键值对，只是最后会转化为一条信息。当设置 multipart/form-data，http 会忽略 contenttype 属性。\n\n小知识\n\nform 表单不支持其他请求方式（也没必要），使用时需要在 input 中添加一个**_method属性**，ajax 方式示例：\n\n注意：java 后端需配置hiddenhttpmethodfilter\n\n$.ajax({\n  url: \'/user\',\n  type: \'post\',\n  data: {\n    _method: \'delete\',\n    body: $(\'#form1\').serialize(),\n  },\n  success: function(href) {\n    location.href = href\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 表单提交\n\n传统方式：\n\n * 所有input包裹到一个form\n * form设置action（请求服务器的地址）\n * input或button为 submit 类型（button默认为 submit 类型）\n * 点击提交后，提交有name属性的数据到服务器，\n   * 弊端一：进行页面跳转。意味着服务器必须先将一个页面写好并返回给前端，前端直接展示，即服务端渲染\n   * 弊端二：不方便进行表单数据验证\n\n前后端分离：\n\n * js 获取所有表单内容\n * 正则验证内容\n * 发送 ajax 请求，接收后端数据并解析\n\n\n# input\n\n单标签\n\n * text：文本，默认宽度 size 为 20 个字符。使用 action 提交后台需指定 name 属性\n\n * password：密码，字符被掩码，使用 action 提交后台需指定 name 属性\n\n * radio：单选，使用 action 提交后台需指定**相同 name **属性，value\n   \n   * checked，判断时可以通过 true 或 false\n\n * checkbox：多选，使用 action 提交后台需指定**相同 name **属性，value\n   \n   * checked，判断时可以通过 true 或 false\n   * 表单提交时数据格式为hobby=song&hobby=dance\n\n * button：普通按钮，不属于input，需指定 value 值，和 js 使用\n\n * reset：form 中的重置按钮，默认 value 为重置（根据浏览器翻译）\n\n * submit：form 中的提交按钮，默认 value 为提交（根据浏览器翻译），点击后跳转至指定 action 或本页\n   \n   * 可以获取form，使用其submit()方法，返回 false（true 或无返回值都将跳转）！用于 ajax 提交表单\n     \n     <a onclick="document:loginform.submit()">登陆</a>\n     \x3c!--这样也可以提交，但是会跳转。了解--\x3e\n     \n     \n     1\n     2\n     \n   \n   * 可以使用 form 的onsubmit事件，如onsubmit = "return checkform()"，必须加 return，并且方法返回 boolean 类型，true 提交，false 不提交\n   \n   * 可使用普通 button，配合 js 来使用 ajax 提交表单。type 需指定为 button，否则在<form>中 type 会被设置为 submit\n     \n     <input type="submit" />\n     \x3c!--默认为提交（中文环境）、submit（英文环境）--\x3e\n     <input type="submit" value="注册" />\n     \n     \n     1\n     2\n     3\n     \n\n * image：图片提交按钮\n\n * file：上传文件，使用 action 提交后台需指定 name 属性，需要设置enctype\n\n * hidden：隐藏域，使用 action 提交后台需指定 name 属性，value。页面看不到但数据会被提交\n\nhtml5 新添加的 type 类型\n\n * search：搜索，带有x\n * number：定义用于输入数字的字段，会用正则自动校验\n * tel：电话，会用正则自动校验\n\n * email：定义用于 e-mail 地址的字段，会用正则自动校验\n * url：定义用于输入 url 的字段，会用正则自动校验\n * color：定义拾色器\n * range：定义用于精确值不重要的输入数字的控件（比如 slider 控件）\n * date：定义 date 控件（包括年、月、日，不包括时间）\n * month：年月\n * week：年周\n * time：定义用于输入时分秒的控件（不带时区）\n * datetime-local：定义 date 和 time 控件（包括年、月、日、时、分、秒、几分之一秒，不带时区）\n\n其他属性\n\n * name：提交数据到服务器时，用于区分不同字段\n * placeholder：占位符\n * maxlength：允许输入的最大字符数，正整数\n * size：以字符数计的可见宽度，正整数\n * readonly：只读，表单提交时会提交该数据\n * disabled：禁用，表单提交时不会提交该数据\n * required：必填\n * checked：默认选中\n * selected：默认选择\n * autofocus：自动获得焦点\n * autocomplate：on/off，自动完成\n * multiple：文件多选\n * form：可以指定 form 的 id，即使标签不在 form 中也可以提交数据\n\n布尔类型\n\nchecked、selected、readonly、required、autofocus、multiple、disabled 填任意（即使是空字符串）都是代表true\n\n\n# label\n\n<label> 标签为 input 元素定义标注（标签）。绑定一个表单元素，当点击<label> 标签内的文本时，浏览器就会自动将焦点（光标）转到或者选择对应的表单元素上，用来增加用户体验\n\n使用方式：\n\n * 用 label 直接包括 input 表单，适合单个表单选择\n   \n   <label>\n     用户名： <input type="radio" name="usename" value="请输入用户名" />\n   </label>\n   \n   \n   1\n   2\n   3\n   \n\n * 用 for 属性规定 label 与哪个表单元素 id 绑定\n   \n   <label for="sex">男</label> <input type="radio" name="sex" id="sex" />\n   \n   \n   1\n   \n\n\n# legend\n\nfieldset的标题\n\n\n# fieldset\n\n表单元素组\n\n\n# select 下拉框\n\n实际中使用 ui 框架，底层可能是用 div 来实现的\n\n使用 action 提交后台需指定 name 属性，option 中指定 value 属性，不指定 value 则默认为标签中数据\n\n<select name="birth" multiple="可以多选, true | false" size="可见选项数目, 2">\n  <option value="1991" selected>1991</option>\n  <option value="1992">1992</option>\n  <option value="1993">1993</option>\n</select>\n\n\n1\n2\n3\n4\n5\n\n\n\n# textarea 文本域\n\n常见于留言板，评论。使用 action 提交后台需指定 name 属性。\n\n<textarea cols="10" rows="10">我是...</textarea>\n\n\n1\n\n\n去掉其可以拖动改变大小\n\ntextarea {\n  resize: none;\n}\n\n\n1\n2\n3\n\n\n\n# 综合练习\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>表单</title>\n    <style>\n      fieldset {\n        width: 300px;\n      }\n      input,\n      textarea {\n        outline: transparent;\n      }\n    </style>\n  </head>\n  <body>\n    <form action="#" method="post">\n      <fieldset>\n        <legend>必填信息</legend>\n        <div>\n          <label for="phone">手机：</label\n          ><input id="phone" name="phone" type="tel" />\n        </div>\n        <div>\n          <label for="password">密码：</label\n          ><input id="password" name="password" type="password" />\n        </div>\n        <div>\n          <label for="verifycode">验证码：</label\n          ><input id="verifycode" name="verifycode" type="text" />\n          <input type="button" value="获取验证码" />\n        </div>\n      </fieldset>\n\n      <fieldset>\n        <legend>选填信息</legend>\n        <div>\n          <label for="name">姓名：</label\n          ><input id="name" name="name" type="text" />\n        </div>\n        <div>\n          <label for="photo">照片：</label\n          ><input id="photo" name="photo" type="file" multiple />\n        </div>\n        <div>\n          <span>性别：</span>\n          <label for="man">男</label\n          ><input type="radio" id="man" name="sex" value="man" />\n          <label for="woman">女</label\n          ><input type="radio" id="woman" name="sex" value="woman" />\n        </div>\n        <div>\n          <label>爱好：</label>\n          <label for="song">唱</label>\n          <input type="checkbox" id="song" name="hobby" value="sing" />\n          <label for="dance">跳</label>\n          <input type="checkbox" id="dance" name="hobby" value="dance" />\n          <label for="rap">rap</label>\n          <input type="checkbox" id="rap" name="hobby" value="rap" />\n          <label for="basketball">篮球</label>\n          <input\n            type="checkbox"\n            id="basketball"\n            name="hobby"\n            value="basketball"\n          />\n        </div>\n        <div>\n          <span>国家：</span>\n          <select name="contry">\n            <option value="china">中国</option>\n            <option svalue="america">美国</option>\n          </select>\n        </div>\n        <div>\n          <label for="extra">备注：</label>\n          <textarea\n            id="extra"\n            name="extra"\n            cols="30"\n            rows="10"\n            placeholder="备注"\n          ></textarea>\n        </div>\n      </fieldset>\n      <input type="submit" value="提交" />\n      <input type="reset" value="重置" />\n    </form>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n\n# 共有属性\n\n\n# title\n\n鼠标放在标签上，会显示 title 中的内容。所有标签都支持',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"基础",frontmatter:{title:"基础",date:"2019-12-21T17:49:41.000Z",permalink:"/pages/d8978d/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/200.CSS%E5%9F%BA%E7%A1%80/201.CSS-1%E5%9F%BA%E7%A1%80.html",relativePath:"1100.H5&CSS3/200.CSS基础/201.CSS-1基础.md",key:"v-15a8cec6",path:"/pages/d8978d/",headers:[{level:2,title:"书籍推荐",slug:"书籍推荐",normalizedTitle:"书籍推荐",charIndex:92},{level:2,title:"引入方式",slug:"引入方式",normalizedTitle:"引入方式",charIndex:119},{level:3,title:"inline style",slug:"inline-style",normalizedTitle:"inline style",charIndex:128},{level:3,title:"document style sheet",slug:"document-style-sheet",normalizedTitle:"document style sheet",charIndex:261},{level:3,title:"external style sheet",slug:"external-style-sheet",normalizedTitle:"external style sheet",charIndex:611},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:1405},{level:2,title:"选择器",slug:"选择器",normalizedTitle:"选择器",charIndex:497},{level:3,title:"通用（通配符）选择器",slug:"通用-通配符-选择器",normalizedTitle:"通用（通配符）选择器",charIndex:1714},{level:3,title:"id 选择器",slug:"id-选择器",normalizedTitle:"id 选择器",charIndex:1829},{level:3,title:"class 选择器",slug:"class-选择器",normalizedTitle:"class 选择器",charIndex:1905},{level:3,title:"元素选择器",slug:"元素选择器",normalizedTitle:"元素选择器",charIndex:1999},{level:3,title:"属性选择器",slug:"属性选择器",normalizedTitle:"属性选择器",charIndex:2070},{level:3,title:"组合选择器",slug:"组合选择器",normalizedTitle:"组合选择器",charIndex:3192},{level:3,title:"伪类选择器 :",slug:"伪类选择器",normalizedTitle:"伪类选择器 :",charIndex:3568},{level:4,title:"动态伪类 🔥",slug:"动态伪类-🔥",normalizedTitle:"动态伪类 🔥",charIndex:3617},{level:4,title:"元素状态伪类 🔥",slug:"元素状态伪类-🔥",normalizedTitle:"元素状态伪类 🔥",charIndex:4026},{level:4,title:"结构伪类 🔥",slug:"结构伪类-🔥",normalizedTitle:"结构伪类 🔥",charIndex:4153},{level:4,title:"目标伪类—锚点",slug:"目标伪类-锚点",normalizedTitle:"目标伪类—锚点",charIndex:8030},{level:4,title:"空伪类",slug:"空伪类",normalizedTitle:"空伪类",charIndex:8342},{level:4,title:"否定伪类",slug:"否定伪类",normalizedTitle:"否定伪类",charIndex:8412},{level:4,title:"语言伪类",slug:"语言伪类",normalizedTitle:"语言伪类",charIndex:8607},{level:3,title:"伪元素选择器 ::",slug:"伪元素选择器",normalizedTitle:"伪元素选择器 ::",charIndex:8623},{level:4,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:8636},{level:4,title:"伪元素字体图标",slug:"伪元素字体图标",normalizedTitle:"伪元素字体图标",charIndex:10295},{level:4,title:"仿视频遮罩功能",slug:"仿视频遮罩功能",normalizedTitle:"仿视频遮罩功能",charIndex:11408},{level:4,title:"清除浮动",slug:"清除浮动",normalizedTitle:"清除浮动",charIndex:11817},{level:2,title:"特性",slug:"特性",normalizedTitle:"特性",charIndex:11839},{level:3,title:"层叠性 🔥",slug:"层叠性-🔥",normalizedTitle:"层叠性 🔥",charIndex:11846},{level:3,title:"继承性 🔥",slug:"继承性-🔥",normalizedTitle:"继承性 🔥",charIndex:13397},{level:2,title:"元素分类",slug:"元素分类",normalizedTitle:"元素分类",charIndex:14187},{level:3,title:"块级元素 block element",slug:"块级元素-block-element",normalizedTitle:"块级元素 block element",charIndex:14196},{level:3,title:"行内元素 inline element",slug:"行内元素-inline-element",normalizedTitle:"行内元素 inline element",charIndex:14380},{level:3,title:"替换元素",slug:"替换元素",normalizedTitle:"替换元素",charIndex:14435},{level:3,title:"非替换元素",slug:"非替换元素",normalizedTitle:"非替换元素",charIndex:14434},{level:3,title:"总结",slug:"总结-2",normalizedTitle:"总结",charIndex:1405},{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:16343},{level:3,title:"calc 计算",slug:"calc-计算",normalizedTitle:"calc 计算",charIndex:16350}],headersStr:"书籍推荐 引入方式 inline style document style sheet external style sheet 总结 选择器 通用（通配符）选择器 id 选择器 class 选择器 元素选择器 属性选择器 组合选择器 伪类选择器 : 动态伪类 🔥 元素状态伪类 🔥 结构伪类 🔥 目标伪类—锚点 空伪类 否定伪类 语言伪类 伪元素选择器 :: 介绍 伪元素字体图标 仿视频遮罩功能 清除浮动 特性 层叠性 🔥 继承性 🔥 元素分类 块级元素 block element 行内元素 inline element 替换元素 非替换元素 总结 函数 calc 计算",content:'# 基础\n\n * CSS（cascading style sheets，层叠样式表）：多个样式可以作用在同一个 html 元素上，同时生效。\n\n * 将网页内容和样式进行分离\n\n\n# 书籍推荐\n\n * 《CSS 权威指南第四版》\n\n\n# 引入方式\n\n\n# inline style\n\n内联样式。在每个 html 标签上面都有一个 style 属性，把 css 和 html 结合在一起，不推荐\n\n<标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"> 内容 </标签名>\n\n\n1\n\n\n\n# document style sheet\n\n文档样式表，或称作 embed style sheet 即内嵌样式表\n\n将 CSS 代码集中写在 HTML 文档的 <head> 头部标签中，并且用 <style> 标签定义\n\n * style 标签一般位于 head 标签中，当然理论上他可以放在 HTML 文档的任何地方\n * type="text/css" 在 html5 中可以省略。\n * 只能控制当前的页面，没有彻底分离\n\n<head>\n  <style>\n    选择器（选择的标签） {\n      属性1: 属性值1;\n      属性2: 属性值2;\n      属性3: 属性值3;\n    }\n  </style>\n</head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# external style sheet\n\n外部样式表。将所有的样式放在一个或多个以**.css为扩展名的外部样式表文件中，通过<link>标签**将外部样式表文件链接到 HTML 文档中\n\n * link 是个单标签\n * link 标签需要放在 head 头部标签中，并且指定 link 标签的三个属性\n * 可以样式共享，复用\n * 可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验\n\n<head>\n  <link rel="stylesheet" href="css文件路径" />\n</head>\n\n\n1\n2\n3\n\n\n属性     作用\nrel    定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。\nhref   定义所链接外部样式表文件的 URL，可以是相对路径，也可以是绝对路径。\ntype   定义所链接文档的类型，在这里需要指定为“text/css”，表示链接的外部文件为 CSS 样式表。我们都可以省略\n\n注意\n\n在 external style sheet 的外部 CSS 文件中，有时有必要设置 CSS 文件的编码（如使用font-family的中文字体时）\n\n@charset "UTF-8"; /*可在首行添加*/\n\n\n1\n\n\nstyle 标签中也可以引入外部 CSS 文件。还可以在 CSS 文件中引入其他 CSS 文件。\n\n对比来说使用 link比import效率高，在现代框架中使用很多import是因为可以打包重新编译生成\n\n<style>\n  /* 二选一 */\n  @import url(./css/style.css); /*也可以用引号括起来*/\n  @import \'./css/style.css\';\n</style>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 总结\n\n优先级：相同的设置，由上到下，由外到内，优先级由低到高。 **后加载的优先级高，**就近原则或叠加\n\n样式表    优点             缺点             使用情况      控制范围\n内联样式   书写方便，权重高       没有实现样式和结构相分离   较少        控制一个标签（少）\n内嵌样式   部分结构和样式相分离     没有彻底分离         较多        控制一个页面（中）\n外链样式   完全实现结构和样式相分离   需要引入           最多，强烈推荐   控制整个站点（多）\n\n\n# 选择器\n\n可以通过 CSS Diner 练习\n\n\n# 通用（通配符）选择器\n\n匹配所有元素，降低页面响应速度，效率低，即使在清除样式时也应该所有元素都写上。\n\n* {\n  属性1: 属性值1;\n  属性2: 属性值2;\n  属性3: 属性值3;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# id 选择器\n\n#idName {\n  属性1: 属性值1;\n  属性2: 属性值2;\n  属性3: 属性值3;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# class 选择器\n\n.class-name {\n  属性1: 属性值1;\n  属性2: 属性值2;\n  属性3: 属性值3;\n}\n\n\n1\n2\n3\n4\n5\n\n\n推荐使用中划线命名\n\n\n# 元素选择器\n\n元素名 {\n  属性1: 属性值1;\n  属性2: 属性值2;\n  属性3: 属性值3;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 属性选择器\n\n使用场景：input 标签等。可以利用正则。如下 value 要加引号，即属性怎么写就怎么复制过来\n\n属性                        选择\n[attr]🔥                  带有以 attr 命名的属性的元素\n[attr=value]🔥            带有以 attr 命名的，且值为 " value" 的属性的元素\n[attr^=value]             表示带有以 attr 命名的，且值是以"value"开头的属性的元素。正则开始符号\n[attr$=value]             表示带有以 attr 命名的，且值是以"value"结尾的属性的元素。正则结束符号\n[attr*=value]🔥           表示带有以 attr 命名的，且值包含有"value"的属性的元素，不一定非要空格隔开\n[attr~=value]             带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为"value"\n[attr|=value]             带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（"-"为连字符，Unicode\n                          编码为 U+002D）开头。用来匹配lang简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）\n[attr operator value i]   在带有属性值的属性选型选择器表达式的右括号（]括号）前添加用空格间隔开的字母 i（或\n                          I）可以忽略属性值的大小写（ASCII 字符范围内的字母）\n\n属性选择器可以配合其他选择器一起使用\n\n若属性选择器写作[class~=value]则和类选择器表示一致\n\n<style>\n  [title] {\n    font-size: 16px;\n  }\n\n  [title=\'p\'] {\n    color: skyblue;\n  }\n\n  [title*=\'pp\'] {\n    background-color: yellow;\n  }\n</style>\n<div title="div">div1</div>\n<p title="p">p1</p>\n<p title="p pp">p2</p>\n<div title="div">div2</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 组合选择器\n\n可以为任何选择器组合。下面除了并集、交集选择器，都是选择元素 B\n\n组合      选择\nA, B    并集选择器（选择所有 A 元素和 B 元素）\nA.B     交集选择器（div.one，选择 class 属性包含one的div元素）\nA B     后代选择器（选择 A 元素里面的所有 B 元素，A 可能多个，即使 A 一个，选择的 B 也可能多个）\nA > B   儿子选择器（选择 A 元素里面的所有直接 B 元素，A 可能多个，即使 A 一个，选择的 B 也可能多个）\nA ~ B   一般兄弟选择器。B 是 A之后的所有兄弟节点，A 可能多个，即使 A 一个，选择的 B 也可能多个\nA + B   相邻兄弟选择器。B 是 A 之后紧挨着的兄弟节点，A 可能多个，所以选择的 B 可能多个；否则 B 只有一个\n\n\n# 伪类选择器 :\n\nPseudo（伪类）。添加到选择器的关键字，指定要选择的元素的特殊状态。\n\n# 动态伪类 🔥\n\n * :link 未被访问，可用于a，注意缓存引起的问题（通过时间戳可以解决）\n\n * :visited 已被访问，可用于a。由于隐私问题，只能用于修改a的颜色\n\n * :focus 拥有输入焦点的元素（能接收键盘输入）\n   \n   可用于除过hidden、radio、checkbox、file的input元素，select、textarea、a也可以使用\n\n * :hover 鼠标悬浮，常用，可用于任意元素\n\n * :active 鼠标点击不放（按下未弹起），可用于任意元素\n\n注意\n\n * 为了确保生效，请按照 LVFHA 顺序声明（上面的顺序）\n * 因为 a 标签在浏览器中有默认样式，所以必须单独给 a 标签的单独伪类设置样式才能生效，且不能直接给a设置样式，否则造成给a的所有动态伪类设置了同一个样式！实际开发中就给 a 标签一个样式，再给 a:hover 一个样式即可足够\n\n# 元素状态伪类 🔥\n\n注意\n\n不仅仅是input 标签，select、textarea 之类也可以\n\n * :focus 看动态伪类\n\n * :checked 被选中，可用于input\n * :disabled禁用，可用于button、input\n\n# 结构伪类 🔥\n\n选择器                    例子                      例子描述                                                                      CSS\n:first-child🔥         p:first-child           选择属于其父元素的第一个子元素的为<p>的每个 <p> 元素。可能多个，因为每个节点都有可能是父元素。                       2\n:last-child🔥          p:last-child            选择属于其父元素的最后一个子元素为<p>的每个 <p> 元素。可能多个，因为每个节点都有可能是父元素。                       3\n:nth-child(n)🔥        p:nth-child(2)；         选择属于其父元素的第二个子元素的每个<p> 元素。                                                 3\n                       n 也可以是关键字；              隔行换色，括号中参数替换为：even 偶数、odd 奇数。\n                       n 也可以是公式；               2n，2n+1 等等。n 会从 0 开始（但是 HTML 中顺序是从 1 开始）\n                                               -n+5 代表 0 ～ 5，排行榜中会使用\n:nth-last-child(n)     p:nth-last-child(2)     同上，从最后一个子元素开始计数。                                                          3\n                                                                                                                         \n:first-of-type🔥       p:first-of-type         选择属于其父元素的首个 <p> 元素的每个<p>元素。                                               3\n:last-of-type🔥        p:last-of-type          选择属于其父元素的最后<p> 元素的每个 <p> 元素。                                              3\n:nth-of-type(n)🔥      p:nth-of-type(2)        选择属于其父元素第二个 <p> 元素的每个 <p> 元素。                                             3\n:nth-last-of-type(n)   p:nth-last-of-type(2)   同上，但是从最后一个子元素开始计数。                                                        3\n                                                                                                                         \n:only-child🔥          body:only-child         父元素中该子元素只有一个！。<body>父元素的唯一子元素；不推荐直接写:only-child否则会造成选择了全部元素，因为<html>也属于   \n                                               Document 的唯一子元素\n:only-of-type🔥        body:only-of-type       父元素中该类型子元素只有一个！。<body>父元素中唯一该类型的子元素。                                      \n                                                                                                                         \n:root                                          根元素<html>，与直接写html{}效果一致                                                  \n                                                                                                                         \n:empty                                         选择内容（html 或文本）为空的元素，空格也算内容。为了显示可以给定一个高度和背景色                               \n\n注意\n\n:nth-child(n) 与 :nth-of-type(n) 都需要先获取到其父元素，区别在于\n\n * :nth-child(n) 先将所有子元素排序，然后找到符合 n 的，再找到匹配该子元素的（此时可能不匹配）\n * :nth-of-type(n) 先将指定的子元素排序，然后找到符合 n 的\n\n注意 和后代选择器结合 以及 和交集选择器结合 时的区别\n\n:nth-child(n)示例\n\n<style>\n  /*所有只要是第三个子元素*/\n  /*:nth-child(3) {\n  color: skyblue;\n  }*/\n  p:nth-child(3) {\n    color: skyblue;\n  }\n</style>\n<body>\n  <div>\n    <p>test1</p>\n    <p>test2</p>\n    <p>test3</p>\n    <p>test4</p>\n  </div>\n  <div>\n    <strong>strong1</strong>\n    <strong>strong2</strong>\n    <strong>strong3</strong>\n    <strong>strong4</strong>\n  </div>\n  <p>\n    <span>span1</span>\n    <span>span2</span>\n    <span>span3</span>\n    <span>span4</span>\n  </p>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n<html>\n    <div id="demo1">\n        <div>\n            <p>test1</p>\n            <p>test2</p>\n            <p>test3</p>\n            <p>test4</p>\n        </div>\n        <div>\n            <strong>strong1</strong>\n            <strong>strong2</strong>\n            <strong>strong3</strong>\n            <strong>strong4</strong>\n        </div>\n        <p>\n            <span>span1</span>\n            <span>span2</span>\n            <span>span3</span>\n            <span>span4</span>\n        </p>\n    </div>\n\n</html>\n<style>\n    /*所有只要是第三个子元素*/\n    /*:nth-child(3) {\n    color: skyblue;\n    }*/\n    #demo1 p:nth-child(3) {\n        color: skyblue;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 目标伪类—锚点\n\n很少使用\n\n<style>\n  :target {\n    color: skyblue;\n  }\n</style>\n<a href="#title1">去标题1</a>\n<a href="#title2">去标题2</a>\n<a href="#title3">去标题3</a>\n<a href="#title4">去标题4</a>\n<h3 id="title1">标题1</h3>\n<h3 id="title2">标题2</h3>\n<h3 id="title3">标题3</h3>\n<h3 id="title4">标题4</h3>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 空伪类\n\n:empty\n\n/* 选择所有空的 div 元素，即 div 里是空的 */\ndiv:empty {\n}\n\n\n1\n2\n3\n\n\n# 否定伪类\n\n基本上不用\n\n:not(x)：x 可以是 id、class、元素、通用、属性、伪类（除否定伪类）选择器。不支持组合选择器\n\n/* body下除了 div 的其他元素 */\nbody :not(div) {\n  color: red;\n}\n\n/* 除了第三个li */\nul > li:not(:nth-of-type(3)) {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 语言伪类\n\n基本上不用\n\n\n# 伪元素选择器 ::\n\n# 介绍\n\n伪元素选择器可以帮助我们利用 CSS 创建新标签元素，而不需要 HTML 标签，从而简化 HTML 结构。\n\n可以用::或:，但是推荐使用前者，可以区别伪类和伪元素。\n\n选择器              例子                例子描述                            CSS\n::first-letter   p::first-letter   选择每个 <p> 元素内容的首字母。有属性设置限制       1\n::first-line     p::first-line     选择每个 <p> 元素内容的首行。有属性设置限制        1\n::selection      p::selection      选择每个 <p> 元素中被选中的字符              4\n::before🔥       p::before         在每个 <p> 元素的内容之前插入内容，可以是文字、图片。   2\n::after🔥        p::after          在每个 <p> 元素的内容之后插入内容，可以是文字、图片。   2\n\n注意\n\n * before 和 after 创建一个元素，但是属于行内元素，且无法选中\n * 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素\n * before 和 after 必须有 content 属性，可以是文字（直接写字符串）或图片（url()）\n * before 在父元素里面内容的前面创建元素，after 在父元素里面内容的后面插入元素\n * 伪元素选择器和标签选择器一样，权重为 1\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n    <title>Document</title>\n\n    <style>\n      div {\n        width: 200px;\n        height: 200px;\n        background-color: pink;\n      }\n      div::before {\n        content: "111";\n      }\n      div::after {\n        content: "999";\n      }\n    </style>\n  </head>\n\n  <body>\n    <div>666</div>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n<html>\n    <div id="demo2">\n        <div>666</div>\n    </div>\n</html>\n<style>\n    #demo2 div {\n        width: 200px;\n        height: 200px;\n        background-color: pink;\n    }\n    #demo2 div::before {\n        content: \'111\';\n    }\n    #demo2 div::after {\n        content: \'999\';\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 伪元素字体图标\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n    <title>Document</title>\n    <style>\n      div {\n        position: relative;\n        width: 200px;\n        height: 35px;\n        border: 1px solid skyblue;\n      }\n\n      div::after {\n        position: absolute;\n        top: 7px;\n        right: 10px;\n        /* 可以用字体图标代替 */\n        content: \'x\';\n      }\n    </style>\n  </head>\n\n  <body>\n    <div></div>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n<html>\n    <div id="demo3">\n        <div>\n\n        </div>\n    </div>\n</html>\n\n<style>\n    #demo3 div {\n        position: relative;\n        width: 200px;\n        height: 35px;\n        border: 1px solid skyblue;\n    }\n\n    #demo3 div::after {\n        position: absolute;\n        top: 7px;\n        right: 10px;\n        /* 可以用字体图标代替 */\n        content: \'x\';\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 仿视频遮罩功能\n\n取代之前写的 mask 类\n\n/* mask遮罩 */\n.box .box-body ul li::before {\n  /* 必须加content */\n  content: \'\';\n  /* 隐藏遮罩 */\n  display: none;\n  position: absolute;\n  width: 228px;\n  height: 270px;\n  background: rgba(0, 0, 0, 0.4) url(../images/arr.png) no-repeat 100px 60px;\n}\n\n/* 鼠标经过li盒子时，才让其中的伪元素显示，和以往不同的写法，注意 */\n.box .box-body ul li:hover::before {\n  display: block;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 清除浮动\n\n看 float 中代码\n\n\n# 特性\n\n\n# 层叠性 🔥\n\n解决样式冲突问题\n\n * 相同选择器设置相同的样式，此时就近样式就会**覆盖（层叠）**另一个冲突的样式。\n\n * 不同选择器设置相同的样式，需考虑选择器权重，权重还是相同则发生覆盖（层叠）\n   \n   选择器                权重\n   继承 或 *             0,0,0,0\n   元素（标签）选择器，伪元素选择器   0,0,0,1\n   类选择器，伪类选择器，属性选择器   0,0,1,0\n   ID 选择器             0,1,0,0\n   行内样式 style         1,0,0,0\n   !important;        1,0,0,0,0\n\n权重注意点:\n\n * 权重是有 5 组数字组成，但是不会有进位。\n\n * 等级判断从左向右，如果某一位数值相同，则判断下一位数值。\n\n * 继承的权重是 0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。\n   \n   <style>\n     #father {\n       color: red;\n     }\n     p {\n       color: pink;\n     }\n   </style>\n   <div id="father">\n     <p>此处颜色是pink</p>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * a 元素浏览器默认指定了样式，除非手动修改，否则继承父元素不起作用\n   \n   <style>\n     body {\n       color: red;\n     }\n   </style>\n   <body>\n     <a href="#">此处还是蓝色</a>\n   </body>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。\n   \n   * div ul li ===> 0,0,0,3\n   * .nav ul li ===> 0,0,1,2\n   * a:hover ===> 0,0,1,1。⚠️ 这里是按照 2 个来计算的，属性选择器也是类似\n   * .nav a ===> 0,0,1,1\n   \n   <style>\n     /* .nav li  权重是 11 */\n     .nav li {\n       color: red;\n     }\n     /* 需求把第一个小li 颜色改为粉色加粗 ? */\n     /* .pink  权重是 10    .nav .pink  20  */\n     .nav .pink {\n       color: pink;\n       font-weight: 700;\n     }\n   </style>\n   \n   <ul class="nav">\n     <li class="pink">人生四大悲</li>\n     <li>家里没宽带</li>\n     <li>网速不够快</li>\n     <li>手机没流量</li>\n     <li>学校没wifi</li>\n   </ul>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 继承性 🔥\n\n * 简化代码。字标签会继承父标签中的某些样式，\n   \n   font-，text-，line-，list-，color 可以被继承，逐个查看 MDN 可知晓\n   \n   背景相关的，布局相关等的这些样式都不会被继承。\n\n * 不能继承的属性，一般可以对该属性使用inherit值强制继承\n\n * 注意：属性继承的是计算值，并不是字面值\n   \n   <style>\n     .class1 {\n       font-size: 60px;\n     }\n     .class2 {\n       font-size: 0.5em;\n       /* 此时 p 元素的 font-size 继承的是 30px，不是 .5em，否则会变为 15px */\n     }\n   </style>\n   <div class="class1">\n     <div class="class2">\n       <p>haha</p>\n     </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n * 可以使用开发者工具查看继承来的属性\n   \n   body {\n     font: 12px/1.5 Microsoft YaHei;\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   * 行高可以跟单位也可以不跟单位\n   \n   * 如果子元素没有设置行高，则会继承父元素的行高为 1.5。此时子元素的行高为当前子元素的文字大小 * 1.5\n     \n     body 行高 1.5 这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高\n\n\n# 元素分类\n\n\n# 块级元素 block element\n\n * 独占父元素一行，无论是否设置了 width\n * 高度、宽度（默认为父级容器宽度的 100%）、外边距、内边距都可以控制\n * 是一个容器盒子，里面可以放块级元素或行内元素\n * 文字类元素内不能使用块级元素，如 p 里不能放 div\n\n常见的有：h1~h6、p、div、ul、ol、li、table、div 等\n\n\n# 行内元素 inline element\n\n * 多个行内元素可以在父元素的同一行中显示，且基线对齐\n\n * 非替换元素的高、宽直接设置是无效的，默认宽度就是它本身内容的宽度；替换元素可以设置\n\n * 跟其他行内元素在同一行显示，有空白缝隙，这是因为浏览器把空格或换行也解析显示了。解决方案如下：\n   \n   * 可以一行显示（不推荐）\n   \n   * 可以用注释注释掉空格或换行符（不推荐）\n     \n     <span>span1</span\n     >\x3c!--\n     --\x3e<span>span2</span>\n     \n     \n     1\n     2\n     3\n     \n   \n   * 设置父元素的font-size为 0，然后在子元素中重新设置自己需要的font-size（不推荐）。Safari 也不支持。\n   \n   * 使用float（推荐），浮动后顶部对齐\n\n * 行内元素只能容纳文本或其他行内元素\n\n * 链接 a 里面不能再放 a。特殊情况 a 里面可以放块级元素，但是给 a 转换块级模式最安全\n\n * 为了照顾兼容性，行内元素尽量只设置左右内外边距，不设置上下内外边距。但转换为块级和行内块元素就都可设置\n\n * 行内元素可以区分替换元素（如 img）和非替换元素\n\n常见的有：a、strong、b、em、i、ins、u、del、s、span 等\n\n注意\n\n * 以下属性对行内非替换元素不起作用，如：width, height\n\n * 以下属性对行内非替换元素的效果比较特殊\n   \n   padding-top, padding-bottom（上下多出的区域不占据 DOM 空间，即不会影响页面的布局）\n   \n   border-top, border-bottom（上下多出的区域不占据 DOM 空间，即不会影响页面的布局）\n   \n   margin-top**, **margin-bottom（上下多出的区域不占据 DOM 空间，即不会影响页面的布局）\n   \n   可以改为inline-block即替换元素类型即可解决该问题\n\n\n# 替换元素\n\n\n# 非替换元素\n\n\n# 总结\n\n元素分类           具体元素                                                          默认特征\n块元素    替换元素                                                                  \n       非替换元素   div, p, pre, h1~h6, ul, ol, li, dl, dt, dd, table, form,       * 独占父元素的一行\n               article, aside, footer, header, hgroup, main, mav, section,    * 可以随意设置宽高\n               blockquote, hr 等                                               * 宽度默认为父容器100%，高度默认由内容决定\n行内元素   替换元素    img, input, iframe, video, audio, embed, canvas, object 等      * 跟其他行内元素在同一行显示，有空白缝隙\n                                                                              * 可以随意设置宽高和内外边距\n                                                                              * 默认宽高由内容决定\n       非替换元素   a, strong, span, code, label 等                                 * 跟其他行内元素在同一行显示，有空白缝隙\n                                                                              * 不可以随意设置宽高或内外边距\n                                                                              * 默认宽高由内容决定\n\n可以通过`display`属性改变\n\n\n# 函数\n\n\n# calc 计算\n\n此 CSS 函数让你在声明 CSS 属性值时执行一些计算\n\nwidth: calc(100% - 80px);\n\n\n1\n\n\n括号里面可以使用 + - * / 来进行计算',normalizedContent:'# 基础\n\n * css（cascading style sheets，层叠样式表）：多个样式可以作用在同一个 html 元素上，同时生效。\n\n * 将网页内容和样式进行分离\n\n\n# 书籍推荐\n\n * 《css 权威指南第四版》\n\n\n# 引入方式\n\n\n# inline style\n\n内联样式。在每个 html 标签上面都有一个 style 属性，把 css 和 html 结合在一起，不推荐\n\n<标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"> 内容 </标签名>\n\n\n1\n\n\n\n# document style sheet\n\n文档样式表，或称作 embed style sheet 即内嵌样式表\n\n将 css 代码集中写在 html 文档的 <head> 头部标签中，并且用 <style> 标签定义\n\n * style 标签一般位于 head 标签中，当然理论上他可以放在 html 文档的任何地方\n * type="text/css" 在 html5 中可以省略。\n * 只能控制当前的页面，没有彻底分离\n\n<head>\n  <style>\n    选择器（选择的标签） {\n      属性1: 属性值1;\n      属性2: 属性值2;\n      属性3: 属性值3;\n    }\n  </style>\n</head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# external style sheet\n\n外部样式表。将所有的样式放在一个或多个以**.css为扩展名的外部样式表文件中，通过<link>标签**将外部样式表文件链接到 html 文档中\n\n * link 是个单标签\n * link 标签需要放在 head 头部标签中，并且指定 link 标签的三个属性\n * 可以样式共享，复用\n * 可以使用到浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验\n\n<head>\n  <link rel="stylesheet" href="css文件路径" />\n</head>\n\n\n1\n2\n3\n\n\n属性     作用\nrel    定义当前文档与被链接文档之间的关系，在这里需要指定为“stylesheet”，表示被链接的文档是一个样式表文件。\nhref   定义所链接外部样式表文件的 url，可以是相对路径，也可以是绝对路径。\ntype   定义所链接文档的类型，在这里需要指定为“text/css”，表示链接的外部文件为 css 样式表。我们都可以省略\n\n注意\n\n在 external style sheet 的外部 css 文件中，有时有必要设置 css 文件的编码（如使用font-family的中文字体时）\n\n@charset "utf-8"; /*可在首行添加*/\n\n\n1\n\n\nstyle 标签中也可以引入外部 css 文件。还可以在 css 文件中引入其他 css 文件。\n\n对比来说使用 link比import效率高，在现代框架中使用很多import是因为可以打包重新编译生成\n\n<style>\n  /* 二选一 */\n  @import url(./css/style.css); /*也可以用引号括起来*/\n  @import \'./css/style.css\';\n</style>\n\n\n1\n2\n3\n4\n5\n\n\n\n# 总结\n\n优先级：相同的设置，由上到下，由外到内，优先级由低到高。 **后加载的优先级高，**就近原则或叠加\n\n样式表    优点             缺点             使用情况      控制范围\n内联样式   书写方便，权重高       没有实现样式和结构相分离   较少        控制一个标签（少）\n内嵌样式   部分结构和样式相分离     没有彻底分离         较多        控制一个页面（中）\n外链样式   完全实现结构和样式相分离   需要引入           最多，强烈推荐   控制整个站点（多）\n\n\n# 选择器\n\n可以通过 css diner 练习\n\n\n# 通用（通配符）选择器\n\n匹配所有元素，降低页面响应速度，效率低，即使在清除样式时也应该所有元素都写上。\n\n* {\n  属性1: 属性值1;\n  属性2: 属性值2;\n  属性3: 属性值3;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# id 选择器\n\n#idname {\n  属性1: 属性值1;\n  属性2: 属性值2;\n  属性3: 属性值3;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# class 选择器\n\n.class-name {\n  属性1: 属性值1;\n  属性2: 属性值2;\n  属性3: 属性值3;\n}\n\n\n1\n2\n3\n4\n5\n\n\n推荐使用中划线命名\n\n\n# 元素选择器\n\n元素名 {\n  属性1: 属性值1;\n  属性2: 属性值2;\n  属性3: 属性值3;\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 属性选择器\n\n使用场景：input 标签等。可以利用正则。如下 value 要加引号，即属性怎么写就怎么复制过来\n\n属性                        选择\n[attr]🔥                  带有以 attr 命名的属性的元素\n[attr=value]🔥            带有以 attr 命名的，且值为 " value" 的属性的元素\n[attr^=value]             表示带有以 attr 命名的，且值是以"value"开头的属性的元素。正则开始符号\n[attr$=value]             表示带有以 attr 命名的，且值是以"value"结尾的属性的元素。正则结束符号\n[attr*=value]🔥           表示带有以 attr 命名的，且值包含有"value"的属性的元素，不一定非要空格隔开\n[attr~=value]             带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为"value"\n[attr|=value]             带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（"-"为连字符，unicode\n                          编码为 u+002d）开头。用来匹配lang简写代码（如 zh-cn，zh-tw 可以用 zh 作为 value）\n[attr operator value i]   在带有属性值的属性选型选择器表达式的右括号（]括号）前添加用空格间隔开的字母 i（或\n                          i）可以忽略属性值的大小写（ascii 字符范围内的字母）\n\n属性选择器可以配合其他选择器一起使用\n\n若属性选择器写作[class~=value]则和类选择器表示一致\n\n<style>\n  [title] {\n    font-size: 16px;\n  }\n\n  [title=\'p\'] {\n    color: skyblue;\n  }\n\n  [title*=\'pp\'] {\n    background-color: yellow;\n  }\n</style>\n<div title="div">div1</div>\n<p title="p">p1</p>\n<p title="p pp">p2</p>\n<div title="div">div2</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 组合选择器\n\n可以为任何选择器组合。下面除了并集、交集选择器，都是选择元素 b\n\n组合      选择\na, b    并集选择器（选择所有 a 元素和 b 元素）\na.b     交集选择器（div.one，选择 class 属性包含one的div元素）\na b     后代选择器（选择 a 元素里面的所有 b 元素，a 可能多个，即使 a 一个，选择的 b 也可能多个）\na > b   儿子选择器（选择 a 元素里面的所有直接 b 元素，a 可能多个，即使 a 一个，选择的 b 也可能多个）\na ~ b   一般兄弟选择器。b 是 a之后的所有兄弟节点，a 可能多个，即使 a 一个，选择的 b 也可能多个\na + b   相邻兄弟选择器。b 是 a 之后紧挨着的兄弟节点，a 可能多个，所以选择的 b 可能多个；否则 b 只有一个\n\n\n# 伪类选择器 :\n\npseudo（伪类）。添加到选择器的关键字，指定要选择的元素的特殊状态。\n\n# 动态伪类 🔥\n\n * :link 未被访问，可用于a，注意缓存引起的问题（通过时间戳可以解决）\n\n * :visited 已被访问，可用于a。由于隐私问题，只能用于修改a的颜色\n\n * :focus 拥有输入焦点的元素（能接收键盘输入）\n   \n   可用于除过hidden、radio、checkbox、file的input元素，select、textarea、a也可以使用\n\n * :hover 鼠标悬浮，常用，可用于任意元素\n\n * :active 鼠标点击不放（按下未弹起），可用于任意元素\n\n注意\n\n * 为了确保生效，请按照 lvfha 顺序声明（上面的顺序）\n * 因为 a 标签在浏览器中有默认样式，所以必须单独给 a 标签的单独伪类设置样式才能生效，且不能直接给a设置样式，否则造成给a的所有动态伪类设置了同一个样式！实际开发中就给 a 标签一个样式，再给 a:hover 一个样式即可足够\n\n# 元素状态伪类 🔥\n\n注意\n\n不仅仅是input 标签，select、textarea 之类也可以\n\n * :focus 看动态伪类\n\n * :checked 被选中，可用于input\n * :disabled禁用，可用于button、input\n\n# 结构伪类 🔥\n\n选择器                    例子                      例子描述                                                                      css\n:first-child🔥         p:first-child           选择属于其父元素的第一个子元素的为<p>的每个 <p> 元素。可能多个，因为每个节点都有可能是父元素。                       2\n:last-child🔥          p:last-child            选择属于其父元素的最后一个子元素为<p>的每个 <p> 元素。可能多个，因为每个节点都有可能是父元素。                       3\n:nth-child(n)🔥        p:nth-child(2)；         选择属于其父元素的第二个子元素的每个<p> 元素。                                                 3\n                       n 也可以是关键字；              隔行换色，括号中参数替换为：even 偶数、odd 奇数。\n                       n 也可以是公式；               2n，2n+1 等等。n 会从 0 开始（但是 html 中顺序是从 1 开始）\n                                               -n+5 代表 0 ～ 5，排行榜中会使用\n:nth-last-child(n)     p:nth-last-child(2)     同上，从最后一个子元素开始计数。                                                          3\n                                                                                                                         \n:first-of-type🔥       p:first-of-type         选择属于其父元素的首个 <p> 元素的每个<p>元素。                                               3\n:last-of-type🔥        p:last-of-type          选择属于其父元素的最后<p> 元素的每个 <p> 元素。                                              3\n:nth-of-type(n)🔥      p:nth-of-type(2)        选择属于其父元素第二个 <p> 元素的每个 <p> 元素。                                             3\n:nth-last-of-type(n)   p:nth-last-of-type(2)   同上，但是从最后一个子元素开始计数。                                                        3\n                                                                                                                         \n:only-child🔥          body:only-child         父元素中该子元素只有一个！。<body>父元素的唯一子元素；不推荐直接写:only-child否则会造成选择了全部元素，因为<html>也属于   \n                                               document 的唯一子元素\n:only-of-type🔥        body:only-of-type       父元素中该类型子元素只有一个！。<body>父元素中唯一该类型的子元素。                                      \n                                                                                                                         \n:root                                          根元素<html>，与直接写html{}效果一致                                                  \n                                                                                                                         \n:empty                                         选择内容（html 或文本）为空的元素，空格也算内容。为了显示可以给定一个高度和背景色                               \n\n注意\n\n:nth-child(n) 与 :nth-of-type(n) 都需要先获取到其父元素，区别在于\n\n * :nth-child(n) 先将所有子元素排序，然后找到符合 n 的，再找到匹配该子元素的（此时可能不匹配）\n * :nth-of-type(n) 先将指定的子元素排序，然后找到符合 n 的\n\n注意 和后代选择器结合 以及 和交集选择器结合 时的区别\n\n:nth-child(n)示例\n\n<style>\n  /*所有只要是第三个子元素*/\n  /*:nth-child(3) {\n  color: skyblue;\n  }*/\n  p:nth-child(3) {\n    color: skyblue;\n  }\n</style>\n<body>\n  <div>\n    <p>test1</p>\n    <p>test2</p>\n    <p>test3</p>\n    <p>test4</p>\n  </div>\n  <div>\n    <strong>strong1</strong>\n    <strong>strong2</strong>\n    <strong>strong3</strong>\n    <strong>strong4</strong>\n  </div>\n  <p>\n    <span>span1</span>\n    <span>span2</span>\n    <span>span3</span>\n    <span>span4</span>\n  </p>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n<html>\n    <div id="demo1">\n        <div>\n            <p>test1</p>\n            <p>test2</p>\n            <p>test3</p>\n            <p>test4</p>\n        </div>\n        <div>\n            <strong>strong1</strong>\n            <strong>strong2</strong>\n            <strong>strong3</strong>\n            <strong>strong4</strong>\n        </div>\n        <p>\n            <span>span1</span>\n            <span>span2</span>\n            <span>span3</span>\n            <span>span4</span>\n        </p>\n    </div>\n\n</html>\n<style>\n    /*所有只要是第三个子元素*/\n    /*:nth-child(3) {\n    color: skyblue;\n    }*/\n    #demo1 p:nth-child(3) {\n        color: skyblue;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 目标伪类—锚点\n\n很少使用\n\n<style>\n  :target {\n    color: skyblue;\n  }\n</style>\n<a href="#title1">去标题1</a>\n<a href="#title2">去标题2</a>\n<a href="#title3">去标题3</a>\n<a href="#title4">去标题4</a>\n<h3 id="title1">标题1</h3>\n<h3 id="title2">标题2</h3>\n<h3 id="title3">标题3</h3>\n<h3 id="title4">标题4</h3>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 空伪类\n\n:empty\n\n/* 选择所有空的 div 元素，即 div 里是空的 */\ndiv:empty {\n}\n\n\n1\n2\n3\n\n\n# 否定伪类\n\n基本上不用\n\n:not(x)：x 可以是 id、class、元素、通用、属性、伪类（除否定伪类）选择器。不支持组合选择器\n\n/* body下除了 div 的其他元素 */\nbody :not(div) {\n  color: red;\n}\n\n/* 除了第三个li */\nul > li:not(:nth-of-type(3)) {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n# 语言伪类\n\n基本上不用\n\n\n# 伪元素选择器 ::\n\n# 介绍\n\n伪元素选择器可以帮助我们利用 css 创建新标签元素，而不需要 html 标签，从而简化 html 结构。\n\n可以用::或:，但是推荐使用前者，可以区别伪类和伪元素。\n\n选择器              例子                例子描述                            css\n::first-letter   p::first-letter   选择每个 <p> 元素内容的首字母。有属性设置限制       1\n::first-line     p::first-line     选择每个 <p> 元素内容的首行。有属性设置限制        1\n::selection      p::selection      选择每个 <p> 元素中被选中的字符              4\n::before🔥       p::before         在每个 <p> 元素的内容之前插入内容，可以是文字、图片。   2\n::after🔥        p::after          在每个 <p> 元素的内容之后插入内容，可以是文字、图片。   2\n\n注意\n\n * before 和 after 创建一个元素，但是属于行内元素，且无法选中\n * 新创建的这个元素在文档树中是找不到的，所以我们称为伪元素\n * before 和 after 必须有 content 属性，可以是文字（直接写字符串）或图片（url()）\n * before 在父元素里面内容的前面创建元素，after 在父元素里面内容的后面插入元素\n * 伪元素选择器和标签选择器一样，权重为 1\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <title>document</title>\n\n    <style>\n      div {\n        width: 200px;\n        height: 200px;\n        background-color: pink;\n      }\n      div::before {\n        content: "111";\n      }\n      div::after {\n        content: "999";\n      }\n    </style>\n  </head>\n\n  <body>\n    <div>666</div>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n<html>\n    <div id="demo2">\n        <div>666</div>\n    </div>\n</html>\n<style>\n    #demo2 div {\n        width: 200px;\n        height: 200px;\n        background-color: pink;\n    }\n    #demo2 div::before {\n        content: \'111\';\n    }\n    #demo2 div::after {\n        content: \'999\';\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 伪元素字体图标\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <title>document</title>\n    <style>\n      div {\n        position: relative;\n        width: 200px;\n        height: 35px;\n        border: 1px solid skyblue;\n      }\n\n      div::after {\n        position: absolute;\n        top: 7px;\n        right: 10px;\n        /* 可以用字体图标代替 */\n        content: \'x\';\n      }\n    </style>\n  </head>\n\n  <body>\n    <div></div>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n<html>\n    <div id="demo3">\n        <div>\n\n        </div>\n    </div>\n</html>\n\n<style>\n    #demo3 div {\n        position: relative;\n        width: 200px;\n        height: 35px;\n        border: 1px solid skyblue;\n    }\n\n    #demo3 div::after {\n        position: absolute;\n        top: 7px;\n        right: 10px;\n        /* 可以用字体图标代替 */\n        content: \'x\';\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 仿视频遮罩功能\n\n取代之前写的 mask 类\n\n/* mask遮罩 */\n.box .box-body ul li::before {\n  /* 必须加content */\n  content: \'\';\n  /* 隐藏遮罩 */\n  display: none;\n  position: absolute;\n  width: 228px;\n  height: 270px;\n  background: rgba(0, 0, 0, 0.4) url(../images/arr.png) no-repeat 100px 60px;\n}\n\n/* 鼠标经过li盒子时，才让其中的伪元素显示，和以往不同的写法，注意 */\n.box .box-body ul li:hover::before {\n  display: block;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n# 清除浮动\n\n看 float 中代码\n\n\n# 特性\n\n\n# 层叠性 🔥\n\n解决样式冲突问题\n\n * 相同选择器设置相同的样式，此时就近样式就会**覆盖（层叠）**另一个冲突的样式。\n\n * 不同选择器设置相同的样式，需考虑选择器权重，权重还是相同则发生覆盖（层叠）\n   \n   选择器                权重\n   继承 或 *             0,0,0,0\n   元素（标签）选择器，伪元素选择器   0,0,0,1\n   类选择器，伪类选择器，属性选择器   0,0,1,0\n   id 选择器             0,1,0,0\n   行内样式 style         1,0,0,0\n   !important;        1,0,0,0,0\n\n权重注意点:\n\n * 权重是有 5 组数字组成，但是不会有进位。\n\n * 等级判断从左向右，如果某一位数值相同，则判断下一位数值。\n\n * 继承的权重是 0， 如果该元素没有直接选中，不管父元素权重多高，子元素得到的权重都是 0。\n   \n   <style>\n     #father {\n       color: red;\n     }\n     p {\n       color: pink;\n     }\n   </style>\n   <div id="father">\n     <p>此处颜色是pink</p>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n\n * a 元素浏览器默认指定了样式，除非手动修改，否则继承父元素不起作用\n   \n   <style>\n     body {\n       color: red;\n     }\n   </style>\n   <body>\n     <a href="#">此处还是蓝色</a>\n   </body>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 权重叠加：如果是复合选择器，则会有权重叠加，需要计算权重。\n   \n   * div ul li ===> 0,0,0,3\n   * .nav ul li ===> 0,0,1,2\n   * a:hover ===> 0,0,1,1。⚠️ 这里是按照 2 个来计算的，属性选择器也是类似\n   * .nav a ===> 0,0,1,1\n   \n   <style>\n     /* .nav li  权重是 11 */\n     .nav li {\n       color: red;\n     }\n     /* 需求把第一个小li 颜色改为粉色加粗 ? */\n     /* .pink  权重是 10    .nav .pink  20  */\n     .nav .pink {\n       color: pink;\n       font-weight: 700;\n     }\n   </style>\n   \n   <ul class="nav">\n     <li class="pink">人生四大悲</li>\n     <li>家里没宽带</li>\n     <li>网速不够快</li>\n     <li>手机没流量</li>\n     <li>学校没wifi</li>\n   </ul>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   \n\n\n# 继承性 🔥\n\n * 简化代码。字标签会继承父标签中的某些样式，\n   \n   font-，text-，line-，list-，color 可以被继承，逐个查看 mdn 可知晓\n   \n   背景相关的，布局相关等的这些样式都不会被继承。\n\n * 不能继承的属性，一般可以对该属性使用inherit值强制继承\n\n * 注意：属性继承的是计算值，并不是字面值\n   \n   <style>\n     .class1 {\n       font-size: 60px;\n     }\n     .class2 {\n       font-size: 0.5em;\n       /* 此时 p 元素的 font-size 继承的是 30px，不是 .5em，否则会变为 15px */\n     }\n   </style>\n   <div class="class1">\n     <div class="class2">\n       <p>haha</p>\n     </div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n * 可以使用开发者工具查看继承来的属性\n   \n   body {\n     font: 12px/1.5 microsoft yahei;\n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   * 行高可以跟单位也可以不跟单位\n   \n   * 如果子元素没有设置行高，则会继承父元素的行高为 1.5。此时子元素的行高为当前子元素的文字大小 * 1.5\n     \n     body 行高 1.5 这样写法最大的优势就是里面子元素可以根据自己文字大小自动调整行高\n\n\n# 元素分类\n\n\n# 块级元素 block element\n\n * 独占父元素一行，无论是否设置了 width\n * 高度、宽度（默认为父级容器宽度的 100%）、外边距、内边距都可以控制\n * 是一个容器盒子，里面可以放块级元素或行内元素\n * 文字类元素内不能使用块级元素，如 p 里不能放 div\n\n常见的有：h1~h6、p、div、ul、ol、li、table、div 等\n\n\n# 行内元素 inline element\n\n * 多个行内元素可以在父元素的同一行中显示，且基线对齐\n\n * 非替换元素的高、宽直接设置是无效的，默认宽度就是它本身内容的宽度；替换元素可以设置\n\n * 跟其他行内元素在同一行显示，有空白缝隙，这是因为浏览器把空格或换行也解析显示了。解决方案如下：\n   \n   * 可以一行显示（不推荐）\n   \n   * 可以用注释注释掉空格或换行符（不推荐）\n     \n     <span>span1</span\n     >\x3c!--\n     --\x3e<span>span2</span>\n     \n     \n     1\n     2\n     3\n     \n   \n   * 设置父元素的font-size为 0，然后在子元素中重新设置自己需要的font-size（不推荐）。safari 也不支持。\n   \n   * 使用float（推荐），浮动后顶部对齐\n\n * 行内元素只能容纳文本或其他行内元素\n\n * 链接 a 里面不能再放 a。特殊情况 a 里面可以放块级元素，但是给 a 转换块级模式最安全\n\n * 为了照顾兼容性，行内元素尽量只设置左右内外边距，不设置上下内外边距。但转换为块级和行内块元素就都可设置\n\n * 行内元素可以区分替换元素（如 img）和非替换元素\n\n常见的有：a、strong、b、em、i、ins、u、del、s、span 等\n\n注意\n\n * 以下属性对行内非替换元素不起作用，如：width, height\n\n * 以下属性对行内非替换元素的效果比较特殊\n   \n   padding-top, padding-bottom（上下多出的区域不占据 dom 空间，即不会影响页面的布局）\n   \n   border-top, border-bottom（上下多出的区域不占据 dom 空间，即不会影响页面的布局）\n   \n   margin-top**, **margin-bottom（上下多出的区域不占据 dom 空间，即不会影响页面的布局）\n   \n   可以改为inline-block即替换元素类型即可解决该问题\n\n\n# 替换元素\n\n\n# 非替换元素\n\n\n# 总结\n\n元素分类           具体元素                                                          默认特征\n块元素    替换元素                                                                  \n       非替换元素   div, p, pre, h1~h6, ul, ol, li, dl, dt, dd, table, form,       * 独占父元素的一行\n               article, aside, footer, header, hgroup, main, mav, section,    * 可以随意设置宽高\n               blockquote, hr 等                                               * 宽度默认为父容器100%，高度默认由内容决定\n行内元素   替换元素    img, input, iframe, video, audio, embed, canvas, object 等      * 跟其他行内元素在同一行显示，有空白缝隙\n                                                                              * 可以随意设置宽高和内外边距\n                                                                              * 默认宽高由内容决定\n       非替换元素   a, strong, span, code, label 等                                 * 跟其他行内元素在同一行显示，有空白缝隙\n                                                                              * 不可以随意设置宽高或内外边距\n                                                                              * 默认宽高由内容决定\n\n可以通过`display`属性改变\n\n\n# 函数\n\n\n# calc 计算\n\n此 css 函数让你在声明 css 属性值时执行一些计算\n\nwidth: calc(100% - 80px);\n\n\n1\n\n\n括号里面可以使用 + - * / 来进行计算',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"属性",frontmatter:{title:"属性",date:"2020-03-10T16:37:55.000Z",permalink:"/pages/687c1b/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/200.CSS%E5%9F%BA%E7%A1%80/202.CSS-2%E5%B1%9E%E6%80%A7.html",relativePath:"1100.H5&CSS3/200.CSS基础/202.CSS-2属性.md",key:"v-f2696468",path:"/pages/687c1b/",headers:[{level:2,title:"长度单位 🔥",slug:"长度单位-🔥",normalizedTitle:"长度单位 🔥",charIndex:9},{level:2,title:"color 颜色单位 🔥",slug:"color-颜色单位-🔥",normalizedTitle:"color 颜色单位 🔥",charIndex:262},{level:3,title:"颜色关键字",slug:"颜色关键字",normalizedTitle:"颜色关键字",charIndex:311},{level:3,title:"RGB",slug:"rgb",normalizedTitle:"rgb",charIndex:373},{level:3,title:"RGBA",slug:"rgba",normalizedTitle:"rgba",charIndex:546},{level:3,title:"HSL & HSLA",slug:"hsl-hsla",normalizedTitle:"hsl &amp; hsla",charIndex:null},{level:2,title:"font 字体 🔥",slug:"font-字体-🔥",normalizedTitle:"font 字体 🔥",charIndex:976},{level:3,title:"font 缩写 🔥",slug:"font-缩写-🔥",normalizedTitle:"font 缩写 🔥",charIndex:1018},{level:3,title:"font-style 倾斜",slug:"font-style-倾斜",normalizedTitle:"font-style 倾斜",charIndex:1306},{level:3,title:"font-variant 小写字母显示方式",slug:"font-variant-小写字母显示方式",normalizedTitle:"font-variant 小写字母显示方式",charIndex:1453},{level:3,title:"font-weight 粗细",slug:"font-weight-粗细",normalizedTitle:"font-weight 粗细",charIndex:1531},{level:3,title:"font-size 字号",slug:"font-size-字号",normalizedTitle:"font-size 字号",charIndex:1604},{level:3,title:"font-family 字体",slug:"font-family-字体",normalizedTitle:"font-family 字体",charIndex:2110},{level:2,title:"@font-face 网络字体",slug:"font-face-网络字体",normalizedTitle:"@font-face 网络字体",charIndex:3016},{level:2,title:"字体图标",slug:"字体图标",normalizedTitle:"字体图标",charIndex:3473},{level:3,title:"发展",slug:"发展",normalizedTitle:"发展",charIndex:3482},{level:3,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:3525},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:303},{level:3,title:"推荐下载网站",slug:"推荐下载网站",normalizedTitle:"推荐下载网站",charIndex:4544},{level:2,title:"text 文本 🔥",slug:"text-文本-🔥",normalizedTitle:"text 文本 🔥",charIndex:4809},{level:3,title:"text-decoration 修饰 🔥",slug:"text-decoration-修饰-🔥",normalizedTitle:"text-decoration 修饰 🔥",charIndex:4833},{level:3,title:"text-align 元素内元素水平对齐 🔥",slug:"text-align-元素内元素水平对齐-🔥",normalizedTitle:"text-align 元素内元素水平对齐 🔥",charIndex:5437},{level:3,title:"line-height 行高 🔥",slug:"line-height-行高-🔥",normalizedTitle:"line-height 行高 🔥",charIndex:7115},{level:3,title:"text-indent 缩进",slug:"text-indent-缩进",normalizedTitle:"text-indent 缩进",charIndex:7459},{level:3,title:"text-shadow 文字阴影",slug:"text-shadow-文字阴影",normalizedTitle:"text-shadow 文字阴影",charIndex:7759},{level:3,title:"letter-spacing 字符间距",slug:"letter-spacing-字符间距",normalizedTitle:"letter-spacing 字符间距",charIndex:7958},{level:3,title:"word-spacing 字间距",slug:"word-spacing-字间距",normalizedTitle:"word-spacing 字间距",charIndex:8062},{level:3,title:"text-transform 大小写转换",slug:"text-transform-大小写转换",normalizedTitle:"text-transform 大小写转换",charIndex:8169},{level:2,title:"vertical-align 与文字垂直对齐",slug:"vertical-align-与文字垂直对齐",normalizedTitle:"vertical-align 与文字垂直对齐",charIndex:8275},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:4512},{level:3,title:"案例 1：图片底部默认空白缝隙",slug:"案例-1-图片底部默认空白缝隙",normalizedTitle:"案例 1：图片底部默认空白缝隙",charIndex:9067},{level:3,title:"图片在盒子中垂直居中对齐",slug:"图片在盒子中垂直居中对齐",normalizedTitle:"图片在盒子中垂直居中对齐",charIndex:9250},{level:3,title:"盒子中有文字",slug:"盒子中有文字",normalizedTitle:"盒子中有文字",charIndex:9535},{level:2,title:"background 背景 🔥",slug:"background-背景-🔥",normalizedTitle:"background 背景 🔥",charIndex:9880},{level:3,title:"background 缩写 🔥",slug:"background-缩写-🔥",normalizedTitle:"background 缩写 🔥",charIndex:9901},{level:3,title:"background-image 背景图片 🔥",slug:"background-image-背景图片-🔥",normalizedTitle:"background-image 背景图片 🔥",charIndex:10398},{level:3,title:"background-position 背景定位 🔥",slug:"background-position-背景定位-🔥",normalizedTitle:"background-position 背景定位 🔥",charIndex:10613},{level:4,title:"使用",slug:"使用-2",normalizedTitle:"使用",charIndex:303},{level:4,title:"为什么需要精灵图 Sprite",slug:"为什么需要精灵图-sprite",normalizedTitle:"为什么需要精灵图 sprite",charIndex:11013},{level:4,title:"精灵图 Sprite 的使用",slug:"精灵图-sprite-的使用",normalizedTitle:"精灵图 sprite 的使用",charIndex:11249},{level:3,title:"background-size 背景大小 🔥",slug:"background-size-背景大小-🔥",normalizedTitle:"background-size 背景大小 🔥",charIndex:12848},{level:3,title:"background-repeat 背景平铺 🔥",slug:"background-repeat-背景平铺-🔥",normalizedTitle:"background-repeat 背景平铺 🔥",charIndex:13518},{level:3,title:"background-attachment 背景附着 🔥",slug:"background-attachment-背景附着-🔥",normalizedTitle:"background-attachment 背景附着 🔥",charIndex:13626},{level:3,title:"background-origin偏移原点",slug:"background-origin偏移原点",normalizedTitle:"background-origin偏移原点",charIndex:13928},{level:3,title:"background-clip背景范围",slug:"background-clip背景范围",normalizedTitle:"background-clip背景范围",charIndex:14086},{level:3,title:"background-color 背景颜色",slug:"background-color-背景颜色",normalizedTitle:"background-color 背景颜色",charIndex:14219},{level:3,title:"img 和 background-image 选择",slug:"img-和-background-image-选择",normalizedTitle:"img 和 background-image 选择",charIndex:14358},{level:3,title:"gradient图片渐变 🔥",slug:"gradient图片渐变-🔥",normalizedTitle:"gradient图片渐变 🔥",charIndex:14737},{level:2,title:"list-style 列表 🔥",slug:"list-style-列表-🔥",normalizedTitle:"list-style 列表 🔥",charIndex:16065},{level:3,title:"list-style 缩写 🔥",slug:"list-style-缩写-🔥",normalizedTitle:"list-style 缩写 🔥",charIndex:16086},{level:3,title:"list-style-type 类型",slug:"list-style-type-类型",normalizedTitle:"list-style-type 类型",charIndex:16209},{level:3,title:"list-style-position 放置位置",slug:"list-style-position-放置位置",normalizedTitle:"list-style-position 放置位置",charIndex:16317},{level:3,title:"list-style-image 图片样式",slug:"list-style-image-图片样式",normalizedTitle:"list-style-image 图片样式",charIndex:16394},{level:2,title:"display & visibility & overflow 🔥",slug:"display-visibility-overflow-🔥",normalizedTitle:"display &amp; visibility &amp; overflow 🔥",charIndex:null},{level:3,title:"display",slug:"display",normalizedTitle:"display",charIndex:7084},{level:3,title:"visibility",slug:"visibility",normalizedTitle:"visibility",charIndex:16456},{level:3,title:"overflow",slug:"overflow",normalizedTitle:"overflow",charIndex:16469},{level:3,title:"遮罩案例",slug:"遮罩案例",normalizedTitle:"遮罩案例",charIndex:17783},{level:2,title:"word-break 单词换行",slug:"word-break-单词换行",normalizedTitle:"word-break 单词换行",charIndex:18619},{level:2,title:"溢出文字隐藏 🔥",slug:"溢出文字隐藏-🔥",normalizedTitle:"溢出文字隐藏 🔥",charIndex:18698},{level:3,title:"white-space",slug:"white-space",normalizedTitle:"white-space",charIndex:18712},{level:3,title:"text-overflow",slug:"text-overflow",normalizedTitle:"text-overflow",charIndex:18809},{level:3,title:"单行文本溢出显示省略号",slug:"单行文本溢出显示省略号",normalizedTitle:"单行文本溢出显示省略号",charIndex:18936},{level:3,title:"多行文本溢出显示省略号",slug:"多行文本溢出显示省略号",normalizedTitle:"多行文本溢出显示省略号",charIndex:19772},{level:2,title:"cursor 光标 🔥",slug:"cursor-光标-🔥",normalizedTitle:"cursor 光标 🔥",charIndex:21076},{level:2,title:"resize 防止拖拽",slug:"resize-防止拖拽",normalizedTitle:"resize 防止拖拽",charIndex:21278},{level:2,title:"浏览器私有前缀",slug:"浏览器私有前缀",normalizedTitle:"浏览器私有前缀",charIndex:21374}],headersStr:"长度单位 🔥 color 颜色单位 🔥 颜色关键字 RGB RGBA HSL & HSLA font 字体 🔥 font 缩写 🔥 font-style 倾斜 font-variant 小写字母显示方式 font-weight 粗细 font-size 字号 font-family 字体 @font-face 网络字体 字体图标 发展 优点 使用 推荐下载网站 text 文本 🔥 text-decoration 修饰 🔥 text-align 元素内元素水平对齐 🔥 line-height 行高 🔥 text-indent 缩进 text-shadow 文字阴影 letter-spacing 字符间距 word-spacing 字间距 text-transform 大小写转换 vertical-align 与文字垂直对齐 介绍 案例 1：图片底部默认空白缝隙 图片在盒子中垂直居中对齐 盒子中有文字 background 背景 🔥 background 缩写 🔥 background-image 背景图片 🔥 background-position 背景定位 🔥 使用 为什么需要精灵图 Sprite 精灵图 Sprite 的使用 background-size 背景大小 🔥 background-repeat 背景平铺 🔥 background-attachment 背景附着 🔥 background-origin偏移原点 background-clip背景范围 background-color 背景颜色 img 和 background-image 选择 gradient图片渐变 🔥 list-style 列表 🔥 list-style 缩写 🔥 list-style-type 类型 list-style-position 放置位置 list-style-image 图片样式 display & visibility & overflow 🔥 display visibility overflow 遮罩案例 word-break 单词换行 溢出文字隐藏 🔥 white-space text-overflow 单行文本溢出显示省略号 多行文本溢出显示省略号 cursor 光标 🔥 resize 防止拖拽 浏览器私有前缀",content:'# 属性\n\n\n# 长度单位 🔥\n\n * px：像素（不是物理像素，是逻辑像素）\n * em：相对于自己元素font-size的倍数\n   * font-size：相对于自己元素font-size的倍数\n   * width：相对于自己元素font-size的倍数，自己没有则继承父元素的\n * rem：相对于根元素，具体哪个元素参考上面 em\n * %：不同场景相对的不同！太多了需查文档！举例如下两个：\n   * width：相对于父元素的width\n   * margin-top：相对于父元素的width！\n\n\n# color 颜色单位 🔥\n\n其实是前景色，包括border的颜色。很多元素都可以使用。\n\n\n# 颜色关键字\n\n如red、green、blue、black、white、yellow、purple、skyblue等\n\n\n# RGB\n\n * 十进制：rgb(red,green,blue)\n   \n   * red：0~255\n   * green：0~255\n   * blue：0~255\n   \n   每个颜色使用一个字节表示，所以为 0~255\n\n * 十六进制：#rrggbb或#rgb\n   \n   每个颜色使用0~F表示，比十进制表示多些，推荐使用\n\n\n# RGBA\n\nrgba(red,green,blue,alpha)\n\n * alpha 表示透明度，值范围为 0 ～ 1，0 即完全透明，1 即完全不透明\n   \n   还有个特别的属性opacity: .5可以为整个元素设置透明度\n\n * transparent：如下两种表示方式结果一样\n   \n   div {\n     background-color: rgba(0, 0, 0, 0);\n     background-color: transparent;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# HSL & HSLA\n\n * H 色相(0 - 360)*\n\n * S 饱和度，颜色的浓度 0% - 100%\n\n * L 亮度，颜色的亮度 0% - 100%\n   \n   background-color: hsla(98, 48%, 40%, 0.658);\n   \n   \n   1\n   \n\n\n# font 字体 🔥\n\n用于定义字体系列、大小、粗细、和文字样式(如斜体)\n\n\n# font 缩写 🔥\n\n选择器 {\n  font: [font-style] [font-variant] [font-weight] font-size/line-height\n    font-family;\n}\n\n\n1\n2\n3\n4\n\n * 其中不需要设置的属性可以省略（取默认值），但必须包含font-size、font-family，否则 font 属性将不起作用。\n * font-style、font-variant、 font-weight顺序可以随意更换，但是必须在font-size/line-height之前，font-family 必须最后指定\n\n\n# font-style 倾斜\n\n * normal正常，默认值\n * italic斜体，推荐。字体本身支持斜体，否则无效\n * oblique倾斜，无论字体本身是否支持斜体，都倾斜显示\n * inherit\n\n注意\n\n平时我们很少给文字加斜体，反而要给斜体标签(em，i)改为不倾斜字体\n\n\n# font-variant 小写字母显示方式\n\n使用很少\n\n * normal默认正常显示\n\n * small-cap小写字母按照大写字母全大写显示\n\n\n# font-weight 粗细\n\n * normal 400，默认值\n * bold 700\n * 100~900\n * 一般使用单词表示\n\n\n# font-size 字号\n\n可以使用相对长度单位，也可以使用绝对长度单位。\n\n * 具体数值+单位\n\n * %：设置为基于父元素的一个百分比值，具体相对于什么属性根据文档来看\n * xx-small、x-small、small、medium、large、x-large、xx-large\n * inherit：规定应该从父元素继承字体尺寸，默认\n\n长度单位名称   说明\npx       相对长度单位，像素，推荐使用\nem       相对长度单位，相对于自己元素的font-size大小*em\nrem      相对长度单位，相对于 root 元素的font-size大小*em，浏览器中为html元素\nin       绝对长度单位，英寸\ncm       绝对长度单位，厘米\nmm       绝对长度单位，毫米\npt       绝对长度单位，点\n\n注意\n\nChrome 默认的普通文字（如段落）大小为16px，但是不同浏览器可能默认显示的字号大小不一致，一般给 body 指定整个页面文字的大小。\n\nChrome 默认最小font-size是 12px，注意使用em、rem和%时的字体大小\n\n\n# font-family 字体\n\n * 各种字体之间必须使用英文状态下的逗号隔开，以第一个为准，找不到则找下一个，以此类推\n * 一般如果字体名中包含空格、#、$等符号或是 中文字体，加引号（单双都可），有连接符号则不用加引号\n * 在设置多个字体时，一般建议先写英文字体，后写中文字体，否则容易造成中文字体覆盖了英文字体\n * 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示\n\n注意\n\n在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。XP 系统不支持类似微软雅黑的中文。解决如下：\n\n * 使用英文来替代。 比如font-family:"Microsoft Yahei"。\n * 在 CSS 直接使用 Unicode 编码来写字体名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。\n\n字体名称        英文名称              UNICODE 编码\n宋体          SimSun            \\5B8B\\4F53\n新宋体         NSimSun           \\65B0\\5B8B\\4F53\n黑体          SimHei            \\9ED1\\4F53\n微软雅黑        Microsoft YaHei   \\5FAE\\8F6F\\96C5\\9ED1\n楷体_GB2312   KaiTi_GB2312      \\6977\\4F53_GB2312\n隶书          LiSu              \\96B6\\4E66\n幼园          YouYuan           \\5E7C\\5706\n华文细黑        STXihei           \\534E\\6587\\7EC6\\9ED1\n细明体         MingLiU           \\7EC6\\660E\\4F53\n新细明体        PMingLiU          \\65B0\\7EC6\\660E\\4F53\n\n\n# @font-face 网络字体\n\n@font-face 可以让网页支持网络字体（Web Font），不再局限于系统自带的字体\n\n@font-face {\n  font-family: \'conanan\';\n  src: url(\'./font/conanan.ttf\'), url(\'./font/conanan.otf\');\n}\n\np {\n  font-family: \'conanan\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n常见的字体种类：\n\n * TrueType：.ttf\n * OpenType：.ttf、.otf，建立在 TrueType 之上\n * Embedded OpenType：.eot，OpenType 字体的压缩版\n * SVG：.svg、.svgz\n * web 开放字体：.woff，建立在 TrueType 字体之上\n\n注意加载速度和版权问题！\n\n根据浏览器的支持，准备多种字体\n\nGoogle Fonts 下载：https://fonts.google.com\n\n\n# 字体图标\n\n\n# 发展\n\n字体图标使用场景：主要用于显示网页中通用、常用的一些小图标。\n\n精灵图是有诸多优点的，但是缺点很明显。\n\n * 图片文件还是比较大的。\n * 图片本身放大和缩小会失真。\n * 一旦图片制作完毕想要更换非常复杂。\n\n此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。\n\n\n# 优点\n\n * 轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求\n * 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等\n * 兼容性：几乎支持所有的浏览器，请放心使用\n\n注意：字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。\n\n * 如果遇到一些结构和样式比较简单的小图标，就用字体图标。\n * 如果遇到一些结构和样式复杂一点的小图片，就用精灵图。\n\n\n# 使用\n\n字体图标是一些网页常见的小图标，我们直接网上下载即可。 因此使用可以分为:\n\n 1. 字体图标的下载，把下载包里面的 fonts 文件夹放入页面根目录下\n    \n    不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容就是因为包含了主流浏览器支持的字体文件。\n    \n    * TureType(.ttf)格式.ttf 字体是 Windows 和 Mac 的最常见的字体，支持这种字体的浏览器有 IE9+、Firefox3.5+、 Chrome4+、Safari3+、Opera10+、iOS Mobile、Safari4.2+;\n    * Web Open Font Format(.woff)格式 woff 字体，支持这种字体的浏览器有 IE9+、Firefox3.5+、Chrome6+、 Safari3.6+、Opera11.1+;\n    * Embedded Open Type(.eot)格式.eot 字体是 IE 专用字体，支持这种字体的浏览器有 IE4+;\n    * SVG(.svg)格式.svg 字体是基于 SVG 字体渲染的一种格式，支持这种字体的浏览器有 Chrome4+、Safari3.1+、 Opera10.0+、iOS Mobile Safari3.2+;\n\n 2. 字体图标的引入 (引入到我们 html 页面中)\n    \n    一般下载的 demo 会有介绍\n\n 3. 字体图标的追加 (以后添加新的小图标)\n\n\n# 推荐下载网站\n\n * Font Awesome\n   \n   别进中文网站了，版本太低！\n\n * icomoon\n   \n   IcoMoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成\n   \n   一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。\n\n * iconfont\n   \n   这个是阿里妈妈 M2UX 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 AI 制作图标上传生成。 重点是，免费!\n\n\n# text 文本 🔥\n\n定义文本的外观\n\n\n# text-decoration 修饰 🔥\n\n简写方式，可以使用普通属性三个值中的任何一个，可以组合使用\n\n<\'text-decoration-line\'> || <\'text-decoration-style\'> || <\'text-decoration-color\'> || <\'text-decoration-thickness\'>\n\n\n1\n\n * text-decoration-line 文本修饰线的位置\n   * none表示没有文本修饰效果。默认，常用。一般给所有a标签去掉下划线时使用\n   * underline 在文本的下方有一条修饰线。常用\n   * overline 在文本的上方有一条修饰线。\n   * line-through 有一条贯穿文本中间的修饰线\n   * blink 文本闪烁（文本交替处于显示与隐藏状态），不宜使用。\n * text-decoration-colo 设置文本修饰线的颜色\n * text-decoration-style 设置文本修饰线的样式\n   * solid 画一条实线。\n   * double 画一条双实线。\n   * dotted 画一条点划线。\n   * dashed 画一条虚线。\n   * wavy 画一条波浪线。\n   * -moz-none 不画线。亦可用 text-decoration-line : none 替代。\n\n\n# text-align 元素内元素水平对齐 🔥\n\n让元素里的**内容（可能还是元素，不一定非是文本，其实文本是文本元素）**水平对齐\n\n * left\n * right\n * center\n * justify：两端对齐，但是对最后一行没有效果，可以使用text-align-last: justify解决\n * inherit\n * ...\n\n<style>\n    .outer {\n        height: 100px;\n        background-color: skyblue;\n        text-align: center;\n    }\n    .inner {\n        background-color: palegreen;\n    }\n</style>\n<div class="outer">\n    <div class="inner">haha</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n此时 haha 会居中显示，如下：\n\n<html>\n    <div class="demo1">\n        <div class="outer">\n        <div class="inner">haha</div>\n    </div>\n    </div>\n</html>\n\n<style>\n  .demo1 .outer {\n    height: 100px;\n    background-color: skyblue;\n    text-align: center;\n  }\n  .demo1 .inner {\n    background-color: palegreen;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n若改变下 inner 的宽度\n\n<style>\n  .outer {\n    height: 100px;\n    background-color: skyblue;\n    text-align: center;\n  }\n  .inner {\n    width: 200px;\n    background-color: palegreen;\n  }\n</style>\n<div class="outer">\n  <div class="inner">haha</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n显示如下\n\n<html>\n    <div class="demo2">\n        <div class="outer">\n        <div class="inner">haha</div>\n    </div>\n    </div>\n</html>\n\n<style>\n  .demo2 .outer {\n    height: 100px;\n    background-color: skyblue;\n    text-align: center;\n  }\n  .demo2 .inner {\n    width: 200px;\n    background-color: palegreen;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n这是由于div是块级元素，独占一行（即使width缩小），且text-align: center;只是让.outer的内部元素即.inner居中对齐。由于此时.inner还是独占一行，所以.outer认为.inner已经居中对齐了，所以.inner元素的位置不会改变，haha居中是由于.inner继承了.outer的居中对齐样式！\n\n可以给.inner使用display: inline-block即可解决。\n\n\n# line-height 行高 🔥\n\n提示\n\n行高即行间距影响阅读顺序，横读或竖读\n\n行高的严格定义：两行文字基线（baseline）之间的间距。由下图可得：行高 = 上空隙 + 下空隙 + 文字本身高度。\n\n\n\n行高小于盒子高度则文字偏上，否则文字偏下，前提是行高小于等于盒子高度。否则行高将撑开盒子，不用设置盒子高度了。\n\n可据此来间接实现盒子中的文本垂直居中，让其等于块级盒子的height即可。也可以在 font 中 font-size 指定：font-size: 16px/1.5即文字大小的 1.5 倍\n\n * normal 默认\n * px\n * em\n * % 不跟单位，倍数关系\n * 没有单位，表示font-size的倍数\n * inherit\n * ...\n\n\n# text-indent 缩进\n\n * px：一般在 Chrome 中设置 32px 即可，因为 Chrome 中一个字符是 16px\n\n * em，em 是一个相对单位，就是当前元素的font-size 倍数的大小，如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。\n   \n   p {\n     text-indent: 2em; /*相对 p 元素 font-size 大小的 2 倍*/\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * rem：相对root在浏览器中即html的大小\n\n * %\n\n * inherit，默认继承父类\n\n * ...\n\n\n# text-shadow 文字阴影\n\n不常用\n\ntext-shadow: h-shadow v-shadow blur color;\n\n\n1\n\n\n值          描述\nh-shadow   必需。水平阴影的位置。允许负值。\nv-shadow   必需。垂直阴影的位置。允许负值。\nblur       可选。模糊的距离。\ncolor      可选。阴影的颜色。参阅 CSS 颜色值。\n\n\n# letter-spacing 字符间距\n\n每个字符（单个字母、单个汉字等）之间的间距\n\n * normal，默认即 0\n * [length]，单位px，可以为负值（挤压一起）\n * inherit\n\n\n# word-spacing 字间距\n\n每个单词（一个英文单词、没有空格的一组汉字）之间的间距\n\n * normal，默认即 0\n * [length]，单位px，可以为负值（挤压一起）\n * inherit\n\n\n# text-transform 大小写转换\n\n * none：没有任何影响，默认\n\n * capitalize：每个单词首字母大写\n\n * uppercase ：全大写\n\n * lowercase：全小写\n\n\n# vertical-align 与文字垂直对齐\n\n\n# 介绍\n\n一般重置元素时使用，实际使用不多。\n\n其会影响行内元素在一个行盒line-box中垂直方向的位置。经常用于设置图片或者表单（行内块元素）和文字垂直对齐。\n\n思考：一个 div 没有设置height时，会不会有height？\n\n * 没有内容，则没有height\n\n * 有内容，则有内容撑起来的height\n   \n   内容撑起来的高度的本质是？内容有line-height，撑起来 div 的height\n\nline-height为什么可以撑起div的高度？\n\n * 这是因为line-box的存在，且line-box有一个特性，包裹每行的inline-level元素\n * 而其中的文字是有line-height的，必须将整个line-height包裹进去，才算包裹这个inline-leve元素\n\n值             描述\nbaseline🔥    默认。元素放置在父元素的基线上。\nsub           垂直对齐文本的下标。\nsuper         垂直对齐文本的上标\ntop🔥         把元素的顶端与行中最高元素的顶端对齐\ntext-top      把元素的顶端与父元素字体的顶端对齐\nmiddle🔥      行内盒子的中心点与父盒子基线加上xheight 一半的线对齐（文字下沉，不一定是中线）\nbottom🔥      把元素的顶端与行中最低的元素的顶端对齐。\ntext-bottom   把元素的底端与父元素字体的底端对齐。\nlength        \n%             使用 "line-height" 属性的百分比值来排列此元素。允许使用负值。\ninherit       规定应该从父元素继承 vertical-align 属性的值。\n\n\n\n\n# 案例 1：图片底部默认空白缝隙\n\n解决图片底部默认空白缝隙问题\n\nbug：div（不指定 height）包裹图片时底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐，解决方法如下：\n\n * 给图片添加 vertical-align: middle | top| bottom 等，推荐\n * 或把图片转换为块级元素display: block;不推荐\n\n\n# 图片在盒子中垂直居中对齐\n\n<style>\n  div {\n    height: 600px;\n    background-color: skyblue;\n    line-height: 600px;\n    font-size: 0;\n  }\n\n  img {\n    vertical-align: middle;\n  }\n</style>\n<div>\n  <img src="./images/beauty.jpg" alt="" srcset="" />\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 盒子中有文字\n\n则不能这样做，因为font-size: 0;，需使用定位\n\n<style>\n  div {\n    height: 600px;\n    background-color: skyblue;\n  }\n\n  img {\n    position: relative;\n    top: 50%;\n    transform: translate(0, -50%);\n  }\n</style>\n<div>\n  <img src="./images/beauty.jpg" alt="" srcset="" />\n  <span>XxsfsfsfsfSFsF</span>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# background 背景 🔥\n\n\n# background 缩写 🔥\n\ndiv {\n  background: image position[/size] repeat attachment color; /* 常用的 */\n}\n\n\n1\n2\n3\n\n\nbackground 属性被指定多个背景层时，使用逗号分隔每个背景层。每一层的语法如下：\n\n * 在每一层中，下列的值可以出现 0 次或 1 次：\n   * <bg-image>\n   * <position>\n   * <bg-size>\n   * <repeat-style>\n   * <attachment>\n * <bg-size> 只能紧接着 <position> 出现，以/分割，如： center/80%.\n * <box> 可能出现 0 次、1 次或 2 次。如果出现 1 次，它同时设定 background-origin 和 background-clip。如果出现 2 次，第一次的出现设置 background-origin，第二次的出现设置 background-clip。\n * <background-color> 只能被包含在最后一层。\n\n\n# background-image 背景图片 🔥\n\n常用于 logo、装饰性小图片、超大背景图、精灵图，相比 img 非常便于控制位置。\n\n会盖在（不是覆盖，不会替换，会有多层，图片没占满空间则后面会显示背景颜色）background-color上。\n\n元素必须有宽高，否则背景图片显示不出来。\n\n * 默认为nono；\n * url(test.png)，也可以加引号。可写多个url，默认显示第一张，除非第一张显示不了\n\n\n# background-position 背景定位 🔥\n\n# 使用\n\nbackground-position: x y;\n\n\n1\n\n\n参数代表 x，y 坐标，可以使用方位名词或精确单位。可用于精灵图（Sprite）\n\n * position ：left 、center 、right ；top 、center 、bottom 。\n   \n   分号前后可两两组合，与顺序无关，因为上下左右用词不一样；\n   \n   若只指定了一个方位名词，另一个省略，则第二个值默认居中对齐\n\n * length ：百分数｜由浮点数和单位标识符组成的长度值。\n   \n   第一个必须是 x 坐标，第二个必须是 y 坐标。图像的左上角距盒子左上角的偏移。\n   \n   若只指定了一个精确值，另一个省略，则第二个值默认居中对齐\n\n * 混合单位：混合上述两个，但第一个必须是 x 坐标，第二个必须是 y 坐标\n\n# 为什么需要精灵图 Sprite\n\n一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。因此，为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 CSS 精灵技术（也称 CSS Sprites、CSS 雪碧）。\n\n核心原理：将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。\n\n在王者荣耀官网和淘宝官网中可看到应用。\n\n# 精灵图 Sprite 的使用\n\n使用精灵图核心:\n\n * 精灵图主要针对于小的背景图片使用。\n * 移动背景图片位置， 此时可以使用 background-position 。\n * 一般情况下精灵图都是负值（距离父盒子距离）。千万注意网页中的坐标：x 轴右边走是正值，左边走是负值， y 轴同理。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n    <title>精灵图</title>\n    <style>\n      .sprites {\n        width: 1200px;\n        height: 100px;\n        margin: 100px auto;\n      }\n\n      .sprites .c {\n        display: inline-block;\n        width: 120px;\n        height: 120px;\n        background: url(./images/abcd.jpg) -230px 0;\n      }\n\n      .sprites .o {\n        display: inline-block;\n        width: 120px;\n        height: 120px;\n        background: url(./images/abcd.jpg) -370px -270px;\n      }\n\n      .sprites .n {\n        display: inline-block;\n        width: 120px;\n        height: 120px;\n        background: url(./images/abcd.jpg) -250px -270px;\n      }\n\n      .sprites .a {\n        display: inline-block;\n        width: 120px;\n        height: 120px;\n        background: url(./images/abcd.jpg) 0 -5px;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="sprites">\n      <span class="c"></span>\n      <span class="o"></span>\n      <span class="n"></span>\n      <span class="a"></span>\n      <span class="n"></span>\n      <span class="a"></span>\n      <span class="n"></span>\n    </div>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n\n\n# background-size 背景大小 🔥\n\n设置背景图片大小。图片可以保有其原有的尺寸，或拉伸到新的尺寸，或在保持其原有比例的同时缩放到元素的可用空间的尺寸。\n\n * auto：以背景图片的比例缩放背景图片，原始大小\n * cover：缩放背景图片以完全覆盖背景区，可能背景图片部分看不到。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。\n * contain：缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。\n * <percentage>即百分比：指定背景图片相对背景区（background positioning area）的百分比。背景区由 background-origin 设置，默认为盒模型的内容区与内边距，也可设置为只有内容区，或者还包括边框。如果 attachment 为 fixed，背景区为浏览器可视区（即视口），不包括滚动条。不能为负值。若只有一个值，则表示按宽度缩放；有两个值，则按宽高缩放\n * <length> ：指定背景图片大小，不能为负值。写一个值，则另一个默认为 auto。多个值则按照值计算。\n\n\n# background-repeat 背景平铺 🔥\n\n * repeat 平铺，默认值\n * no-repeat 不平铺，常用\n * repeat-x 水平方向上重复\n * repeat-y 垂直方向上重复\n\n\n# background-attachment 背景附着 🔥\n\n决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。常用于视差滚动效果，如下载 QQ 首页。\n\n查看MDN 文档演示\n\n * scroll： 默认，此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。\n * fixed：此关键字表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。\n * local：此关键字表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。\n\n\n# background-origin偏移原点\n\n背景图片的偏移量计算的原点，注意兼容性\n\n * padding-box 默认值，background-position 从内边距处开始计算\n * content-box 背景图片的偏移量从内容区处计算\n * border-box 背景图片的变量从边框处开始计算\n\n\n# background-clip背景范围\n\n设置背景的范围，注意兼容性\n\n * border-box 默认值，背景会出现在边框的下边\n * padding-box 背景不会出现在边框，只出现在内容区和内边距\n * content-box 背景只会出现在内容区\n\n\n# background-color 背景颜色\n\n * 默认值为transparent 透明；\n * 预设值；\n * #FFFFFF；\n * RGB；\n * RGBA，A 代表 alpha 不透明度，即 0 代表透明，1 代表不透明。影响的只有背景色。0.3 可省略为.3\n\n\n# img 和 background-image 选择\n\n                IMG            BACKGROUND-IMAGE\n性质              HTML 元素        CSS 样式\n图片是否占用空间        ✅              ❌\n浏览器右键复制图片       ✅              ❌\n支持 CSS Sprite   ❌              ✅\n更有可能被搜索引擎收录     ✅（配合 alt 属性）   ❌\n加载顺序            优先加载           等加载完 HTML 元素后按需加载\n\n * img：作为网页重要组成部分，如广告图片、LOGO 图片、文章配图、产品图片\n * bgi：可有可无，有使网页更美观，无也不影响用户获取完整网页内容信息\n\n\n# gradient图片渐变 🔥\n\n通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果。渐变是图片，通过background-image设置。详细看文档吧。\n\n * linear-gradient() 线性渐变，颜色沿着一条直线发生变化\n   \n   linear-gradient(red,yellow) /* 红色在开头，黄色在结尾，中间是过渡区域 */\n   \n   \n   1\n   \n   \n   渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，也可以手动指定渐变的分布情况\n   \n   线性渐变的开头，我们可以指定一个渐变的方向：\n   \n   * to left\n   * to right\n   * to bottom\n   * to top\n   * deg deg 表示度数\n   * turn 表示圈\n\n * repeating-linear-gradient() 可以平铺的线性渐变\n   \n   <style>\n     .box1 {\n       width: 200px;\n       height: 200px;\n       /* background-image: linear-gradient(red,yellow,#bfa,orange); */\n       /* background-image: linear-gradient(red 50px,yellow 100px, green 120px, orange 200px); */\n       background-image: repeating-linear-gradient(to right, red, yellow 50px);\n     }\n   </style>\n   <div class="box1"></div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * radial-gradient() 径向渐变（放射性的效果）\n   \n   默认情况下径向渐变的形状根据元素的形状来计算的：\n   \n   * 正方形 --\x3e 圆形\n   * 长方形 --\x3e 椭圆形\n   \n   我们也可以手动指定径向渐变的大小：\n   \n   * circle\n   * ellipse\n   \n   也可以指定渐变的位置\n   \n   radial-gradient(大小 at 位置, 颜色 位置 ,颜色 位置 ,颜色 位置)\n   \n   \n   1\n   \n   \n   大小：\n   \n   * circle 圆形\n   * ellipse 椭圆\n   * closest-side 近边\n   * closest-corner 近角\n   * farthest-side 远边\n   * farthest-corner 远角\n   \n   位置：\n   \n   * top right left center bottom\n\n * repeating-radial-gradient() 可以平铺的径向渐变\n\n\n# list-style 列表 🔥\n\n\n# list-style 缩写 🔥\n\n语法，一般就写list-style-type的值none\n\nlist-style: list-style-type list-style-position list-style-image;\n\n\n1\n\n\n\n# list-style-type 类型\n\n * none 去掉样式，常用于取消列表左侧样式\n * circle 空圆\n * disc 实圆\n * square 实方块\n * decimal 数字\n * ...\n\n\n# list-style-position 放置位置\n\n * outside 默认列表标记放置文本以外\n * inside 默认列表标记放置文本以内\n\n\n# list-style-image 图片样式\n\n基本不用\n\n * url("test.gif")\n\n\n# display & visibility & overflow 🔥\n\n\n# display\n\ndisplay属性有两个作用：\n\n * 一是定义元素的类型（块元素或行内元素，只改变显示角色，不改变固有性质），规定元素的流式布局。此处只介绍该作用\n * 二是控制其子元素的布局（Flex 或 Grid）\n\n常见属性值有：\n\n * block 转换为块级元素。有些块级元素默认不是设置的该值\n\n * inline 转换为行内元素\n\n * inline-block 同时具备块级、行内元素特性，即同一行显示，也可设置宽高内外边距。\n   \n   主要用于行内非替换元素的宽高内外边距设置和块级元素同一行显示\n\n * none 隐藏元素，不再占有原来的位置，但是元素还存在于 DOM 中。也可以通过设置width或height来隐藏！\n\n若display设置为如下值，则等同于某些 HTML 元素，但是基本不用\n\n * table：<table>，一个块级表格\n * inline-table：<table>，一个行内表格，基本不用\n * table-row：<tr>\n * table-row-group：<tbody>\n * table-header-group：<thead>\n * table-footer-group：<tfoot>\n * table-cell：<th> <td>\n * table-caption：<caption>，表格的标题\n * list-item：<li>\n\n如 a 标签为行内元素，不能设置宽、高之类的，需要转换为块级元素。\n\na {\n  display: block;\n  width: 100px;\n  background-color: pink;\n  text-decoration: underline red double;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# visibility\n\nvisibility 属性用于控制一个元素的可见性\n\n * visible 元素可见\n * hidden 元素隐藏，隐藏元素后，继续占有原有 DOM 位置\n\n\n# overflow\n\noverflow 属性指定了内容溢出一个元素的框（超过其指定高度及宽度）时，会发生什么。\n\n可以区分 x,y 轴（但是没成为标准，不推荐），取值同overflow\n\n * overflow-x\n * overflow-y\n\n值          描述\nvisible    默认值。内容不会被修剪，会呈现在元素框之外。\nhidden🔥   内容会被修剪，并且其余内容是不可见的。\nscroll     内容会被修剪，但是浏览器总是会显示滚动条以便查看其余的内容。\nauto🔥     自动。如果内容被修剪，则浏览器会显示滚动条（滚动条也属于宽高一部分）以便查看其余的内容。\ninherit    规定应该从父元素继承 overflow 属性的值。\n\n一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。\n\n如果有定位的盒子，请慎用overflow:hidden，因为它会隐藏多余的部分。此时利用其副作用对首页大图进行定位微调\n\n\n# 遮罩案例\n\n核心原理：原先半透明的黑色遮罩看不见，鼠标经过大盒子，就显示出来。 遮罩的盒子不占有位置，就需要用绝对定位 和 display 配合。详细查看学成在线代码\n\n/* mask遮罩 */\n.box .box-body .mask {\n  /* 隐藏遮罩 */\n  display: none;\n  position: absolute;\n  width: 228px;\n  height: 270px;\n  background: rgba(0, 0, 0, 0.4) url(./images/arr.png) no-repeat 100px 60px;\n}\n\n/* 鼠标经过li盒子时（不能是经过mask），才让mask显示，和以往不同的写法，注意 */\n.box .box-body ul li:hover .mask {\n  display: block;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n学习了伪元素选择器后，改写为\n\n/* mask遮罩 */\n.box .box-body ul li::before {\n  /* 必须加content */\n  content: \'\';\n  /* 隐藏遮罩 */\n  display: none;\n  position: absolute;\n  width: 228px;\n  height: 270px;\n  background: rgba(0, 0, 0, 0.4) url(./images/arr.png) no-repeat 100px 60px;\n}\n\n/* 鼠标经过li盒子时（不能是经过mask），才让mask显示，和以往不同的写法，注意 */\n.box .box-body ul li:hover::before {\n  display: block;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# word-break 单词换行\n\n * break-all强制换行。默认单词（或一个汉字）就会换行，但是若是遇到aaaaa...这种可使用该属性解决\n\n\n# 溢出文字隐藏 🔥\n\n\n# white-space\n\n用于设置空白处理和换行规则\n\n * normal：合并所有连续的空白，允许单词超屏时自动换行\n * mowrap：合并所有连续的空白，不允许单词超屏时自动换行\n\n\n# text-overflow\n\n用来设置文字溢出时的行为（处理那部分不可见的内容）。生效的前提是overflow不为visible\n\n * clip：溢出的内容直接裁剪掉（字符可能显示不完整）\n * ellipsis：溢出的那行的结尾用省略号表示\n\n\n# 单行文本溢出显示省略号\n\n必须满足三个条件\n\n<style>\n  p {\n    width: 100px;\n    margin: 0 auto;\n    background-color: skyblue;\n\n    /*1. 先强制一行内显示文本，默认 normal 自动换行*/\n    white-space: nowrap;\n    /*2. 超出的部分隐藏*/\n    overflow: hidden;\n    /*3. 文字用省略号替代超出的部分*/\n    text-overflow: ellipsis;\n  }\n</style>\n<p>\n  哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落\n</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n<html>\n    <div class="demo3">\n        <p>\n            哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落\n        </p>\n    </div>\n</html>\n\n<style>\n    .demo3 p {\n        width: 100px;\n        margin: 0 auto;\n        background-color: skyblue;\n\n        /*1. 先强制一行内显示文本，默认 normal 自动换行*/\n        white-space: nowrap;\n        /*2. 超出的部分隐藏*/\n        overflow: hidden;\n        /*3. 文字用省略号替代超出的部分*/\n        text-overflow: ellipsis;\n    }\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n# 多行文本溢出显示省略号\n\n多行文本溢出显示省略号，有较大兼容性问题\n\n<style>\n  p {\n    width: 100px;\n    /* 不能指定高度，否则虽然第二行末尾省略号显示，但是之后的行还是会显示所有文字 */\n    margin: 0 auto;\n    background-color: skyblue;\n\n    /* 1. 弹性伸缩盒子模型显示 */\n    display: -webkit-box;\n    /* 2. 超出的部分隐藏*/\n    overflow: hidden;\n    /* 3. 文字用省略号替代超出的部分*/\n    text-overflow: ellipsis;\n    /* 4. 限制在一个块元素显示的文本的行数 */\n    -webkit-line-clamp: 2;\n    /* 5. 设置或检索伸缩盒对象的子元素的排列方式 */\n    -webkit-box-orient: vertical;\n  }\n</style>\n<p>\n  哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落\n</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n<html>\n    <div class="demo4">\n        <p>\n            哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落\n        </p>\n    </div>\n\n</html>\n<style>\n    .demo4 p {\n        width: 100px;\n        /* 不能指定高度，否则虽然第二行末尾省略号显示，但是之后的行还是会显示所有文字 */\n        margin: 0 auto;\n        background-color: skyblue;\n\n        /* 1. 弹性伸缩盒子模型显示 */\n        display: -webkit-box;\n        /* 2. 超出的部分隐藏*/\n        overflow: hidden;\n        /* 3. 文字用省略号替代超出的部分*/\n        text-overflow: ellipsis;\n        /* 4. 限制在一个块元素显示的文本的行数 */\n        -webkit-line-clamp: 2;\n        /* 5. 设置或检索伸缩盒对象的子元素的排列方式 */\n        -webkit-box-orient: vertical;\n    }\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。\n\n\n# cursor 光标 🔥\n\n * auto ：默认，浏览器设置的光标\n * default：默认为小白箭头\n * pointer：指示链接的手型，常用\n * text：文本\n * move：四方箭头\n * not-allowed：禁止\n * wait：沙漏、转圈、表\n * help：箭头带问号\n * crosshair：十字架\n * url：自定义光标的 url\n * none：没有任何显示\n\n\n# resize 防止拖拽\n\n防止拖拽 textarea（textarea 标签放在同一行即可没有类似 padding 的空白距离）\n\n * none：禁止拖拽，右下角那个功能也就没有了\n\n\n# 浏览器私有前缀\n\n模块化打包工具如 Webpack 会自动添加前缀，不使用则需要自己查看文档添加',normalizedContent:'# 属性\n\n\n# 长度单位 🔥\n\n * px：像素（不是物理像素，是逻辑像素）\n * em：相对于自己元素font-size的倍数\n   * font-size：相对于自己元素font-size的倍数\n   * width：相对于自己元素font-size的倍数，自己没有则继承父元素的\n * rem：相对于根元素，具体哪个元素参考上面 em\n * %：不同场景相对的不同！太多了需查文档！举例如下两个：\n   * width：相对于父元素的width\n   * margin-top：相对于父元素的width！\n\n\n# color 颜色单位 🔥\n\n其实是前景色，包括border的颜色。很多元素都可以使用。\n\n\n# 颜色关键字\n\n如red、green、blue、black、white、yellow、purple、skyblue等\n\n\n# rgb\n\n * 十进制：rgb(red,green,blue)\n   \n   * red：0~255\n   * green：0~255\n   * blue：0~255\n   \n   每个颜色使用一个字节表示，所以为 0~255\n\n * 十六进制：#rrggbb或#rgb\n   \n   每个颜色使用0~f表示，比十进制表示多些，推荐使用\n\n\n# rgba\n\nrgba(red,green,blue,alpha)\n\n * alpha 表示透明度，值范围为 0 ～ 1，0 即完全透明，1 即完全不透明\n   \n   还有个特别的属性opacity: .5可以为整个元素设置透明度\n\n * transparent：如下两种表示方式结果一样\n   \n   div {\n     background-color: rgba(0, 0, 0, 0);\n     background-color: transparent;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# hsl & hsla\n\n * h 色相(0 - 360)*\n\n * s 饱和度，颜色的浓度 0% - 100%\n\n * l 亮度，颜色的亮度 0% - 100%\n   \n   background-color: hsla(98, 48%, 40%, 0.658);\n   \n   \n   1\n   \n\n\n# font 字体 🔥\n\n用于定义字体系列、大小、粗细、和文字样式(如斜体)\n\n\n# font 缩写 🔥\n\n选择器 {\n  font: [font-style] [font-variant] [font-weight] font-size/line-height\n    font-family;\n}\n\n\n1\n2\n3\n4\n\n * 其中不需要设置的属性可以省略（取默认值），但必须包含font-size、font-family，否则 font 属性将不起作用。\n * font-style、font-variant、 font-weight顺序可以随意更换，但是必须在font-size/line-height之前，font-family 必须最后指定\n\n\n# font-style 倾斜\n\n * normal正常，默认值\n * italic斜体，推荐。字体本身支持斜体，否则无效\n * oblique倾斜，无论字体本身是否支持斜体，都倾斜显示\n * inherit\n\n注意\n\n平时我们很少给文字加斜体，反而要给斜体标签(em，i)改为不倾斜字体\n\n\n# font-variant 小写字母显示方式\n\n使用很少\n\n * normal默认正常显示\n\n * small-cap小写字母按照大写字母全大写显示\n\n\n# font-weight 粗细\n\n * normal 400，默认值\n * bold 700\n * 100~900\n * 一般使用单词表示\n\n\n# font-size 字号\n\n可以使用相对长度单位，也可以使用绝对长度单位。\n\n * 具体数值+单位\n\n * %：设置为基于父元素的一个百分比值，具体相对于什么属性根据文档来看\n * xx-small、x-small、small、medium、large、x-large、xx-large\n * inherit：规定应该从父元素继承字体尺寸，默认\n\n长度单位名称   说明\npx       相对长度单位，像素，推荐使用\nem       相对长度单位，相对于自己元素的font-size大小*em\nrem      相对长度单位，相对于 root 元素的font-size大小*em，浏览器中为html元素\nin       绝对长度单位，英寸\ncm       绝对长度单位，厘米\nmm       绝对长度单位，毫米\npt       绝对长度单位，点\n\n注意\n\nchrome 默认的普通文字（如段落）大小为16px，但是不同浏览器可能默认显示的字号大小不一致，一般给 body 指定整个页面文字的大小。\n\nchrome 默认最小font-size是 12px，注意使用em、rem和%时的字体大小\n\n\n# font-family 字体\n\n * 各种字体之间必须使用英文状态下的逗号隔开，以第一个为准，找不到则找下一个，以此类推\n * 一般如果字体名中包含空格、#、$等符号或是 中文字体，加引号（单双都可），有连接符号则不用加引号\n * 在设置多个字体时，一般建议先写英文字体，后写中文字体，否则容易造成中文字体覆盖了英文字体\n * 尽量使用系统默认自带字体，保证在任何用户的浏览器中都能正确显示\n\n注意\n\n在 css 中设置字体名称，直接写中文是可以的。但是在文件编码（gb2312、utf-8 等）不匹配时会产生乱码的错误。xp 系统不支持类似微软雅黑的中文。解决如下：\n\n * 使用英文来替代。 比如font-family:"microsoft yahei"。\n * 在 css 直接使用 unicode 编码来写字体名称可以避免这些错误。使用 unicode 写中文字体名称，浏览器是可以正确的解析的。\n\n字体名称        英文名称              unicode 编码\n宋体          simsun            \\5b8b\\4f53\n新宋体         nsimsun           \\65b0\\5b8b\\4f53\n黑体          simhei            \\9ed1\\4f53\n微软雅黑        microsoft yahei   \\5fae\\8f6f\\96c5\\9ed1\n楷体_gb2312   kaiti_gb2312      \\6977\\4f53_gb2312\n隶书          lisu              \\96b6\\4e66\n幼园          youyuan           \\5e7c\\5706\n华文细黑        stxihei           \\534e\\6587\\7ec6\\9ed1\n细明体         mingliu           \\7ec6\\660e\\4f53\n新细明体        pmingliu          \\65b0\\7ec6\\660e\\4f53\n\n\n# @font-face 网络字体\n\n@font-face 可以让网页支持网络字体（web font），不再局限于系统自带的字体\n\n@font-face {\n  font-family: \'conanan\';\n  src: url(\'./font/conanan.ttf\'), url(\'./font/conanan.otf\');\n}\n\np {\n  font-family: \'conanan\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n常见的字体种类：\n\n * truetype：.ttf\n * opentype：.ttf、.otf，建立在 truetype 之上\n * embedded opentype：.eot，opentype 字体的压缩版\n * svg：.svg、.svgz\n * web 开放字体：.woff，建立在 truetype 字体之上\n\n注意加载速度和版权问题！\n\n根据浏览器的支持，准备多种字体\n\ngoogle fonts 下载：https://fonts.google.com\n\n\n# 字体图标\n\n\n# 发展\n\n字体图标使用场景：主要用于显示网页中通用、常用的一些小图标。\n\n精灵图是有诸多优点的，但是缺点很明显。\n\n * 图片文件还是比较大的。\n * 图片本身放大和缩小会失真。\n * 一旦图片制作完毕想要更换非常复杂。\n\n此时，有一种技术的出现很好的解决了以上问题，就是字体图标 iconfont。字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。\n\n\n# 优点\n\n * 轻量级：一个图标字体要比一系列的图像要小。一旦字体加载了，图标就会马上渲染出来，减少了服务器请求\n * 灵活性：本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果、旋转等\n * 兼容性：几乎支持所有的浏览器，请放心使用\n\n注意：字体图标不能替代精灵技术，只是对工作中图标部分技术的提升和优化。\n\n * 如果遇到一些结构和样式比较简单的小图标，就用字体图标。\n * 如果遇到一些结构和样式复杂一点的小图片，就用精灵图。\n\n\n# 使用\n\n字体图标是一些网页常见的小图标，我们直接网上下载即可。 因此使用可以分为:\n\n 1. 字体图标的下载，把下载包里面的 fonts 文件夹放入页面根目录下\n    \n    不同浏览器所支持的字体格式是不一样的，字体图标之所以兼容就是因为包含了主流浏览器支持的字体文件。\n    \n    * turetype(.ttf)格式.ttf 字体是 windows 和 mac 的最常见的字体，支持这种字体的浏览器有 ie9+、firefox3.5+、 chrome4+、safari3+、opera10+、ios mobile、safari4.2+;\n    * web open font format(.woff)格式 woff 字体，支持这种字体的浏览器有 ie9+、firefox3.5+、chrome6+、 safari3.6+、opera11.1+;\n    * embedded open type(.eot)格式.eot 字体是 ie 专用字体，支持这种字体的浏览器有 ie4+;\n    * svg(.svg)格式.svg 字体是基于 svg 字体渲染的一种格式，支持这种字体的浏览器有 chrome4+、safari3.1+、 opera10.0+、ios mobile safari3.2+;\n\n 2. 字体图标的引入 (引入到我们 html 页面中)\n    \n    一般下载的 demo 会有介绍\n\n 3. 字体图标的追加 (以后添加新的小图标)\n\n\n# 推荐下载网站\n\n * font awesome\n   \n   别进中文网站了，版本太低！\n\n * icomoon\n   \n   icomoon 成立于 2011 年，推出了第一个自定义图标字体生成器，它允许用户选择所需要的图标，使它们成\n   \n   一字型。该字库内容种类繁多，非常全面，唯一的遗憾是国外服务器，打开网速较慢。\n\n * iconfont\n   \n   这个是阿里妈妈 m2ux 的一个 iconfont 字体图标字库，包含了淘宝图标库和阿里妈妈图标库。可以使用 ai 制作图标上传生成。 重点是，免费!\n\n\n# text 文本 🔥\n\n定义文本的外观\n\n\n# text-decoration 修饰 🔥\n\n简写方式，可以使用普通属性三个值中的任何一个，可以组合使用\n\n<\'text-decoration-line\'> || <\'text-decoration-style\'> || <\'text-decoration-color\'> || <\'text-decoration-thickness\'>\n\n\n1\n\n * text-decoration-line 文本修饰线的位置\n   * none表示没有文本修饰效果。默认，常用。一般给所有a标签去掉下划线时使用\n   * underline 在文本的下方有一条修饰线。常用\n   * overline 在文本的上方有一条修饰线。\n   * line-through 有一条贯穿文本中间的修饰线\n   * blink 文本闪烁（文本交替处于显示与隐藏状态），不宜使用。\n * text-decoration-colo 设置文本修饰线的颜色\n * text-decoration-style 设置文本修饰线的样式\n   * solid 画一条实线。\n   * double 画一条双实线。\n   * dotted 画一条点划线。\n   * dashed 画一条虚线。\n   * wavy 画一条波浪线。\n   * -moz-none 不画线。亦可用 text-decoration-line : none 替代。\n\n\n# text-align 元素内元素水平对齐 🔥\n\n让元素里的**内容（可能还是元素，不一定非是文本，其实文本是文本元素）**水平对齐\n\n * left\n * right\n * center\n * justify：两端对齐，但是对最后一行没有效果，可以使用text-align-last: justify解决\n * inherit\n * ...\n\n<style>\n    .outer {\n        height: 100px;\n        background-color: skyblue;\n        text-align: center;\n    }\n    .inner {\n        background-color: palegreen;\n    }\n</style>\n<div class="outer">\n    <div class="inner">haha</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n此时 haha 会居中显示，如下：\n\n<html>\n    <div class="demo1">\n        <div class="outer">\n        <div class="inner">haha</div>\n    </div>\n    </div>\n</html>\n\n<style>\n  .demo1 .outer {\n    height: 100px;\n    background-color: skyblue;\n    text-align: center;\n  }\n  .demo1 .inner {\n    background-color: palegreen;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n若改变下 inner 的宽度\n\n<style>\n  .outer {\n    height: 100px;\n    background-color: skyblue;\n    text-align: center;\n  }\n  .inner {\n    width: 200px;\n    background-color: palegreen;\n  }\n</style>\n<div class="outer">\n  <div class="inner">haha</div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n显示如下\n\n<html>\n    <div class="demo2">\n        <div class="outer">\n        <div class="inner">haha</div>\n    </div>\n    </div>\n</html>\n\n<style>\n  .demo2 .outer {\n    height: 100px;\n    background-color: skyblue;\n    text-align: center;\n  }\n  .demo2 .inner {\n    width: 200px;\n    background-color: palegreen;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n这是由于div是块级元素，独占一行（即使width缩小），且text-align: center;只是让.outer的内部元素即.inner居中对齐。由于此时.inner还是独占一行，所以.outer认为.inner已经居中对齐了，所以.inner元素的位置不会改变，haha居中是由于.inner继承了.outer的居中对齐样式！\n\n可以给.inner使用display: inline-block即可解决。\n\n\n# line-height 行高 🔥\n\n提示\n\n行高即行间距影响阅读顺序，横读或竖读\n\n行高的严格定义：两行文字基线（baseline）之间的间距。由下图可得：行高 = 上空隙 + 下空隙 + 文字本身高度。\n\n\n\n行高小于盒子高度则文字偏上，否则文字偏下，前提是行高小于等于盒子高度。否则行高将撑开盒子，不用设置盒子高度了。\n\n可据此来间接实现盒子中的文本垂直居中，让其等于块级盒子的height即可。也可以在 font 中 font-size 指定：font-size: 16px/1.5即文字大小的 1.5 倍\n\n * normal 默认\n * px\n * em\n * % 不跟单位，倍数关系\n * 没有单位，表示font-size的倍数\n * inherit\n * ...\n\n\n# text-indent 缩进\n\n * px：一般在 chrome 中设置 32px 即可，因为 chrome 中一个字符是 16px\n\n * em，em 是一个相对单位，就是当前元素的font-size 倍数的大小，如果当前元素没有设置大小，则会按照父元素的 1 个文字大小。\n   \n   p {\n     text-indent: 2em; /*相对 p 元素 font-size 大小的 2 倍*/\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * rem：相对root在浏览器中即html的大小\n\n * %\n\n * inherit，默认继承父类\n\n * ...\n\n\n# text-shadow 文字阴影\n\n不常用\n\ntext-shadow: h-shadow v-shadow blur color;\n\n\n1\n\n\n值          描述\nh-shadow   必需。水平阴影的位置。允许负值。\nv-shadow   必需。垂直阴影的位置。允许负值。\nblur       可选。模糊的距离。\ncolor      可选。阴影的颜色。参阅 css 颜色值。\n\n\n# letter-spacing 字符间距\n\n每个字符（单个字母、单个汉字等）之间的间距\n\n * normal，默认即 0\n * [length]，单位px，可以为负值（挤压一起）\n * inherit\n\n\n# word-spacing 字间距\n\n每个单词（一个英文单词、没有空格的一组汉字）之间的间距\n\n * normal，默认即 0\n * [length]，单位px，可以为负值（挤压一起）\n * inherit\n\n\n# text-transform 大小写转换\n\n * none：没有任何影响，默认\n\n * capitalize：每个单词首字母大写\n\n * uppercase ：全大写\n\n * lowercase：全小写\n\n\n# vertical-align 与文字垂直对齐\n\n\n# 介绍\n\n一般重置元素时使用，实际使用不多。\n\n其会影响行内元素在一个行盒line-box中垂直方向的位置。经常用于设置图片或者表单（行内块元素）和文字垂直对齐。\n\n思考：一个 div 没有设置height时，会不会有height？\n\n * 没有内容，则没有height\n\n * 有内容，则有内容撑起来的height\n   \n   内容撑起来的高度的本质是？内容有line-height，撑起来 div 的height\n\nline-height为什么可以撑起div的高度？\n\n * 这是因为line-box的存在，且line-box有一个特性，包裹每行的inline-level元素\n * 而其中的文字是有line-height的，必须将整个line-height包裹进去，才算包裹这个inline-leve元素\n\n值             描述\nbaseline🔥    默认。元素放置在父元素的基线上。\nsub           垂直对齐文本的下标。\nsuper         垂直对齐文本的上标\ntop🔥         把元素的顶端与行中最高元素的顶端对齐\ntext-top      把元素的顶端与父元素字体的顶端对齐\nmiddle🔥      行内盒子的中心点与父盒子基线加上xheight 一半的线对齐（文字下沉，不一定是中线）\nbottom🔥      把元素的顶端与行中最低的元素的顶端对齐。\ntext-bottom   把元素的底端与父元素字体的底端对齐。\nlength        \n%             使用 "line-height" 属性的百分比值来排列此元素。允许使用负值。\ninherit       规定应该从父元素继承 vertical-align 属性的值。\n\n\n\n\n# 案例 1：图片底部默认空白缝隙\n\n解决图片底部默认空白缝隙问题\n\nbug：div（不指定 height）包裹图片时底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐，解决方法如下：\n\n * 给图片添加 vertical-align: middle | top| bottom 等，推荐\n * 或把图片转换为块级元素display: block;不推荐\n\n\n# 图片在盒子中垂直居中对齐\n\n<style>\n  div {\n    height: 600px;\n    background-color: skyblue;\n    line-height: 600px;\n    font-size: 0;\n  }\n\n  img {\n    vertical-align: middle;\n  }\n</style>\n<div>\n  <img src="./images/beauty.jpg" alt="" srcset="" />\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 盒子中有文字\n\n则不能这样做，因为font-size: 0;，需使用定位\n\n<style>\n  div {\n    height: 600px;\n    background-color: skyblue;\n  }\n\n  img {\n    position: relative;\n    top: 50%;\n    transform: translate(0, -50%);\n  }\n</style>\n<div>\n  <img src="./images/beauty.jpg" alt="" srcset="" />\n  <span>xxsfsfsfsfsfsf</span>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# background 背景 🔥\n\n\n# background 缩写 🔥\n\ndiv {\n  background: image position[/size] repeat attachment color; /* 常用的 */\n}\n\n\n1\n2\n3\n\n\nbackground 属性被指定多个背景层时，使用逗号分隔每个背景层。每一层的语法如下：\n\n * 在每一层中，下列的值可以出现 0 次或 1 次：\n   * <bg-image>\n   * <position>\n   * <bg-size>\n   * <repeat-style>\n   * <attachment>\n * <bg-size> 只能紧接着 <position> 出现，以/分割，如： center/80%.\n * <box> 可能出现 0 次、1 次或 2 次。如果出现 1 次，它同时设定 background-origin 和 background-clip。如果出现 2 次，第一次的出现设置 background-origin，第二次的出现设置 background-clip。\n * <background-color> 只能被包含在最后一层。\n\n\n# background-image 背景图片 🔥\n\n常用于 logo、装饰性小图片、超大背景图、精灵图，相比 img 非常便于控制位置。\n\n会盖在（不是覆盖，不会替换，会有多层，图片没占满空间则后面会显示背景颜色）background-color上。\n\n元素必须有宽高，否则背景图片显示不出来。\n\n * 默认为nono；\n * url(test.png)，也可以加引号。可写多个url，默认显示第一张，除非第一张显示不了\n\n\n# background-position 背景定位 🔥\n\n# 使用\n\nbackground-position: x y;\n\n\n1\n\n\n参数代表 x，y 坐标，可以使用方位名词或精确单位。可用于精灵图（sprite）\n\n * position ：left 、center 、right ；top 、center 、bottom 。\n   \n   分号前后可两两组合，与顺序无关，因为上下左右用词不一样；\n   \n   若只指定了一个方位名词，另一个省略，则第二个值默认居中对齐\n\n * length ：百分数｜由浮点数和单位标识符组成的长度值。\n   \n   第一个必须是 x 坐标，第二个必须是 y 坐标。图像的左上角距盒子左上角的偏移。\n   \n   若只指定了一个精确值，另一个省略，则第二个值默认居中对齐\n\n * 混合单位：混合上述两个，但第一个必须是 x 坐标，第二个必须是 y 坐标\n\n# 为什么需要精灵图 sprite\n\n一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接收和发送请求图片，造成服务器请求压力过大，这将大大降低页面的加载速度。因此，为了有效地减少服务器接收和发送请求的次数，提高页面的加载速度，出现了 css 精灵技术（也称 css sprites、css 雪碧）。\n\n核心原理：将网页中的一些小背景图像整合到一张大图中 ，这样服务器只需要一次请求就可以了。\n\n在王者荣耀官网和淘宝官网中可看到应用。\n\n# 精灵图 sprite 的使用\n\n使用精灵图核心:\n\n * 精灵图主要针对于小的背景图片使用。\n * 移动背景图片位置， 此时可以使用 background-position 。\n * 一般情况下精灵图都是负值（距离父盒子距离）。千万注意网页中的坐标：x 轴右边走是正值，左边走是负值， y 轴同理。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <title>精灵图</title>\n    <style>\n      .sprites {\n        width: 1200px;\n        height: 100px;\n        margin: 100px auto;\n      }\n\n      .sprites .c {\n        display: inline-block;\n        width: 120px;\n        height: 120px;\n        background: url(./images/abcd.jpg) -230px 0;\n      }\n\n      .sprites .o {\n        display: inline-block;\n        width: 120px;\n        height: 120px;\n        background: url(./images/abcd.jpg) -370px -270px;\n      }\n\n      .sprites .n {\n        display: inline-block;\n        width: 120px;\n        height: 120px;\n        background: url(./images/abcd.jpg) -250px -270px;\n      }\n\n      .sprites .a {\n        display: inline-block;\n        width: 120px;\n        height: 120px;\n        background: url(./images/abcd.jpg) 0 -5px;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="sprites">\n      <span class="c"></span>\n      <span class="o"></span>\n      <span class="n"></span>\n      <span class="a"></span>\n      <span class="n"></span>\n      <span class="a"></span>\n      <span class="n"></span>\n    </div>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n\n\n# background-size 背景大小 🔥\n\n设置背景图片大小。图片可以保有其原有的尺寸，或拉伸到新的尺寸，或在保持其原有比例的同时缩放到元素的可用空间的尺寸。\n\n * auto：以背景图片的比例缩放背景图片，原始大小\n * cover：缩放背景图片以完全覆盖背景区，可能背景图片部分看不到。和 contain 值相反，cover 值尽可能大的缩放背景图像并保持图像的宽高比例（图像不会被压扁）。该背景图以它的全部宽或者高覆盖所在容器。当容器和背景图大小不同时，背景图的 左/右 或者 上/下 部分会被裁剪。\n * contain：缩放背景图片以完全装入背景区，可能背景区部分空白。contain 尽可能的缩放背景并保持图像的宽高比例（图像不会被压缩）。该背景图会填充所在的容器。当背景图和容器的大小的不同时，容器的空白区域（上/下或者左/右）会显示由 background-color 设置的背景颜色。\n * <percentage>即百分比：指定背景图片相对背景区（background positioning area）的百分比。背景区由 background-origin 设置，默认为盒模型的内容区与内边距，也可设置为只有内容区，或者还包括边框。如果 attachment 为 fixed，背景区为浏览器可视区（即视口），不包括滚动条。不能为负值。若只有一个值，则表示按宽度缩放；有两个值，则按宽高缩放\n * <length> ：指定背景图片大小，不能为负值。写一个值，则另一个默认为 auto。多个值则按照值计算。\n\n\n# background-repeat 背景平铺 🔥\n\n * repeat 平铺，默认值\n * no-repeat 不平铺，常用\n * repeat-x 水平方向上重复\n * repeat-y 垂直方向上重复\n\n\n# background-attachment 背景附着 🔥\n\n决定背景图像的位置是在视口内固定，还是随着包含它的区块滚动。常用于视差滚动效果，如下载 qq 首页。\n\n查看mdn 文档演示\n\n * scroll： 默认，此关键字表示背景相对于元素本身固定， 而不是随着它的内容滚动（对元素边框是有效的）。\n * fixed：此关键字表示背景相对于视口固定。即使一个元素拥有滚动机制，背景也不会随着元素的内容滚动。\n * local：此关键字表示背景相对于元素的内容固定。如果一个元素拥有滚动机制，背景将会随着元素的内容滚动， 并且背景的绘制区域和定位区域是相对于可滚动的区域而不是包含他们的边框。\n\n\n# background-origin偏移原点\n\n背景图片的偏移量计算的原点，注意兼容性\n\n * padding-box 默认值，background-position 从内边距处开始计算\n * content-box 背景图片的偏移量从内容区处计算\n * border-box 背景图片的变量从边框处开始计算\n\n\n# background-clip背景范围\n\n设置背景的范围，注意兼容性\n\n * border-box 默认值，背景会出现在边框的下边\n * padding-box 背景不会出现在边框，只出现在内容区和内边距\n * content-box 背景只会出现在内容区\n\n\n# background-color 背景颜色\n\n * 默认值为transparent 透明；\n * 预设值；\n * #ffffff；\n * rgb；\n * rgba，a 代表 alpha 不透明度，即 0 代表透明，1 代表不透明。影响的只有背景色。0.3 可省略为.3\n\n\n# img 和 background-image 选择\n\n                img            background-image\n性质              html 元素        css 样式\n图片是否占用空间        ✅              ❌\n浏览器右键复制图片       ✅              ❌\n支持 css sprite   ❌              ✅\n更有可能被搜索引擎收录     ✅（配合 alt 属性）   ❌\n加载顺序            优先加载           等加载完 html 元素后按需加载\n\n * img：作为网页重要组成部分，如广告图片、logo 图片、文章配图、产品图片\n * bgi：可有可无，有使网页更美观，无也不影响用户获取完整网页内容信息\n\n\n# gradient图片渐变 🔥\n\n通过渐变可以设置一些复杂的背景颜色，可以实现从一个颜色向其他颜色过渡的效果。渐变是图片，通过background-image设置。详细看文档吧。\n\n * linear-gradient() 线性渐变，颜色沿着一条直线发生变化\n   \n   linear-gradient(red,yellow) /* 红色在开头，黄色在结尾，中间是过渡区域 */\n   \n   \n   1\n   \n   \n   渐变可以同时指定多个颜色，多个颜色默认情况下平均分布，也可以手动指定渐变的分布情况\n   \n   线性渐变的开头，我们可以指定一个渐变的方向：\n   \n   * to left\n   * to right\n   * to bottom\n   * to top\n   * deg deg 表示度数\n   * turn 表示圈\n\n * repeating-linear-gradient() 可以平铺的线性渐变\n   \n   <style>\n     .box1 {\n       width: 200px;\n       height: 200px;\n       /* background-image: linear-gradient(red,yellow,#bfa,orange); */\n       /* background-image: linear-gradient(red 50px,yellow 100px, green 120px, orange 200px); */\n       background-image: repeating-linear-gradient(to right, red, yellow 50px);\n     }\n   </style>\n   <div class="box1"></div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n * radial-gradient() 径向渐变（放射性的效果）\n   \n   默认情况下径向渐变的形状根据元素的形状来计算的：\n   \n   * 正方形 --\x3e 圆形\n   * 长方形 --\x3e 椭圆形\n   \n   我们也可以手动指定径向渐变的大小：\n   \n   * circle\n   * ellipse\n   \n   也可以指定渐变的位置\n   \n   radial-gradient(大小 at 位置, 颜色 位置 ,颜色 位置 ,颜色 位置)\n   \n   \n   1\n   \n   \n   大小：\n   \n   * circle 圆形\n   * ellipse 椭圆\n   * closest-side 近边\n   * closest-corner 近角\n   * farthest-side 远边\n   * farthest-corner 远角\n   \n   位置：\n   \n   * top right left center bottom\n\n * repeating-radial-gradient() 可以平铺的径向渐变\n\n\n# list-style 列表 🔥\n\n\n# list-style 缩写 🔥\n\n语法，一般就写list-style-type的值none\n\nlist-style: list-style-type list-style-position list-style-image;\n\n\n1\n\n\n\n# list-style-type 类型\n\n * none 去掉样式，常用于取消列表左侧样式\n * circle 空圆\n * disc 实圆\n * square 实方块\n * decimal 数字\n * ...\n\n\n# list-style-position 放置位置\n\n * outside 默认列表标记放置文本以外\n * inside 默认列表标记放置文本以内\n\n\n# list-style-image 图片样式\n\n基本不用\n\n * url("test.gif")\n\n\n# display & visibility & overflow 🔥\n\n\n# display\n\ndisplay属性有两个作用：\n\n * 一是定义元素的类型（块元素或行内元素，只改变显示角色，不改变固有性质），规定元素的流式布局。此处只介绍该作用\n * 二是控制其子元素的布局（flex 或 grid）\n\n常见属性值有：\n\n * block 转换为块级元素。有些块级元素默认不是设置的该值\n\n * inline 转换为行内元素\n\n * inline-block 同时具备块级、行内元素特性，即同一行显示，也可设置宽高内外边距。\n   \n   主要用于行内非替换元素的宽高内外边距设置和块级元素同一行显示\n\n * none 隐藏元素，不再占有原来的位置，但是元素还存在于 dom 中。也可以通过设置width或height来隐藏！\n\n若display设置为如下值，则等同于某些 html 元素，但是基本不用\n\n * table：<table>，一个块级表格\n * inline-table：<table>，一个行内表格，基本不用\n * table-row：<tr>\n * table-row-group：<tbody>\n * table-header-group：<thead>\n * table-footer-group：<tfoot>\n * table-cell：<th> <td>\n * table-caption：<caption>，表格的标题\n * list-item：<li>\n\n如 a 标签为行内元素，不能设置宽、高之类的，需要转换为块级元素。\n\na {\n  display: block;\n  width: 100px;\n  background-color: pink;\n  text-decoration: underline red double;\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# visibility\n\nvisibility 属性用于控制一个元素的可见性\n\n * visible 元素可见\n * hidden 元素隐藏，隐藏元素后，继续占有原有 dom 位置\n\n\n# overflow\n\noverflow 属性指定了内容溢出一个元素的框（超过其指定高度及宽度）时，会发生什么。\n\n可以区分 x,y 轴（但是没成为标准，不推荐），取值同overflow\n\n * overflow-x\n * overflow-y\n\n值          描述\nvisible    默认值。内容不会被修剪，会呈现在元素框之外。\nhidden🔥   内容会被修剪，并且其余内容是不可见的。\nscroll     内容会被修剪，但是浏览器总是会显示滚动条以便查看其余的内容。\nauto🔥     自动。如果内容被修剪，则浏览器会显示滚动条（滚动条也属于宽高一部分）以便查看其余的内容。\ninherit    规定应该从父元素继承 overflow 属性的值。\n\n一般情况下，我们都不想让溢出的内容显示出来，因为溢出的部分会影响布局。\n\n如果有定位的盒子，请慎用overflow:hidden，因为它会隐藏多余的部分。此时利用其副作用对首页大图进行定位微调\n\n\n# 遮罩案例\n\n核心原理：原先半透明的黑色遮罩看不见，鼠标经过大盒子，就显示出来。 遮罩的盒子不占有位置，就需要用绝对定位 和 display 配合。详细查看学成在线代码\n\n/* mask遮罩 */\n.box .box-body .mask {\n  /* 隐藏遮罩 */\n  display: none;\n  position: absolute;\n  width: 228px;\n  height: 270px;\n  background: rgba(0, 0, 0, 0.4) url(./images/arr.png) no-repeat 100px 60px;\n}\n\n/* 鼠标经过li盒子时（不能是经过mask），才让mask显示，和以往不同的写法，注意 */\n.box .box-body ul li:hover .mask {\n  display: block;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n学习了伪元素选择器后，改写为\n\n/* mask遮罩 */\n.box .box-body ul li::before {\n  /* 必须加content */\n  content: \'\';\n  /* 隐藏遮罩 */\n  display: none;\n  position: absolute;\n  width: 228px;\n  height: 270px;\n  background: rgba(0, 0, 0, 0.4) url(./images/arr.png) no-repeat 100px 60px;\n}\n\n/* 鼠标经过li盒子时（不能是经过mask），才让mask显示，和以往不同的写法，注意 */\n.box .box-body ul li:hover::before {\n  display: block;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# word-break 单词换行\n\n * break-all强制换行。默认单词（或一个汉字）就会换行，但是若是遇到aaaaa...这种可使用该属性解决\n\n\n# 溢出文字隐藏 🔥\n\n\n# white-space\n\n用于设置空白处理和换行规则\n\n * normal：合并所有连续的空白，允许单词超屏时自动换行\n * mowrap：合并所有连续的空白，不允许单词超屏时自动换行\n\n\n# text-overflow\n\n用来设置文字溢出时的行为（处理那部分不可见的内容）。生效的前提是overflow不为visible\n\n * clip：溢出的内容直接裁剪掉（字符可能显示不完整）\n * ellipsis：溢出的那行的结尾用省略号表示\n\n\n# 单行文本溢出显示省略号\n\n必须满足三个条件\n\n<style>\n  p {\n    width: 100px;\n    margin: 0 auto;\n    background-color: skyblue;\n\n    /*1. 先强制一行内显示文本，默认 normal 自动换行*/\n    white-space: nowrap;\n    /*2. 超出的部分隐藏*/\n    overflow: hidden;\n    /*3. 文字用省略号替代超出的部分*/\n    text-overflow: ellipsis;\n  }\n</style>\n<p>\n  哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落\n</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n<html>\n    <div class="demo3">\n        <p>\n            哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落\n        </p>\n    </div>\n</html>\n\n<style>\n    .demo3 p {\n        width: 100px;\n        margin: 0 auto;\n        background-color: skyblue;\n\n        /*1. 先强制一行内显示文本，默认 normal 自动换行*/\n        white-space: nowrap;\n        /*2. 超出的部分隐藏*/\n        overflow: hidden;\n        /*3. 文字用省略号替代超出的部分*/\n        text-overflow: ellipsis;\n    }\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n\n# 多行文本溢出显示省略号\n\n多行文本溢出显示省略号，有较大兼容性问题\n\n<style>\n  p {\n    width: 100px;\n    /* 不能指定高度，否则虽然第二行末尾省略号显示，但是之后的行还是会显示所有文字 */\n    margin: 0 auto;\n    background-color: skyblue;\n\n    /* 1. 弹性伸缩盒子模型显示 */\n    display: -webkit-box;\n    /* 2. 超出的部分隐藏*/\n    overflow: hidden;\n    /* 3. 文字用省略号替代超出的部分*/\n    text-overflow: ellipsis;\n    /* 4. 限制在一个块元素显示的文本的行数 */\n    -webkit-line-clamp: 2;\n    /* 5. 设置或检索伸缩盒对象的子元素的排列方式 */\n    -webkit-box-orient: vertical;\n  }\n</style>\n<p>\n  哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落\n</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n<html>\n    <div class="demo4">\n        <p>\n            哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落哈哈哈哈哈段落\n        </p>\n    </div>\n\n</html>\n<style>\n    .demo4 p {\n        width: 100px;\n        /* 不能指定高度，否则虽然第二行末尾省略号显示，但是之后的行还是会显示所有文字 */\n        margin: 0 auto;\n        background-color: skyblue;\n\n        /* 1. 弹性伸缩盒子模型显示 */\n        display: -webkit-box;\n        /* 2. 超出的部分隐藏*/\n        overflow: hidden;\n        /* 3. 文字用省略号替代超出的部分*/\n        text-overflow: ellipsis;\n        /* 4. 限制在一个块元素显示的文本的行数 */\n        -webkit-line-clamp: 2;\n        /* 5. 设置或检索伸缩盒对象的子元素的排列方式 */\n        -webkit-box-orient: vertical;\n    }\n</style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n更推荐让后台人员来做这个效果，因为后台人员可以设置显示多少个字，操作更简单。\n\n\n# cursor 光标 🔥\n\n * auto ：默认，浏览器设置的光标\n * default：默认为小白箭头\n * pointer：指示链接的手型，常用\n * text：文本\n * move：四方箭头\n * not-allowed：禁止\n * wait：沙漏、转圈、表\n * help：箭头带问号\n * crosshair：十字架\n * url：自定义光标的 url\n * none：没有任何显示\n\n\n# resize 防止拖拽\n\n防止拖拽 textarea（textarea 标签放在同一行即可没有类似 padding 的空白距离）\n\n * none：禁止拖拽，右下角那个功能也就没有了\n\n\n# 浏览器私有前缀\n\n模块化打包工具如 webpack 会自动添加前缀，不使用则需要自己查看文档添加',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"动画",frontmatter:{title:"动画",date:"2020-03-23T00:14:49.000Z",permalink:"/pages/528b1e/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/200.CSS%E5%9F%BA%E7%A1%80/301.CSS-3%E5%8A%A8%E7%94%BB.html",relativePath:"1100.H5&CSS3/200.CSS基础/301.CSS-3动画.md",key:"v-a45689ae",path:"/pages/528b1e/",headers:[{level:2,title:"transform-origin形变原点 🔥",slug:"transform-origin形变原点-🔥",normalizedTitle:"transform-origin形变原点 🔥",charIndex:75},{level:2,title:"transform 形变 🔥",slug:"transform-形变-🔥",normalizedTitle:"transform 形变 🔥",charIndex:318},{level:3,title:"translate(tx,ty)平移",slug:"translate-tx-ty-平移",normalizedTitle:"translate(tx,ty)平移",charIndex:427},{level:3,title:"translate3D(tx,ty,tz)3D 平移",slug:"translate3d-tx-ty-tz-3d-平移",normalizedTitle:"translate3d(tx,ty,tz)3d 平移",charIndex:594},{level:3,title:"scale(sx,sy)缩放",slug:"scale-sx-sy-缩放",normalizedTitle:"scale(sx,sy)缩放",charIndex:737},{level:3,title:"scale3d(sx,sy,sz)3D 缩放",slug:"scale3d-sx-sy-sz-3d-缩放",normalizedTitle:"scale3d(sx,sy,sz)3d 缩放",charIndex:905},{level:3,title:"rotate(deg)旋转",slug:"rotate-deg-旋转",normalizedTitle:"rotate(deg)旋转",charIndex:1028},{level:3,title:"rotate3d(x,y,z,deg)3D 旋转",slug:"rotate3d-x-y-z-deg-3d-旋转",normalizedTitle:"rotate3d(x,y,z,deg)3d 旋转",charIndex:2700},{level:3,title:"skew(deg,deg)倾斜",slug:"skew-deg-deg-倾斜",normalizedTitle:"skew(deg,deg)倾斜",charIndex:2799},{level:3,title:"backface-visibility元素背面",slug:"backface-visibility元素背面",normalizedTitle:"backface-visibility元素背面",charIndex:2990},{level:2,title:"transition 过渡动画 🔥",slug:"transition-过渡动画-🔥",normalizedTitle:"transition 过渡动画 🔥",charIndex:3055},{level:2,title:"@keyframes & animation 动画 🔥",slug:"keyframes-animation-动画-🔥",normalizedTitle:"@keyframes &amp; animation 动画 🔥",charIndex:null},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:4323},{level:3,title:"案例 1—移动的方块",slug:"案例-1-移动的方块",normalizedTitle:"案例 1—移动的方块",charIndex:5360},{level:3,title:"案例 2—9 个小球",slug:"案例-2-9-个小球",normalizedTitle:"案例 2—9 个小球",charIndex:5995},{level:3,title:"骰子",slug:"骰子",normalizedTitle:"骰子",charIndex:7614},{level:2,title:"perspective & preserve-3d 动画 🔥",slug:"perspective-preserve-3d-动画-🔥",normalizedTitle:"perspective &amp; preserve-3d 动画 🔥",charIndex:null},{level:2,title:"filter 滤镜 🔥",slug:"filter-滤镜-🔥",normalizedTitle:"filter 滤镜 🔥",charIndex:12269}],headersStr:"transform-origin形变原点 🔥 transform 形变 🔥 translate(tx,ty)平移 translate3D(tx,ty,tz)3D 平移 scale(sx,sy)缩放 scale3d(sx,sy,sz)3D 缩放 rotate(deg)旋转 rotate3d(x,y,z,deg)3D 旋转 skew(deg,deg)倾斜 backface-visibility元素背面 transition 过渡动画 🔥 @keyframes & animation 动画 🔥 简介 案例 1—移动的方块 案例 2—9 个小球 骰子 perspective & preserve-3d 动画 🔥 filter 滤镜 🔥",content:'# 动画\n\n并不存在真正意义上的 CSS3，只是对某些 Module Level 3 的统称，某些 Level 3 是否成为标准还需查阅文档\n\n\n# transform-origin形变原点 🔥\n\ntransform-origin属性让你更改一个元素变形的原点。默认值：50% 50% 0\n\n * 一个值\n   \n   设置 x 轴的原点\n\n * 两个值\n   \n   设置 x 轴和 y 轴的原点\n\n * 值可以是\n   \n   * <length>：从左上角开始计算\n   * <percentage>：参考元素本身的大小\n   * left, right, center, top, bottom关键字中的两个（常用）\n\n\n# transform 形变 🔥\n\ntransform属性允许你平移，旋转，缩放，倾斜指定元素。这是通过修改 CSS 视觉格式化模型的坐标空间来实现的。可使用多个function，空格分割即可。不影响页面布局！\n\n\n# translate(tx,ty)平移\n\n * translate(tx, ty)或translate(tx)。第二个参数不写默认为 0\n * 可以简写为translateX(tx)或translateY(ty)\n * 单位\n   * 可以是px；\n   * %（相对于元素自己宽度或高度）\n\n用处：\n\n * hover时平移\n\n\n# translate3D(tx,ty,tz)3D 平移\n\n * 配合 3D 动画，且需要设置网页的视距\n\n * tz为 0 时可以认为就是translate(tx,ty)\n\n * 可以简写为translateX(tx)或translateY(ty)或translateZ(tz)\n\n\n# scale(sx,sy)缩放\n\n * scale(sx,sy)或scale(sx)。第二个参数不写默认为sx以保持等比缩放\n * 可以简写为scaleX(sx)或scaleY(sy)\n * 数字\n   * 1：保持不变\n   * 2：放大一倍\n   * 0.5：缩小一半\n * 不支持百分比\n\n用处：\n\n * hover时缩放\n\n\n# scale3d(sx,sy,sz)3D 缩放\n\n * 配合 3D 动画，且需要设置网页的视距\n\n * sz为 1 时可以认为就是scale(sx,sy)\n\n * 可以简写为scaleX(sx)或scaleY(sy)或scaleZ(sz)\n\n\n# rotate(deg)旋转\n\n * 一个值\n   \n   表示旋转的角度\n\n * 值类型 deg\n   \n   旋转的角度，正数为顺时针，负数为逆时针\n   \n   * shan\n\n * 旋转的原点受transform-origin影响。默认按照 z 轴的和元素中心\n\n * 可以简写为rotateX(rx)或rotateY(ry)或rotateZ(rz)\n\n用处：\n\n * hover时卡片背面\n * 钟表 🕙\n\n<html>\n  <div class="clock">\n    <div class="hour"></div>\n    <div class="min"></div>\n    <div class="sec"></div>\n  </div>\n</html>\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n  }\n\n  /* 设置表的样式 */\n  .clock {\n    width: 500px;\n    height: 500px;\n    margin: 0 auto;\n    margin-top: 100px;\n    border-radius: 50%;\n    position: relative;\n    background-image: url(./img/13/bg3.jpg);\n    background-size: cover;\n  }\n\n  .clock > div {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n  }\n\n  .hour {\n    margin: 16% auto;\n    height: 34%;\n    width: 7px;\n    background-color: skyblue;\n    transform-origin: bottom center;\n    animation: run 8640s steps(60) infinite; /*秒数除以10方便观察*/\n  }\n\n  .min {\n    margin: 13% auto;\n    height: 37%;\n    width: 5px;\n    background-color: green;\n    transform-origin: bottom center;\n    animation: run 360s steps(60) infinite; /*秒数除以10方便观察*/\n  }\n\n  .sec {\n    margin: 10% auto;\n    height: 40%;\n    width: 2px;\n    background-color: red;\n    transform-origin: bottom center;\n    animation: run 6s steps(60) infinite; /*秒数除以10方便观察*/\n  }\n\n  @keyframes run {\n    from {\n      transform: rotateZ(0);\n    }\n\n    to {\n      transform: rotateZ(360deg);\n    }\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n\n# rotate3d(x,y,z,deg)3D 旋转\n\n * 配合 3D 动画，且需要设置网页的视距\n\n * x,y都是 0 且z是 1 时可以认为就是rotate(deg)按照 z 轴旋转。\n\n\n# skew(deg,deg)倾斜\n\n可能会形变，旋转并不会形变\n\n * 一个值\n   \n   表示 x 轴上的倾斜\n\n * 两个值\n   \n   表示 x 轴和 y 轴上的倾斜\n\n * 值类型 deg\n   \n   倾斜的角度，正数为顺时针，负数为逆时针\n\n * 旋转的原点受transform-origin影响\n\n * 可以简写为skewX(deg)或skewY(deg)\n\n\n# backface-visibility元素背面\n\n * visiable：默认为显示，透视效果\n\n * none：不显示\n\n\n# transition 过渡动画 🔥\n\n过渡 transition 是 CSS3 中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。虽然低版本浏览器不支持（IE9 以下版本）但是不影响页面布局。经常和 :hover 搭配使用。谁做过渡给谁加，控制多个元素可以在,后继续写，但不能写多个transition（MDN 文档中体现在#）。\n\n * 这个属性是用来进行过渡动画，只能控制首尾两个值。\n * 大部分属性都支持过渡效果，注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡（auto 就不是有效值）\n\ntransition: 要过渡的属性 持续时间 运动曲线 何时开始, 要过渡的属性 持续时间\n    运动曲线 何时开始;\n\n\n1\n2\n\n\n * property：要变化的 CSS 属性， 宽高、背景颜色、内外边距、形变都可以。如果想要所有的属性都变化过渡， 写 all 即可。\n\n * duration：持续时间，单位是秒（必须写单位），比如 .5 s\n\n * timing-function：过渡的时序函数，运动曲线，默认是 ease（可以省略）\n   \n   值                                      描述\n   linear                                 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。\n   ease                                   规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。\n   ease-in                                规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。\n   ease-out                               规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。\n   ease-in-out                            规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。\n   cubic-bezier(n,n,n,n)                  在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。\n   steps(number_of_steps [, direction])   分步执行过渡效果，可以对多帧图片使用，模拟动画\n\n * delay：过渡效果的延迟，等待一段时间后在执行过渡，单位是秒（必须写单位），默认是 0s（可以省略）\n\n\n# @keyframes & animation 动画 🔥\n\n\n# 简介\n\n使用transition只能进行过渡动画，且只能控制首尾两个值。\n\n * 从关键帧动画的角度相当于只是定义了两帧的状态：第一帧和最后一帧\n * 如果希望可以有更多状态的变化，可以直接使用关键帧动画\n\n关键帧动画使用@keyframes 来定义多个变化状态，并且使用animation-name来声明匹配\n\n 1. 使用@keyframes创建一个规则，@keyframes中使用百分比定义各个阶段的样式。\n    \n    可以用from和to指定 0%和 100%\n\n 2. 通过animation将动画添加到属性上，具体取值如下：\n    \n    animation: name duration timing-function delay iteration-count direction\n      fill-mode;\n    \n    \n    1\n    2\n    \n\n * name：要使用的@keyframes的 identifier。必填\n\n * duration：动画持续的时间，默认值为0s。必填\n\n * timing-function：指定动画的变化曲线，默认值为ease\n\n * delay：延迟执行时间，默认值为0s\n\n * iteration-count：指定动画的执行次数，默认值为 1。值为infinite表示无限执行\n\n * direction：指定方向\n   \n   * normal 默认值 从 from 向 to 运行 每次都是这样\n   * reverse 从 to 向 from 运行 每次都是这样\n   * alternate 从 from 向 to 运行 重复执行动画时反向执行\n   * alternate-reverse 从 to 向 from 运行 重复执行动画时反向执行\n\n * fill-mode：执行动画最后保留哪一个值\n   \n   * none：默认值，动画执行完毕元素回到原来位置\n   * forwards：动画执行完毕元素会停止在动画结束（最后一帧）的位置\n   * backwards：动画延时等待时，元素就会处于开始（第一帧）位置\n   * both：结合了 forwards 和 backwards\n\n * play-state：用在 JS 中，指定动画的运行或暂停！\n   \n   * running：默认值，当前动画正在运行\n   * paused：当前动画以被停止\n\n\n# 案例 1—移动的方块\n\n<style>\n  @keyframes box-frame-1 {\n    from {\n      transform: translate3d(0, 0, 0);\n    }\n    25% {\n      transform: translate3d(200px, 0, 0);\n    }\n    50% {\n      transform: translate3d(200px, 100px, 0);\n    }\n    75% {\n      transform: translate3d(0, 100px, 0);\n    }\n    to {\n      transform: translate3d(0, 0, 0);\n    }\n  }\n\n  .move-box {\n    width: 100px;\n    height: 100px;\n    background-color: skyblue;\n  }\n\n  .move-box:hover {\n    animation: box-frame-1 4s;\n  }\n</style>\n<html>\n  <div class="move-box"></div>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n# 案例 2—9 个小球\n\n<style>\n  .outer {\n    height: 500px;\n    border-bottom: 10px black solid;\n    margin: 50px auto;\n    /* 解决margin重叠问题 */\n    overflow: hidden;\n  }\n  .outer div {\n    float: left;\n    width: 100px;\n    height: 100px;\n    border-radius: 50%;\n    background-color: #bfa;\n    animation: ball 0.5s forwards ease-in-out infinite alternate;\n  }\n\n  div.box2 {\n    background-color: orange;\n    animation-delay: 0.1s;\n  }\n\n  div.box3 {\n    background-color: yellow;\n    animation-delay: 0.2s;\n  }\n\n  div.box4 {\n    background-color: yellowgreen;\n    animation-delay: 0.3s;\n  }\n\n  div.box5 {\n    background-color: blue;\n    animation-delay: 0.4s;\n  }\n  div.box6 {\n    background-color: pink;\n    animation-delay: 0.5s;\n  }\n  div.box7 {\n    background-color: tomato;\n    animation-delay: 0.6s;\n  }\n  div.box8 {\n    background-color: skyblue;\n    animation-delay: 0.7s;\n  }\n  div.box9 {\n    background-color: chocolate;\n    animation-delay: 0.8s;\n  }\n\n  /* 创建小球下落的动画 */\n  @keyframes ball {\n    from {\n      margin-top: 0;\n    }\n\n    to {\n      margin-top: 400px;\n    }\n  }\n</style>\n<html>\n  <div class="outer">\n    <div class="box1"></div>\n    <div class="box2"></div>\n    <div class="box3"></div>\n    <div class="box4"></div>\n    <div class="box5"></div>\n    <div class="box6"></div>\n    <div class="box7"></div>\n    <div class="box8"></div>\n    <div class="box9"></div>\n  </div>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n\n# 骰子\n\n<style>\n  html {\n    perspective: 800px;\n  }\n\n  .cube {\n    width: 200px;\n    height: 200px;\n    /* background-color: #bfa; */\n    margin: 100px auto;\n    /* 设置3d变形效果 */\n    transform-style: preserve-3d;\n    /* transform: rotateX(45deg) rotateZ(45deg); */\n    animation: rotate 20s infinite linear;\n    /* transform:rotateY(45deg) scaleZ(2); */\n  }\n\n  .cube > div {\n    width: 200px;\n    height: 200px;\n    /* 为元素设置透明效果 */\n    opacity: 0.7;\n    position: absolute;\n  }\n\n  img {\n    vertical-align: top;\n  }\n\n  .box1 {\n    /* 虽然看似都是translateZ(100px)，但是这是根据rotate后的面来说的 */\n    transform: rotateY(90deg) translateZ(100px);\n  }\n\n  .box2 {\n    transform: rotateY(-90deg) translateZ(100px);\n  }\n\n  .box3 {\n    transform: rotateX(90deg) translateZ(100px);\n  }\n\n  .box4 {\n    transform: rotateX(-90deg) translateZ(100px);\n  }\n\n  .box5 {\n    transform: rotateY(180deg) translateZ(100px);\n  }\n\n  .box6 {\n    transform: rotateY(0deg) translateZ(100px);\n  }\n\n  @keyframes rotate {\n    form {\n      transform: rotateX(0) rotateZ(0);\n    }\n\n    to {\n      transform: rotateX(1turn) rotateZ(1turn);\n    }\n  }\n</style>\n\x3c!-- 创建一个外部的容器 --\x3e\n<div class="cube">\n  \x3c!-- 引入图片 --\x3e\n  <div class="box1">\n    <img src="./img/14/1.jpg" />\n  </div>\n\n  <div class="box2">\n    <img src="./img/14/2.jpg" />\n  </div>\n\n  <div class="box3">\n    <img src="./img/14/3.jpg" />\n  </div>\n\n  <div class="box4">\n    <img src="./img/14/4.jpg" />\n  </div>\n\n  <div class="box5">\n    <img src="./img/14/5.jpg" />\n  </div>\n\n  <div class="box6">\n    <img src="./img/14/6.jpg" />\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n\n# perspective & preserve-3d 动画 🔥\n\n前端东西很多对 IE 有兼容性问题，自己查文档，懒得逼逼\n\n * CSS 3D 动画：\n   \n   * perspective：视距！一般给父元素设置即可继承\n   * transform-style: preserve-3d：若使用transform时体现 3D 效果，则需要此属性\n   \n   <style>\n     body {\n       /* 视距，指元素距离屏幕的距离 */\n       perspective: 1000px;\n     }\n     .container {\n       position: relative;\n       width: 200px;\n       height: 200px;\n       margin: 100px auto;\n     }\n     .container .box {\n       position: absolute;\n       width: 200px;\n       height: 200px;\n       /* 意思为保持 3D 效果 */\n       transform-style: preserve-3d;\n     }\n     .container .box1 {\n       background-color: skyblue;\n       transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, -100px);\n     }\n     .container .box2 {\n       background-color: orange;\n       transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, 0);\n     }\n     .container .box3 {\n       background-color: blue;\n       transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, 100px);\n     }\n   </style>\n   <div class="container">\n     <div class="box box1"></div>\n     <div class="box box2"></div>\n     <div class="box box3"></div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   \n   \n   <html>\n       <div class="perspective">\n           <div class="container">\n               <div class="box box1"></div>\n               <div class="box box2"></div>\n               <div class="box box3"></div>\n           </div>\n       </div>\n   \n   </html>\n   \n   <style>\n       .perspective {\n           /* 视距，指元素距离屏幕的距离 */\n           perspective: 1000px;\n       }\n       .perspective .container {\n           position: relative;\n           width: 200px;\n           height: 200px;\n           margin: 100px auto;\n       }\n       .perspective .container .box {\n           position: absolute;\n           width: 200px;\n           height: 200px;\n           /* 意思为保持 3D 效果 */\n           transform-style: preserve-3d;\n       }\n       .perspective .container .box1 {\n           background-color: skyblue;\n           transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, -100px);\n       }\n       .perspective .container .box2 {\n           background-color: orange;\n           transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, 0);\n       }\n       .perspective .container .box3 {\n           background-color: blue;\n           transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, 100px);\n       }\n   </style>\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   \n   \n\n * JS 3D 动画库（兼容性好）：\n   \n   * three.js\n\n\n# filter 滤镜 🔥\n\nfilter属性将模糊或颜色偏移等图形效果应用于元素。\n\nfilter: 函数();\n\n\n1\n\n * blur 模糊处理，数值越大越模糊，如blur(5px)',normalizedContent:'# 动画\n\n并不存在真正意义上的 css3，只是对某些 module level 3 的统称，某些 level 3 是否成为标准还需查阅文档\n\n\n# transform-origin形变原点 🔥\n\ntransform-origin属性让你更改一个元素变形的原点。默认值：50% 50% 0\n\n * 一个值\n   \n   设置 x 轴的原点\n\n * 两个值\n   \n   设置 x 轴和 y 轴的原点\n\n * 值可以是\n   \n   * <length>：从左上角开始计算\n   * <percentage>：参考元素本身的大小\n   * left, right, center, top, bottom关键字中的两个（常用）\n\n\n# transform 形变 🔥\n\ntransform属性允许你平移，旋转，缩放，倾斜指定元素。这是通过修改 css 视觉格式化模型的坐标空间来实现的。可使用多个function，空格分割即可。不影响页面布局！\n\n\n# translate(tx,ty)平移\n\n * translate(tx, ty)或translate(tx)。第二个参数不写默认为 0\n * 可以简写为translatex(tx)或translatey(ty)\n * 单位\n   * 可以是px；\n   * %（相对于元素自己宽度或高度）\n\n用处：\n\n * hover时平移\n\n\n# translate3d(tx,ty,tz)3d 平移\n\n * 配合 3d 动画，且需要设置网页的视距\n\n * tz为 0 时可以认为就是translate(tx,ty)\n\n * 可以简写为translatex(tx)或translatey(ty)或translatez(tz)\n\n\n# scale(sx,sy)缩放\n\n * scale(sx,sy)或scale(sx)。第二个参数不写默认为sx以保持等比缩放\n * 可以简写为scalex(sx)或scaley(sy)\n * 数字\n   * 1：保持不变\n   * 2：放大一倍\n   * 0.5：缩小一半\n * 不支持百分比\n\n用处：\n\n * hover时缩放\n\n\n# scale3d(sx,sy,sz)3d 缩放\n\n * 配合 3d 动画，且需要设置网页的视距\n\n * sz为 1 时可以认为就是scale(sx,sy)\n\n * 可以简写为scalex(sx)或scaley(sy)或scalez(sz)\n\n\n# rotate(deg)旋转\n\n * 一个值\n   \n   表示旋转的角度\n\n * 值类型 deg\n   \n   旋转的角度，正数为顺时针，负数为逆时针\n   \n   * shan\n\n * 旋转的原点受transform-origin影响。默认按照 z 轴的和元素中心\n\n * 可以简写为rotatex(rx)或rotatey(ry)或rotatez(rz)\n\n用处：\n\n * hover时卡片背面\n * 钟表 🕙\n\n<html>\n  <div class="clock">\n    <div class="hour"></div>\n    <div class="min"></div>\n    <div class="sec"></div>\n  </div>\n</html>\n<style>\n  * {\n    margin: 0;\n    padding: 0;\n    box-sizing: border-box;\n  }\n\n  /* 设置表的样式 */\n  .clock {\n    width: 500px;\n    height: 500px;\n    margin: 0 auto;\n    margin-top: 100px;\n    border-radius: 50%;\n    position: relative;\n    background-image: url(./img/13/bg3.jpg);\n    background-size: cover;\n  }\n\n  .clock > div {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    right: 0;\n  }\n\n  .hour {\n    margin: 16% auto;\n    height: 34%;\n    width: 7px;\n    background-color: skyblue;\n    transform-origin: bottom center;\n    animation: run 8640s steps(60) infinite; /*秒数除以10方便观察*/\n  }\n\n  .min {\n    margin: 13% auto;\n    height: 37%;\n    width: 5px;\n    background-color: green;\n    transform-origin: bottom center;\n    animation: run 360s steps(60) infinite; /*秒数除以10方便观察*/\n  }\n\n  .sec {\n    margin: 10% auto;\n    height: 40%;\n    width: 2px;\n    background-color: red;\n    transform-origin: bottom center;\n    animation: run 6s steps(60) infinite; /*秒数除以10方便观察*/\n  }\n\n  @keyframes run {\n    from {\n      transform: rotatez(0);\n    }\n\n    to {\n      transform: rotatez(360deg);\n    }\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\n\n\n# rotate3d(x,y,z,deg)3d 旋转\n\n * 配合 3d 动画，且需要设置网页的视距\n\n * x,y都是 0 且z是 1 时可以认为就是rotate(deg)按照 z 轴旋转。\n\n\n# skew(deg,deg)倾斜\n\n可能会形变，旋转并不会形变\n\n * 一个值\n   \n   表示 x 轴上的倾斜\n\n * 两个值\n   \n   表示 x 轴和 y 轴上的倾斜\n\n * 值类型 deg\n   \n   倾斜的角度，正数为顺时针，负数为逆时针\n\n * 旋转的原点受transform-origin影响\n\n * 可以简写为skewx(deg)或skewy(deg)\n\n\n# backface-visibility元素背面\n\n * visiable：默认为显示，透视效果\n\n * none：不显示\n\n\n# transition 过渡动画 🔥\n\n过渡 transition 是 css3 中具有颠覆性的特征之一，我们可以在不使用 flash 动画或 javascript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。虽然低版本浏览器不支持（ie9 以下版本）但是不影响页面布局。经常和 :hover 搭配使用。谁做过渡给谁加，控制多个元素可以在,后继续写，但不能写多个transition（mdn 文档中体现在#）。\n\n * 这个属性是用来进行过渡动画，只能控制首尾两个值。\n * 大部分属性都支持过渡效果，注意过渡时必须是从一个有效数值向另外一个有效数值进行过渡（auto 就不是有效值）\n\ntransition: 要过渡的属性 持续时间 运动曲线 何时开始, 要过渡的属性 持续时间\n    运动曲线 何时开始;\n\n\n1\n2\n\n\n * property：要变化的 css 属性， 宽高、背景颜色、内外边距、形变都可以。如果想要所有的属性都变化过渡， 写 all 即可。\n\n * duration：持续时间，单位是秒（必须写单位），比如 .5 s\n\n * timing-function：过渡的时序函数，运动曲线，默认是 ease（可以省略）\n   \n   值                                      描述\n   linear                                 规定以相同速度开始至结束的过渡效果（等于 cubic-bezier(0,0,1,1)）。\n   ease                                   规定慢速开始，然后变快，然后慢速结束的过渡效果（cubic-bezier(0.25,0.1,0.25,1)）。\n   ease-in                                规定以慢速开始的过渡效果（等于 cubic-bezier(0.42,0,1,1)）。\n   ease-out                               规定以慢速结束的过渡效果（等于 cubic-bezier(0,0,0.58,1)）。\n   ease-in-out                            规定以慢速开始和结束的过渡效果（等于 cubic-bezier(0.42,0,0.58,1)）。\n   cubic-bezier(n,n,n,n)                  在 cubic-bezier 函数中定义自己的值。可能的值是 0 至 1 之间的数值。\n   steps(number_of_steps [, direction])   分步执行过渡效果，可以对多帧图片使用，模拟动画\n\n * delay：过渡效果的延迟，等待一段时间后在执行过渡，单位是秒（必须写单位），默认是 0s（可以省略）\n\n\n# @keyframes & animation 动画 🔥\n\n\n# 简介\n\n使用transition只能进行过渡动画，且只能控制首尾两个值。\n\n * 从关键帧动画的角度相当于只是定义了两帧的状态：第一帧和最后一帧\n * 如果希望可以有更多状态的变化，可以直接使用关键帧动画\n\n关键帧动画使用@keyframes 来定义多个变化状态，并且使用animation-name来声明匹配\n\n 1. 使用@keyframes创建一个规则，@keyframes中使用百分比定义各个阶段的样式。\n    \n    可以用from和to指定 0%和 100%\n\n 2. 通过animation将动画添加到属性上，具体取值如下：\n    \n    animation: name duration timing-function delay iteration-count direction\n      fill-mode;\n    \n    \n    1\n    2\n    \n\n * name：要使用的@keyframes的 identifier。必填\n\n * duration：动画持续的时间，默认值为0s。必填\n\n * timing-function：指定动画的变化曲线，默认值为ease\n\n * delay：延迟执行时间，默认值为0s\n\n * iteration-count：指定动画的执行次数，默认值为 1。值为infinite表示无限执行\n\n * direction：指定方向\n   \n   * normal 默认值 从 from 向 to 运行 每次都是这样\n   * reverse 从 to 向 from 运行 每次都是这样\n   * alternate 从 from 向 to 运行 重复执行动画时反向执行\n   * alternate-reverse 从 to 向 from 运行 重复执行动画时反向执行\n\n * fill-mode：执行动画最后保留哪一个值\n   \n   * none：默认值，动画执行完毕元素回到原来位置\n   * forwards：动画执行完毕元素会停止在动画结束（最后一帧）的位置\n   * backwards：动画延时等待时，元素就会处于开始（第一帧）位置\n   * both：结合了 forwards 和 backwards\n\n * play-state：用在 js 中，指定动画的运行或暂停！\n   \n   * running：默认值，当前动画正在运行\n   * paused：当前动画以被停止\n\n\n# 案例 1—移动的方块\n\n<style>\n  @keyframes box-frame-1 {\n    from {\n      transform: translate3d(0, 0, 0);\n    }\n    25% {\n      transform: translate3d(200px, 0, 0);\n    }\n    50% {\n      transform: translate3d(200px, 100px, 0);\n    }\n    75% {\n      transform: translate3d(0, 100px, 0);\n    }\n    to {\n      transform: translate3d(0, 0, 0);\n    }\n  }\n\n  .move-box {\n    width: 100px;\n    height: 100px;\n    background-color: skyblue;\n  }\n\n  .move-box:hover {\n    animation: box-frame-1 4s;\n  }\n</style>\n<html>\n  <div class="move-box"></div>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n\n# 案例 2—9 个小球\n\n<style>\n  .outer {\n    height: 500px;\n    border-bottom: 10px black solid;\n    margin: 50px auto;\n    /* 解决margin重叠问题 */\n    overflow: hidden;\n  }\n  .outer div {\n    float: left;\n    width: 100px;\n    height: 100px;\n    border-radius: 50%;\n    background-color: #bfa;\n    animation: ball 0.5s forwards ease-in-out infinite alternate;\n  }\n\n  div.box2 {\n    background-color: orange;\n    animation-delay: 0.1s;\n  }\n\n  div.box3 {\n    background-color: yellow;\n    animation-delay: 0.2s;\n  }\n\n  div.box4 {\n    background-color: yellowgreen;\n    animation-delay: 0.3s;\n  }\n\n  div.box5 {\n    background-color: blue;\n    animation-delay: 0.4s;\n  }\n  div.box6 {\n    background-color: pink;\n    animation-delay: 0.5s;\n  }\n  div.box7 {\n    background-color: tomato;\n    animation-delay: 0.6s;\n  }\n  div.box8 {\n    background-color: skyblue;\n    animation-delay: 0.7s;\n  }\n  div.box9 {\n    background-color: chocolate;\n    animation-delay: 0.8s;\n  }\n\n  /* 创建小球下落的动画 */\n  @keyframes ball {\n    from {\n      margin-top: 0;\n    }\n\n    to {\n      margin-top: 400px;\n    }\n  }\n</style>\n<html>\n  <div class="outer">\n    <div class="box1"></div>\n    <div class="box2"></div>\n    <div class="box3"></div>\n    <div class="box4"></div>\n    <div class="box5"></div>\n    <div class="box6"></div>\n    <div class="box7"></div>\n    <div class="box8"></div>\n    <div class="box9"></div>\n  </div>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n\n\n\n\n# 骰子\n\n<style>\n  html {\n    perspective: 800px;\n  }\n\n  .cube {\n    width: 200px;\n    height: 200px;\n    /* background-color: #bfa; */\n    margin: 100px auto;\n    /* 设置3d变形效果 */\n    transform-style: preserve-3d;\n    /* transform: rotatex(45deg) rotatez(45deg); */\n    animation: rotate 20s infinite linear;\n    /* transform:rotatey(45deg) scalez(2); */\n  }\n\n  .cube > div {\n    width: 200px;\n    height: 200px;\n    /* 为元素设置透明效果 */\n    opacity: 0.7;\n    position: absolute;\n  }\n\n  img {\n    vertical-align: top;\n  }\n\n  .box1 {\n    /* 虽然看似都是translatez(100px)，但是这是根据rotate后的面来说的 */\n    transform: rotatey(90deg) translatez(100px);\n  }\n\n  .box2 {\n    transform: rotatey(-90deg) translatez(100px);\n  }\n\n  .box3 {\n    transform: rotatex(90deg) translatez(100px);\n  }\n\n  .box4 {\n    transform: rotatex(-90deg) translatez(100px);\n  }\n\n  .box5 {\n    transform: rotatey(180deg) translatez(100px);\n  }\n\n  .box6 {\n    transform: rotatey(0deg) translatez(100px);\n  }\n\n  @keyframes rotate {\n    form {\n      transform: rotatex(0) rotatez(0);\n    }\n\n    to {\n      transform: rotatex(1turn) rotatez(1turn);\n    }\n  }\n</style>\n\x3c!-- 创建一个外部的容器 --\x3e\n<div class="cube">\n  \x3c!-- 引入图片 --\x3e\n  <div class="box1">\n    <img src="./img/14/1.jpg" />\n  </div>\n\n  <div class="box2">\n    <img src="./img/14/2.jpg" />\n  </div>\n\n  <div class="box3">\n    <img src="./img/14/3.jpg" />\n  </div>\n\n  <div class="box4">\n    <img src="./img/14/4.jpg" />\n  </div>\n\n  <div class="box5">\n    <img src="./img/14/5.jpg" />\n  </div>\n\n  <div class="box6">\n    <img src="./img/14/6.jpg" />\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n\n# perspective & preserve-3d 动画 🔥\n\n前端东西很多对 ie 有兼容性问题，自己查文档，懒得逼逼\n\n * css 3d 动画：\n   \n   * perspective：视距！一般给父元素设置即可继承\n   * transform-style: preserve-3d：若使用transform时体现 3d 效果，则需要此属性\n   \n   <style>\n     body {\n       /* 视距，指元素距离屏幕的距离 */\n       perspective: 1000px;\n     }\n     .container {\n       position: relative;\n       width: 200px;\n       height: 200px;\n       margin: 100px auto;\n     }\n     .container .box {\n       position: absolute;\n       width: 200px;\n       height: 200px;\n       /* 意思为保持 3d 效果 */\n       transform-style: preserve-3d;\n     }\n     .container .box1 {\n       background-color: skyblue;\n       transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, -100px);\n     }\n     .container .box2 {\n       background-color: orange;\n       transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, 0);\n     }\n     .container .box3 {\n       background-color: blue;\n       transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, 100px);\n     }\n   </style>\n   <div class="container">\n     <div class="box box1"></div>\n     <div class="box box2"></div>\n     <div class="box box3"></div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   \n   \n   <html>\n       <div class="perspective">\n           <div class="container">\n               <div class="box box1"></div>\n               <div class="box box2"></div>\n               <div class="box box3"></div>\n           </div>\n       </div>\n   \n   </html>\n   \n   <style>\n       .perspective {\n           /* 视距，指元素距离屏幕的距离 */\n           perspective: 1000px;\n       }\n       .perspective .container {\n           position: relative;\n           width: 200px;\n           height: 200px;\n           margin: 100px auto;\n       }\n       .perspective .container .box {\n           position: absolute;\n           width: 200px;\n           height: 200px;\n           /* 意思为保持 3d 效果 */\n           transform-style: preserve-3d;\n       }\n       .perspective .container .box1 {\n           background-color: skyblue;\n           transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, -100px);\n       }\n       .perspective .container .box2 {\n           background-color: orange;\n           transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, 0);\n       }\n       .perspective .container .box3 {\n           background-color: blue;\n           transform: rotate3d(0, 1, 0, 75deg) translate3d(0, 0, 100px);\n       }\n   </style>\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   \n   \n\n * js 3d 动画库（兼容性好）：\n   \n   * three.js\n\n\n# filter 滤镜 🔥\n\nfilter属性将模糊或颜色偏移等图形效果应用于元素。\n\nfilter: 函数();\n\n\n1\n\n * blur 模糊处理，数值越大越模糊，如blur(5px)',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"Less",frontmatter:{title:"Less",date:"2020-04-09T00:53:52.000Z",permalink:"/pages/9aeeea/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/200.CSS%E5%9F%BA%E7%A1%80/401.CSS-8Less.html",relativePath:"1100.H5&CSS3/200.CSS基础/401.CSS-8Less.md",key:"v-1aa5a292",path:"/pages/9aeeea/",headersStr:null,content:"# Less\n\nless是一门css的预处理语言\n\n * less是一个css的增强版，通过less可以编写更少的代码实现更强大的样式\n * 在less中添加了许多的新特性：像对变量的支持、对mixin的支持... ...\n * less的语法大体上和css语法一致，但是less中增添了许多对css的扩展，所以浏览器无法直接执行less代码，要执行必须向将less转换为css，然后再由浏览器执行\n\nhtml{\n  /* css原生也支持变量的设置 */\n  --color:#ff0;\n  --length:200px;\n}\n\n.box1{\n  /* calc()计算函数 */\n  width: calc(200px*2);\n  height: var(--length);\n  background-color: var(--color);\n}\n\n.box2{\n  width: var(--length);\n  height: var(--length);\n  color: var(--color);\n}\n\n.box3{\n  width: var(--length);\n  height: var(--length);\n  border: 10px solid var(--color);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n使用 VSCode的 EasyLess插件可以将 Less 转换为 CSS文件，保存时自动生成！\n\n剩下的看文档吧！",normalizedContent:"# less\n\nless是一门css的预处理语言\n\n * less是一个css的增强版，通过less可以编写更少的代码实现更强大的样式\n * 在less中添加了许多的新特性：像对变量的支持、对mixin的支持... ...\n * less的语法大体上和css语法一致，但是less中增添了许多对css的扩展，所以浏览器无法直接执行less代码，要执行必须向将less转换为css，然后再由浏览器执行\n\nhtml{\n  /* css原生也支持变量的设置 */\n  --color:#ff0;\n  --length:200px;\n}\n\n.box1{\n  /* calc()计算函数 */\n  width: calc(200px*2);\n  height: var(--length);\n  background-color: var(--color);\n}\n\n.box2{\n  width: var(--length);\n  height: var(--length);\n  color: var(--color);\n}\n\n.box3{\n  width: var(--length);\n  height: var(--length);\n  border: 10px solid var(--color);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n使用 vscode的 easyless插件可以将 less 转换为 css文件，保存时自动生成！\n\n剩下的看文档吧！",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"盒子模型",frontmatter:{title:"盒子模型",date:"2020-03-14T17:10:27.000Z",permalink:"/pages/335968/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/300.CSS%E5%B8%83%E5%B1%80/301.CSS-%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.html",relativePath:"1100.H5&CSS3/300.CSS布局/301.CSS-盒子模型.md",key:"v-6cf68056",path:"/pages/335968/",headers:[{level:2,title:"box-sizing 盒子标准 🔥",slug:"box-sizing-盒子标准-🔥",normalizedTitle:"box-sizing 盒子标准 🔥",charIndex:163},{level:2,title:"Visual formatting model 细节 🔥",slug:"visual-formatting-model-细节-🔥",normalizedTitle:"visual formatting model 细节 🔥",charIndex:745},{level:3,title:"布局和包含块 🔥",slug:"布局和包含块-🔥",normalizedTitle:"布局和包含块 🔥",charIndex:779},{level:3,title:"Horizontal Formatting🔥",slug:"horizontal-formatting🔥",normalizedTitle:"horizontal formatting🔥",charIndex:1715},{level:2,title:"width 宽度",slug:"width-宽度",normalizedTitle:"width 宽度",charIndex:732},{level:2,title:"height 高度",slug:"height-高度",normalizedTitle:"height 高度",charIndex:4631},{level:2,title:"padding 内边距",slug:"padding-内边距",normalizedTitle:"padding 内边距",charIndex:4785},{level:2,title:"border 边框",slug:"border-边框",normalizedTitle:"border 边框",charIndex:5188},{level:3,title:"border 缩写 🔥",slug:"border-缩写-🔥",normalizedTitle:"border 缩写 🔥",charIndex:5202},{level:3,title:"border-width 宽度",slug:"border-width-宽度",normalizedTitle:"border-width 宽度",charIndex:5548},{level:3,title:"border-style 样式",slug:"border-style-样式",normalizedTitle:"border-style 样式",charIndex:5576},{level:3,title:"border-color 颜色",slug:"border-color-颜色",normalizedTitle:"border-color 颜色",charIndex:5688},{level:3,title:"利用border作图 🔥",slug:"利用border作图-🔥",normalizedTitle:"利用border作图 🔥",charIndex:5733},{level:3,title:"border-collapse 表格边框 🔥",slug:"border-collapse-表格边框-🔥",normalizedTitle:"border-collapse 表格边框 🔥",charIndex:8921},{level:3,title:"border-radius圆角边框 🔥",slug:"border-radius圆角边框-🔥",normalizedTitle:"border-radius圆角边框 🔥",charIndex:9086},{level:2,title:"outline轮廓线",slug:"outline轮廓线",normalizedTitle:"outline轮廓线",charIndex:9453},{level:2,title:"margin 外边距",slug:"margin-外边距",normalizedTitle:"margin 外边距",charIndex:9604},{level:3,title:"margin 缩写 🔥",slug:"margin-缩写-🔥",normalizedTitle:"margin 缩写 🔥",charIndex:9619},{level:3,title:"margin 负值 🔥",slug:"margin-负值-🔥",normalizedTitle:"margin 负值 🔥",charIndex:9907},{level:4,title:"问题 1",slug:"问题-1",normalizedTitle:"问题 1",charIndex:9923},{level:4,title:"问题 2",slug:"问题-2",normalizedTitle:"问题 2",charIndex:10140},{level:3,title:"块级盒子水平居中 🔥",slug:"块级盒子水平居中-🔥",normalizedTitle:"块级盒子水平居中 🔥",charIndex:10184},{level:3,title:"边界折叠问题 🔥",slug:"边界折叠问题-🔥",normalizedTitle:"边界折叠问题 🔥",charIndex:10561},{level:4,title:"兄弟元素",slug:"兄弟元素",normalizedTitle:"兄弟元素",charIndex:10689},{level:4,title:"父子元素",slug:"父子元素",normalizedTitle:"父子元素",charIndex:11351},{level:4,title:"空的块级元素",slug:"空的块级元素",normalizedTitle:"空的块级元素",charIndex:12539},{level:2,title:"box-shadow 盒子阴影 🔥",slug:"box-shadow-盒子阴影-🔥",normalizedTitle:"box-shadow 盒子阴影 🔥",charIndex:13178}],headersStr:"box-sizing 盒子标准 🔥 Visual formatting model 细节 🔥 布局和包含块 🔥 Horizontal Formatting🔥 width 宽度 height 高度 padding 内边距 border 边框 border 缩写 🔥 border-width 宽度 border-style 样式 border-color 颜色 利用border作图 🔥 border-collapse 表格边框 🔥 border-radius圆角边框 🔥 outline轮廓线 margin 外边距 margin 缩写 🔥 margin 负值 🔥 问题 1 问题 2 块级盒子水平居中 🔥 边界折叠问题 🔥 兄弟元素 父子元素 空的块级元素 box-shadow 盒子阴影 🔥",content:"# Box Model 盒子模型\n\n盒子模型：所有 HTML 元素可以看作盒子，盒子模型用来设计和布局时使用。CSS 盒模型本质上是一个盒子，封装周围的 HTML 元素，它包括：margin，border，padding 和 content。盒模型允许我们在其它元素和周围元素 border 之间的空间放置元素。\n\n\n\n\n# box-sizing 盒子标准 🔥\n\nCSS3 中可以通过 box-sizing 来指定盒模型，这样我们计算盒子大小的方式就发生了改变。有 2 个值：\n\n * content-box：即设置width和height仅针对content，最终盒子大小为 content + padding + border\n   \n   若盒子模型改为content-box且没有指定 width 或 height（即使子节点和父节点一样宽，也不要指定宽度，100%也不行），则给定 padding 不会改变盒子大小及 width 或 height（对应，没 width 则不改变 width，没 height 则不改变 height）\n   \n   但是 padding可以撑开盒子，我们可以做非常巧妙的运用。因为每个导航栏里面的字数不一样多，我们可以不用给每个盒子宽度了，直接给 padding 最合适，且 a 标签为行内元素，需转为行内块元素才能修改宽高\n\n * border-box：CSS3，即设置width和height针对 content + padding + border\n   \n   若盒子模型改为 border-box ， 那 padding 和 border 就不会撑大盒子了，前提 padding 和 border 不会超过 width 宽度\n\n\n# Visual formatting model 细节 🔥\n\n\n# 布局和包含块 🔥\n\n提示\n\n参考W3 文档， MDN 文档。\n\n一个元素大小的和位置经常受其包含块的影响。大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样。确定一个元素的包含块的过程完全依赖于这个元素的 position 属性：\n\n 1. 如果 position 属性为 static 或 relative ，包含块就是由它的最近的祖先块元素（比如说 inline-block, block 或 list-item 元素）或格式化上下文(比如说 a table container, flex container, grid container, or the block container itself)的内容区的边缘组成的。\n 2. 如果 position 属性为 absolute ，包含块就是由它的最近的 position 的值不是 static （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的内边距区的边缘组成。\n 3. 如果 position 属性是 fixed，在连续媒体的情况下(continuous media)包含块是 viewport ,在分页媒体(paged media)下的情况下包含块是分页区域(page area)。\n 4. 如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：\n    1. A transform or perspective value other than none\n    2. A will-change value of transform or perspective\n    3. A filter value other than none or a will-change value of filter(only works on Firefox).\n    4. A contain value of paint (例如: contain: paint;)\n\n注意\n\n根元素(<html>)所在的包含块是一个被称为初始包含块的矩形。\n\n\n# Horizontal Formatting🔥\n\n标准流水平布局中的七个属性中必须包含以下约束（绝对/固定定位的公式需要添加 left 和 right，其余规则类似）：\n\nmargin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right\n=\nwidth of containing block\n\n\n1\n2\n3\n\n\n * 🔥 上述值中只有 'width'， 'margin-left' 和 'margin-right' 可以设置为 'auto'，且 'width' 默认就是 'auto'（只可设置为非负值）。其余几个属性必须设置为特定的值或默认值为 0。且只有 'margin' 可以为负值。\n\n * 🔥 如果恰好有一个值指定为“ auto”，其余俩值有特定值，则 'auto' 值根据等式计算得出。\n   \n   div {\n     width: 500px;\n   }\n   p {\n     margin-left: auto;\n     margin-right: 100px;\n     width: 100px;\n   } /* 'auto' left margin evaluates to 300px */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   p {\n     margin-left: 100px;\n     margin-right: 100px;\n     /* 省略了也是默认值 auto */\n     /* width: auto; */\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 🔥 如果 'width' 被设置为 'auto'，那么任何其他 'auto' 的值都将变成 '0'，并且 'width 的值由等式推出（即计算包含块）。\n   \n   div {\n     width: 500px;\n   }\n   p {\n     margin-left: auto;\n     margin-right: 100px;\n     width: auto;\n   } /* left margin evaluates to 0; width becomes 400px */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   div {\n     width: 500px;\n   }\n   p {\n     margin-left: auto;\n     margin-right: auto;\n     width: auto;\n   } /* left and right margin evaluates to 0; width becomes 500px */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 🔥 若 'width' 有除 “auto” 以外的计算值，且 'margin-left' 和 'margin-right' 均为 'auto'，则它们的使用值相等（当然也可以手动设置相同值，不过没必要）。这使元素相对于包含块的边缘水平居中。\n   \n   div {\n     width: 500px;\n   }\n   p {\n     width: 300px;\n     margin-left: auto;\n     margin-right: auto;\n   }\n   /* each margin is 100 pixels wide, because (500-300)/2 = 100 */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 🔥 如果以上所有内容均具有除 “auto” 以外的计算值，则这些值被称为“过度约束”，并且必定造成其中一个的值与其计算值不同。 如果包含块的 'direction' 属性的值为 'ltr'，则将忽略指定的 'margin-right' 值（即设置为 'auto'），并计算该值以使等式成立。 如果 'direction'的值为 'rtl'，则恰好是 'margin-left'（即设置为 'auto'）。设置为 'auto' 后会根据等式计算得出值。\n   \n   div {\n     width: 500px;\n   }\n   p {\n     margin-left: 100px;\n     margin-right: 100px;\n     width: 100px;\n   } /* right margin forced to be 300px */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 🔥 当 'width of containing block' 一定，若 'margin-right' 为负值且其他值不变，则 'widht' 变大；'margin-left' 为负值，左移。\n   \n   当添加 padding 或 border 后，width 会变小。\n   \n   div {\n     width: 500px;\n     border: 3px solid black;\n   }\n   p.wide {\n     margin-left: 10px;\n     width: auto;\n     margin-right: -50px;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 如果 'width' 不是 'auto' 并且 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width'（加上任何值不是 'auto' 的 'margin-left' 或 'margin-right' ）大于包含块的宽度，那么对于任何 'auto' 的 'margin-left' 或 'margin-right'，将应用如下规则：'auto' 值都将被视为 0。没懂！不知道场景！\n\n\n# width 宽度\n\n * width 设置盒子的宽度，默认值为 'auto'\n\n * min-width 代表最小宽度，最终值大于等于min-width，多用于 PC 网站，固定最小宽度\n\n * max-width 代表最大宽度，最终值小于等于max-width，用于inline-block的元素内容，超过即换行\n\n\n# height 高度\n\n * height 设置盒子的高度\n\n * min-height 代表最小高度，最终值大于等于min-height，多用于 PC 网站，固定最小高度\n\n * max-height 代表最大高度，最终值小于等于max-width，用于固定最大高度，超过可通过overflow隐藏\n\n\n# padding 内边距\n\npadding 属性用于设置内边距，即 border 与 content 之间的距离。也可以分开指定上下左右。\n\n值的个数                           含义\npadding: 5px;                  1 个值，代表上下左右\npadding: 5px 10px;             2 个值，代表上下、左右\npadding: 5px 10px 20px;        3 个值，代表上、左右、下\npadding: 5px 10px 20px 30px;   4 个值，代表上、右、下、左\n\n * 在box-sizing为content-box时，padding 影响了盒子实际大小。 也就是说，如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子；如果盒子没有了宽度或高度，则不影响\n\n * 背景颜色会延伸到内边距上\n\n\n# border 边框\n\n\n# border 缩写 🔥\n\n简写\n\nborder: border-width || border-style || border-color;\n\n\n1\n\n\n分开写\n\nborder-top: border-width || border-style || border-color;\nborder-bottom: border-width || border-style || border-color;\nborder-left: border-width || border-style || border-color;\nborder-right: border-width || border-style || border-color;\n\n\n1\n2\n3\n4\n\n\n注意边框的层叠性\n\n\n# border-width 宽度\n\n * 同其他\n\n\n# border-style 样式\n\n * none：没有边框即忽略所有边框的宽度，默认\n * solid：单实线，常用\n * double：双实线\n * dashed：块虚线\n * dotted：点虚线\n * ...\n\n\n# border-color 颜色\n\n * 同其他\n * transparent透明\n\n\n# 利用border作图 🔥\n\n如下代码：\n\n<style>\n  div {\n    display: inline-block;\n  }\n  .border-shape-1 {\n    width: 100px;\n    height: 100px;\n    border-top: 50px solid red;\n    border-right: 50px solid blue;\n    border-bottom: 50px solid green;\n    border-left: 50px solid skyblue;\n  }\n\n  .border-shape-2 {\n    /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n    width: 0;\n    border-top: 100px solid red;\n    border-right: 100px solid blue;\n    border-bottom: 100px solid green;\n    border-left: 100px solid skyblue;\n  }\n\n  .border-shape-3 {\n    /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n    width: 0;\n    border-top: 200px solid red;\n    border-left: 200px solid skyblue;\n    /* 上左，上右改变分割线方向 */\n    /* border-right: 200px solid blue; */\n  }\n\n  /* 也可以配合3种示例，结合旋转实现 */\n  .border-shape-4 {\n    /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n    width: 0;\n    border: 100px solid transparent;\n    border-left: 100px solid skyblue;\n  }\n\n  .border-shape-5 {\n    /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n    width: 0;\n    border-top: 200px solid red;\n    border-right: 100px solid blue;\n    border-left: 100px solid skyblue;\n  }\n</style>\n<div class=\"border-shape-1\"></div>\n<div class=\"border-shape-2\"></div>\n<div class=\"border-shape-3\"></div>\n<div class=\"border-shape-4\"></div>\n<div class=\"border-shape-5\"></div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n显示效果如下：\n\n<style>\n    .shape-demo div {\n        display: inline-block;\n    }\n    .shape-demo .border-shape-1 {\n        width: 100px;\n        height: 100px;\n        border-top: 25px solid red;\n        border-right: 25px solid blue;\n        border-bottom: 25px solid green;\n        border-left: 25px solid skyblue;\n    }\n\n    .shape-demo .border-shape-2 {\n        /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n        width: 0;\n        border-top: 50px solid red;\n        border-right: 50px solid blue;\n        border-bottom: 50px solid green;\n        border-left: 50px solid skyblue;\n    }\n\n    .shape-demo .border-shape-3 {\n        /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n        width: 0;\n        border-top: 100px solid red;\n        border-left: 100px solid skyblue;\n        /* 上左，上右改变分割线方向 */\n        /* border-right: 200px solid blue; */\n    }\n\n    /* 也可以配合3种示例，结合旋转实现 */\n    .shape-demo .border-shape-4 {\n        /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n        width: 0;\n        border: 50px solid transparent;\n        border-left: 50px solid skyblue;\n    }\n\n    .shape-demo .border-shape-5 {\n        /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n        width: 0;\n        border-top: 100px solid red;\n        border-right: 50px solid blue;\n        border-left: 50px solid skyblue;\n    }\n</style>\n<html>\n    <div class=\"shape-demo\">\n        <div class=\"border-shape-1\"></div>\n        <div class=\"border-shape-2\"></div>\n        <div class=\"border-shape-3\"></div>\n        <div class=\"border-shape-4\"></div>\n        <div class=\"border-shape-5\"></div>\n    </div>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n\n# border-collapse 表格边框 🔥\n\nborder-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。\n\nborder-collapse: collapse || separate;\n\n\n1\n\n * collapse：合并，表示相邻边框合并在一起，常用\n * separate：分开\n\n\n# border-radius圆角边框 🔥\n\n> radius：半径\n\n可以分别给四个角都设置角度\n\n * 左上、 右上、 右下、 左下\n * 左上和右下、 右上和左下\n * 甚至还能直接指定 top、bottom、left、right，必须前两个在前面\n * 可以对每个角的 x, y 设置不同的角度\n * 若单位为%，则参考的是当前盒子的宽度\n\n案例\n\n * 如何让一个盒子变圆形：给border-radius为正方盒子 width 和 height（相等） 的一半，如 50%\n   \n   div {\n     border-radius: 50%;\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 如何让一个盒子变圆角矩形：给border-radius为盒子 height 的一半，如 50%\n\n\n# outline轮廓线\n\n不属于盒子模型。同 border 相比，outline不会增加盒子的大小，默认显示在border外面，取值同 border。\n\n可用于分析网站布局；也可用于去掉input或a（tab 选中）或textraea的 focus 轮廓蓝线。\n\n * none：取消，写0也可\n\n\n# margin 外边距\n\n\n# margin 缩写 🔥\n\nmargin 清除周围的（外边框）元素区域。margin 没有背景颜色，是完全透明的。也可以分开指定上下左右。默认值为 0\n\n值的个数                          含义\nmargin: 5px;                  1 个值，代表上下左右\nmargin: 5px 10px;             2 个值，代表上下、左右\nmargin: 5px 10px 20px;        3 个值，代表上、左右、下\nmargin: 5px 10px 20px 30px;   4 个值，代表上、右、下、左\n\n\n# margin 负值 🔥\n\n# 问题 1\n\n有间隙的格子布局时一行中最后一个元素的margin-right总会多余\n\n解决：\n\n * 选择一行最后一个元素，添加class，去除margin-right\n\n * 使用伪类选择器（IE8 不支持）\n\n * 增大包含块的宽度。\n   \n   .container固定宽度> .wrap>很多item。.wrap一般是ul\n   \n   给.wrap+负margin即可增大.wrap宽度；或直接给.wrap宽度增大\n\n# 问题 2\n\n无间隙的格子布局，需要对变粗的边界进行合并，可以使用负margin\n\n\n# 块级盒子水平居中 🔥\n\nmargin 典型应用——让块级盒子水平居中，但需满足两个条件\n\n * 子盒子必须指定了 width\n\n * 子盒子的左右 margin 都设置为 auto\n   \n   div {\n     width: 100px;\n     margin: 0 auto;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n若是行内元素或行内块元素的内容需要水平居中，可以给其父元素添加text-align: center即可\n\nmargin 水平居中原理\n\n原理参考 Visual formatting model 章节\n\n对块元素所属行的剩余空间的分配问题。auto则表示剩余空间都给这侧。据此可以实现左对齐，右对齐。\n\n垂直居中需要使用定位和移动，移动父元素高度的一半并减去子元素盒子高度的一半。\n\n\n# 边界折叠问题 🔥\n\n两个块元素（block）的相邻垂直margin同时都有设定时只会只会保留最大边距，这种行为称为边界折叠（margin collapsing），有时也翻译为外边距重叠。只有垂直外边距会发生该问题。\n\n有三种情况会形成外边距重叠：\n\n# 兄弟元素\n\n相邻的两个兄弟元素之间的外边距重叠，除非后一个元素加上clear-fix 清除浮动。\n\n * 两者都是正值，兄弟元素间的相邻垂直外边距会取两者之间的较大值\n * 如果相邻的外边距一正一负，则取两者的和\n * 如果相邻的外边距都是负值，则取两者中绝对值较大的\n\n兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理\n\n如下图，上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距是取最大值。对于段落p元素正好可以使用该副作用。\n\n\n\n<style>\n  p:nth-child(1) {\n    width: 100px;\n    height: 100px;\n    background-color: skyblue;\n    margin-bottom: 50px;\n  }\n  p:nth-child(2) {\n    width: 100px;\n    height: 100px;\n    background-color: skyblue;\n    margin-top: 50px;\n  }\n</style>\n\n<div>\n  <p>下边界范围会...</p>\n  <p>...会跟这个元素的上边界范围重叠。</p>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n解决方案（一般无需解决）：\n\n * 尽量只给一个盒子添加 margin 值\n\n# 父子元素\n\n如果没有 border，padding，content，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界 margin-top 与其内一个或多个后代块级元素的上边界 margin-top；\n\n或没有边框，内边距，行内内容，高度 height，最小高度 min-height 或 最大高度 max-height 来分开一个块级元素的下边界 margin-bottom 与其内的一个或多个后代后代块元素的下边界 margin-bottom\n\n则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。即子元素的会传递给父元素（上外边距）\n\n父子外边距的折叠会影响到页面的布局，必须要进行处理\n\n如下图，对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时（其实父元素可以没有外边距）子元素也有上外边距，此时父元素会塌陷较大的外边距值。即子元素想距离父元素上边距失效（即父子元素上边框还是重合的）。注意以内容区域为视角看问题。下外边距同理（但是必须父元素的高度是auto）\n\n\n\n<style type=\"text/css\">\n  section {\n    width: 400px;\n    height: auto;\n    background-color: skyblue;\n    margin-top: 50px;\n    margin-bottom: 100px;\n  }\n\n  header {\n    width: 100px;\n    height: 100px;\n    background-color: orange;\n    margin-top: 100px;\n  }\n\n  footer {\n    width: 100px;\n    height: 100px;\n    background-color: greenyellow;\n    margin-bottom: 50px;\n  }\n</style>\n\n<hr />\n<section>\n  <header>上边界重叠</header>\n  <main></main>\n  <footer>下边界重叠</footer>\n</section>\n<hr />\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n解决方案：\n\n * 可以为父元素定义border-top/bottom\n\n * 可以为父元素定义padding-top/bottom\n\n * 触发 BFC（查看 float 章节）\n   \n   推荐使用伪元素添加一个display:table匿名表格单元格元素（推荐，查看 float 章节）\n\n# 空的块级元素\n\n当一个块元素上边界 margin-top 直接贴到元素下边界 margin-bottom 时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框 border、内边距 paddng、高度 height、最小高度 min-height 、最大高度 max-height 、内容设定为 inline 或是加上 clear-fix 的时候。\n\n<style>\n  p {\n    margin: 0;\n  }\n  div {\n    margin-top: 13px;\n    margin-bottom: 87px;\n  }\n</style>\n\n<p>上边界范围是 87 ...</p>\n<div></div>\n<p>... 上边界范围是 87</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 上述情况的组合会产生更复杂的外边距折叠。\n * 即使某一外边距为 0，这些规则仍然适用。因此就算父元素的外边距是 0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。\n * 如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和,；也就是说如果有-13px 8px 100px 叠在一起，边界范围的技术就是 100px -13px 的 87px。\n * 如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。\n\n\n# box-shadow 盒子阴影 🔥\n\n同类型的还有text-shadow，用得少，见属性笔记\n\nbox-shadow: h-shadow v-shadow blur spread color inset; /* 与顺序无关 */\n\n\n1\n\n\n值          描述\nh-shadow   必需。水平阴影的位置。正值向右移动，负值向左移动\nv-shadow   必需。垂直阴影的位置。正值向下移动，负值向上移动\nblur       可选。模糊半径，阴影的发散程度\nspread     可选。阴影的尺寸，就是阴影向四周延伸的大小\ncolor      可选。阴影的颜色。请参阅 CSS 颜色值。\ninset      可选。将外部阴影 (outset) 改为内部阴影。不能写 outset 否则失效\n\n可以通过,设置多个值\n\ndiv {\n  box-shadow: 5px 5px 10px, -5px -5px 10px; /* 对应x y blur, y x blur. 但是明显对角线割裂了，不推荐 */\n}\n\n\n1\n2\n3\n\n\n注意\n\n影子不占用空间，不影响其他盒子排列",normalizedContent:"# box model 盒子模型\n\n盒子模型：所有 html 元素可以看作盒子，盒子模型用来设计和布局时使用。css 盒模型本质上是一个盒子，封装周围的 html 元素，它包括：margin，border，padding 和 content。盒模型允许我们在其它元素和周围元素 border 之间的空间放置元素。\n\n\n\n\n# box-sizing 盒子标准 🔥\n\ncss3 中可以通过 box-sizing 来指定盒模型，这样我们计算盒子大小的方式就发生了改变。有 2 个值：\n\n * content-box：即设置width和height仅针对content，最终盒子大小为 content + padding + border\n   \n   若盒子模型改为content-box且没有指定 width 或 height（即使子节点和父节点一样宽，也不要指定宽度，100%也不行），则给定 padding 不会改变盒子大小及 width 或 height（对应，没 width 则不改变 width，没 height 则不改变 height）\n   \n   但是 padding可以撑开盒子，我们可以做非常巧妙的运用。因为每个导航栏里面的字数不一样多，我们可以不用给每个盒子宽度了，直接给 padding 最合适，且 a 标签为行内元素，需转为行内块元素才能修改宽高\n\n * border-box：css3，即设置width和height针对 content + padding + border\n   \n   若盒子模型改为 border-box ， 那 padding 和 border 就不会撑大盒子了，前提 padding 和 border 不会超过 width 宽度\n\n\n# visual formatting model 细节 🔥\n\n\n# 布局和包含块 🔥\n\n提示\n\n参考w3 文档， mdn 文档。\n\n一个元素大小的和位置经常受其包含块的影响。大多数情况下，包含块就是这个元素最近的祖先块元素的内容区，但也不是总是这样。确定一个元素的包含块的过程完全依赖于这个元素的 position 属性：\n\n 1. 如果 position 属性为 static 或 relative ，包含块就是由它的最近的祖先块元素（比如说 inline-block, block 或 list-item 元素）或格式化上下文(比如说 a table container, flex container, grid container, or the block container itself)的内容区的边缘组成的。\n 2. 如果 position 属性为 absolute ，包含块就是由它的最近的 position 的值不是 static （也就是值为fixed, absolute, relative 或 sticky）的祖先元素的内边距区的边缘组成。\n 3. 如果 position 属性是 fixed，在连续媒体的情况下(continuous media)包含块是 viewport ,在分页媒体(paged media)下的情况下包含块是分页区域(page area)。\n 4. 如果 position 属性是 absolute 或 fixed，包含块也可能是由满足以下条件的最近父级元素的内边距区的边缘组成的：\n    1. a transform or perspective value other than none\n    2. a will-change value of transform or perspective\n    3. a filter value other than none or a will-change value of filter(only works on firefox).\n    4. a contain value of paint (例如: contain: paint;)\n\n注意\n\n根元素(<html>)所在的包含块是一个被称为初始包含块的矩形。\n\n\n# horizontal formatting🔥\n\n标准流水平布局中的七个属性中必须包含以下约束（绝对/固定定位的公式需要添加 left 和 right，其余规则类似）：\n\nmargin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right\n=\nwidth of containing block\n\n\n1\n2\n3\n\n\n * 🔥 上述值中只有 'width'， 'margin-left' 和 'margin-right' 可以设置为 'auto'，且 'width' 默认就是 'auto'（只可设置为非负值）。其余几个属性必须设置为特定的值或默认值为 0。且只有 'margin' 可以为负值。\n\n * 🔥 如果恰好有一个值指定为“ auto”，其余俩值有特定值，则 'auto' 值根据等式计算得出。\n   \n   div {\n     width: 500px;\n   }\n   p {\n     margin-left: auto;\n     margin-right: 100px;\n     width: 100px;\n   } /* 'auto' left margin evaluates to 300px */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   p {\n     margin-left: 100px;\n     margin-right: 100px;\n     /* 省略了也是默认值 auto */\n     /* width: auto; */\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 🔥 如果 'width' 被设置为 'auto'，那么任何其他 'auto' 的值都将变成 '0'，并且 'width 的值由等式推出（即计算包含块）。\n   \n   div {\n     width: 500px;\n   }\n   p {\n     margin-left: auto;\n     margin-right: 100px;\n     width: auto;\n   } /* left margin evaluates to 0; width becomes 400px */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n   \n   div {\n     width: 500px;\n   }\n   p {\n     margin-left: auto;\n     margin-right: auto;\n     width: auto;\n   } /* left and right margin evaluates to 0; width becomes 500px */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 🔥 若 'width' 有除 “auto” 以外的计算值，且 'margin-left' 和 'margin-right' 均为 'auto'，则它们的使用值相等（当然也可以手动设置相同值，不过没必要）。这使元素相对于包含块的边缘水平居中。\n   \n   div {\n     width: 500px;\n   }\n   p {\n     width: 300px;\n     margin-left: auto;\n     margin-right: auto;\n   }\n   /* each margin is 100 pixels wide, because (500-300)/2 = 100 */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 🔥 如果以上所有内容均具有除 “auto” 以外的计算值，则这些值被称为“过度约束”，并且必定造成其中一个的值与其计算值不同。 如果包含块的 'direction' 属性的值为 'ltr'，则将忽略指定的 'margin-right' 值（即设置为 'auto'），并计算该值以使等式成立。 如果 'direction'的值为 'rtl'，则恰好是 'margin-left'（即设置为 'auto'）。设置为 'auto' 后会根据等式计算得出值。\n   \n   div {\n     width: 500px;\n   }\n   p {\n     margin-left: 100px;\n     margin-right: 100px;\n     width: 100px;\n   } /* right margin forced to be 300px */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * 🔥 当 'width of containing block' 一定，若 'margin-right' 为负值且其他值不变，则 'widht' 变大；'margin-left' 为负值，左移。\n   \n   当添加 padding 或 border 后，width 会变小。\n   \n   div {\n     width: 500px;\n     border: 3px solid black;\n   }\n   p.wide {\n     margin-left: 10px;\n     width: auto;\n     margin-right: -50px;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * 如果 'width' 不是 'auto' 并且 'border-left-width' + 'padding-left' + 'width' + 'padding-right' + 'border-right-width'（加上任何值不是 'auto' 的 'margin-left' 或 'margin-right' ）大于包含块的宽度，那么对于任何 'auto' 的 'margin-left' 或 'margin-right'，将应用如下规则：'auto' 值都将被视为 0。没懂！不知道场景！\n\n\n# width 宽度\n\n * width 设置盒子的宽度，默认值为 'auto'\n\n * min-width 代表最小宽度，最终值大于等于min-width，多用于 pc 网站，固定最小宽度\n\n * max-width 代表最大宽度，最终值小于等于max-width，用于inline-block的元素内容，超过即换行\n\n\n# height 高度\n\n * height 设置盒子的高度\n\n * min-height 代表最小高度，最终值大于等于min-height，多用于 pc 网站，固定最小高度\n\n * max-height 代表最大高度，最终值小于等于max-width，用于固定最大高度，超过可通过overflow隐藏\n\n\n# padding 内边距\n\npadding 属性用于设置内边距，即 border 与 content 之间的距离。也可以分开指定上下左右。\n\n值的个数                           含义\npadding: 5px;                  1 个值，代表上下左右\npadding: 5px 10px;             2 个值，代表上下、左右\npadding: 5px 10px 20px;        3 个值，代表上、左右、下\npadding: 5px 10px 20px 30px;   4 个值，代表上、右、下、左\n\n * 在box-sizing为content-box时，padding 影响了盒子实际大小。 也就是说，如果盒子已经有了宽度和高度，此时再指定内边框，会撑大盒子；如果盒子没有了宽度或高度，则不影响\n\n * 背景颜色会延伸到内边距上\n\n\n# border 边框\n\n\n# border 缩写 🔥\n\n简写\n\nborder: border-width || border-style || border-color;\n\n\n1\n\n\n分开写\n\nborder-top: border-width || border-style || border-color;\nborder-bottom: border-width || border-style || border-color;\nborder-left: border-width || border-style || border-color;\nborder-right: border-width || border-style || border-color;\n\n\n1\n2\n3\n4\n\n\n注意边框的层叠性\n\n\n# border-width 宽度\n\n * 同其他\n\n\n# border-style 样式\n\n * none：没有边框即忽略所有边框的宽度，默认\n * solid：单实线，常用\n * double：双实线\n * dashed：块虚线\n * dotted：点虚线\n * ...\n\n\n# border-color 颜色\n\n * 同其他\n * transparent透明\n\n\n# 利用border作图 🔥\n\n如下代码：\n\n<style>\n  div {\n    display: inline-block;\n  }\n  .border-shape-1 {\n    width: 100px;\n    height: 100px;\n    border-top: 50px solid red;\n    border-right: 50px solid blue;\n    border-bottom: 50px solid green;\n    border-left: 50px solid skyblue;\n  }\n\n  .border-shape-2 {\n    /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n    width: 0;\n    border-top: 100px solid red;\n    border-right: 100px solid blue;\n    border-bottom: 100px solid green;\n    border-left: 100px solid skyblue;\n  }\n\n  .border-shape-3 {\n    /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n    width: 0;\n    border-top: 200px solid red;\n    border-left: 200px solid skyblue;\n    /* 上左，上右改变分割线方向 */\n    /* border-right: 200px solid blue; */\n  }\n\n  /* 也可以配合3种示例，结合旋转实现 */\n  .border-shape-4 {\n    /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n    width: 0;\n    border: 100px solid transparent;\n    border-left: 100px solid skyblue;\n  }\n\n  .border-shape-5 {\n    /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n    width: 0;\n    border-top: 200px solid red;\n    border-right: 100px solid blue;\n    border-left: 100px solid skyblue;\n  }\n</style>\n<div class=\"border-shape-1\"></div>\n<div class=\"border-shape-2\"></div>\n<div class=\"border-shape-3\"></div>\n<div class=\"border-shape-4\"></div>\n<div class=\"border-shape-5\"></div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n显示效果如下：\n\n<style>\n    .shape-demo div {\n        display: inline-block;\n    }\n    .shape-demo .border-shape-1 {\n        width: 100px;\n        height: 100px;\n        border-top: 25px solid red;\n        border-right: 25px solid blue;\n        border-bottom: 25px solid green;\n        border-left: 25px solid skyblue;\n    }\n\n    .shape-demo .border-shape-2 {\n        /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n        width: 0;\n        border-top: 50px solid red;\n        border-right: 50px solid blue;\n        border-bottom: 50px solid green;\n        border-left: 50px solid skyblue;\n    }\n\n    .shape-demo .border-shape-3 {\n        /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n        width: 0;\n        border-top: 100px solid red;\n        border-left: 100px solid skyblue;\n        /* 上左，上右改变分割线方向 */\n        /* border-right: 200px solid blue; */\n    }\n\n    /* 也可以配合3种示例，结合旋转实现 */\n    .shape-demo .border-shape-4 {\n        /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n        width: 0;\n        border: 50px solid transparent;\n        border-left: 50px solid skyblue;\n    }\n\n    .shape-demo .border-shape-5 {\n        /* 宽度必须给0，否则独占一行，默认为父容器宽度。高度可以不给，通过内容撑起来 */\n        width: 0;\n        border-top: 100px solid red;\n        border-right: 50px solid blue;\n        border-left: 50px solid skyblue;\n    }\n</style>\n<html>\n    <div class=\"shape-demo\">\n        <div class=\"border-shape-1\"></div>\n        <div class=\"border-shape-2\"></div>\n        <div class=\"border-shape-3\"></div>\n        <div class=\"border-shape-4\"></div>\n        <div class=\"border-shape-5\"></div>\n    </div>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n\n\n\n\n# border-collapse 表格边框 🔥\n\nborder-collapse 属性控制浏览器绘制表格边框的方式。它控制相邻单元格的边框。\n\nborder-collapse: collapse || separate;\n\n\n1\n\n * collapse：合并，表示相邻边框合并在一起，常用\n * separate：分开\n\n\n# border-radius圆角边框 🔥\n\n> radius：半径\n\n可以分别给四个角都设置角度\n\n * 左上、 右上、 右下、 左下\n * 左上和右下、 右上和左下\n * 甚至还能直接指定 top、bottom、left、right，必须前两个在前面\n * 可以对每个角的 x, y 设置不同的角度\n * 若单位为%，则参考的是当前盒子的宽度\n\n案例\n\n * 如何让一个盒子变圆形：给border-radius为正方盒子 width 和 height（相等） 的一半，如 50%\n   \n   div {\n     border-radius: 50%;\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 如何让一个盒子变圆角矩形：给border-radius为盒子 height 的一半，如 50%\n\n\n# outline轮廓线\n\n不属于盒子模型。同 border 相比，outline不会增加盒子的大小，默认显示在border外面，取值同 border。\n\n可用于分析网站布局；也可用于去掉input或a（tab 选中）或textraea的 focus 轮廓蓝线。\n\n * none：取消，写0也可\n\n\n# margin 外边距\n\n\n# margin 缩写 🔥\n\nmargin 清除周围的（外边框）元素区域。margin 没有背景颜色，是完全透明的。也可以分开指定上下左右。默认值为 0\n\n值的个数                          含义\nmargin: 5px;                  1 个值，代表上下左右\nmargin: 5px 10px;             2 个值，代表上下、左右\nmargin: 5px 10px 20px;        3 个值，代表上、左右、下\nmargin: 5px 10px 20px 30px;   4 个值，代表上、右、下、左\n\n\n# margin 负值 🔥\n\n# 问题 1\n\n有间隙的格子布局时一行中最后一个元素的margin-right总会多余\n\n解决：\n\n * 选择一行最后一个元素，添加class，去除margin-right\n\n * 使用伪类选择器（ie8 不支持）\n\n * 增大包含块的宽度。\n   \n   .container固定宽度> .wrap>很多item。.wrap一般是ul\n   \n   给.wrap+负margin即可增大.wrap宽度；或直接给.wrap宽度增大\n\n# 问题 2\n\n无间隙的格子布局，需要对变粗的边界进行合并，可以使用负margin\n\n\n# 块级盒子水平居中 🔥\n\nmargin 典型应用——让块级盒子水平居中，但需满足两个条件\n\n * 子盒子必须指定了 width\n\n * 子盒子的左右 margin 都设置为 auto\n   \n   div {\n     width: 100px;\n     margin: 0 auto;\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n若是行内元素或行内块元素的内容需要水平居中，可以给其父元素添加text-align: center即可\n\nmargin 水平居中原理\n\n原理参考 visual formatting model 章节\n\n对块元素所属行的剩余空间的分配问题。auto则表示剩余空间都给这侧。据此可以实现左对齐，右对齐。\n\n垂直居中需要使用定位和移动，移动父元素高度的一半并减去子元素盒子高度的一半。\n\n\n# 边界折叠问题 🔥\n\n两个块元素（block）的相邻垂直margin同时都有设定时只会只会保留最大边距，这种行为称为边界折叠（margin collapsing），有时也翻译为外边距重叠。只有垂直外边距会发生该问题。\n\n有三种情况会形成外边距重叠：\n\n# 兄弟元素\n\n相邻的两个兄弟元素之间的外边距重叠，除非后一个元素加上clear-fix 清除浮动。\n\n * 两者都是正值，兄弟元素间的相邻垂直外边距会取两者之间的较大值\n * 如果相邻的外边距一正一负，则取两者的和\n * 如果相邻的外边距都是负值，则取两者中绝对值较大的\n\n兄弟元素之间的外边距的重叠，对于开发是有利的，所以我们不需要进行处理\n\n如下图，上面的元素有下外边距 margin-bottom，下面的元素有上外边距 margin-top ，则他们之间的垂直间距是取最大值。对于段落p元素正好可以使用该副作用。\n\n\n\n<style>\n  p:nth-child(1) {\n    width: 100px;\n    height: 100px;\n    background-color: skyblue;\n    margin-bottom: 50px;\n  }\n  p:nth-child(2) {\n    width: 100px;\n    height: 100px;\n    background-color: skyblue;\n    margin-top: 50px;\n  }\n</style>\n\n<div>\n  <p>下边界范围会...</p>\n  <p>...会跟这个元素的上边界范围重叠。</p>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n解决方案（一般无需解决）：\n\n * 尽量只给一个盒子添加 margin 值\n\n# 父子元素\n\n如果没有 border，padding，content，也没有创建块级格式上下文或清除浮动来分开一个块级元素的上边界 margin-top 与其内一个或多个后代块级元素的上边界 margin-top；\n\n或没有边框，内边距，行内内容，高度 height，最小高度 min-height 或 最大高度 max-height 来分开一个块级元素的下边界 margin-bottom 与其内的一个或多个后代后代块元素的下边界 margin-bottom\n\n则就会出现父块元素和其内后代块元素外边界重叠，重叠部分最终会溢出到父级块元素外面。即子元素的会传递给父元素（上外边距）\n\n父子外边距的折叠会影响到页面的布局，必须要进行处理\n\n如下图，对于两个嵌套关系（父子关系）的块元素，父元素有上外边距同时（其实父元素可以没有外边距）子元素也有上外边距，此时父元素会塌陷较大的外边距值。即子元素想距离父元素上边距失效（即父子元素上边框还是重合的）。注意以内容区域为视角看问题。下外边距同理（但是必须父元素的高度是auto）\n\n\n\n<style type=\"text/css\">\n  section {\n    width: 400px;\n    height: auto;\n    background-color: skyblue;\n    margin-top: 50px;\n    margin-bottom: 100px;\n  }\n\n  header {\n    width: 100px;\n    height: 100px;\n    background-color: orange;\n    margin-top: 100px;\n  }\n\n  footer {\n    width: 100px;\n    height: 100px;\n    background-color: greenyellow;\n    margin-bottom: 50px;\n  }\n</style>\n\n<hr />\n<section>\n  <header>上边界重叠</header>\n  <main></main>\n  <footer>下边界重叠</footer>\n</section>\n<hr />\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n解决方案：\n\n * 可以为父元素定义border-top/bottom\n\n * 可以为父元素定义padding-top/bottom\n\n * 触发 bfc（查看 float 章节）\n   \n   推荐使用伪元素添加一个display:table匿名表格单元格元素（推荐，查看 float 章节）\n\n# 空的块级元素\n\n当一个块元素上边界 margin-top 直接贴到元素下边界 margin-bottom 时也会发生边界折叠。这种情况会发生在一个块元素完全没有设定边框 border、内边距 paddng、高度 height、最小高度 min-height 、最大高度 max-height 、内容设定为 inline 或是加上 clear-fix 的时候。\n\n<style>\n  p {\n    margin: 0;\n  }\n  div {\n    margin-top: 13px;\n    margin-bottom: 87px;\n  }\n</style>\n\n<p>上边界范围是 87 ...</p>\n<div></div>\n<p>... 上边界范围是 87</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n * 上述情况的组合会产生更复杂的外边距折叠。\n * 即使某一外边距为 0，这些规则仍然适用。因此就算父元素的外边距是 0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。\n * 如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和,；也就是说如果有-13px 8px 100px 叠在一起，边界范围的技术就是 100px -13px 的 87px。\n * 如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。\n\n\n# box-shadow 盒子阴影 🔥\n\n同类型的还有text-shadow，用得少，见属性笔记\n\nbox-shadow: h-shadow v-shadow blur spread color inset; /* 与顺序无关 */\n\n\n1\n\n\n值          描述\nh-shadow   必需。水平阴影的位置。正值向右移动，负值向左移动\nv-shadow   必需。垂直阴影的位置。正值向下移动，负值向上移动\nblur       可选。模糊半径，阴影的发散程度\nspread     可选。阴影的尺寸，就是阴影向四周延伸的大小\ncolor      可选。阴影的颜色。请参阅 css 颜色值。\ninset      可选。将外部阴影 (outset) 改为内部阴影。不能写 outset 否则失效\n\n可以通过,设置多个值\n\ndiv {\n  box-shadow: 5px 5px 10px, -5px -5px 10px; /* 对应x y blur, y x blur. 但是明显对角线割裂了，不推荐 */\n}\n\n\n1\n2\n3\n\n\n注意\n\n影子不占用空间，不影响其他盒子排列",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"标准流",frontmatter:{title:"标准流",date:"2020-03-15T16:59:05.000Z",permalink:"/pages/3d870b/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/300.CSS%E5%B8%83%E5%B1%80/302.CSS-%E6%A0%87%E5%87%86%E6%B5%81.html",relativePath:"1100.H5&CSS3/300.CSS布局/302.CSS-标准流.md",key:"v-603d9e38",path:"/pages/3d870b/",headersStr:null,content:"# Normal Flow 标准流\n\n也称为文档流或普通流\n\n * 网页是一个多层的结构，一层摞着一层，通过CSS可以分别为每一层来设置样式。作为用户来讲只能看到最顶上一层，这些层中，最底下的一层称为标准流（文档流），是网页的基础。我们所创建的元素默认都是在标准流（文档流）中进行排列\n\n * 对于我们来说元素主要有两个状态：在文档流中；脱离文档流\n\n * 标准流中的元素从左到右、从上到下按顺序摆放好\n   \n   * 块元素\n     * 会独占一行（无论是否有 width），从上向下顺序排列。\n     * 默认宽度是父元素的全部（会把父元素撑满）\n     * 默认高度是被内容撑开（子元素）\n   * 行内元素\n     * 只占自身的大小，会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行\n     * 默认宽度和高度都是被内容撑开",normalizedContent:"# normal flow 标准流\n\n也称为文档流或普通流\n\n * 网页是一个多层的结构，一层摞着一层，通过css可以分别为每一层来设置样式。作为用户来讲只能看到最顶上一层，这些层中，最底下的一层称为标准流（文档流），是网页的基础。我们所创建的元素默认都是在标准流（文档流）中进行排列\n\n * 对于我们来说元素主要有两个状态：在文档流中；脱离文档流\n\n * 标准流中的元素从左到右、从上到下按顺序摆放好\n   \n   * 块元素\n     * 会独占一行（无论是否有 width），从上向下顺序排列。\n     * 默认宽度是父元素的全部（会把父元素撑满）\n     * 默认高度是被内容撑开（子元素）\n   * 行内元素\n     * 只占自身的大小，会按照顺序，从左到右顺序排列，碰到父元素边缘则自动换行\n     * 默认宽度和高度都是被内容撑开",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"浮动",frontmatter:{title:"浮动",date:"2020-03-15T17:02:19.000Z",permalink:"/pages/9fccab/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/300.CSS%E5%B8%83%E5%B1%80/303.CSS-%E6%B5%AE%E5%8A%A8.html",relativePath:"1100.H5&CSS3/300.CSS布局/303.CSS-浮动.md",key:"v-3f9649d2",path:"/pages/9fccab/",headers:[{level:2,title:"浮动规则",slug:"浮动规则",normalizedTitle:"浮动规则",charIndex:15},{level:2,title:"脱离标准流元素特点—重复 🔥",slug:"脱离标准流元素特点-重复-🔥",normalizedTitle:"脱离标准流元素特点—重复 🔥",charIndex:579},{level:2,title:"现象思考 🤔",slug:"现象思考-🤔",normalizedTitle:"现象思考 🤔",charIndex:899},{level:2,title:"浮动的应用",slug:"浮动的应用",normalizedTitle:"浮动的应用",charIndex:1318},{level:2,title:"高度坍塌 🔥",slug:"高度坍塌-🔥",normalizedTitle:"高度坍塌 🔥",charIndex:1368},{level:2,title:"BFC 🔥",slug:"bfc-🔥",normalizedTitle:"bfc 🔥",charIndex:1442},{level:2,title:"清除浮动 🔥",slug:"清除浮动-🔥",normalizedTitle:"清除浮动 🔥",charIndex:3258},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3270},{level:3,title:"父元素增加 height—不推荐",slug:"父元素增加-height-不推荐",normalizedTitle:"父元素增加 height—不推荐",charIndex:3636},{level:3,title:"额外块元素法—隔墙法",slug:"额外块元素法-隔墙法",normalizedTitle:"额外块元素法—隔墙法",charIndex:3660},{level:3,title:"父级添加::after伪元素",slug:"父级添加-after伪元素",normalizedTitle:"父级添加::after伪元素",charIndex:3859},{level:3,title:"父级添加双伪元素 🔥",slug:"父级添加双伪元素-🔥",normalizedTitle:"父级添加双伪元素 🔥",charIndex:4283}],headersStr:"浮动规则 脱离标准流元素特点—重复 🔥 现象思考 🤔 浮动的应用 高度坍塌 🔥 BFC 🔥 清除浮动 🔥 简介 父元素增加 height—不推荐 额外块元素法—隔墙法 父级添加::after伪元素 父级添加双伪元素 🔥",content:'# Float 浮动\n\n\n# 浮动规则\n\n选择器 {\n  float: 属性值;\n}\n\n\n1\n2\n3\n\n\n值         描述\nleft      元素向左浮动。\nright     元素向右浮动。\nnone      默认值。元素不浮动，并会显示在其在文本中出现的位置。\ninherit   规定应该从父元素继承 float 属性的值。\n\n * 脱标。查看脱离标准流元素特点总结元素类型\n\n * 浮动用于创建浮动框，将元素横向移到一边，直到左边缘或右边缘触及 包含块（容器或父元素） 或 另一个浮动框 的边缘。\n\n * 浮动的元素允许文本和行内元素（inline 或 inline-block 等）环绕它\n\n * 行内元素（inline 或 inline-block 等）浮动后，其顶部将与所在行的顶部对齐，不会朝上浮\n\n * 定位元素（非 static）会层叠在浮动元素上（按标准流——浮动——定位的顺序）。浮动元素间不能层叠（不多解释）。\n\n * 浮动元素的顶端不能超过包含块的顶端，也不能超过之前所有浮动元素的的顶端（以最低的为界限）\n   \n   \n\n * 如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间；如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”\n   \n   \n\n\n# 脱离标准流元素特点—重复 🔥\n\n * 可以设置width、height\n * 默认width、height由内容决定\n * 不再给父元素汇报width、height数据，即父元素也不知道该元素了\n * 类似inline-block，但是不是！是block！\n\n注意\n\ndisplay、position、float 都都影响盒子的生成和布局：\n\n * 当 display 为 none 时，就不会生成盒子，对 position 和 float 无影响\n * 当 postion 为 absolute 或 fixed 时，或 float 为 left 或 right 时，元素基本都变为 block 类型（除了布局类型）详细参考文档\n\n\n# 现象思考 🤔\n\n<div class="box">\n  <div class="inner1"></div>\n  <div class="inner2">\n    我是inner2的文本\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n * 当 inner1 进行左浮动/右浮动时，只会在当前自己行中浮动\n * 当 inner1 进行左浮动时，inner2 在没有浮动时，inner1 和 2 会如何排布\n * 当 inner1 进行左浮动时，inner2 在没有浮动时，但是 inner2 中有文字，文字会如何排布（假设 inner2 面积大于 inner1）\n * 当 inner1 进行左浮动时，inner2 也进行左浮动，那么 inner1 和 inner2 依次在地一行排布\n * 当 inner1 进行左浮动时，inner2 也进行左浮动，但是父元素没有设置高度，此时父元素的高度会消失（高度的坍塌）\n\n\n# 浮动的应用\n\n * 解决行内元素（包括inline-block）的水平间隙问题\n * 布局\n\n\n# 高度坍塌 🔥\n\n由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，所以由于父级盒子高度为 0，就影响了下面的标准流盒子。\n\n\n# BFC 🔥\n\nBFC（Block Formatting Context）块级格式化环境，BFC 是一个 CSS 中的一个隐含的属性，可以为一个元素开启 BFC，开启 BFC 该元素会变成一个独立的布局区域。未开启时，整个页面是一个布局整体。\n\n可以通过一些特殊方式来开启元素的 BFC（可参考MDN文档）：\n\n * 设置元素的浮动（不推荐，高度不会坍塌，但是脱离标准流后 width 随即丢失）\n\n * 将元素设置为行内块元素（不推荐，不推荐用于外部容器，且 width 也丢失了）\n\n * 绝对定位（不推荐）\n\n * 将元素的 overflow 设置为一个非 visible 的值（也不完美，最终推荐 clear ）\n   \n   常用的方式即为要开启 BFC 的元素设置 overflow:hidden，以使其可以包含浮动元素\n\n元素开启 BFC后的特点：\n\n * 开启 BFC 的元素可以包含浮动的子元素，即解决高度塌陷问题\n   \n   <style>\n   .outer {\n     border: 10px red solid;\n     overflow: hidden;\n   }\n   .inner {\n     float: left;\n     width: 100px;\n     height: 100px;\n     background-color: skyblue;\n   }\n   </style>\n   <div class="outer">\n   \t<div class="inner"></div>\n   </div>\n   <div style="width: 200px; height: 200px; background-color: yellow;"></div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * 开启 BFC 的元素不会被浮动元素所覆盖（兄弟元素）\n   \n   <style>\n     .box1 {\n       width: 200px;\n       height: 200px;\n       background-color: skyblue;\n       float: left;\n     }\n   \n     .box2 {\n       width: 200px;\n       height: 200px;\n       background-color: orange;\n       overflow: hidden;\n     }\n   </style>\n   <div class="box1"></div>\n   <div class="box2"></div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n * 开启 BFC 的元素子元素和父元素外边距不会重叠\n   \n   本来是 box1 带着 box3 往下移动 100px；之后正常\n   \n   <style>\n   .box1 {\n     width: 200px;\n     height: 200px;\n     background-color: skyblue;\n     overflow: hidden;\n   }\n   \n   .box3 {\n     width: 100px;\n     height: 100px;\n     background-color: yellow;\n     margin-top: 100px;\n   }\n   </style>\n   <div class="box1">\n   \t<div class="box3"></div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 清除浮动 🔥\n\n\n# 简介\n\n清除浮动的本质是清除浮动元素造成的影响。如果父盒子本身有高度，则不需要清除浮动\n\n设置清除浮动之后，浏览器会自动为元素添加一个上外边距，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了\n\n选择器 {\n  clear: 属性值;\n}\n\n\n1\n2\n3\n\n\n值         描述\nleft      在左侧不允许浮动元素。要求元素（新）的顶部低于之前生成的所有左浮动元素的底部。其他同理\nright     在右侧不允许浮动元素。\nboth      清除两侧中最大影响的那侧。实际工作中， 几乎只用 both\nnone      默认值。允许浮动元素出现在两侧。\ninherit   规定应该从父元素继承 clear 属性的值。\n\n清除浮动的策略是：闭合浮动，将浮动元素只限制到父元素中\n\n\n# 父元素增加 height—不推荐\n\n略\n\n\n# 额外块元素法—隔墙法\n\n额外标签法也称为隔墙法，是 W3C 推荐的做法。但是不常用。额外标签法会在浮动元素末尾添加一个空的块级元素。例如\n\n<div style="clear:both"></div>\n\n\n1\n\n\n或者br标签（没见过这种写法）\n\n<br clear="all" />\n\n\n1\n\n\n * 优点: 通俗易懂，书写方便\n\n * 缺点: 添加许多无意义的标签，且样式与结构耦合。\n\n\n# 父级添加::after伪元素\n\n父级添加::after伪元素，是额外标签法的升级版。给父元素添加。强烈推荐！🔥\n\n/* 为了兼容IE8可以写单冒号 */\n.clearfix::after {\n  /* content是使用伪元素必须出现的 */\n  content: \'\';\n  /* 伪元素默认为行内元素，需改为块级元素 */\n  display: block;\n  clear: both;\n\n  /* 为了兼容旧浏览器，需写下面2行代码，代表不看到该元素 */\n  height: 0;\n  visibility: hidden;\n}\n.clearfix {\n  /* 兼容 IE6、7，禁止缩放 */\n  *zoom: 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n * 优点：没有增加标签，结构更简单\n\n * 缺点：照顾低版本浏览器\n   \n   代表网站：百度、淘宝网、网易\n\n\n# 父级添加双伪元素 🔥\n\n父级添加双伪元素，可以看作上述升级版。给父元素添加。强烈推荐！🔥\n\n/* 为了兼容IE8可以写单冒号 */\n.clearfix::before,\n.clearfix::after {\n  content: \'\';\n  /* 直接使用block，则before和after会在两行显示，不适用 */\n  display: table;\n}\n.clearfix:after {\n  clear: both;\n}\n.clearfix {\n  /* IE6、7 专有 */\n  *zoom: 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n.clearfix::before可以解决父子元素边界折叠问题：添加了一个空元素，子元素的margin-top相对于该元素\n\n.clearfix::after可以解决高度塌陷问题，添加了一个空块元素，并清除浮动\n\n * 优点：代码更简洁\n\n * 缺点：照顾低版本浏览器\n   \n   代表网站：小米、腾讯等',normalizedContent:'# float 浮动\n\n\n# 浮动规则\n\n选择器 {\n  float: 属性值;\n}\n\n\n1\n2\n3\n\n\n值         描述\nleft      元素向左浮动。\nright     元素向右浮动。\nnone      默认值。元素不浮动，并会显示在其在文本中出现的位置。\ninherit   规定应该从父元素继承 float 属性的值。\n\n * 脱标。查看脱离标准流元素特点总结元素类型\n\n * 浮动用于创建浮动框，将元素横向移到一边，直到左边缘或右边缘触及 包含块（容器或父元素） 或 另一个浮动框 的边缘。\n\n * 浮动的元素允许文本和行内元素（inline 或 inline-block 等）环绕它\n\n * 行内元素（inline 或 inline-block 等）浮动后，其顶部将与所在行的顶部对齐，不会朝上浮\n\n * 定位元素（非 static）会层叠在浮动元素上（按标准流——浮动——定位的顺序）。浮动元素间不能层叠（不多解释）。\n\n * 浮动元素的顶端不能超过包含块的顶端，也不能超过之前所有浮动元素的的顶端（以最低的为界限）\n   \n   \n\n * 如果包含框太窄，无法容纳水平排列的三个浮动元素，那么其它浮动块向下移动，直到有足够的空间；如果浮动元素的高度不同，那么当它们向下移动时可能被其它浮动元素“卡住”\n   \n   \n\n\n# 脱离标准流元素特点—重复 🔥\n\n * 可以设置width、height\n * 默认width、height由内容决定\n * 不再给父元素汇报width、height数据，即父元素也不知道该元素了\n * 类似inline-block，但是不是！是block！\n\n注意\n\ndisplay、position、float 都都影响盒子的生成和布局：\n\n * 当 display 为 none 时，就不会生成盒子，对 position 和 float 无影响\n * 当 postion 为 absolute 或 fixed 时，或 float 为 left 或 right 时，元素基本都变为 block 类型（除了布局类型）详细参考文档\n\n\n# 现象思考 🤔\n\n<div class="box">\n  <div class="inner1"></div>\n  <div class="inner2">\n    我是inner2的文本\n  </div>\n</div>\n\n\n1\n2\n3\n4\n5\n6\n\n * 当 inner1 进行左浮动/右浮动时，只会在当前自己行中浮动\n * 当 inner1 进行左浮动时，inner2 在没有浮动时，inner1 和 2 会如何排布\n * 当 inner1 进行左浮动时，inner2 在没有浮动时，但是 inner2 中有文字，文字会如何排布（假设 inner2 面积大于 inner1）\n * 当 inner1 进行左浮动时，inner2 也进行左浮动，那么 inner1 和 inner2 依次在地一行排布\n * 当 inner1 进行左浮动时，inner2 也进行左浮动，但是父元素没有设置高度，此时父元素的高度会消失（高度的坍塌）\n\n\n# 浮动的应用\n\n * 解决行内元素（包括inline-block）的水平间隙问题\n * 布局\n\n\n# 高度坍塌 🔥\n\n由于父级盒子很多情况下，不方便给高度，但是子盒子浮动又不占有位置，所以由于父级盒子高度为 0，就影响了下面的标准流盒子。\n\n\n# bfc 🔥\n\nbfc（block formatting context）块级格式化环境，bfc 是一个 css 中的一个隐含的属性，可以为一个元素开启 bfc，开启 bfc 该元素会变成一个独立的布局区域。未开启时，整个页面是一个布局整体。\n\n可以通过一些特殊方式来开启元素的 bfc（可参考mdn文档）：\n\n * 设置元素的浮动（不推荐，高度不会坍塌，但是脱离标准流后 width 随即丢失）\n\n * 将元素设置为行内块元素（不推荐，不推荐用于外部容器，且 width 也丢失了）\n\n * 绝对定位（不推荐）\n\n * 将元素的 overflow 设置为一个非 visible 的值（也不完美，最终推荐 clear ）\n   \n   常用的方式即为要开启 bfc 的元素设置 overflow:hidden，以使其可以包含浮动元素\n\n元素开启 bfc后的特点：\n\n * 开启 bfc 的元素可以包含浮动的子元素，即解决高度塌陷问题\n   \n   <style>\n   .outer {\n     border: 10px red solid;\n     overflow: hidden;\n   }\n   .inner {\n     float: left;\n     width: 100px;\n     height: 100px;\n     background-color: skyblue;\n   }\n   </style>\n   <div class="outer">\n   \t<div class="inner"></div>\n   </div>\n   <div style="width: 200px; height: 200px; background-color: yellow;"></div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * 开启 bfc 的元素不会被浮动元素所覆盖（兄弟元素）\n   \n   <style>\n     .box1 {\n       width: 200px;\n       height: 200px;\n       background-color: skyblue;\n       float: left;\n     }\n   \n     .box2 {\n       width: 200px;\n       height: 200px;\n       background-color: orange;\n       overflow: hidden;\n     }\n   </style>\n   <div class="box1"></div>\n   <div class="box2"></div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   \n\n * 开启 bfc 的元素子元素和父元素外边距不会重叠\n   \n   本来是 box1 带着 box3 往下移动 100px；之后正常\n   \n   <style>\n   .box1 {\n     width: 200px;\n     height: 200px;\n     background-color: skyblue;\n     overflow: hidden;\n   }\n   \n   .box3 {\n     width: 100px;\n     height: 100px;\n     background-color: yellow;\n     margin-top: 100px;\n   }\n   </style>\n   <div class="box1">\n   \t<div class="box3"></div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   \n\n\n# 清除浮动 🔥\n\n\n# 简介\n\n清除浮动的本质是清除浮动元素造成的影响。如果父盒子本身有高度，则不需要清除浮动\n\n设置清除浮动之后，浏览器会自动为元素添加一个上外边距，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了\n\n选择器 {\n  clear: 属性值;\n}\n\n\n1\n2\n3\n\n\n值         描述\nleft      在左侧不允许浮动元素。要求元素（新）的顶部低于之前生成的所有左浮动元素的底部。其他同理\nright     在右侧不允许浮动元素。\nboth      清除两侧中最大影响的那侧。实际工作中， 几乎只用 both\nnone      默认值。允许浮动元素出现在两侧。\ninherit   规定应该从父元素继承 clear 属性的值。\n\n清除浮动的策略是：闭合浮动，将浮动元素只限制到父元素中\n\n\n# 父元素增加 height—不推荐\n\n略\n\n\n# 额外块元素法—隔墙法\n\n额外标签法也称为隔墙法，是 w3c 推荐的做法。但是不常用。额外标签法会在浮动元素末尾添加一个空的块级元素。例如\n\n<div style="clear:both"></div>\n\n\n1\n\n\n或者br标签（没见过这种写法）\n\n<br clear="all" />\n\n\n1\n\n\n * 优点: 通俗易懂，书写方便\n\n * 缺点: 添加许多无意义的标签，且样式与结构耦合。\n\n\n# 父级添加::after伪元素\n\n父级添加::after伪元素，是额外标签法的升级版。给父元素添加。强烈推荐！🔥\n\n/* 为了兼容ie8可以写单冒号 */\n.clearfix::after {\n  /* content是使用伪元素必须出现的 */\n  content: \'\';\n  /* 伪元素默认为行内元素，需改为块级元素 */\n  display: block;\n  clear: both;\n\n  /* 为了兼容旧浏览器，需写下面2行代码，代表不看到该元素 */\n  height: 0;\n  visibility: hidden;\n}\n.clearfix {\n  /* 兼容 ie6、7，禁止缩放 */\n  *zoom: 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n * 优点：没有增加标签，结构更简单\n\n * 缺点：照顾低版本浏览器\n   \n   代表网站：百度、淘宝网、网易\n\n\n# 父级添加双伪元素 🔥\n\n父级添加双伪元素，可以看作上述升级版。给父元素添加。强烈推荐！🔥\n\n/* 为了兼容ie8可以写单冒号 */\n.clearfix::before,\n.clearfix::after {\n  content: \'\';\n  /* 直接使用block，则before和after会在两行显示，不适用 */\n  display: table;\n}\n.clearfix:after {\n  clear: both;\n}\n.clearfix {\n  /* ie6、7 专有 */\n  *zoom: 1;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n.clearfix::before可以解决父子元素边界折叠问题：添加了一个空元素，子元素的margin-top相对于该元素\n\n.clearfix::after可以解决高度塌陷问题，添加了一个空块元素，并清除浮动\n\n * 优点：代码更简洁\n\n * 缺点：照顾低版本浏览器\n   \n   代表网站：小米、腾讯等',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"定位",frontmatter:{title:"定位",date:"2020-03-15T17:01:58.000Z",permalink:"/pages/558f03/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/300.CSS%E5%B8%83%E5%B1%80/304.CSS-%E5%AE%9A%E4%BD%8D.html",relativePath:"1100.H5&CSS3/300.CSS布局/304.CSS-定位.md",key:"v-5c3398e2",path:"/pages/558f03/",headers:[{level:2,title:"为什么需要定位",slug:"为什么需要定位",normalizedTitle:"为什么需要定位",charIndex:18},{level:2,title:"定位组成",slug:"定位组成",normalizedTitle:"定位组成",charIndex:269},{level:2,title:"static 静态定位",slug:"static-静态定位",normalizedTitle:"static 静态定位",charIndex:383},{level:2,title:"relative 相对定位 🔥",slug:"relative-相对定位-🔥",normalizedTitle:"relative 相对定位 🔥",charIndex:474},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:495},{level:3,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:708},{level:3,title:"首页大图居中案例",slug:"首页大图居中案例",normalizedTitle:"首页大图居中案例",charIndex:753},{level:2,title:"absolute 绝对定位 🔥",slug:"absolute-绝对定位-🔥",normalizedTitle:"absolute 绝对定位 🔥",charIndex:1201},{level:3,title:"简介",slug:"简介-2",normalizedTitle:"简介",charIndex:495},{level:3,title:"子绝父相的由来",slug:"子绝父相的由来",normalizedTitle:"子绝父相的由来",charIndex:1440},{level:2,title:"fixed 固定定位 🔥",slug:"fixed-固定定位-🔥",normalizedTitle:"fixed 固定定位 🔥",charIndex:1699},{level:2,title:"Horizontal / Vertical Formatting",slug:"horizontal-vertical-formatting",normalizedTitle:"horizontal / vertical formatting",charIndex:1936},{level:3,title:"Horizontal",slug:"horizontal",normalizedTitle:"horizontal",charIndex:1936},{level:3,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:759},{level:2,title:"sticky 粘性定位 🔥",slug:"sticky-粘性定位-🔥",normalizedTitle:"sticky 粘性定位 🔥",charIndex:4669},{level:2,title:"inherit 继承",slug:"inherit-继承",normalizedTitle:"inherit 继承",charIndex:4867},{level:2,title:"偏移量 offset",slug:"偏移量-offset",normalizedTitle:"偏移量 offset",charIndex:5179},{level:2,title:"脱离标准流元素特点—重复 🔥",slug:"脱离标准流元素特点-重复-🔥",normalizedTitle:"脱离标准流元素特点—重复 🔥",charIndex:5900},{level:2,title:"定位和浮动",slug:"定位和浮动",normalizedTitle:"定位和浮动",charIndex:6220}],headersStr:"为什么需要定位 定位组成 static 静态定位 relative 相对定位 🔥 简介 应用 首页大图居中案例 absolute 绝对定位 🔥 简介 子绝父相的由来 fixed 固定定位 🔥 Horizontal / Vertical Formatting Horizontal 案例 sticky 粘性定位 🔥 inherit 继承 偏移量 offset 脱离标准流元素特点—重复 🔥 定位和浮动",content:"# Position 定位\n\n\n# 为什么需要定位\n\n以下情况使用标准流或者浮动能实现吗？\n\n * 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子\n * 当我们滚动窗口的时候，盒子是固定屏幕某个位置的。\n\n以上效果，标准流或浮动都无法快速实现，此时需要定位来实现。\n\n * 浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。\n * 定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。\n * 且内联 inline 元素不能使用定位，需转换为 block 元素🔥\n\n\n# 定位组成\n\n * 定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子。\n * 定位 = 定位模式 + 边偏移\n * 定位模式决定元素的定位方式 ，它通过 CSS 的 position 属性来设置\n\n\n# static 静态定位\n\n默认值，静态定位，元素出现在标准流中（忽略 top, bottom, left, right 或者 z-index 声明，即没有边偏移）很少用到。\n\n\n# relative 相对定位 🔥\n\n\n# 简介\n\n * 相对定位，相对于元素在文档流中的原来位置进行定位\n\n * 元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化\n\n * 会提升元素的层级。可能会覆盖在其他元素之上，所以不影响其他元素布局即新的位置不会占用其他元素空间。\n\n * 没有脱标。原来在标准流的位置继续占有，后面的盒子仍以标准流的方式对待它，不能使用该位置。灵魂出窍😂\n   \n   相对定位不会改变元素的性质，块还是块，行内还是行内\n\n\n# 应用\n\n最典型的应用是给绝对定位当爹的（限制绝对定位），以及对元素位置进行微调。\n\n\n# 首页大图居中案例\n\n * 显示大图主内容（居中）\n * 不能出现 x 轴滚动条\n * 所以 img 需要向左移动：(img-box)/2，化简为-img/2 + box/2\n\n.box {\n  /* 设置最小宽度 */\n  min-width: 1000px;\n  /* 隐藏多余的 */\n  overflow: hidden;\n}\n.box img {\n  /* 向左移动img一半 */\n  position: relative;\n\n  /* 硬编码不好，但是不能写%，因为此处%是相对于包含块即父元素，而我们需要的是相对于元素本身。可以选择translate百分比 */\n  /* left: -960px; */\n  transform: translate(-50%);\n\n  /* 向右移动父元素的一半，使用百分数可以根据视窗灵活调整 */\n  margin-left: 50%;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# absolute 绝对定位 🔥\n\n\n# 简介\n\n * 绝对定位，相对于非 static 定位的最近祖先元素进行定位。最终还没找到，则相对于浏览器视口即 viewport 来定位\n\n * 开启绝对定位后，如果不设置偏移量元素的位置不会发生变化。偏移量（非z-index）赋值为0后位置可能会改变\n\n * 绝对定位会使元素提升一个层级\n\n * 脱标。不再占有原先的位置，其他盒子可以使用原先位置\n   \n   会改变元素的性质（脱标特点），行内变成块，块的宽高被内容撑开\n\n\n# 子绝父相的由来\n\n * 在绝大多数情况下，子元素的绝对定位都是相对于父元素，好参考\n\n * 如果希望子元素相对父元素进行定位，又不希望父元素脱标！常用解决方案就是子绝父相\n   \n   * 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。\n   * 父盒子需要加定位限制子盒子在父盒子内显示。\n   * 父盒子布局时，需要占有位置，因此父亲只能是相对定位（其他 float 等也不行）。\n\n * 当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。\n\n\n# fixed 固定定位 🔥\n\n * 固定定位，相对于浏览器视口即 viewport 进行定位，跟父元素没有任何关系。可以看做是一种特殊的绝对定位。即使画布滚动元素位置也不会改变。\n\n * 脱标。不再占有原先的位置。其他盒子可以使用原先位置\n   \n   会改变元素的性质（脱标特点），行内变成块，块的宽高被内容撑开\n\n右侧固定按键案例（这个其实是配合 JS 实现的粘性定位）：\n\n * 先不使用固定定位\n * 当画布移动到某个位置时，添加固定定位。配合 JS 实现\n\n\n# Horizontal / Vertical Formatting\n\n参考 W3C 文档和 MDN 文档\n\n\n# Horizontal\n\n对于绝对定位元素即 position 为 absolute 或 fixed 的元素来说。需要满足如下约束：\n\nleft + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right\n= \nwidth of containing block\n\n\n1\n2\n3\n\n * 🔥上述值中只有 'width'， 'margin-left' 和 'margin-right'，'left' 和 'right' 可以设置为 'auto'，且 'width'，'left' 和 'right' 默认就是 'auto'。其余几个属性必须设置为特定的值或默认值为 0。width 只可设置为非负值，只有 'margin'，'left' 和 'right'可以为负值。\n * 🔥大多数情况下，height和width 被设定为auto的绝对定位元素，按其内容大小调整尺寸。但是，被绝对定位的元素可以通过指定top和bottom ，保留height未指定（即auto），来填充可用的垂直空间。它们同样可以通过指定left 和 right并将width 指定为auto来填充可用的水平空间。\n * 其他的文档中看不懂😓\n\n水平方向同理！\n\n\n# 案例\n\n * 若希望绝对定位元素的宽高和定位参考对象一样，可以给绝对定位元素设置如下属性\n   \n   <style>\n     .box1 {\n       position: relative;\n       width: 500px;\n       height: 500px;\n       background-color: skyblue;\n     }\n   \n     .box2 {\n       position: absolute;\n       background-color: orange;\n       \n       /* 绝对定位元素的宽高和定位参考对象一样 */\n       /* left: 0;\n       right: 0;\n       top: 0;\n       bottom: 0; */\n   \n       /* 绝对定位元素的宽和定位参考对象一样 */\n       /* left: 0;\n       right: 0;\n       height: 100px; */\n   \n       /* 绝对定位元素的高和定位参考对象一样 */\n       /* top: 0;\n       bottom: 0;\n       width: 100px; */\n     }\n   </style>\n   <div class=\"box1\">\n     <div class=\"box2\"></div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n * 若希望绝对定位元素在定位参考对象中居中（垂直 / 水平）显示（宽高确定！），可以给绝对定位元素设置如下属性\n   \n   <style>\n   .box1 {\n     position: relative;\n     width: 500px;\n     height: 500px;\n     background-color: skyblue;\n   }\n   \n   .box2 {\n     position: absolute;\n     background-color: orange;\n     width: 100px;\n     height: 100px;\n   \n     /* 水平且垂直居中 */\n     /* left: 0;\n     right: 0;\n     top: 0;\n     bottom: 0;\n     margin: auto; */\n   \n     /* 水平居中，margin 二选一*/\n     /* left: 0;\n     right: 0;\n     margin: 0 auto;\n     margin: auto */\n   \n     /* 垂直居中，margin 二选一 */\n     /* top: 0;\n     bottom: 0;\n     margin: auto 0;\n     margin: auto; */\n   }\n   </style>\n   <div class=\"box1\">\n   \t<div class=\"box2\"></div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   \n\n * 当然也可以使用transform实现，特别适用于宽高不确定\n   \n   <style>\n     .box1 {\n       background-color: skyblue;\n       position: absolute;\n       top: 50%;\n       left: 50%;\n       transform: translate(50%, 50%);\n     }\n   </style>\n   <div class=\"box1\">666</div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n\n# sticky 粘性定位 🔥\n\n * 粘性定位可以被认为是相对定位 relative和固定定位 fixed的混合\n\n * 以浏览器的可视窗口为参照点移动元素（固定定位特点）\n\n * 粘性定位占有原先的位置（相对定位特点）\n\n * 必须添加 top 、left、right、bottom 其中一个才有效\n\n注意\n\n跟页面滚动搭配使用。 兼容性较差，IE 不支持，目前大部分使用 JS 实现\n\n\n# inherit 继承\n\n规定应该从父元素继承 position 属性的值。\n\n定位模式            是否脱标         移动位置        是否常用\nstatic 静态定位     否            不能使用边偏移     很少\nrelative 相对定位   否 (占有原来位置)   相对于自身位置移动   常用\nabsolute 绝对定位   是            带有定位的父级     常用\nfixed 固定定位      是            浏览器可视区      常用\nsticky 粘性定位     否 (占有原来位置)   浏览器可视区      当前阶段少\n\n\n# 偏移量 offset\n\n边偏移就是定位的元素移动到最终位置，非定位元素使用无效\n\n属性               描述\ntop              定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。\nright            定义了定位元素右外边距边界与其包含块右边界之间的偏移。\nbottom           定义了定位元素下外边距边界与其包含块下边界之间的偏移。\nleft             定义了定位元素左外边距边界与其包含块左边界之间的偏移。\noverflow         设置当元素的内容溢出其区域时发生的事情。\nclip             设置元素的形状。元素被剪入这个形状之中，然后显示出来。\nvertical-align   设置元素的垂直对齐方式。\nz-index          设置元素的堆叠顺序，z 轴距离，默认为 auto，可负数，数字后面不能加单位。定位盒子才有该属性，如果属性值相同，则按照\n                 HTML 元素的书写顺序，后来居上。\n\n元素的层叠\n\n * 父子关系\n   \n   子元素会层叠在父元素上，无法通过z-index来控制\n\n * 非父子关系\n   \n   * 都是非定位元素（即 static）：在标准流中一般不存在层叠现象\n   * 1 个是定位、1 个是非定位：定位元素会层叠在非定位元素上\n   * 都是定位元素：默认后写的 HTML 元素层叠在先写的上面，可以使用z-index来控制\n\n提示\n\n若一个盒子既有 left 也有 right，则 left 优先级高；同理 top 比 bottom 优先级高\n\n\n# 脱离标准流元素特点—重复 🔥\n\n * 可以设置width、height\n * 默认width、height由内容决定\n * 不再给父元素汇报width、height数据，即父元素也不知道该元素了\n * 类似inline-block，但是不是！是block！\n\n注意\n\ndisplay、position、float 都都影响盒子的生成和布局：\n\n * 当 display 为 none 时，就不会生成盒子，对 position 和 float 无影响\n * 当 postion 为 absolute 或 fixed 时，或 float 为 left 或 right 时，元素基本都变为 block 类型（除了布局类型）详细参考文档\n\n\n# 定位和浮动\n\n * 绝对定位（固定定位）会压住下面标准流所有的内容\n   \n   浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）\n   \n   浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素",normalizedContent:"# position 定位\n\n\n# 为什么需要定位\n\n以下情况使用标准流或者浮动能实现吗？\n\n * 某个元素可以自由的在一个盒子内移动位置，并且压住其他盒子\n * 当我们滚动窗口的时候，盒子是固定屏幕某个位置的。\n\n以上效果，标准流或浮动都无法快速实现，此时需要定位来实现。\n\n * 浮动可以让多个块级盒子一行没有缝隙排列显示， 经常用于横向排列盒子。\n * 定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中某个位置，并且可以压住其他盒子。\n * 且内联 inline 元素不能使用定位，需转换为 block 元素🔥\n\n\n# 定位组成\n\n * 定位：将盒子定在某一个位置，所以定位也是在摆放盒子，按照定位的方式移动盒子。\n * 定位 = 定位模式 + 边偏移\n * 定位模式决定元素的定位方式 ，它通过 css 的 position 属性来设置\n\n\n# static 静态定位\n\n默认值，静态定位，元素出现在标准流中（忽略 top, bottom, left, right 或者 z-index 声明，即没有边偏移）很少用到。\n\n\n# relative 相对定位 🔥\n\n\n# 简介\n\n * 相对定位，相对于元素在文档流中的原来位置进行定位\n\n * 元素开启相对定位以后，如果不设置偏移量元素不会发生任何的变化\n\n * 会提升元素的层级。可能会覆盖在其他元素之上，所以不影响其他元素布局即新的位置不会占用其他元素空间。\n\n * 没有脱标。原来在标准流的位置继续占有，后面的盒子仍以标准流的方式对待它，不能使用该位置。灵魂出窍😂\n   \n   相对定位不会改变元素的性质，块还是块，行内还是行内\n\n\n# 应用\n\n最典型的应用是给绝对定位当爹的（限制绝对定位），以及对元素位置进行微调。\n\n\n# 首页大图居中案例\n\n * 显示大图主内容（居中）\n * 不能出现 x 轴滚动条\n * 所以 img 需要向左移动：(img-box)/2，化简为-img/2 + box/2\n\n.box {\n  /* 设置最小宽度 */\n  min-width: 1000px;\n  /* 隐藏多余的 */\n  overflow: hidden;\n}\n.box img {\n  /* 向左移动img一半 */\n  position: relative;\n\n  /* 硬编码不好，但是不能写%，因为此处%是相对于包含块即父元素，而我们需要的是相对于元素本身。可以选择translate百分比 */\n  /* left: -960px; */\n  transform: translate(-50%);\n\n  /* 向右移动父元素的一半，使用百分数可以根据视窗灵活调整 */\n  margin-left: 50%;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# absolute 绝对定位 🔥\n\n\n# 简介\n\n * 绝对定位，相对于非 static 定位的最近祖先元素进行定位。最终还没找到，则相对于浏览器视口即 viewport 来定位\n\n * 开启绝对定位后，如果不设置偏移量元素的位置不会发生变化。偏移量（非z-index）赋值为0后位置可能会改变\n\n * 绝对定位会使元素提升一个层级\n\n * 脱标。不再占有原先的位置，其他盒子可以使用原先位置\n   \n   会改变元素的性质（脱标特点），行内变成块，块的宽高被内容撑开\n\n\n# 子绝父相的由来\n\n * 在绝大多数情况下，子元素的绝对定位都是相对于父元素，好参考\n\n * 如果希望子元素相对父元素进行定位，又不希望父元素脱标！常用解决方案就是子绝父相\n   \n   * 子级绝对定位，不会占有位置，可以放到父盒子里面的任何一个地方，不会影响其他的兄弟盒子。\n   * 父盒子需要加定位限制子盒子在父盒子内显示。\n   * 父盒子布局时，需要占有位置，因此父亲只能是相对定位（其他 float 等也不行）。\n\n * 当然，子绝父相不是永远不变的，如果父元素不需要占有位置，子绝父绝也会遇到。\n\n\n# fixed 固定定位 🔥\n\n * 固定定位，相对于浏览器视口即 viewport 进行定位，跟父元素没有任何关系。可以看做是一种特殊的绝对定位。即使画布滚动元素位置也不会改变。\n\n * 脱标。不再占有原先的位置。其他盒子可以使用原先位置\n   \n   会改变元素的性质（脱标特点），行内变成块，块的宽高被内容撑开\n\n右侧固定按键案例（这个其实是配合 js 实现的粘性定位）：\n\n * 先不使用固定定位\n * 当画布移动到某个位置时，添加固定定位。配合 js 实现\n\n\n# horizontal / vertical formatting\n\n参考 w3c 文档和 mdn 文档\n\n\n# horizontal\n\n对于绝对定位元素即 position 为 absolute 或 fixed 的元素来说。需要满足如下约束：\n\nleft + margin-left + border-left-width + padding-left + width + padding-right + border-right-width + margin-right + right\n= \nwidth of containing block\n\n\n1\n2\n3\n\n * 🔥上述值中只有 'width'， 'margin-left' 和 'margin-right'，'left' 和 'right' 可以设置为 'auto'，且 'width'，'left' 和 'right' 默认就是 'auto'。其余几个属性必须设置为特定的值或默认值为 0。width 只可设置为非负值，只有 'margin'，'left' 和 'right'可以为负值。\n * 🔥大多数情况下，height和width 被设定为auto的绝对定位元素，按其内容大小调整尺寸。但是，被绝对定位的元素可以通过指定top和bottom ，保留height未指定（即auto），来填充可用的垂直空间。它们同样可以通过指定left 和 right并将width 指定为auto来填充可用的水平空间。\n * 其他的文档中看不懂😓\n\n水平方向同理！\n\n\n# 案例\n\n * 若希望绝对定位元素的宽高和定位参考对象一样，可以给绝对定位元素设置如下属性\n   \n   <style>\n     .box1 {\n       position: relative;\n       width: 500px;\n       height: 500px;\n       background-color: skyblue;\n     }\n   \n     .box2 {\n       position: absolute;\n       background-color: orange;\n       \n       /* 绝对定位元素的宽高和定位参考对象一样 */\n       /* left: 0;\n       right: 0;\n       top: 0;\n       bottom: 0; */\n   \n       /* 绝对定位元素的宽和定位参考对象一样 */\n       /* left: 0;\n       right: 0;\n       height: 100px; */\n   \n       /* 绝对定位元素的高和定位参考对象一样 */\n       /* top: 0;\n       bottom: 0;\n       width: 100px; */\n     }\n   </style>\n   <div class=\"box1\">\n     <div class=\"box2\"></div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   \n\n * 若希望绝对定位元素在定位参考对象中居中（垂直 / 水平）显示（宽高确定！），可以给绝对定位元素设置如下属性\n   \n   <style>\n   .box1 {\n     position: relative;\n     width: 500px;\n     height: 500px;\n     background-color: skyblue;\n   }\n   \n   .box2 {\n     position: absolute;\n     background-color: orange;\n     width: 100px;\n     height: 100px;\n   \n     /* 水平且垂直居中 */\n     /* left: 0;\n     right: 0;\n     top: 0;\n     bottom: 0;\n     margin: auto; */\n   \n     /* 水平居中，margin 二选一*/\n     /* left: 0;\n     right: 0;\n     margin: 0 auto;\n     margin: auto */\n   \n     /* 垂直居中，margin 二选一 */\n     /* top: 0;\n     bottom: 0;\n     margin: auto 0;\n     margin: auto; */\n   }\n   </style>\n   <div class=\"box1\">\n   \t<div class=\"box2\"></div>\n   </div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   \n\n * 当然也可以使用transform实现，特别适用于宽高不确定\n   \n   <style>\n     .box1 {\n       background-color: skyblue;\n       position: absolute;\n       top: 50%;\n       left: 50%;\n       transform: translate(50%, 50%);\n     }\n   </style>\n   <div class=\"box1\">666</div>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n\n# sticky 粘性定位 🔥\n\n * 粘性定位可以被认为是相对定位 relative和固定定位 fixed的混合\n\n * 以浏览器的可视窗口为参照点移动元素（固定定位特点）\n\n * 粘性定位占有原先的位置（相对定位特点）\n\n * 必须添加 top 、left、right、bottom 其中一个才有效\n\n注意\n\n跟页面滚动搭配使用。 兼容性较差，ie 不支持，目前大部分使用 js 实现\n\n\n# inherit 继承\n\n规定应该从父元素继承 position 属性的值。\n\n定位模式            是否脱标         移动位置        是否常用\nstatic 静态定位     否            不能使用边偏移     很少\nrelative 相对定位   否 (占有原来位置)   相对于自身位置移动   常用\nabsolute 绝对定位   是            带有定位的父级     常用\nfixed 固定定位      是            浏览器可视区      常用\nsticky 粘性定位     否 (占有原来位置)   浏览器可视区      当前阶段少\n\n\n# 偏移量 offset\n\n边偏移就是定位的元素移动到最终位置，非定位元素使用无效\n\n属性               描述\ntop              定义了一个定位元素的上外边距边界与其包含块上边界之间的偏移。\nright            定义了定位元素右外边距边界与其包含块右边界之间的偏移。\nbottom           定义了定位元素下外边距边界与其包含块下边界之间的偏移。\nleft             定义了定位元素左外边距边界与其包含块左边界之间的偏移。\noverflow         设置当元素的内容溢出其区域时发生的事情。\nclip             设置元素的形状。元素被剪入这个形状之中，然后显示出来。\nvertical-align   设置元素的垂直对齐方式。\nz-index          设置元素的堆叠顺序，z 轴距离，默认为 auto，可负数，数字后面不能加单位。定位盒子才有该属性，如果属性值相同，则按照\n                 html 元素的书写顺序，后来居上。\n\n元素的层叠\n\n * 父子关系\n   \n   子元素会层叠在父元素上，无法通过z-index来控制\n\n * 非父子关系\n   \n   * 都是非定位元素（即 static）：在标准流中一般不存在层叠现象\n   * 1 个是定位、1 个是非定位：定位元素会层叠在非定位元素上\n   * 都是定位元素：默认后写的 html 元素层叠在先写的上面，可以使用z-index来控制\n\n提示\n\n若一个盒子既有 left 也有 right，则 left 优先级高；同理 top 比 bottom 优先级高\n\n\n# 脱离标准流元素特点—重复 🔥\n\n * 可以设置width、height\n * 默认width、height由内容决定\n * 不再给父元素汇报width、height数据，即父元素也不知道该元素了\n * 类似inline-block，但是不是！是block！\n\n注意\n\ndisplay、position、float 都都影响盒子的生成和布局：\n\n * 当 display 为 none 时，就不会生成盒子，对 position 和 float 无影响\n * 当 postion 为 absolute 或 fixed 时，或 float 为 left 或 right 时，元素基本都变为 block 类型（除了布局类型）详细参考文档\n\n\n# 定位和浮动\n\n * 绝对定位（固定定位）会压住下面标准流所有的内容\n   \n   浮动元素不同，只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字（图片）\n   \n   浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"传统布局总结",frontmatter:{title:"传统布局总结",date:"2019-12-22T19:44:02.000Z",permalink:"/pages/78ced3/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/300.CSS%E5%B8%83%E5%B1%80/305.CSS-%E4%BC%A0%E7%BB%9F%E5%B8%83%E5%B1%80%E6%80%BB%E7%BB%93.html",relativePath:"1100.H5&CSS3/300.CSS布局/305.CSS-传统布局总结.md",key:"v-00d198cf",path:"/pages/78ced3/",headers:[{level:2,title:"布局方案",slug:"布局方案",normalizedTitle:"布局方案",charIndex:13},{level:2,title:"常见布局技巧",slug:"常见布局技巧",normalizedTitle:"常见布局技巧",charIndex:254},{level:3,title:"margin 负值的运用",slug:"margin-负值的运用",normalizedTitle:"margin 负值的运用",charIndex:265},{level:3,title:"文字围绕浮动元素",slug:"文字围绕浮动元素",normalizedTitle:"文字围绕浮动元素",charIndex:456},{level:3,title:"行内块的巧妙运用",slug:"行内块的巧妙运用",normalizedTitle:"行内块的巧妙运用",charIndex:519},{level:2,title:"传统布局总结及案例 🔥",slug:"传统布局总结及案例-🔥",normalizedTitle:"传统布局总结及案例 🔥",charIndex:3638},{level:3,title:"1 CSS 初始化",slug:"_1-css-初始化",normalizedTitle:"1 css 初始化",charIndex:3655},{level:3,title:"2 CSS 属性书写顺序",slug:"_2-css-属性书写顺序",normalizedTitle:"2 css 属性书写顺序",charIndex:5155},{level:3,title:"3 页面整体布局思路",slug:"_3-页面整体布局思路",normalizedTitle:"3 页面整体布局思路",charIndex:5533},{level:3,title:"4 确定版心",slug:"_4-确定版心",normalizedTitle:"4 确定版心",charIndex:5745},{level:3,title:"5 头部盒子",slug:"_5-头部盒子",normalizedTitle:"5 头部盒子",charIndex:5858},{level:3,title:"6 banner",slug:"_6-banner",normalizedTitle:"6 banner",charIndex:6203},{level:3,title:"7 footer",slug:"_7-footer",normalizedTitle:"7 footer",charIndex:6216},{level:3,title:"8 hot",slug:"_8-hot",normalizedTitle:"8 hot",charIndex:6229},{level:3,title:"9 轮播图",slug:"_9-轮播图",normalizedTitle:"9 轮播图",charIndex:6252},{level:2,title:"bootstrap",slug:"bootstrap",normalizedTitle:"bootstrap",charIndex:6292},{level:3,title:"入门",slug:"入门",normalizedTitle:"入门",charIndex:6306},{level:3,title:"布局容器",slug:"布局容器",normalizedTitle:"布局容器",charIndex:6912},{level:3,title:"栅格系统",slug:"栅格系统",normalizedTitle:"栅格系统",charIndex:7064},{level:3,title:"全局 CSS 样式、组件、插件",slug:"全局-css-样式、组件、插件",normalizedTitle:"全局 css 样式、组件、插件",charIndex:8184},{level:3,title:"其他详细的看文档去吧！",slug:"其他详细的看文档去吧",normalizedTitle:"其他详细的看文档去吧！",charIndex:8426}],headersStr:"布局方案 常见布局技巧 margin 负值的运用 文字围绕浮动元素 行内块的巧妙运用 传统布局总结及案例 🔥 1 CSS 初始化 2 CSS 属性书写顺序 3 页面整体布局思路 4 确定版心 5 头部盒子 6 banner 7 footer 8 hot 9 轮播图 bootstrap 入门 布局容器 栅格系统 全局 CSS 样式、组件、插件 其他详细的看文档去吧！",content:'# 传统布局总结\n\n\n# 布局方案\n\n * 标准流：垂直布局\n * 浮动：水平布局（利用标准流约束浮动元素位置）\n * 定位（绝对定位、固定定位）：层叠布局\n\n注意\n\n * 般先设置盒子的大小，之后设置盒子的位置\n * 一个元素浮动了，理论上其余的兄弟元素也要浮动，以防止引起问题（浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流（前面的标准流占一行，无论在浮动盒子的上面还是下面）\n * 遇到 header 和 footer 需要和显示器等宽的，不需要设置 width，自动就是等宽的\n\n\n# 常见布局技巧\n\n\n# margin 负值的运用\n\n盒子细线边框加粗问题\n\n * 让每个盒子 margin 往左侧移动 -1px 正好压住相邻盒子边框（浏览器渲染时是分别渲染的，所以可以实现）\n\nhover 时右侧边框被右边盒子覆盖掉问题\n\n * 鼠标经过某个盒子的时候，提高当前盒子的层级即可。\n   \n   如果父盒子没有有定位，则加相对定位（保留位置）；如果父盒子有定位，则加z-index\n\n\n# 文字围绕浮动元素\n\n父盒子中有左侧图片和右侧文字，此时可以利用 float 的文字环绕来解决，不用再定义 2 个盒子\n\n\n# 行内块的巧妙运用\n\n利用行内块元素中间有缝隙，且可以使用text-align来居中，可以指定 width、height\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n    <title>行内块的巧妙运用</title>\n    <style>\n      * {\n        margin: 0;\n        padding: 0;\n      }\n      .box {\n        text-align: center;\n      }\n      .box a {\n        display: inline-block;\n        width: 36px;\n        height: 36px;\n        background-color: #f7f7f7;\n        border: 1px solid #ccc;\n        text-align: center;\n        line-height: 36px;\n        text-decoration: none;\n        color: #333;\n        font-size: 14px;\n      }\n      .box .prev,\n      .box .next {\n        width: 85px;\n      }\n      .box .current,\n      .box .elp {\n        background-color: #fff;\n        border: none;\n      }\n      .box input {\n        height: 36px;\n        width: 45px;\n        border: 1px solid #ccc;\n        outline: none;\n      }\n      .box button {\n        width: 60px;\n        height: 36px;\n        background-color: #f7f7f7;\n        border: 1px solid #ccc;\n      }\n    </style>\n  </head>\n  <body>\n    <div class="box">\n      <a href="#" class="prev">&lt;&lt;上一页</a>\n      <a href="#" class="current">2</a>\n      <a href="#">3</a>\n      <a href="#">4</a>\n      <a href="#">5</a>\n      <a href="#">6</a>\n      <a href="#" class="elp">...</a>\n      <a href="#" class="next">&gt;&gt;下一页</a>\n      到第\n      <input type="text" />\n      页\n      <button>确定</button>\n    </div>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n效果如下：\n\n<html>\n  <div class="demo1">\n    <div class="box">\n      <a href="#" class="prev">&lt;&lt;上一页</a>\n      <a href="#" class="current">2</a>\n      <a href="#">3</a>\n      <a href="#">4</a>\n      <a href="#">5</a>\n      <a href="#">6</a>\n      <a href="#" class="elp">...</a>\n      <a href="#" class="next">&gt;&gt;下一页</a>\n      到第\n      <input type="text" />\n      页\n      <button>确定</button>\n    </div>\n  </div>\n</html>\n\n<style>\n  .demo1 * {\n    margin: 0;\n    padding: 0;\n  }\n  .demo1 .box {\n    text-align: center;\n  }\n  .demo1 .box a {\n    display: inline-block;\n    width: 36px;\n    height: 36px;\n    background-color: #f7f7f7;\n    border: 1px solid #ccc;\n    text-align: center;\n    line-height: 36px;\n    text-decoration: none;\n    color: #333;\n    font-size: 14px;\n  }\n  .demo1 .box .prev,\n  .demo1 .box .next {\n    width: 85px;\n  }\n  .demo1 .box .current,\n  .demo1 .box .elp {\n    background-color: #fff;\n    border: none;\n  }\n  .demo1 .box input {\n    height: 36px;\n    width: 45px;\n    border: 1px solid #ccc;\n    outline: none;\n  }\n  .demo1 .box button {\n    width: 60px;\n    height: 36px;\n    background-color: #f7f7f7;\n    border: 1px solid #ccc;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n\n# 传统布局总结及案例 🔥\n\n\n# 1 CSS 初始化\n\n不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对 HTML 文本呈现的差异，照顾浏览器的兼 容，我们需要对 CSS 初始化，重设浏览器的样式，也称为 CSS reset。以京东 CSS 初始化代码为例：\n\n@charset "utf-8";\n\n/* 把我们所有标签的内外边距清零 */\n* {\n  margin: 0;\n  padding: 0;\n  /* 指定CSS3盒子模型 */\n  box-sizing: border-box;\n}\n\n/* 去掉li 的小圆点 */\nul,\nol,\nli {\n  list-style: none;\n}\n\na,\ninput,\nselect,\ntextarea,\nbutton {\n  /* 去掉蓝色边框 */\n  outline: none;\n  /* 去掉默认的灰色边框，不一定使用 */\n  border: none;\n}\n\n/* 去掉a的下划线 */\na {\n  text-decoration: none;\n  color: #333;\n}\n\nbutton {\n  /* 当我们鼠标经过button 按钮的时候，鼠标变成小手 */\n  cursor: pointer;\n}\n\nimg {\n  /* 取消图片底侧有空白缝隙的问题；图片和文字一起布局时，需要修改非基线对齐 */\n  vertical-align: middle;\n  /* border 0 或 none 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 */\n  border: none;\n}\n\n/* em 和 i 斜体的文字不倾斜 */\nem,\ni {\n  font-style: normal;\n}\n\n/* 表格 */\ntable {\n  border-collapse: collapse;\n  border-spacing: 0;\n}\n\nbody {\n  /* CSS3 抗锯齿形 让文字显示的更加清晰 */\n  -webkit-font-smoothing: antialiased;\n  background-color: #fff;\n}\n\n.hide,\n.none {\n  display: none;\n}\n\n/* ============= 浮动有关 start ============= */\n.f-left {\n  float: left;\n}\n\n.f-right {\n  float: right;\n}\n\n/* 清除浮动 */\n.clearfix:after {\n  visibility: hidden;\n  clear: both;\n  display: block;\n  content: \'.\';\n  height: 0;\n}\n\n.clearfix {\n  *zoom: 1;\n}\n/* ============= 浮动有关 end ============= */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n\n# 2 CSS 属性书写顺序\n\n * 布局定位属性:display / position / float / clear / visibility / overflow(建议 display 第一个写，关系到模式)\n * 自身属性:width / height / margin / padding / border / background\n * 文本属性:color / font / text-decoration / text-align / vertical-align / white- space / word-break\n * 其他属性(CSS3):content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient ...\n\n\n# 3 页面整体布局思路\n\n为了提高网页制作的效率，布局时通常有以下的布局流程:\n\n 1. 必须确定页面的版心(可视区)，基本上宽度都和它一致。测量可得知。\n 2. 分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行行罗列而成的。\n 3. 制作 HTML 结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。\n 4. 开始运用盒子模型的原理，通过 DIV+CSS 布局来控制网页的各个模块。\n\n\n# 4 确定版心\n\n这个页面的版心 width 是 1200 像素，每个版心都要水平居中对齐，可以定义版心为公共类:\n\n.w {\n  width: 1200px;\n  margin: auto;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 5 头部盒子\n\n * 1 号是版心盒子 header 1200 * 42 的盒子水平居中对齐，上下给一个 margin 值就可以\n * 版心盒子里面包含 2 号盒子 logo。div 布局好后放入 img 即可\n * 版心盒子里面包含 3 号盒子 nav 导航栏，实际开发中，nav 一般采用 li + a 的做法。语义更清楚，且若直接使用 a 来堆砌，搜索引擎容易辨别为有堆砌关键字嫌疑，有降权风险\n   * 给 li 浮动，li 是块级元素，a 是内联元素\n   * 导航栏可以不给宽度，将来可继续添加文字；因为文字不一样多，给a 左右 padding 来撑开盒子即可\n * 版心盒子里面包含 4 号盒子 search 搜索框。一个大 div 套 input 和 button\n\n\n# 6 banner\n\n\n# 7 footer\n\n\n# 8 hot\n\n利用 position\n\n\n# 9 轮播图\n\n利用 position\n\n父盒子相对定位，子模块绝对定位\n\n\n# bootstrap\n\n\n# 入门\n\n> 详细内容访问Bootstrap 中文网\n\n * 引入依赖\n   \n   * css：bootstrap.css\n   * js：jquery.js、popper.js(用于弹窗、提示、下拉菜单。版本 3 没有这个)、bootstrap.js\n\n * 响应式布局：一个网站可以兼容多个终端\n   \n   <meta charset="UTF-8" />\n   \x3c!--响应式 meta 标签;viewport宽度；初始缩放值；最小/最大缩放值；是否允许用户缩放--\x3e\n   \x3c!--还有minimum-scale；maximum-scale；user-scalable=true/false--\x3e\n   <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n   \x3c!--文档兼容模式--\x3e\n   <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   * viewport\n     * 移动设备上的就是设备的屏幕上能用来显示我们的网页的那一块区域\n   * px\n     * css 中 1px 并不等于设备的 1px\n\n * 步骤\n   \n   1. 定义布局容器：container、.container-fluid\n   2. 定义行：row\n   3. 定义列：col-xs-*、col-sm-*、col-md-*、col-lg-*、hidden-**（可以让元素在某个屏幕大小设备不显示）\n\n\n# 布局容器\n\n * Bootstrap 需要为页面内容和栅格系统包裹一个容器\n   * .container 类用于固定宽度（根据不同设备左右有固定留白，但 xs 没有留白）并支持响应式布局的容器\n   * .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器\n\n\n# 栅格系统\n\nBootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口(viewport)尺寸的增加，系统会自动分为最多12 列\n\n * 栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。工作原理如下：\n   * “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。\n   * 通过“行（row）”在水平方向创建一组“列（column）”。\n   * 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为“行（row）”的直接子元素。\n   * 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。Bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。\n   * 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。==多列嵌套时，可以通过==padding:0==来取消内边距，使得元素占满 viewport==\n   * 负值的margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。\n   * 栅格系统中的列是通过指定 1 到 12 的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。\n   * 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。\n   * 向上兼容且不向下兼容：栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类（可能每个列占一行）。 因此，在元素上应用任何 .col-md-*栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-*不存在， 也影响大屏幕设备。\n\n\n# 全局 CSS 样式、组件、插件\n\n全局 CSS 样式\n\n * 按钮： <button> (建议使用)、<a>、 <input> 。class="btn btn-default"\n * 图片：img-responsive"、img-rounded(方)、img-circle(圆)、img-thumbnail(相框)\n * 表格：table、table-bordered、table-hover\n * 表单：\n\n组件\n\n * 导航条\n * 分页：！！！\n\n插件\n\n * 轮播图\n\n\n# 其他详细的看文档去吧！',normalizedContent:'# 传统布局总结\n\n\n# 布局方案\n\n * 标准流：垂直布局\n * 浮动：水平布局（利用标准流约束浮动元素位置）\n * 定位（绝对定位、固定定位）：层叠布局\n\n注意\n\n * 般先设置盒子的大小，之后设置盒子的位置\n * 一个元素浮动了，理论上其余的兄弟元素也要浮动，以防止引起问题（浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流（前面的标准流占一行，无论在浮动盒子的上面还是下面）\n * 遇到 header 和 footer 需要和显示器等宽的，不需要设置 width，自动就是等宽的\n\n\n# 常见布局技巧\n\n\n# margin 负值的运用\n\n盒子细线边框加粗问题\n\n * 让每个盒子 margin 往左侧移动 -1px 正好压住相邻盒子边框（浏览器渲染时是分别渲染的，所以可以实现）\n\nhover 时右侧边框被右边盒子覆盖掉问题\n\n * 鼠标经过某个盒子的时候，提高当前盒子的层级即可。\n   \n   如果父盒子没有有定位，则加相对定位（保留位置）；如果父盒子有定位，则加z-index\n\n\n# 文字围绕浮动元素\n\n父盒子中有左侧图片和右侧文字，此时可以利用 float 的文字环绕来解决，不用再定义 2 个盒子\n\n\n# 行内块的巧妙运用\n\n利用行内块元素中间有缝隙，且可以使用text-align来居中，可以指定 width、height\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <title>行内块的巧妙运用</title>\n    <style>\n      * {\n        margin: 0;\n        padding: 0;\n      }\n      .box {\n        text-align: center;\n      }\n      .box a {\n        display: inline-block;\n        width: 36px;\n        height: 36px;\n        background-color: #f7f7f7;\n        border: 1px solid #ccc;\n        text-align: center;\n        line-height: 36px;\n        text-decoration: none;\n        color: #333;\n        font-size: 14px;\n      }\n      .box .prev,\n      .box .next {\n        width: 85px;\n      }\n      .box .current,\n      .box .elp {\n        background-color: #fff;\n        border: none;\n      }\n      .box input {\n        height: 36px;\n        width: 45px;\n        border: 1px solid #ccc;\n        outline: none;\n      }\n      .box button {\n        width: 60px;\n        height: 36px;\n        background-color: #f7f7f7;\n        border: 1px solid #ccc;\n      }\n    </style>\n  </head>\n  <body>\n    <div class="box">\n      <a href="#" class="prev">&lt;&lt;上一页</a>\n      <a href="#" class="current">2</a>\n      <a href="#">3</a>\n      <a href="#">4</a>\n      <a href="#">5</a>\n      <a href="#">6</a>\n      <a href="#" class="elp">...</a>\n      <a href="#" class="next">&gt;&gt;下一页</a>\n      到第\n      <input type="text" />\n      页\n      <button>确定</button>\n    </div>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n\n\n效果如下：\n\n<html>\n  <div class="demo1">\n    <div class="box">\n      <a href="#" class="prev">&lt;&lt;上一页</a>\n      <a href="#" class="current">2</a>\n      <a href="#">3</a>\n      <a href="#">4</a>\n      <a href="#">5</a>\n      <a href="#">6</a>\n      <a href="#" class="elp">...</a>\n      <a href="#" class="next">&gt;&gt;下一页</a>\n      到第\n      <input type="text" />\n      页\n      <button>确定</button>\n    </div>\n  </div>\n</html>\n\n<style>\n  .demo1 * {\n    margin: 0;\n    padding: 0;\n  }\n  .demo1 .box {\n    text-align: center;\n  }\n  .demo1 .box a {\n    display: inline-block;\n    width: 36px;\n    height: 36px;\n    background-color: #f7f7f7;\n    border: 1px solid #ccc;\n    text-align: center;\n    line-height: 36px;\n    text-decoration: none;\n    color: #333;\n    font-size: 14px;\n  }\n  .demo1 .box .prev,\n  .demo1 .box .next {\n    width: 85px;\n  }\n  .demo1 .box .current,\n  .demo1 .box .elp {\n    background-color: #fff;\n    border: none;\n  }\n  .demo1 .box input {\n    height: 36px;\n    width: 45px;\n    border: 1px solid #ccc;\n    outline: none;\n  }\n  .demo1 .box button {\n    width: 60px;\n    height: 36px;\n    background-color: #f7f7f7;\n    border: 1px solid #ccc;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n\n# 传统布局总结及案例 🔥\n\n\n# 1 css 初始化\n\n不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对 html 文本呈现的差异，照顾浏览器的兼 容，我们需要对 css 初始化，重设浏览器的样式，也称为 css reset。以京东 css 初始化代码为例：\n\n@charset "utf-8";\n\n/* 把我们所有标签的内外边距清零 */\n* {\n  margin: 0;\n  padding: 0;\n  /* 指定css3盒子模型 */\n  box-sizing: border-box;\n}\n\n/* 去掉li 的小圆点 */\nul,\nol,\nli {\n  list-style: none;\n}\n\na,\ninput,\nselect,\ntextarea,\nbutton {\n  /* 去掉蓝色边框 */\n  outline: none;\n  /* 去掉默认的灰色边框，不一定使用 */\n  border: none;\n}\n\n/* 去掉a的下划线 */\na {\n  text-decoration: none;\n  color: #333;\n}\n\nbutton {\n  /* 当我们鼠标经过button 按钮的时候，鼠标变成小手 */\n  cursor: pointer;\n}\n\nimg {\n  /* 取消图片底侧有空白缝隙的问题；图片和文字一起布局时，需要修改非基线对齐 */\n  vertical-align: middle;\n  /* border 0 或 none 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 */\n  border: none;\n}\n\n/* em 和 i 斜体的文字不倾斜 */\nem,\ni {\n  font-style: normal;\n}\n\n/* 表格 */\ntable {\n  border-collapse: collapse;\n  border-spacing: 0;\n}\n\nbody {\n  /* css3 抗锯齿形 让文字显示的更加清晰 */\n  -webkit-font-smoothing: antialiased;\n  background-color: #fff;\n}\n\n.hide,\n.none {\n  display: none;\n}\n\n/* ============= 浮动有关 start ============= */\n.f-left {\n  float: left;\n}\n\n.f-right {\n  float: right;\n}\n\n/* 清除浮动 */\n.clearfix:after {\n  visibility: hidden;\n  clear: both;\n  display: block;\n  content: \'.\';\n  height: 0;\n}\n\n.clearfix {\n  *zoom: 1;\n}\n/* ============= 浮动有关 end ============= */\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n\n# 2 css 属性书写顺序\n\n * 布局定位属性:display / position / float / clear / visibility / overflow(建议 display 第一个写，关系到模式)\n * 自身属性:width / height / margin / padding / border / background\n * 文本属性:color / font / text-decoration / text-align / vertical-align / white- space / word-break\n * 其他属性(css3):content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient ...\n\n\n# 3 页面整体布局思路\n\n为了提高网页制作的效率，布局时通常有以下的布局流程:\n\n 1. 必须确定页面的版心(可视区)，基本上宽度都和它一致。测量可得知。\n 2. 分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行行罗列而成的。\n 3. 制作 html 结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。\n 4. 开始运用盒子模型的原理，通过 div+css 布局来控制网页的各个模块。\n\n\n# 4 确定版心\n\n这个页面的版心 width 是 1200 像素，每个版心都要水平居中对齐，可以定义版心为公共类:\n\n.w {\n  width: 1200px;\n  margin: auto;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 5 头部盒子\n\n * 1 号是版心盒子 header 1200 * 42 的盒子水平居中对齐，上下给一个 margin 值就可以\n * 版心盒子里面包含 2 号盒子 logo。div 布局好后放入 img 即可\n * 版心盒子里面包含 3 号盒子 nav 导航栏，实际开发中，nav 一般采用 li + a 的做法。语义更清楚，且若直接使用 a 来堆砌，搜索引擎容易辨别为有堆砌关键字嫌疑，有降权风险\n   * 给 li 浮动，li 是块级元素，a 是内联元素\n   * 导航栏可以不给宽度，将来可继续添加文字；因为文字不一样多，给a 左右 padding 来撑开盒子即可\n * 版心盒子里面包含 4 号盒子 search 搜索框。一个大 div 套 input 和 button\n\n\n# 6 banner\n\n\n# 7 footer\n\n\n# 8 hot\n\n利用 position\n\n\n# 9 轮播图\n\n利用 position\n\n父盒子相对定位，子模块绝对定位\n\n\n# bootstrap\n\n\n# 入门\n\n> 详细内容访问bootstrap 中文网\n\n * 引入依赖\n   \n   * css：bootstrap.css\n   * js：jquery.js、popper.js(用于弹窗、提示、下拉菜单。版本 3 没有这个)、bootstrap.js\n\n * 响应式布局：一个网站可以兼容多个终端\n   \n   <meta charset="utf-8" />\n   \x3c!--响应式 meta 标签;viewport宽度；初始缩放值；最小/最大缩放值；是否允许用户缩放--\x3e\n   \x3c!--还有minimum-scale；maximum-scale；user-scalable=true/false--\x3e\n   <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n   \x3c!--文档兼容模式--\x3e\n   <meta http-equiv="x-ua-compatible" content="ie=edge" />\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   * viewport\n     * 移动设备上的就是设备的屏幕上能用来显示我们的网页的那一块区域\n   * px\n     * css 中 1px 并不等于设备的 1px\n\n * 步骤\n   \n   1. 定义布局容器：container、.container-fluid\n   2. 定义行：row\n   3. 定义列：col-xs-*、col-sm-*、col-md-*、col-lg-*、hidden-**（可以让元素在某个屏幕大小设备不显示）\n\n\n# 布局容器\n\n * bootstrap 需要为页面内容和栅格系统包裹一个容器\n   * .container 类用于固定宽度（根据不同设备左右有固定留白，但 xs 没有留白）并支持响应式布局的容器\n   * .container-fluid 类用于 100% 宽度，占据全部视口（viewport）的容器\n\n\n# 栅格系统\n\nbootstrap 提供了一套响应式、移动设备优先的流式栅格系统，随着屏幕或视口(viewport)尺寸的增加，系统会自动分为最多12 列\n\n * 栅格系统用于通过一系列的行（row）与列（column）的组合来创建页面布局，你的内容就可以放入这些创建好的布局中。工作原理如下：\n   * “行（row）”必须包含在 .container （固定宽度）或 .container-fluid （100% 宽度）中，以便为其赋予合适的排列（aligment）和内补（padding）。\n   * 通过“行（row）”在水平方向创建一组“列（column）”。\n   * 你的内容应当放置于“列（column）”内，并且，只有“列（column）”可以作为“行（row）”的直接子元素。\n   * 类似 .row 和 .col-xs-4 这种预定义的类，可以用来快速创建栅格布局。bootstrap 源码中定义的 mixin 也可以用来创建语义化的布局。\n   * 通过为“列（column）”设置 padding 属性，从而创建列与列之间的间隔（gutter）。通过为 .row 元素设置负值 margin 从而抵消掉为 .container 元素设置的 padding，也就间接为“行（row）”所包含的“列（column）”抵消掉了padding。==多列嵌套时，可以通过==padding:0==来取消内边距，使得元素占满 viewport==\n   * 负值的margin就是下面的示例为什么是向外突出的原因。在栅格列中的内容排成一行。\n   * 栅格系统中的列是通过指定 1 到 12 的值来表示其跨越的范围。例如，三个等宽的列可以使用三个 .col-xs-4 来创建。\n   * 如果一“行（row）”中包含了的“列（column）”大于 12，多余的“列（column）”所在的元素将被作为一个整体另起一行排列。\n   * 向上兼容且不向下兼容：栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类（可能每个列占一行）。 因此，在元素上应用任何 .col-md-*栅格类适用于与屏幕宽度大于或等于分界点大小的设备 ， 并且针对小屏幕设备覆盖栅格类。 因此，在元素上应用任何 .col-lg-*不存在， 也影响大屏幕设备。\n\n\n# 全局 css 样式、组件、插件\n\n全局 css 样式\n\n * 按钮： <button> (建议使用)、<a>、 <input> 。class="btn btn-default"\n * 图片：img-responsive"、img-rounded(方)、img-circle(圆)、img-thumbnail(相框)\n * 表格：table、table-bordered、table-hover\n * 表单：\n\n组件\n\n * 导航条\n * 分页：！！！\n\n插件\n\n * 轮播图\n\n\n# 其他详细的看文档去吧！',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"Flexible",frontmatter:{title:"Flexible",date:"2020-03-24T23:58:37.000Z",permalink:"/pages/b5b50a/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/300.CSS%E5%B8%83%E5%B1%80/306.CSS-Flexible.html",relativePath:"1100.H5&CSS3/300.CSS布局/306.CSS-Flexible.md",key:"v-10e281d8",path:"/pages/b5b50a/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:20},{level:2,title:"Flex 布局模型",slug:"flex-布局模型",normalizedTitle:"flex 布局模型",charIndex:221},{level:2,title:"用于 flex-container 的属性",slug:"用于-flex-container-的属性",normalizedTitle:"用于 flex-container 的属性",charIndex:274},{level:3,title:"flex-direction 🔥",slug:"flex-direction-🔥",normalizedTitle:"flex-direction 🔥",charIndex:300},{level:3,title:"justify-content 🔥",slug:"justify-content-🔥",normalizedTitle:"justify-content 🔥",charIndex:643},{level:3,title:"align-items 🔥",slug:"align-items-🔥",normalizedTitle:"align-items 🔥",charIndex:1032},{level:3,title:"align-content",slug:"align-content",normalizedTitle:"align-content",charIndex:1330},{level:3,title:"flex-wrap 🔥",slug:"flex-wrap-🔥",normalizedTitle:"flex-wrap 🔥",charIndex:1840},{level:3,title:"flex-flow 缩写",slug:"flex-flow-缩写",normalizedTitle:"flex-flow 缩写",charIndex:2029},{level:2,title:"用于 flex items 的属性",slug:"用于-flex-items-的属性",normalizedTitle:"用于 flex items 的属性",charIndex:2122},{level:3,title:"flex 简写 🔥",slug:"flex-简写-🔥",normalizedTitle:"flex 简写 🔥",charIndex:2144},{level:3,title:"order 🔥",slug:"order-🔥",normalizedTitle:"order 🔥",charIndex:2567},{level:3,title:"align-self 覆盖 align-items 🔥",slug:"align-self-覆盖-align-items-🔥",normalizedTitle:"align-self 覆盖 align-items 🔥",charIndex:2631},{level:3,title:"flex-grow",slug:"flex-grow",normalizedTitle:"flex-grow",charIndex:2158},{level:3,title:"flex-shrink",slug:"flex-shrink",normalizedTitle:"flex-shrink",charIndex:2171},{level:3,title:"flex-basis",slug:"flex-basis",normalizedTitle:"flex-basis",charIndex:2186}],headersStr:"简介 Flex 布局模型 用于 flex-container 的属性 flex-direction 🔥 justify-content 🔥 align-items 🔥 align-content flex-wrap 🔥 flex-flow 缩写 用于 flex items 的属性 flex 简写 🔥 order 🔥 align-self 覆盖 align-items 🔥 flex-grow flex-shrink flex-basis",content:"# Flexible 弹性布局\n\n\n# 简介\n\n移动端使用最多，但 PC 端的 IE10+ 才可以\n\n两个重要概念：\n\n * flex-container：开启的 flex 布局的元素\n * flex items：flex-container里面的直接子元素\n\n如何开启 Flex ？使用display属性\n\n * flex：flex-container为块元素\n * inline-flex：flex-container为行内元素\n\n\n# Flex 布局模型\n\n\n\n主要区分 main axis（主轴）和 cross axis（交叉轴）\n\n\n# 用于 flex-container 的属性\n\n\n# flex-direction 🔥\n\nflex-items 默认沿着 main axis 从 main start 开始往 main end 方向排布。flex-direction 决定了 main axis 的方向：\n\n * row：默认。行排布，主轴将沿着 inline 方向延伸\n * row-reverse：反向行排布，主轴将沿着 inline 方向延伸。main start 和 main end 交换位置\n * column：列排布，主轴会沿着上下方向延伸 — 也就是 block 排列的方向。\n * column-reverse：反向列排布，主轴会沿着上下方向延伸 — 也就是 **block 排列的方向。**main start 和 main end 交换位置\n\n\n# justify-content 🔥\n\n该属性决定了 flex items 在 main axis 上的对齐方式\n\n * flex-start：默认，与 main start 对齐\n * flex-end：与 main end 对齐\n * center：居中对齐\n * space-between：flex items 之间的距离相等；与 main start 、main end 两端对齐\n * space-evenly：flex items 之间的距离相等；flex items 与 main start 、main end 之间的距离等于 flex items 之间的距离\n * space-around：flex items 之间的距离相等；flex items 与 main start 、main end 之间的距离是 flex items 之间距离的一半\n\n\n# align-items 🔥\n\nalign-items 决定了 flex-items 在 cross axis 上的对齐方式\n\n * normal：在弹性布局中，效果和 stretch 一样\n * stretch：当 flex-items 在 cross axis 方向的 size 为 auto 时（不指定），会自动拉伸至填充 flex container\n * flex-start：与 corss start 对齐\n * flex-end：与 cross end 对齐\n * center：居中对齐\n * baseline：与基线对齐（与之前的不同，此处是以第一行文本的基线对齐）\n\n\n# align-content\n\nalign-content 决定了多行 flex items 在 cross axis 上的对齐方式，用法与 justify-content 类似。cross axis 一般不会有空隙。使用较少。\n\n * stretch：与 align-items 的 stretch 类似。基本不使用，因为 div 一般都给高度，不会拉伸填充\n * flex-start：与 corss start 对齐\n * flex-end：与 cross end 对齐\n * center：居中对齐\n * space-between：flex items 之间的距离相等；与 main start 、main end 两端对齐\n * space-evenly：flex items 之间的距离相等；flex items 与 main start 、main end 之间的距离等于 flex items 之间的距离\n * space-around：flex items 之间的距离相等；flex items 与 main start 、main end 之间的距离是 flex items 之间距离的一半\n\n\n# flex-wrap 🔥\n\n**默认情况下，所有 flex items 都会在同一行显示，即使指定了 width 也有可能缩小！**flex-wrap 就是解决此问题的\n\n * nowrap：不换行显示，单行\n * wrap：换行显示，多行\n * wrap-reverse：换行显示，多行（对比 wrap，cross start 与 cross end 相反）使用很少\n\n\n# flex-flow 缩写\n\n缩写属性，即 flex-direction 或 flex-wrap 的缩写，如\n\nflex-flow: row-reverse wrap;\n\n\n1\n\n\n\n# 用于 flex items 的属性\n\n\n# flex 简写 🔥\n\n是 flex-grow || flex-shrink || flex-basis 的简写，可以值指定 1 个、2 个或 3 个\n\n单值语法，值必须是以下其中之一：\n\n * 一个无单位数，会被当作 flex-grow 的值\n * 一个有效宽度（width）值，会被当作 flex-basis 的值\n * 关键字 none，auto 或 initial\n\n双值语法：\n\n * 第一个值必须是一个无单位数，并且它会被当作 flex-grow 的值\n * 第二个值必须为：\n   * 一个无单位数：被当作 flex-shrink\n   * 一个有效单位数：被当作 flex-basis\n\n三值语法：\n\n * 第一个值必须是一个无单位数，会被当作 flex-grow 的值\n * 第二个值必须是一个无单位数，会被当作 flex-shrink 的值\n * 第三个值必须是一个有效的宽度值，会被当作 flex-basis 的值\n\n\n# order 🔥\n\n决定 flex items 的排布顺序\n\n * 可以设置任意整数，值越小则排越前\n * 默认值 0\n\n\n# align-self 覆盖 align-items 🔥\n\nflex items 可以通过 align-self 覆盖 flex container 设置的 align-items\n\n * auto：默认，遵从 flex container 的 align-items 设置\n * stretch、flex-start、flex-end、center、baseline，效果和 align-items 一致\n\n\n# flex-grow\n\n决定了 flex items 如何扩展\n\n * 可以设置任意非负数字，默认值 0\n * 当 flex container 在 main axis 方向上有剩余 size 时，flex-grow 才会生效\n\n如果所有的 flex items 的 flex-grow 总和 sum 大于 1，每个 flex item 扩展的 size 为：\n\n * flex container 的剩余 size * flex-grow / sum，即根据权重分，能分完！\n\n如果所有的 flex items 的 flex-grow 总和 sum 小于等于 1，每个 flex item 扩展的 size 为：\n\n * flex container 的剩余 size * flex-grow，根据占比分，可能分不完！\n\nflex items 扩展后的最终 size 不能大于 max-width / max-height\n\n\n# flex-shrink\n\n决定了 flex items 如何收缩\n\n * 可以设置任意非负数字，默认值 1\n * 当 flex items 在 main axis 方向超过了 flex container 的 size 时，flex-shrink 才会生效\n\n如果所有的 flex items 的 flex-shrink 总和 sum 大于 1，每个 flex item 收缩的 size 为：\n\n * flex items 超出 flex container 的 size * 收缩比例 / 所有 flex item 收缩比例之和\n\n如果所有的 flex items 的 flex-shrink 总和 sum 小于等于 1，每个 flex item 收缩的 size 为：\n\n * flex items 超出 flex container 的 size _ sum _ 收缩比例 / 所有 flex item 收缩比例之和\n * 收缩比例 = flex shrink * flex item 的 base size\n * base size 就是 flex item 放入 flex container 之前的 size\n\nflex items 收缩后的最终 size 不能小于 min-width / min-height\n\n\n# flex-basis\n\n用来设置 flex items 在 main axis 方向上的 base size（宽度）\n\n * auto：默认值\n * 具体宽度数值：如 100 px\n\n决定 flex items 最终 base size 的因素，优先级高到低：\n\n * max-width、max-height、min-width、min-height\n * flex-basis\n * width、height\n * 内容本身的 size",normalizedContent:"# flexible 弹性布局\n\n\n# 简介\n\n移动端使用最多，但 pc 端的 ie10+ 才可以\n\n两个重要概念：\n\n * flex-container：开启的 flex 布局的元素\n * flex items：flex-container里面的直接子元素\n\n如何开启 flex ？使用display属性\n\n * flex：flex-container为块元素\n * inline-flex：flex-container为行内元素\n\n\n# flex 布局模型\n\n\n\n主要区分 main axis（主轴）和 cross axis（交叉轴）\n\n\n# 用于 flex-container 的属性\n\n\n# flex-direction 🔥\n\nflex-items 默认沿着 main axis 从 main start 开始往 main end 方向排布。flex-direction 决定了 main axis 的方向：\n\n * row：默认。行排布，主轴将沿着 inline 方向延伸\n * row-reverse：反向行排布，主轴将沿着 inline 方向延伸。main start 和 main end 交换位置\n * column：列排布，主轴会沿着上下方向延伸 — 也就是 block 排列的方向。\n * column-reverse：反向列排布，主轴会沿着上下方向延伸 — 也就是 **block 排列的方向。**main start 和 main end 交换位置\n\n\n# justify-content 🔥\n\n该属性决定了 flex items 在 main axis 上的对齐方式\n\n * flex-start：默认，与 main start 对齐\n * flex-end：与 main end 对齐\n * center：居中对齐\n * space-between：flex items 之间的距离相等；与 main start 、main end 两端对齐\n * space-evenly：flex items 之间的距离相等；flex items 与 main start 、main end 之间的距离等于 flex items 之间的距离\n * space-around：flex items 之间的距离相等；flex items 与 main start 、main end 之间的距离是 flex items 之间距离的一半\n\n\n# align-items 🔥\n\nalign-items 决定了 flex-items 在 cross axis 上的对齐方式\n\n * normal：在弹性布局中，效果和 stretch 一样\n * stretch：当 flex-items 在 cross axis 方向的 size 为 auto 时（不指定），会自动拉伸至填充 flex container\n * flex-start：与 corss start 对齐\n * flex-end：与 cross end 对齐\n * center：居中对齐\n * baseline：与基线对齐（与之前的不同，此处是以第一行文本的基线对齐）\n\n\n# align-content\n\nalign-content 决定了多行 flex items 在 cross axis 上的对齐方式，用法与 justify-content 类似。cross axis 一般不会有空隙。使用较少。\n\n * stretch：与 align-items 的 stretch 类似。基本不使用，因为 div 一般都给高度，不会拉伸填充\n * flex-start：与 corss start 对齐\n * flex-end：与 cross end 对齐\n * center：居中对齐\n * space-between：flex items 之间的距离相等；与 main start 、main end 两端对齐\n * space-evenly：flex items 之间的距离相等；flex items 与 main start 、main end 之间的距离等于 flex items 之间的距离\n * space-around：flex items 之间的距离相等；flex items 与 main start 、main end 之间的距离是 flex items 之间距离的一半\n\n\n# flex-wrap 🔥\n\n**默认情况下，所有 flex items 都会在同一行显示，即使指定了 width 也有可能缩小！**flex-wrap 就是解决此问题的\n\n * nowrap：不换行显示，单行\n * wrap：换行显示，多行\n * wrap-reverse：换行显示，多行（对比 wrap，cross start 与 cross end 相反）使用很少\n\n\n# flex-flow 缩写\n\n缩写属性，即 flex-direction 或 flex-wrap 的缩写，如\n\nflex-flow: row-reverse wrap;\n\n\n1\n\n\n\n# 用于 flex items 的属性\n\n\n# flex 简写 🔥\n\n是 flex-grow || flex-shrink || flex-basis 的简写，可以值指定 1 个、2 个或 3 个\n\n单值语法，值必须是以下其中之一：\n\n * 一个无单位数，会被当作 flex-grow 的值\n * 一个有效宽度（width）值，会被当作 flex-basis 的值\n * 关键字 none，auto 或 initial\n\n双值语法：\n\n * 第一个值必须是一个无单位数，并且它会被当作 flex-grow 的值\n * 第二个值必须为：\n   * 一个无单位数：被当作 flex-shrink\n   * 一个有效单位数：被当作 flex-basis\n\n三值语法：\n\n * 第一个值必须是一个无单位数，会被当作 flex-grow 的值\n * 第二个值必须是一个无单位数，会被当作 flex-shrink 的值\n * 第三个值必须是一个有效的宽度值，会被当作 flex-basis 的值\n\n\n# order 🔥\n\n决定 flex items 的排布顺序\n\n * 可以设置任意整数，值越小则排越前\n * 默认值 0\n\n\n# align-self 覆盖 align-items 🔥\n\nflex items 可以通过 align-self 覆盖 flex container 设置的 align-items\n\n * auto：默认，遵从 flex container 的 align-items 设置\n * stretch、flex-start、flex-end、center、baseline，效果和 align-items 一致\n\n\n# flex-grow\n\n决定了 flex items 如何扩展\n\n * 可以设置任意非负数字，默认值 0\n * 当 flex container 在 main axis 方向上有剩余 size 时，flex-grow 才会生效\n\n如果所有的 flex items 的 flex-grow 总和 sum 大于 1，每个 flex item 扩展的 size 为：\n\n * flex container 的剩余 size * flex-grow / sum，即根据权重分，能分完！\n\n如果所有的 flex items 的 flex-grow 总和 sum 小于等于 1，每个 flex item 扩展的 size 为：\n\n * flex container 的剩余 size * flex-grow，根据占比分，可能分不完！\n\nflex items 扩展后的最终 size 不能大于 max-width / max-height\n\n\n# flex-shrink\n\n决定了 flex items 如何收缩\n\n * 可以设置任意非负数字，默认值 1\n * 当 flex items 在 main axis 方向超过了 flex container 的 size 时，flex-shrink 才会生效\n\n如果所有的 flex items 的 flex-shrink 总和 sum 大于 1，每个 flex item 收缩的 size 为：\n\n * flex items 超出 flex container 的 size * 收缩比例 / 所有 flex item 收缩比例之和\n\n如果所有的 flex items 的 flex-shrink 总和 sum 小于等于 1，每个 flex item 收缩的 size 为：\n\n * flex items 超出 flex container 的 size _ sum _ 收缩比例 / 所有 flex item 收缩比例之和\n * 收缩比例 = flex shrink * flex item 的 base size\n * base size 就是 flex item 放入 flex container 之前的 size\n\nflex items 收缩后的最终 size 不能小于 min-width / min-height\n\n\n# flex-basis\n\n用来设置 flex items 在 main axis 方向上的 base size（宽度）\n\n * auto：默认值\n * 具体宽度数值：如 100 px\n\n决定 flex items 最终 base size 的因素，优先级高到低：\n\n * max-width、max-height、min-width、min-height\n * flex-basis\n * width、height\n * 内容本身的 size",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"移动端适配",frontmatter:{title:"移动端适配",date:"2020-03-29T17:57:28.000Z",permalink:"/pages/824a06/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/300.CSS%E5%B8%83%E5%B1%80/309.CSS-%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D.html",relativePath:"1100.H5&CSS3/300.CSS布局/309.CSS-移动端适配.md",key:"v-0910fc9a",path:"/pages/824a06/",headers:[{level:2,title:"viewport 视口",slug:"viewport-视口",normalizedTitle:"viewport 视口",charIndex:12},{level:2,title:"大小单位",slug:"大小单位",normalizedTitle:"大小单位",charIndex:676},{level:3,title:"px",slug:"px",normalizedTitle:"px",charIndex:91},{level:3,title:"em",slug:"em",normalizedTitle:"em",charIndex:926},{level:3,title:"rem",slug:"rem",normalizedTitle:"rem",charIndex:1021},{level:3,title:"%",slug:"",normalizedTitle:"%",charIndex:1051},{level:2,title:"动态设置 html 的 font-size",slug:"动态设置-html-的-font-size",normalizedTitle:"动态设置 html 的 font-size",charIndex:1135},{level:3,title:"CSS",slug:"css",normalizedTitle:"css",charIndex:60},{level:3,title:"JS（最优）",slug:"js-最优",normalizedTitle:"js（最优）",charIndex:1815},{level:2,title:"动态计算 rem 值",slug:"动态计算-rem-值",normalizedTitle:"动态计算 rem 值",charIndex:1838},{level:3,title:"postcss-pxtorem（最优）",slug:"postcss-pxtorem-最优",normalizedTitle:"postcss-pxtorem（最优）",charIndex:1910},{level:3,title:"less、sass、stylus 计算能力",slug:"less、sass、stylus-计算能力",normalizedTitle:"less、sass、stylus 计算能力",charIndex:1953}],headersStr:"viewport 视口 大小单位 px em rem % 动态设置 html 的 font-size CSS JS（最优） 动态计算 rem 值 postcss-pxtorem（最优） less、sass、stylus 计算能力",content:'# 移动端适配\n\n\n# viewport 视口\n\n视口视口就是屏幕中用来显示网页的区域，可以通过查看视口的大小，来观察 CSS 像素和物理像素的比值\n\n默认情况下：视口宽度 1920px（CSS 像素），1920px（物理像素），此时，css 像素和物理像素的比是 1:1\n\n放大两倍的情况：视口宽度 960px（CSS 像素），1920px（物理像素），此时，css 像素和物理像素的比是 1:2\n\n我们可以通过改变视口的大小，来改变 CSS 像素和物理像素的比值\n\n移动端默认视口大小为 980px，所有的元素在移动端没有设置视口的情况下都会被缩小。默认情况下，移动端的像素比就是：980/移动端宽度（980/750），如果我们直接在网页中编写移动端代码，这样在 980 的视口下，像素比是非常不好，导致网页中的内容非常非常的小。所以编写移动页面时，必须要确保有一个比较合理的像素比：\n\n * 1css 像素 对应 2 个物理像素\n * 1css 像素 对应 3 个物理像素\n\n可以通过 meta 标签来设置视口大小\n\n每一款移动设备设计时，都会有一个最佳的像素比，一般我们只需要将像素比设置为该值即可得到一个最佳效果，将像素比设置为最佳像素比的视口大小我们称其为完美视口。将网页的视口设置为完美视口：\n\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n\n\n1\n\n * width：设置视口的大小\n * initial-scale：设置缩放比例\n\n\n# 大小单位\n\n\n# px\n\n屏幕是由一个一个发光的小点构成，这一个个的小点就是像素，如分辨率：1920 x 1080 说的就是屏幕中小点的数量。在前端开发中像素要分成两种情况讨论：CSS 像素 和 物理像素。物理像素，上述所说的小点点就属于物理像素；CSS 像素，编写网页时，我们所用像素都是 CSS 像素。浏览器在显示网页时，需要将 CSS 像素转换为物理像素然后再呈现。一个 css 像素最终由几个物理像素显示，由浏览器决定：默认情况下在 pc 端，一个 CSS 像素 = 一个物理像素。\n\n\n# em\n\n相对于父元素font-size的倍数\n\n * font-size：相对于父元素的font-size\n * width：相对于自己的font-size，自己没有则继承父元素的\n\n\n# rem\n\n相对于根元素，具体哪个元素参考上面 em\n\n\n# %\n\n不同场景相对的不同！太多了需查文档！举例如下两个：\n\n * width：相对于父元素的width\n * margin-top：相对于父元素的width！\n\n\n# 动态设置 html 的 font-size\n\n\n# CSS\n\n * 针对不同的手机屏幕，设置不同 html 的 font-size 大小（使用媒体查询设备 width，据此设置 font-size ）\n * 将所有需要适配的元素，如图片、字体大小等，统一使用 rem 单位\n\n<style>\n  /* iPhone 5 */\n  @media screen and (min-width: 320px) {\n    html {\n      font-size: 9px;\n    }\n  }\n  /* iPhone 8 */\n  @media screen and (min-width: 375px) {\n    html {\n      font-size: 10px;\n    }\n  }\n  /* iPhone 8 Plus */\n  @media screen and (min-width: 414px) {\n    html {\n      font-size: 11px;\n    }\n  }\n  .box {\n    width: 10rem;\n    height: 10rem;\n    background-color: orange;\n    font-size: 1rem;\n  }\n</style>\n<div class="box">Hello World</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# JS（最优）\n\n代码太多了，引入即可\n\n\n# 动态计算 rem 值\n\n要设置固定 px 的 width 时，每次需要用 固定值/根元素的font-size，太麻烦了，解决办法如下：\n\n\n# postcss-pxtorem（最优）\n\nnode 的插件，打包时会自动计算\n\n\n# less、sass、stylus 计算能力\n\nLess 是一种 CSS 预处理器，对 CSS 进行了扩展，可以嵌套，可以定义变量，可以计算\n\n没有 Node 时可以使用 VSCode 的插件 Easy LESS 暂时替代',normalizedContent:'# 移动端适配\n\n\n# viewport 视口\n\n视口视口就是屏幕中用来显示网页的区域，可以通过查看视口的大小，来观察 css 像素和物理像素的比值\n\n默认情况下：视口宽度 1920px（css 像素），1920px（物理像素），此时，css 像素和物理像素的比是 1:1\n\n放大两倍的情况：视口宽度 960px（css 像素），1920px（物理像素），此时，css 像素和物理像素的比是 1:2\n\n我们可以通过改变视口的大小，来改变 css 像素和物理像素的比值\n\n移动端默认视口大小为 980px，所有的元素在移动端没有设置视口的情况下都会被缩小。默认情况下，移动端的像素比就是：980/移动端宽度（980/750），如果我们直接在网页中编写移动端代码，这样在 980 的视口下，像素比是非常不好，导致网页中的内容非常非常的小。所以编写移动页面时，必须要确保有一个比较合理的像素比：\n\n * 1css 像素 对应 2 个物理像素\n * 1css 像素 对应 3 个物理像素\n\n可以通过 meta 标签来设置视口大小\n\n每一款移动设备设计时，都会有一个最佳的像素比，一般我们只需要将像素比设置为该值即可得到一个最佳效果，将像素比设置为最佳像素比的视口大小我们称其为完美视口。将网页的视口设置为完美视口：\n\n<meta name="viewport" content="width=device-width, initial-scale=1.0">\n\n\n1\n\n * width：设置视口的大小\n * initial-scale：设置缩放比例\n\n\n# 大小单位\n\n\n# px\n\n屏幕是由一个一个发光的小点构成，这一个个的小点就是像素，如分辨率：1920 x 1080 说的就是屏幕中小点的数量。在前端开发中像素要分成两种情况讨论：css 像素 和 物理像素。物理像素，上述所说的小点点就属于物理像素；css 像素，编写网页时，我们所用像素都是 css 像素。浏览器在显示网页时，需要将 css 像素转换为物理像素然后再呈现。一个 css 像素最终由几个物理像素显示，由浏览器决定：默认情况下在 pc 端，一个 css 像素 = 一个物理像素。\n\n\n# em\n\n相对于父元素font-size的倍数\n\n * font-size：相对于父元素的font-size\n * width：相对于自己的font-size，自己没有则继承父元素的\n\n\n# rem\n\n相对于根元素，具体哪个元素参考上面 em\n\n\n# %\n\n不同场景相对的不同！太多了需查文档！举例如下两个：\n\n * width：相对于父元素的width\n * margin-top：相对于父元素的width！\n\n\n# 动态设置 html 的 font-size\n\n\n# css\n\n * 针对不同的手机屏幕，设置不同 html 的 font-size 大小（使用媒体查询设备 width，据此设置 font-size ）\n * 将所有需要适配的元素，如图片、字体大小等，统一使用 rem 单位\n\n<style>\n  /* iphone 5 */\n  @media screen and (min-width: 320px) {\n    html {\n      font-size: 9px;\n    }\n  }\n  /* iphone 8 */\n  @media screen and (min-width: 375px) {\n    html {\n      font-size: 10px;\n    }\n  }\n  /* iphone 8 plus */\n  @media screen and (min-width: 414px) {\n    html {\n      font-size: 11px;\n    }\n  }\n  .box {\n    width: 10rem;\n    height: 10rem;\n    background-color: orange;\n    font-size: 1rem;\n  }\n</style>\n<div class="box">hello world</div>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# js（最优）\n\n代码太多了，引入即可\n\n\n# 动态计算 rem 值\n\n要设置固定 px 的 width 时，每次需要用 固定值/根元素的font-size，太麻烦了，解决办法如下：\n\n\n# postcss-pxtorem（最优）\n\nnode 的插件，打包时会自动计算\n\n\n# less、sass、stylus 计算能力\n\nless 是一种 css 预处理器，对 css 进行了扩展，可以嵌套，可以定义变量，可以计算\n\n没有 node 时可以使用 vscode 的插件 easy less 暂时替代',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"京东",frontmatter:{title:"京东",date:"2020-01-02T00:26:13.000Z",permalink:"/pages/ac76d8/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/300.CSS%E5%B8%83%E5%B1%80/391.CSS%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B%E2%80%94%E2%80%94%E4%BA%AC%E4%B8%9C.html",relativePath:"1100.H5&CSS3/300.CSS布局/391.CSS项目案例——京东.md",key:"v-7a9c696e",path:"/pages/ac76d8/",headers:[{level:2,title:"项目搭建",slug:"项目搭建",normalizedTitle:"项目搭建",charIndex:9},{level:2,title:"favicon 图标 🔥🔥🔥",slug:"favicon-图标-🔥🔥🔥",normalizedTitle:"favicon 图标 🔥🔥🔥",charIndex:2263},{level:2,title:"TDK 三大标签 SEO 优化 🔥🔥",slug:"tdk-三大标签-seo-优化-🔥🔥",normalizedTitle:"tdk 三大标签 seo 优化 🔥🔥",charIndex:2611},{level:2,title:"首页制作",slug:"首页制作",normalizedTitle:"首页制作",charIndex:3459},{level:3,title:"常用模块类名命名",slug:"常用模块类名命名",normalizedTitle:"常用模块类名命名",charIndex:3513},{level:3,title:"公共部分 — header 头部制作",slug:"公共部分-header-头部制作",normalizedTitle:"公共部分 — header 头部制作",charIndex:3528},{level:4,title:"快捷导航 shortcut 制作 🔥🔥",slug:"快捷导航-shortcut-制作-🔥🔥",normalizedTitle:"快捷导航 shortcut 制作 🔥🔥",charIndex:3550},{level:4,title:"header 头部模块搭建 🔥🔥🔥",slug:"header-头部模块搭建-🔥🔥🔥",normalizedTitle:"header 头部模块搭建 🔥🔥🔥",charIndex:4159},{level:4,title:"nav 导航模块制作 🔥🔥🔥",slug:"nav-导航模块制作-🔥🔥🔥",normalizedTitle:"nav 导航模块制作 🔥🔥🔥",charIndex:5143},{level:3,title:"公共部分 — footer 底部制作",slug:"公共部分-footer-底部制作",normalizedTitle:"公共部分 — footer 底部制作",charIndex:5727},{level:3,title:"main 主体模块制作",slug:"main-主体模块制作",normalizedTitle:"main 主体模块制作",charIndex:6575},{level:3,title:"家用电器模块 🔥🔥🔥",slug:"家用电器模块-🔥🔥🔥",normalizedTitle:"家用电器模块 🔥🔥🔥",charIndex:6804},{level:4,title:"box_hd 制作",slug:"box-hd-制作",normalizedTitle:"box_hd 制作",charIndex:6872},{level:4,title:"box_bd 制作",slug:"box-bd-制作",normalizedTitle:"box_bd 制作",charIndex:7075},{level:4,title:"tab 栏切换需求 🔥🔥🔥",slug:"tab-栏切换需求-🔥🔥🔥",normalizedTitle:"tab 栏切换需求 🔥🔥🔥",charIndex:7456}],headersStr:"项目搭建 favicon 图标 🔥🔥🔥 TDK 三大标签 SEO 优化 🔥🔥 首页制作 常用模块类名命名 公共部分 — header 头部制作 快捷导航 shortcut 制作 🔥🔥 header 头部模块搭建 🔥🔥🔥 nav 导航模块制作 🔥🔥🔥 公共部分 — footer 底部制作 main 主体模块制作 家用电器模块 🔥🔥🔥 box_hd 制作 box_bd 制作 tab 栏切换需求 🔥🔥🔥",content:'# 京东\n\n\n# 项目搭建\n\n> 采用模块化开发\n\n * 首页 index.html\n\n * CSS 初始化样式文件 reset.css，还有normalize.css类似（统一样式）\n   \n   @charset "utf-8";\n   \n   /* 把我们所有标签的内外边距清零 */\n   * {\n     margin: 0;\n     padding: 0;\n     /* 指定CSS3盒子模型 */\n     box-sizing: border-box;\n   }\n   \n   /* 去掉li 的小圆点 */\n   ul,\n   ol,\n   li {\n     list-style: none;\n   }\n   \n   a,\n   input,\n   select,\n   textarea,\n   button {\n     /* 去掉蓝色边框 */\n     outline: none;\n     /* 去掉默认的灰色边框，不一定使用 */\n     border: none;\n   }\n   \n   /* 去掉a的下划线 */\n   a {\n     text-decoration: none;\n     color: #333;\n   }\n   \n   button {\n     /* 当我们鼠标经过button 按钮的时候，鼠标变成小手 */\n     cursor: pointer;\n   }\n   \n   img {\n     /* 取消图片底侧有空白缝隙的问题；图片和文字一起布局时，需要修改非基线对齐 */\n     vertical-align: middle;\n     /* border 0 或 none 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 */\n     border: none;\n   }\n   \n   /* em 和 i 斜体的文字不倾斜 */\n   em,\n   i {\n     font-style: normal;\n   }\n   \n   /* 表格 */\n   table {\n     border-collapse: collapse;\n     border-spacing: 0;\n   }\n   \n   body {\n     /* CSS3 抗锯齿形 让文字显示的更加清晰 */\n     -webkit-font-smoothing: antialiased;\n     background-color: #fff;\n   }\n   \n   .hide,\n   .none {\n     display: none;\n   }\n   \n   /* ============= 浮动有关 start ============= */\n   .f-left {\n     float: left;\n   }\n   \n   .f-right {\n     float: right;\n   }\n   \n   /* 清除浮动 */\n   .clearfix:after {\n     visibility: hidden;\n     clear: both;\n     display: block;\n     content: \'.\';\n     height: 0;\n   }\n   \n   .clearfix {\n     *zoom: 1;\n   }\n   /* ============= 浮动有关 end ============= */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   80\n   81\n   82\n   83\n   84\n   85\n   86\n   87\n   88\n   89\n   90\n   91\n   \n\n * CSS 公共样式文件 common.css\n   \n   公共样式里面包含页面头部、底部、版心宽度、清除浮动、页面文字颜色等公共样式\n   \n   > 有些网站初始化的不太提倡 * { margin: 0; padding: 0; }。比如新浪，将所有标签都写出来 html,body,ul,li,ol,dl,dd,dt,p,h1,h2,h3,h4,h5,h6,form,fieldset,legend,img{margin:0;padding:0}\n\n\n# favicon 图标 🔥🔥🔥\n\nfavicon.ico 一般用于作为缩略的网站标志，它显示在浏览器的地址栏或者标签上。目前主要的浏览器都支持 favicon.ico 图标。制作 favicon 图标如下：\n\n * 把图标切成 png 图片\n\n * 把 png 图片转换为 ico 图标，这需要借助于第三方转换网站，例如比特虫：http://www.bitbug.net/\n\n * favicon 图标放到网站根目录下\n\n * 在 html 页面里面的 <head> </head>元素之间引入代码\n   \n   <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />\n   \n   \n   1\n   \n\n\n# TDK 三大标签 SEO 优化 🔥🔥\n\n**SEO（Search Engine Optimization）**汉译为搜索引擎优化，是一种利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式。其目的是对网站进行深度的优化，从而帮助网站获取免费的流量，进而在搜索引擎上提升网站的排名，提高网站的知名度。页面必须有三个标签用来符合 SEO 优化：\n\n * title\n   \n   具有不可替代性，是我们内页的第一个重要标签，是搜索引擎了解网页的入口和对网页主题归属的最佳判断点。建议使用网站名（产品名）- 网站的介绍 （尽量不要超过 30 个汉字）\n\n * description 是 meta 中的 name 值\n   \n   简要说明我们网站主要是做什么的。作为网站的总体业务和主题概括，多采用“我们是…”、“我们提供…”、“××× 网作为…”、“电话：010…”之类语句。\n\n * keywords 是 meta 中的 name 值\n   \n   页面关键词，是搜索引擎的关注点之一。最好限制为 6 ～ 8 个关键词，关键词之间用英文逗号隔开，采用关键词 1,关键词 2 的形式。\n\n> 一般由专门的 SEO 人员准备\n\n<head>\n  <title>京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！</title>\n  <meta\n    name="description"\n    content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"\n  />\n  <meta\n    name="keywords"\n    content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东"\n  />\n</head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 首页制作\n\n我们开始制作首页的头部和底部的时候，根据模块化开发，样式要写到common.css里面\n\n\n# 常用模块类名命名\n\n\n\n\n# 公共部分 — header 头部制作\n\n# 快捷导航 shortcut 制作 🔥🔥\n\n\n\n布局思路\n\n * 通栏的盒子命名为 shortcut ，是快捷导航的意思。 注意这里的行高，可以继承给里面的子盒子\n * 里面包含版心的盒子\n * 版心盒子里面包含 1 号左侧盒子左浮动\n   * 1 号盒子 里面包含一个ul，ul包裹 li，第一个 li 里面包裹文字就行，因为不能点击，第二个 li 包含两个 a 标签\n   * 里面的内容是水平排列，所以需要给li设置浮动\n   * 文字要垂直居中，我们可以给 shortcut 设置行高，因为行高可以继承，里面的孩子就不需要设置了\n * 版心盒子里面包含 2 号右侧盒子右浮动\n   * 2 号盒子 里面包含一个ul，ul包裹li，中间的|可以用样式去设置div，也可以用字符 |\n   * 里面内容水平排列，给li设置浮动\n   * 找到里面所有偶数的 li 设置样式（偶数的 li 显示是一个 | 竖线，所以需要单独选择出来设置样式，利用 nth-child 就可以实现）\n * 需要用到字体图标\n   * 利用伪元素的方式来实现字体图标，给需要添加的标签设置类名为 ： arrow-icon\n   * 先要引入字体图片的资源\n   * 在样式里面利用 font-face 来进行声明\n   * 在伪元素的 content 属性设置 图标的编码\n   * 给伪元素设置 font-family 属性\n\n# header 头部模块搭建 🔥🔥🔥\n\n\n\n * header 盒子必须要有高度\n\n * 1 号盒子是 logo 标志定位，在正常开发过程中，logo 的布局其实是有讲究的，需要进行 logoSEO的优化 （★★★）\n   \n   * logo 里面首先放一个 h1 标签，目的是为了提权，告诉搜索引擎，这个地方很重要\n   * h1 里面再放一个链接，可以返回首页的，把 logo 的背景图片给链接即可\n   * 为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来\n     * 方法 1：text-indent 移到盒子外面（text-indent: -9999px) ，然后 overflow:hidden ，淘宝的做法\n     * 方法 2：直接给 font-size: 0; 就看不到文字了，京东的做法\n   * 最后给链接一个 title 属性，这样鼠标放到 logo 上就可以看到提示文字了\n\n * 2 号盒子是 search 搜索模块定位\n   \n   * search 盒子利用定位的方式放在对应的位置\n   * search 盒子设置绝对定位，header 盒子设置相对定位\n   * search 盒子里面包含两个子元素，一个是输入框，一个是按钮，分别跟定固定的宽高（搜索框 宽度：454px；按钮宽度：80px）\n   * 输入框和按钮本来就是行内块元素，在一行显示，但是中间会有间隙，所以我们可以让让这两个元素浮动起来\n\n * 3 号盒子是 hotwords 热词模块定位\n   \n   * 热词模块怎么简单怎么来，直接在里面放 a 标签即可\n   * 给里面所有的 a 标签设置 左右 10px 的外边距\n   * 给第一个 a 标签设置文字变红色（#c81623）\n\n * 4 号盒子是 shopcar 购物车模块\n   \n   * 在shopcar里面添加一个 before 伪元素和 after 伪元素，分别放置 购物车的图标和 右箭头\n   * count 统计部分用绝对定位做\n   * count 统计部分不要给宽度，因为可能买的件数比较多，让件数撑开就好了，给一个高度\n   * 一定注意左下角不是圆角，其余三个是圆角 写法： border-radius: 7px 7px 7px 0;\n\n# nav 导航模块制作 🔥🔥🔥\n\nnav 盒子通栏有高度，而且有个下边框，里面包含版心，版心里面包含 1 号盒子 和 2 号盒子\n\n * 1 号盒子左侧浮动，dropdown\n   \n   * 1 号盒子有讲究，根据相关性 里面包含 .dt 和 .dd 两个盒子\n   * .dt 内容是全部商品分类，然后把这个盒子的宽高设置跟父亲一样，这样就把 .dd 挤到下面去了\n   * 给 .dd 盒子设置宽度 和 高度，以及背景颜色\n   * 给 .dd 盒子里面定义 无序列表 （ul > li > a）\n   * 每个 li 都有一个高度（31px），宽度可以不用设置，让文字垂直居中，左边设置 2 个像素的 margin 值\n   * 给 li 里面的 a 设置文字大小（14px）\n   * 给 li 设置 hover，当鼠标移入的时候，让li的背景变成白色，让里面的文字变成红色\n   * li 右侧的三角 就可以利用 伪元素来实现，给伪元素设置字体图标，利用定位的方式放在li的右侧，那么给li设置相对定位\n\n * 2 号盒子左侧浮动，navitems 导航栏组\n   \n   * 里面结构是 ul > li > a\n   * 导航栏都是能点击的，所以我们不能给定宽度，给a左右的padding把两侧撑开\n   * 让文字垂直居中（行高等于高度）\n\n\n# 公共部分 — footer 底部制作\n\n\n\n * footer 页面底部盒子通栏给一个高度（415px）和灰色的背景\n\n * footer 里面有一个大的版心\n\n * 版心里面包含 1 号盒子，mod_service 是服务模块，mod 是模块的意思\n   \n   * 给 mod_service 设置高度（80px）和下边框\n   * 在里面定义 ul > li ,每个li 宽度是 300px 高度是 50px，给每个li设置 35px 的左内边距\n   * 在每个li里面，放一个 h5（里面放图标），一个div（里面放div和p）\n   * 给 h5设置浮动，让 h5 与这个 div 左右排列\n   * 通过精灵图技术（核心思路：利用 background-position 来实现），把图标设置给 h5\n\n * 版心里面包含 2 号盒子，mod_help 是帮助模块\n   \n   * 给 mod_help 设置 50px 的左内边距和 20px 的上内边距，给定高度（185px）\n   * 里面的布局利用 自定义列表来实现（dl > dt + dd）\n   * 给 dl 设置浮动，让其可以水平排列，给每个 dl 盒子设置宽度\n   * 给 dt 设置文字大小（16px），设置下外边距（10px），让dt和dd之间有些距离\n   * 最后一个 dl 结构和样式不一样，需要单独设置\n\n * 版心里面包含 3 号盒子，mod_copyright 是版权模块\n   \n   * 分为上下两块，上面是 links 友情链接，下面是 copyright，给 mod_copyright 大盒子设置 文字水平居中，20px 的上内边距，让上面内容和下面内容之间有些间隙\n   * 把内容分别复制到相应模块中\n   * 给 links 设置 15px 的下外边距，给links 里面 的 a 标签设置 左右 3px 的外边距\n   * 给copyright 设置 20px 的行高\n\n\n# main 主体模块制作\n\nmain 主体模块是 index 里面专有的，注意需要新的样式文件 index.css\n\n * main 盒子宽度为 980 像素，高度是 455 像素，位置距离左边 220px (margin-left ) ，给高度就不用清除浮动\n\n * main 里面包含左侧盒子，宽度为 721 像素，左浮动，focus 焦点图模块\n\n * main 里面包含右侧盒子，宽度为 250 像素，右浮动，newsflash 新闻快报模块\n\n\n# 家用电器模块 🔥🔥🔥\n\n注意这个 floor ，不要给高度，内容有多少，算多少\n\n第一楼是家用电器模块： 里面包含两个盒子\n\n# box_hd 制作\n\n * 1 号盒子 box_hd，给一个高度，有个下边框，里面分为左右 2 个盒子\n   \n   \n   \n   * box_hd 给 30px 的高度，2 个像素的下边框\n   * 里面放一个左侧 h3 的盒子，右侧一个 div 盒子，div 盒子里面放 ul > li > a\n   * 左侧盒左浮动，右侧盒子右浮动\n   * a标签之间的距离用左右的padding撑开即可\n\n# box_bd 制作\n\n * 2 号盒子 box_bd，不要给高度\n   \n   \n   \n   * box_bd 属于是 tab 栏的内容区域，所以在这个里面先嵌套一个盒子 tab_content，在tab_content 里面包裹 tab 选项卡对应的内容\n   * 内容被一个大盒子包裹（tab_list_item），里面是 ul 包裹 5 个 li，每个li设置对应的宽度，然后设置浮动\n   * 而这 5 个li的宽度是不一致的，在这里我们的做法是 先把宽度的样式列出来，然后给对应的li设置\n     * 第一个小 li 分为上下结构，上面是 ul 包裹 li ，li里面包裹 a，下面插入一张图片\n     * 上面的 li 设置宽高，设置浮动，这样就排列下来了\n     * 后面的小 li 里面先放一个a标签，然后在a标签里面插入图片即可\n\n# tab 栏切换需求 🔥🔥🔥\n\n\n\n * tab栏的布局是 ul > li > a\n * 有多少个tab选项卡，那么对应就有多少个内容\n * 但是每一次只会显示一个内容块，其他内容进行的隐藏\n * 等后面我们学习了js之后，我们就会配合js来实现，tab栏的切换',normalizedContent:'# 京东\n\n\n# 项目搭建\n\n> 采用模块化开发\n\n * 首页 index.html\n\n * css 初始化样式文件 reset.css，还有normalize.css类似（统一样式）\n   \n   @charset "utf-8";\n   \n   /* 把我们所有标签的内外边距清零 */\n   * {\n     margin: 0;\n     padding: 0;\n     /* 指定css3盒子模型 */\n     box-sizing: border-box;\n   }\n   \n   /* 去掉li 的小圆点 */\n   ul,\n   ol,\n   li {\n     list-style: none;\n   }\n   \n   a,\n   input,\n   select,\n   textarea,\n   button {\n     /* 去掉蓝色边框 */\n     outline: none;\n     /* 去掉默认的灰色边框，不一定使用 */\n     border: none;\n   }\n   \n   /* 去掉a的下划线 */\n   a {\n     text-decoration: none;\n     color: #333;\n   }\n   \n   button {\n     /* 当我们鼠标经过button 按钮的时候，鼠标变成小手 */\n     cursor: pointer;\n   }\n   \n   img {\n     /* 取消图片底侧有空白缝隙的问题；图片和文字一起布局时，需要修改非基线对齐 */\n     vertical-align: middle;\n     /* border 0 或 none 照顾低版本浏览器 如果 图片外面包含了链接会有边框的问题 */\n     border: none;\n   }\n   \n   /* em 和 i 斜体的文字不倾斜 */\n   em,\n   i {\n     font-style: normal;\n   }\n   \n   /* 表格 */\n   table {\n     border-collapse: collapse;\n     border-spacing: 0;\n   }\n   \n   body {\n     /* css3 抗锯齿形 让文字显示的更加清晰 */\n     -webkit-font-smoothing: antialiased;\n     background-color: #fff;\n   }\n   \n   .hide,\n   .none {\n     display: none;\n   }\n   \n   /* ============= 浮动有关 start ============= */\n   .f-left {\n     float: left;\n   }\n   \n   .f-right {\n     float: right;\n   }\n   \n   /* 清除浮动 */\n   .clearfix:after {\n     visibility: hidden;\n     clear: both;\n     display: block;\n     content: \'.\';\n     height: 0;\n   }\n   \n   .clearfix {\n     *zoom: 1;\n   }\n   /* ============= 浮动有关 end ============= */\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   51\n   52\n   53\n   54\n   55\n   56\n   57\n   58\n   59\n   60\n   61\n   62\n   63\n   64\n   65\n   66\n   67\n   68\n   69\n   70\n   71\n   72\n   73\n   74\n   75\n   76\n   77\n   78\n   79\n   80\n   81\n   82\n   83\n   84\n   85\n   86\n   87\n   88\n   89\n   90\n   91\n   \n\n * css 公共样式文件 common.css\n   \n   公共样式里面包含页面头部、底部、版心宽度、清除浮动、页面文字颜色等公共样式\n   \n   > 有些网站初始化的不太提倡 * { margin: 0; padding: 0; }。比如新浪，将所有标签都写出来 html,body,ul,li,ol,dl,dd,dt,p,h1,h2,h3,h4,h5,h6,form,fieldset,legend,img{margin:0;padding:0}\n\n\n# favicon 图标 🔥🔥🔥\n\nfavicon.ico 一般用于作为缩略的网站标志，它显示在浏览器的地址栏或者标签上。目前主要的浏览器都支持 favicon.ico 图标。制作 favicon 图标如下：\n\n * 把图标切成 png 图片\n\n * 把 png 图片转换为 ico 图标，这需要借助于第三方转换网站，例如比特虫：http://www.bitbug.net/\n\n * favicon 图标放到网站根目录下\n\n * 在 html 页面里面的 <head> </head>元素之间引入代码\n   \n   <link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />\n   \n   \n   1\n   \n\n\n# tdk 三大标签 seo 优化 🔥🔥\n\n**seo（search engine optimization）**汉译为搜索引擎优化，是一种利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式。其目的是对网站进行深度的优化，从而帮助网站获取免费的流量，进而在搜索引擎上提升网站的排名，提高网站的知名度。页面必须有三个标签用来符合 seo 优化：\n\n * title\n   \n   具有不可替代性，是我们内页的第一个重要标签，是搜索引擎了解网页的入口和对网页主题归属的最佳判断点。建议使用网站名（产品名）- 网站的介绍 （尽量不要超过 30 个汉字）\n\n * description 是 meta 中的 name 值\n   \n   简要说明我们网站主要是做什么的。作为网站的总体业务和主题概括，多采用“我们是…”、“我们提供…”、“××× 网作为…”、“电话：010…”之类语句。\n\n * keywords 是 meta 中的 name 值\n   \n   页面关键词，是搜索引擎的关注点之一。最好限制为 6 ～ 8 个关键词，关键词之间用英文逗号隔开，采用关键词 1,关键词 2 的形式。\n\n> 一般由专门的 seo 人员准备\n\n<head>\n  <title>京东(jd.com)-正品低价、品质保障、配送及时、轻松购物！</title>\n  <meta\n    name="description"\n    content="京东jd.com-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!"\n  />\n  <meta\n    name="keywords"\n    content="网上购物,网上商城,手机,笔记本,电脑,mp3,cd,vcd,dv,相机,数码,配件,手表,存储卡,京东"\n  />\n</head>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 首页制作\n\n我们开始制作首页的头部和底部的时候，根据模块化开发，样式要写到common.css里面\n\n\n# 常用模块类名命名\n\n\n\n\n# 公共部分 — header 头部制作\n\n# 快捷导航 shortcut 制作 🔥🔥\n\n\n\n布局思路\n\n * 通栏的盒子命名为 shortcut ，是快捷导航的意思。 注意这里的行高，可以继承给里面的子盒子\n * 里面包含版心的盒子\n * 版心盒子里面包含 1 号左侧盒子左浮动\n   * 1 号盒子 里面包含一个ul，ul包裹 li，第一个 li 里面包裹文字就行，因为不能点击，第二个 li 包含两个 a 标签\n   * 里面的内容是水平排列，所以需要给li设置浮动\n   * 文字要垂直居中，我们可以给 shortcut 设置行高，因为行高可以继承，里面的孩子就不需要设置了\n * 版心盒子里面包含 2 号右侧盒子右浮动\n   * 2 号盒子 里面包含一个ul，ul包裹li，中间的|可以用样式去设置div，也可以用字符 |\n   * 里面内容水平排列，给li设置浮动\n   * 找到里面所有偶数的 li 设置样式（偶数的 li 显示是一个 | 竖线，所以需要单独选择出来设置样式，利用 nth-child 就可以实现）\n * 需要用到字体图标\n   * 利用伪元素的方式来实现字体图标，给需要添加的标签设置类名为 ： arrow-icon\n   * 先要引入字体图片的资源\n   * 在样式里面利用 font-face 来进行声明\n   * 在伪元素的 content 属性设置 图标的编码\n   * 给伪元素设置 font-family 属性\n\n# header 头部模块搭建 🔥🔥🔥\n\n\n\n * header 盒子必须要有高度\n\n * 1 号盒子是 logo 标志定位，在正常开发过程中，logo 的布局其实是有讲究的，需要进行 logoseo的优化 （★★★）\n   \n   * logo 里面首先放一个 h1 标签，目的是为了提权，告诉搜索引擎，这个地方很重要\n   * h1 里面再放一个链接，可以返回首页的，把 logo 的背景图片给链接即可\n   * 为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来\n     * 方法 1：text-indent 移到盒子外面（text-indent: -9999px) ，然后 overflow:hidden ，淘宝的做法\n     * 方法 2：直接给 font-size: 0; 就看不到文字了，京东的做法\n   * 最后给链接一个 title 属性，这样鼠标放到 logo 上就可以看到提示文字了\n\n * 2 号盒子是 search 搜索模块定位\n   \n   * search 盒子利用定位的方式放在对应的位置\n   * search 盒子设置绝对定位，header 盒子设置相对定位\n   * search 盒子里面包含两个子元素，一个是输入框，一个是按钮，分别跟定固定的宽高（搜索框 宽度：454px；按钮宽度：80px）\n   * 输入框和按钮本来就是行内块元素，在一行显示，但是中间会有间隙，所以我们可以让让这两个元素浮动起来\n\n * 3 号盒子是 hotwords 热词模块定位\n   \n   * 热词模块怎么简单怎么来，直接在里面放 a 标签即可\n   * 给里面所有的 a 标签设置 左右 10px 的外边距\n   * 给第一个 a 标签设置文字变红色（#c81623）\n\n * 4 号盒子是 shopcar 购物车模块\n   \n   * 在shopcar里面添加一个 before 伪元素和 after 伪元素，分别放置 购物车的图标和 右箭头\n   * count 统计部分用绝对定位做\n   * count 统计部分不要给宽度，因为可能买的件数比较多，让件数撑开就好了，给一个高度\n   * 一定注意左下角不是圆角，其余三个是圆角 写法： border-radius: 7px 7px 7px 0;\n\n# nav 导航模块制作 🔥🔥🔥\n\nnav 盒子通栏有高度，而且有个下边框，里面包含版心，版心里面包含 1 号盒子 和 2 号盒子\n\n * 1 号盒子左侧浮动，dropdown\n   \n   * 1 号盒子有讲究，根据相关性 里面包含 .dt 和 .dd 两个盒子\n   * .dt 内容是全部商品分类，然后把这个盒子的宽高设置跟父亲一样，这样就把 .dd 挤到下面去了\n   * 给 .dd 盒子设置宽度 和 高度，以及背景颜色\n   * 给 .dd 盒子里面定义 无序列表 （ul > li > a）\n   * 每个 li 都有一个高度（31px），宽度可以不用设置，让文字垂直居中，左边设置 2 个像素的 margin 值\n   * 给 li 里面的 a 设置文字大小（14px）\n   * 给 li 设置 hover，当鼠标移入的时候，让li的背景变成白色，让里面的文字变成红色\n   * li 右侧的三角 就可以利用 伪元素来实现，给伪元素设置字体图标，利用定位的方式放在li的右侧，那么给li设置相对定位\n\n * 2 号盒子左侧浮动，navitems 导航栏组\n   \n   * 里面结构是 ul > li > a\n   * 导航栏都是能点击的，所以我们不能给定宽度，给a左右的padding把两侧撑开\n   * 让文字垂直居中（行高等于高度）\n\n\n# 公共部分 — footer 底部制作\n\n\n\n * footer 页面底部盒子通栏给一个高度（415px）和灰色的背景\n\n * footer 里面有一个大的版心\n\n * 版心里面包含 1 号盒子，mod_service 是服务模块，mod 是模块的意思\n   \n   * 给 mod_service 设置高度（80px）和下边框\n   * 在里面定义 ul > li ,每个li 宽度是 300px 高度是 50px，给每个li设置 35px 的左内边距\n   * 在每个li里面，放一个 h5（里面放图标），一个div（里面放div和p）\n   * 给 h5设置浮动，让 h5 与这个 div 左右排列\n   * 通过精灵图技术（核心思路：利用 background-position 来实现），把图标设置给 h5\n\n * 版心里面包含 2 号盒子，mod_help 是帮助模块\n   \n   * 给 mod_help 设置 50px 的左内边距和 20px 的上内边距，给定高度（185px）\n   * 里面的布局利用 自定义列表来实现（dl > dt + dd）\n   * 给 dl 设置浮动，让其可以水平排列，给每个 dl 盒子设置宽度\n   * 给 dt 设置文字大小（16px），设置下外边距（10px），让dt和dd之间有些距离\n   * 最后一个 dl 结构和样式不一样，需要单独设置\n\n * 版心里面包含 3 号盒子，mod_copyright 是版权模块\n   \n   * 分为上下两块，上面是 links 友情链接，下面是 copyright，给 mod_copyright 大盒子设置 文字水平居中，20px 的上内边距，让上面内容和下面内容之间有些间隙\n   * 把内容分别复制到相应模块中\n   * 给 links 设置 15px 的下外边距，给links 里面 的 a 标签设置 左右 3px 的外边距\n   * 给copyright 设置 20px 的行高\n\n\n# main 主体模块制作\n\nmain 主体模块是 index 里面专有的，注意需要新的样式文件 index.css\n\n * main 盒子宽度为 980 像素，高度是 455 像素，位置距离左边 220px (margin-left ) ，给高度就不用清除浮动\n\n * main 里面包含左侧盒子，宽度为 721 像素，左浮动，focus 焦点图模块\n\n * main 里面包含右侧盒子，宽度为 250 像素，右浮动，newsflash 新闻快报模块\n\n\n# 家用电器模块 🔥🔥🔥\n\n注意这个 floor ，不要给高度，内容有多少，算多少\n\n第一楼是家用电器模块： 里面包含两个盒子\n\n# box_hd 制作\n\n * 1 号盒子 box_hd，给一个高度，有个下边框，里面分为左右 2 个盒子\n   \n   \n   \n   * box_hd 给 30px 的高度，2 个像素的下边框\n   * 里面放一个左侧 h3 的盒子，右侧一个 div 盒子，div 盒子里面放 ul > li > a\n   * 左侧盒左浮动，右侧盒子右浮动\n   * a标签之间的距离用左右的padding撑开即可\n\n# box_bd 制作\n\n * 2 号盒子 box_bd，不要给高度\n   \n   \n   \n   * box_bd 属于是 tab 栏的内容区域，所以在这个里面先嵌套一个盒子 tab_content，在tab_content 里面包裹 tab 选项卡对应的内容\n   * 内容被一个大盒子包裹（tab_list_item），里面是 ul 包裹 5 个 li，每个li设置对应的宽度，然后设置浮动\n   * 而这 5 个li的宽度是不一致的，在这里我们的做法是 先把宽度的样式列出来，然后给对应的li设置\n     * 第一个小 li 分为上下结构，上面是 ul 包裹 li ，li里面包裹 a，下面插入一张图片\n     * 上面的 li 设置宽高，设置浮动，这样就排列下来了\n     * 后面的小 li 里面先放一个a标签，然后在a标签里面插入图片即可\n\n# tab 栏切换需求 🔥🔥🔥\n\n\n\n * tab栏的布局是 ul > li > a\n * 有多少个tab选项卡，那么对应就有多少个内容\n * 但是每一次只会显示一个内容块，其他内容进行的隐藏\n * 等后面我们学习了js之后，我们就会配合js来实现，tab栏的切换',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"考拉",frontmatter:{title:"考拉",date:"2020-03-23T23:54:03.000Z",permalink:"/pages/d2628c/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/300.CSS%E5%B8%83%E5%B1%80/392.CSS%E9%A1%B9%E7%9B%AE%E6%A1%88%E4%BE%8B%E2%80%94%E2%80%94%E8%80%83%E6%8B%89.html",relativePath:"1100.H5&CSS3/300.CSS布局/392.CSS项目案例——考拉.md",key:"v-6cc34f95",path:"/pages/d2628c/",headersStr:null,content:"# 考拉",normalizedContent:"# 考拉",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"高级技巧",frontmatter:{title:"高级技巧",date:"2019-12-29T18:37:45.000Z",permalink:"/pages/da720c/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/401.CSS-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7.html",relativePath:"1100.H5&CSS3/401.CSS-高级技巧.md",key:"v-0bdb65db",path:"/pages/da720c/",headers:[{level:2,title:"CSS 三角",slug:"css-三角",normalizedTitle:"css 三角",charIndex:11},{level:3,title:"使用1",slug:"使用1",normalizedTitle:"使用1",charIndex:22},{level:3,title:"使用2",slug:"使用2",normalizedTitle:"使用2",charIndex:1513},{level:3,title:"京东三角案例1",slug:"京东三角案例1",normalizedTitle:"京东三角案例1",charIndex:2363},{level:3,title:"京东三角案例2",slug:"京东三角案例2",normalizedTitle:"京东三角案例2",charIndex:3871}],headersStr:"CSS 三角 使用1 使用2 京东三角案例1 京东三角案例2",content:'# 高级技巧\n\n\n# CSS 三角\n\n\n# 使用1\n\n看如下代码：\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>CSS三角</title>\n    <style>\n      .demo1 {\n        width: 0;\n        height: 0;\n        border-top: 100px solid red;\n        border-right: 100px solid green;\n        border-bottom: 100px solid blue;\n        border-left: 100px solid pink;\n      }\n    </style>\n  </head>\n  <body>\n    <div class="demo1"></div>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n其结果如下图：\n\n<html>\n    <div class="demo1"></div>\n</html>\n\n<style>\n    .demo1 {\n        width: 0;\n        height: 0;\n        border-top: 100px solid red;\n        border-right: 100px solid green;\n        border-bottom: 100px solid blue;\n        border-left: 100px solid pink;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n由此可画出三角形，如向右的三角，具体代码如下：\n\n.demo1-2 {\n  width: 0;\n  height: 0;\n  border: 100px solid transparent;/* transparent 的使用*/\n  border-left: 100px solid red;\n  /* 照顾兼容性问题 */\n  line-height: 0;\n  font-size: 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n<html>\n    <div class="demo1-2"></div>\n</html>\n\n<style>\n    .demo1-2 {\n        width: 0;\n        height: 0;\n        border: 100px solid transparent;/* transparent 的使用*/\n        border-left: 100px solid red;\n        /* 照顾兼容性问题 */\n        line-height: 0;\n        font-size: 0;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n# 使用2\n\n<!DOCTYPE html>\n<html lang="en">\n\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>CSS三角</title>\n    <style>\n      .demo2 {\n        width: 0;\n        height: 0;\n        border-top: 100px solid red;\n        border-left: 50px solid green;\n        border-right: 50px solid blue;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="demo2"></div>\n  </body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n效果如下：\n\n<html>\n    <div class="demo2"></div>\n</html>\n\n<style>\n    .demo2 {\n        width: 0;\n        height: 0;\n        border-top: 100px solid red;\n        border-left: 50px solid green;\n        border-right: 50px solid blue;\n      }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n# 京东三角案例1\n\n使用 position 和 CSS 三角完成，如下：\n\n<!DOCTYPE html>\n<html lang="en">\n\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>CSS三角</title>\n    <style>\n      .demo3 .jd {\n        position: relative;\n        width: 50px;\n        height: 100px;\n        background-color: pink;\n        margin: 50px auto;\n      }\n\n      .demo3 .jd span {\n        position: absolute;\n        left: 35px;\n        top: -10px;\n        width: 0;\n        height: 0;\n        border: 5px solid transparent;\n        border-bottom: 5px solid pink;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="demo3">\n        <div class="jd">\n            <span></span>\n        </div>\n    </div>\n  </body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n具体效果如下：\n\n<html>\n    <div class="demo3">\n        <div class="jd">\n            <span></span>\n        </div>\n    </div>\n</html>\n\n<style>\n    .demo3 .jd {\n        position: relative;\n        width: 50px;\n        height: 100px;\n        background-color: pink;\n        margin: 50px auto;\n      }\n\n      .demo3 .jd span {\n        position: absolute;\n        left: 35px;\n        top: -10px;\n        width: 0;\n        height: 0;\n        border: 5px solid transparent;\n        border-bottom: 5px solid pink;\n      }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n\n# 京东三角案例2\n\n<!DOCTYPE html>\n<html lang="en">\n\n  <head>\n    <meta charset="UTF-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="X-UA-Compatible" content="ie=edge">\n    <title>CSS三角强化的巧妙运用</title>\n    <style>\n      .price {\n        width: 160px;\n        height: 24px;\n        line-height: 24px;\n        border: 1px solid red;\n        margin: 0 auto;\n      }\n\n      .miaosha {\n        position: relative;\n        float: left;\n        width: 90px;\n        height: 100%;\n        background-color: red;\n        text-align: center;\n        color: #fff;\n        font-weight: 700;\n        margin-right: 8px;\n\n      }\n\n      .miaosha i {\n        position: absolute;\n        right: 0;\n        top: 0;\n        width: 0;\n        height: 0;\n        border-color: transparent #fff transparent transparent;\n        border-style: solid;\n        border-width: 24px 10px 0 0;\n      }\n\n      .origin {\n        font-size: 12px;\n        color: gray;\n        text-decoration: line-through;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="price">\n      <span class="miaosha">\n        ¥1650\n        <i></i>\n      </span>\n      <span class="origin">¥5650</span>\n    </div>\n  </body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n效果如下：\n\n<html>\n    <div class="price">\n        <span class="miaosha">\n            ¥1650\n            <i></i>\n        </span>\n        <span class="origin">¥5650</span>\n    </div>\n</html>\n\n<style>\n    .price {\n        width: 160px;\n        height: 24px;\n        line-height: 24px;\n        border: 1px solid red;\n        margin: 0 auto;\n    }\n\n    .miaosha {\n        position: relative;\n        float: left;\n        width: 90px;\n        height: 100%;\n        background-color: red;\n        text-align: center;\n        color: #fff;\n        font-weight: 700;\n        margin-right: 8px;\n\n    }\n\n    .miaosha i {\n        position: absolute;\n        right: 0;\n        top: 0;\n        width: 0;\n        height: 0;\n        border-color: transparent #fff transparent transparent;\n        border-style: solid;\n        border-width: 24px 10px 0 0;\n    }\n\n    .origin {\n        font-size: 12px;\n        color: gray;\n        text-decoration: line-through;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n',normalizedContent:'# 高级技巧\n\n\n# css 三角\n\n\n# 使用1\n\n看如下代码：\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>css三角</title>\n    <style>\n      .demo1 {\n        width: 0;\n        height: 0;\n        border-top: 100px solid red;\n        border-right: 100px solid green;\n        border-bottom: 100px solid blue;\n        border-left: 100px solid pink;\n      }\n    </style>\n  </head>\n  <body>\n    <div class="demo1"></div>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n其结果如下图：\n\n<html>\n    <div class="demo1"></div>\n</html>\n\n<style>\n    .demo1 {\n        width: 0;\n        height: 0;\n        border-top: 100px solid red;\n        border-right: 100px solid green;\n        border-bottom: 100px solid blue;\n        border-left: 100px solid pink;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n由此可画出三角形，如向右的三角，具体代码如下：\n\n.demo1-2 {\n  width: 0;\n  height: 0;\n  border: 100px solid transparent;/* transparent 的使用*/\n  border-left: 100px solid red;\n  /* 照顾兼容性问题 */\n  line-height: 0;\n  font-size: 0;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n<html>\n    <div class="demo1-2"></div>\n</html>\n\n<style>\n    .demo1-2 {\n        width: 0;\n        height: 0;\n        border: 100px solid transparent;/* transparent 的使用*/\n        border-left: 100px solid red;\n        /* 照顾兼容性问题 */\n        line-height: 0;\n        font-size: 0;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n\n# 使用2\n\n<!doctype html>\n<html lang="en">\n\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>css三角</title>\n    <style>\n      .demo2 {\n        width: 0;\n        height: 0;\n        border-top: 100px solid red;\n        border-left: 50px solid green;\n        border-right: 50px solid blue;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="demo2"></div>\n  </body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n效果如下：\n\n<html>\n    <div class="demo2"></div>\n</html>\n\n<style>\n    .demo2 {\n        width: 0;\n        height: 0;\n        border-top: 100px solid red;\n        border-left: 50px solid green;\n        border-right: 50px solid blue;\n      }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n\n# 京东三角案例1\n\n使用 position 和 css 三角完成，如下：\n\n<!doctype html>\n<html lang="en">\n\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>css三角</title>\n    <style>\n      .demo3 .jd {\n        position: relative;\n        width: 50px;\n        height: 100px;\n        background-color: pink;\n        margin: 50px auto;\n      }\n\n      .demo3 .jd span {\n        position: absolute;\n        left: 35px;\n        top: -10px;\n        width: 0;\n        height: 0;\n        border: 5px solid transparent;\n        border-bottom: 5px solid pink;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="demo3">\n        <div class="jd">\n            <span></span>\n        </div>\n    </div>\n  </body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n具体效果如下：\n\n<html>\n    <div class="demo3">\n        <div class="jd">\n            <span></span>\n        </div>\n    </div>\n</html>\n\n<style>\n    .demo3 .jd {\n        position: relative;\n        width: 50px;\n        height: 100px;\n        background-color: pink;\n        margin: 50px auto;\n      }\n\n      .demo3 .jd span {\n        position: absolute;\n        left: 35px;\n        top: -10px;\n        width: 0;\n        height: 0;\n        border: 5px solid transparent;\n        border-bottom: 5px solid pink;\n      }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n\n# 京东三角案例2\n\n<!doctype html>\n<html lang="en">\n\n  <head>\n    <meta charset="utf-8">\n    <meta name="viewport" content="width=device-width, initial-scale=1.0">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <title>css三角强化的巧妙运用</title>\n    <style>\n      .price {\n        width: 160px;\n        height: 24px;\n        line-height: 24px;\n        border: 1px solid red;\n        margin: 0 auto;\n      }\n\n      .miaosha {\n        position: relative;\n        float: left;\n        width: 90px;\n        height: 100%;\n        background-color: red;\n        text-align: center;\n        color: #fff;\n        font-weight: 700;\n        margin-right: 8px;\n\n      }\n\n      .miaosha i {\n        position: absolute;\n        right: 0;\n        top: 0;\n        width: 0;\n        height: 0;\n        border-color: transparent #fff transparent transparent;\n        border-style: solid;\n        border-width: 24px 10px 0 0;\n      }\n\n      .origin {\n        font-size: 12px;\n        color: gray;\n        text-decoration: line-through;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div class="price">\n      <span class="miaosha">\n        ¥1650\n        <i></i>\n      </span>\n      <span class="origin">¥5650</span>\n    </div>\n  </body>\n\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n效果如下：\n\n<html>\n    <div class="price">\n        <span class="miaosha">\n            ¥1650\n            <i></i>\n        </span>\n        <span class="origin">¥5650</span>\n    </div>\n</html>\n\n<style>\n    .price {\n        width: 160px;\n        height: 24px;\n        line-height: 24px;\n        border: 1px solid red;\n        margin: 0 auto;\n    }\n\n    .miaosha {\n        position: relative;\n        float: left;\n        width: 90px;\n        height: 100%;\n        background-color: red;\n        text-align: center;\n        color: #fff;\n        font-weight: 700;\n        margin-right: 8px;\n\n    }\n\n    .miaosha i {\n        position: absolute;\n        right: 0;\n        top: 0;\n        width: 0;\n        height: 0;\n        border-color: transparent #fff transparent transparent;\n        border-style: solid;\n        border-width: 24px 10px 0 0;\n    }\n\n    .origin {\n        font-size: 12px;\n        color: gray;\n        text-decoration: line-through;\n    }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"代码规范",frontmatter:{title:"代码规范",date:"2020-01-01T21:58:18.000Z",permalink:"/pages/abf94c/",categories:["H5&CSS3"],tags:[null]},regularPath:"/1100.H5&CSS3/501.%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.html",relativePath:"1100.H5&CSS3/501.代码规范.md",key:"v-2ab16e45",path:"/pages/abf94c/",headers:[{level:2,title:"HTML 规范",slug:"html-规范",normalizedTitle:"html 规范",charIndex:25},{level:3,title:"DOCTYPE 声明",slug:"doctype-声明",normalizedTitle:"doctype 声明",charIndex:37},{level:3,title:"页面语言 lang",slug:"页面语言-lang",normalizedTitle:"页面语言 lang",charIndex:424},{level:3,title:"charset 字符集合",slug:"charset-字符集合",normalizedTitle:"charset 字符集合",charIndex:763},{level:3,title:"书写风格",slug:"书写风格",normalizedTitle:"书写风格",charIndex:1065},{level:3,title:"类型属性",slug:"类型属性",normalizedTitle:"类型属性",charIndex:1207},{level:3,title:"元素属性",slug:"元素属性",normalizedTitle:"元素属性",charIndex:1433},{level:3,title:"特殊字符引用",slug:"特殊字符引用",normalizedTitle:"特殊字符引用",charIndex:1665},{level:3,title:"代码缩进",slug:"代码缩进",normalizedTitle:"代码缩进",charIndex:1864},{level:3,title:"代码嵌套",slug:"代码嵌套",normalizedTitle:"代码嵌套",charIndex:1965},{level:2,title:"图片规范",slug:"图片规范",normalizedTitle:"图片规范",charIndex:2344},{level:3,title:"内容图",slug:"内容图",normalizedTitle:"内容图",charIndex:2353},{level:3,title:"背景图",slug:"背景图",normalizedTitle:"背景图",charIndex:2502},{level:2,title:"CSS 规范",slug:"css-规范",normalizedTitle:"css 规范",charIndex:2777},{level:3,title:"代码格式化",slug:"代码格式化",normalizedTitle:"代码格式化",charIndex:2788},{level:3,title:"代码大小写",slug:"代码大小写",normalizedTitle:"代码大小写",charIndex:2973},{level:3,title:"选择器",slug:"选择器",normalizedTitle:"选择器",charIndex:2982},{level:3,title:"代码缩进",slug:"代码缩进-2",normalizedTitle:"代码缩进",charIndex:1864},{level:3,title:"分号",slug:"分号",normalizedTitle:"分号",charIndex:3401},{level:3,title:"代码易读性",slug:"代码易读性",normalizedTitle:"代码易读性",charIndex:3476},{level:3,title:"属性值引号",slug:"属性值引号",normalizedTitle:"属性值引号",charIndex:4346},{level:3,title:"属性书写顺序",slug:"属性书写顺序",normalizedTitle:"属性书写顺序",charIndex:4510},{level:2,title:"命名规范",slug:"命名规范",normalizedTitle:"命名规范",charIndex:5324},{level:3,title:"目录命名",slug:"目录命名",normalizedTitle:"目录命名",charIndex:5392},{level:3,title:"ClassName 命名",slug:"classname-命名",normalizedTitle:"classname 命名",charIndex:5489},{level:4,title:"常用命名推荐",slug:"常用命名推荐",normalizedTitle:"常用命名推荐",charIndex:5577}],headersStr:"HTML 规范 DOCTYPE 声明 页面语言 lang charset 字符集合 书写风格 类型属性 元素属性 特殊字符引用 代码缩进 代码嵌套 图片规范 内容图 背景图 CSS 规范 代码格式化 代码大小写 选择器 代码缩进 分号 代码易读性 属性值引号 属性书写顺序 命名规范 目录命名 ClassName 命名 常用命名推荐",content:'# 代码规范\n\n> 借鉴京东前端代码规范\n\n\n# HTML 规范\n\n\n# DOCTYPE 声明\n\nHTML 文件必须加上 DOCTYPE 声明，并统一使用 HTML5 的文档声明：\n\n<!DOCTYPE html>\n\n\n1\n\n\nHTML5 标准模版\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="X-UA-Compatible" content="ie=edge" />\n    <title>Document</title>\n  </head>\n  <body></body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 页面语言 lang\n\n可以省略，也使用属性值 cmn-Hans-CN（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-CN 属性值\n\n<html lang="zh-CN"></html>\n\n\n1\n\n\n更多地区语言参考：\n\nzh-SG 中文 (简体, 新加坡)   对应 cmn-Hans-SG 普通话 (简体, 新加坡)\nzh-HK 中文 (繁体, 香港)     对应 cmn-Hant-HK 普通话 (繁体, 香港)\nzh-MO 中文 (繁体, 澳门)     对应 cmn-Hant-MO 普通话 (繁体, 澳门)\nzh-TW 中文 (繁体, 台湾)     对应 cmn-Hant-TW 普通话 (繁体, 台湾)\n\n\n1\n2\n3\n4\n\n\n\n# charset 字符集合\n\n一般情况下统一使用 “UTF-8” 编码\n\n<meta charset="UTF-8" />\n\n\n1\n\n\n由于历史原因，有些业务可能会使用 “GBK” 编码\n\n<meta charset="GBK" />\n\n\n1\n\n\n请尽量统一写成标准的 “UTF-8”，不要写成 “utf-8” 或 “utf8” 或 “UTF8”。根据 IETF 对 UTF-8 的定义，其编码标准的写法是 “UTF-8”；而 UTF8 或 utf8 的写法只是出现在某些编程系统中，如 .NET framework 的类 System.Text.Encoding 中的一个属性名就叫 UTF8。\n\n\n# 书写风格\n\nHTML 标签名、类名、标签属性和大部分属性值统一用小写\n\n推荐：\n\n<div class="demo"></div>\n\n\n1\n\n\n不推荐：\n\n<div class="DEMO"></div>\n\n<div class="DEMO"></div>\n\n\n1\n2\n3\n\n\n\n# 类型属性\n\n不需要为 CSS、JS 指定类型属性，HTML5 中默认已包含\n\n推荐：\n\n<link rel="stylesheet" href="" />\n<script src=""><\/script>\n\n\n1\n2\n\n\n不推荐：\n\n<link rel="stylesheet" type="text/css" href="" />\n<script type="text/javascript" src=""><\/script>\n\n\n1\n2\n\n\n\n# 元素属性\n\n * 元素属性值使用双引号语法\n * 元素属性值可以写上的都写上\n\n推荐：\n\n<input type="text" /> <input type="radio" name="name" checked="checked" />\n\n\n1\n\n\n不推荐：\n\n<input type="text" />\n<input type="text" />\n<input type="radio" name="name" checked />\n\n\n1\n2\n3\n\n\n\n# 特殊字符引用\n\n文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。\n\n在 HTML 中不能使用小于号 “<” 和大于号 “>”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 HTML 源代码中使用字符实体\n\n推荐：\n\n<a href="#">more&gt;&gt;</a>\n\n\n1\n\n\n不推荐：\n\n<a href="#">more>></a>\n\n\n1\n\n\n\n# 代码缩进\n\n统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）\n\n<div class="jdc">\n  <a href="#"></a>\n</div>\n\n\n1\n2\n3\n\n\n\n# 代码嵌套\n\n元素嵌套规范，每个块状元素独立一行，内联元素可选\n\n推荐：\n\n<div>\n  <h1></h1>\n  <p></p>\n</div>\n<p><span></span><span></span></p>\n\n\n1\n2\n3\n4\n5\n\n\n不推荐：\n\n<div>\n  <h1></h1>\n  <p></p>\n</div>\n<p>\n  <span></span>\n  <span></span>\n</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n段落元素与标题元素只能嵌套内联元素\n\n推荐：\n\n<h1><span></span></h1>\n<p><span></span><span></span></p>\n\n\n1\n2\n\n\n不推荐：\n\n<h1><div></div></h1>\n<p><div></div><div></div></p>\n\n\n1\n2\n\n\n\n# 图片规范\n\n\n# 内容图\n\n内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大\n\n * 优先考虑 JPEG 格式，条件允许的话优先考虑 WebP 格式\n * 尽量不使用 PNG 格式，PNG8 色位太低，PNG24 压缩率低，文件体积大\n * PC 平台单张的图片的大小不应大于 200KB。\n\n\n# 背景图\n\n背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片\n\n * PNG 与 GIF 格式，优先考虑使用 PNG 格式,PNG 格式允许更多的颜色并提供更好的压缩率\n * 图像颜色比较简单的，如纯色块线条图标，优先考虑使用 PNG8 格式，避免不使用 JPEG 格式\n * 图像颜色丰富而且图片文件不太大的（40KB 以下）或有半透明效果的优先考虑 PNG24 格式\n * 图像颜色丰富而且文件比较大的（40KB - 200KB）优先考虑 JPEG 格式\n * 条件允许的，优先考虑 WebP 代替 PNG 和 JPEG 格式\n\n\n# CSS 规范\n\n\n# 代码格式化\n\n样式书写一般有两种：一种是紧凑格式 (Compact)\n\n.jdc {\n  display: block;\n  width: 50px;\n}\n\n\n1\n2\n3\n4\n\n\n一种是展开格式（Expanded）\n\n.jdc {\n  display: block;\n  width: 50px;\n}\n\n\n1\n2\n3\n4\n\n\n团队约定：统一使用展开格式书写样式\n\n\n# 代码大小写\n\n样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。\n\n/* 推荐 */\n.jdc {\n  display: block;\n}\n\n/* 不推荐 */\n.JDC {\n  display: BLOCK;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 选择器\n\n * 尽量少用通用选择器 *\n * 不使用 ID 选择器\n * 不使用无具体语义定义的标签选择器\n\n/* 推荐 */\n.jdc {\n}\n.jdc li {\n}\n.jdc li p {\n}\n\n/* 不推荐 */\n* {\n}\n#jdc {\n}\n.jdc div {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 代码缩进\n\n统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）\n\n.jdc {\n  width: 100%;\n  height: 100%;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 分号\n\n每个属性声明末尾都要加分号；\n\n.jdc {\n  width: 100%;\n  height: 100%;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 代码易读性\n\n左括号与类名之间一个空格，冒号与属性值之间一个空格\n\n推荐：\n\n.jdc {\n  width: 100%;\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  width: 100%;\n}\n\n\n1\n2\n3\n\n\n逗号分隔的取值，逗号之后一个空格\n\n推荐：\n\n.jdc {\n  box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;\n}\n\n\n1\n2\n3\n\n\n为单个 css 选择器或新申明开启新行\n\n推荐：\n\n.jdc,\n.jdc_logo,\n.jdc_hd {\n  color: #ff0;\n}\n.nav {\n  color: #fff;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n不推荐：\n\n.jdc,\njdc_logo,\n.jdc_hd {\n  color: #ff0;\n}\n.nav {\n  color: #fff;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0\n\n推荐：\n\n.jdc {\n  color: rgba(255, 255, 255, 0.5);\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  color: rgba(255, 255, 255, 0.5);\n}\n\n\n1\n2\n3\n\n\n属性值十六进制数值能用简写的尽量用简写\n\n推荐：\n\n.jdc {\n  color: #fff;\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  color: #ffffff;\n}\n\n\n1\n2\n3\n\n\n不要为 0 指明单位\n\n推荐：\n\n.jdc {\n  margin: 0 10px;\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  margin: 0px 10px;\n}\n\n\n1\n2\n3\n\n\n\n# 属性值引号\n\ncss 属性值需要用到引号时，统一使用单引号\n\n/* 推荐 */\n.jdc {\n  font-family: \'Hiragino Sans GB\';\n}\n\n/* 不推荐 */\n.jdc {\n  font-family: \'Hiragino Sans GB\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 属性书写顺序\n\n建议遵循以下顺序：\n\n 1. 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）\n 2. 自身属性：width / height / margin / padding / border / background\n 3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word\n 4. 其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …\n\n.jdc {\n  display: block;\n  position: relative;\n  float: left;\n  width: 100px;\n  height: 100px;\n  margin: 0 10px;\n  padding: 20px 0;\n  font-family: Arial, \'Helvetica Neue\', Helvetica, sans-serif;\n  color: #333;\n  background: rgba(0, 0, 0, 0.5);\n  -webkit-border-radius: 10px;\n  -moz-border-radius: 10px;\n  -o-border-radius: 10px;\n  -ms-border-radius: 10px;\n  border-radius: 10px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 命名规范\n\n由历史原因及个人习惯引起的 DOM 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。\n\n\n# 目录命名\n\n * 样式文件夹：css\n * 脚本文件夹：js\n * 样式类图片文件夹：images\n * 产品类图片文件夹（经常更换）： upload\n * 字体类文件夹： fonts\n\n\n# ClassName 命名\n\nClassName 的命名应该尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线 “_” 连接\n\n.nav_top\n\n# 常用命名推荐\n\n注意：ad、banner、gg、guanggao 等有机会和广告挂勾的不建议直接用来做 ClassName，因为有些浏览器插件（Chrome 的广告拦截插件等）会直接过滤这些类名，因此\n\n<div class="ad"></div>\n\n\n1\n\n\n这种广告的英文或拼音类名不应该出现\n\n另外，敏感不和谐字眼也不应该出现，如：\n\n<div class="fuck"></div>\n<div class="jer"></div>\n<div class="sm"></div>\n<div class="gcd"></div>\n<div class="ass"></div>\n<div class="KMT"></div>\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nCLASSNAME                含义\nabout                    关于\naccount                  账户\narrow                    箭头图标\narticle                  文章\naside                    边栏\naudio                    音频\navatar                   头像\nbg,background            背景\nbar                      栏（工具类）\nbranding                 品牌化\ncrumb,breadcrumbs        面包屑\nbtn,button               按钮\ncaption                  标题，说明\ncategory                 分类\nchart                    图表\nclearfix                 清除浮动\nclose                    关闭\ncol,column               列\ncomment                  评论\ncommunity                社区\ncontainer                容器\ncontent                  内容\ncopyright                版权\ncurrent                  当前态，选中态\ndefault                  默认\ndescription              描述\ndetails                  细节\ndisabled                 不可用\nentry                    文章，博文\nerror                    错误\neven                     偶数，常用于多行列表或表格中\nfail                     失败（提示）\nfeature                  专题\nfewer                    收起\nfield                    用于表单的输入区域\nfigure                   图\nfilter                   筛选\nfirst                    第一个，常用于列表中\nfooter                   页脚\nforum                    论坛\ngallery                  画廊\ngroup                    模块，清除浮动\nheader                   页头\nhelp                     帮助\nhide                     隐藏\nhightlight               高亮\nhome                     主页\nicon                     图标\ninfo,information         信息\nlast                     最后一个，常用于列表中\nlinks                    链接\nlogin                    登录\nlogout                   退出\nlogo                     标志\nmain                     主体\nmenu                     菜单\nmeta                     作者、更新时间等信息栏，一般位于标题之下\nmodule                   模块\nmore                     更多（展开）\nmsg,message              消息\nnav,navigation           导航\nnext                     下一页\nnub                      小块\nodd                      奇数，常用于多行列表或表格中\noff                      鼠标离开\non                       鼠标移过\noutput                   输出\npagination               分页\npop,popup                弹窗\npreview                  预览\nprevious                 上一页\nprimary                  主要\nprogress                 进度条\npromotion                促销\nrcommd,recommendations   推荐\nreg,register             注册\nsave                     保存\nsearch                   搜索\nsecondary                次要\nsection                  区块\nselected                 已选\nshare                    分享\nshow                     显示\nsidebar                  边栏，侧栏\nslide                    幻灯片，图片切换\nsort                     排序\nsub                      次级的，子级的\nsubmit                   提交\nsubscribe                订阅\nsubtitle                 副标题\nsuccess                  成功（提示）\nsummary                  摘要\ntab                      标签页\ntable                    表格\ntxt,text                 文本\nthumbnail                缩略图\ntime                     时间\ntips                     提示\ntitle                    标题\nvideo                    视频\nwrap                     容器，包，一般用于最外层\nwrapper                  容器，包，一般用于最外层',normalizedContent:'# 代码规范\n\n> 借鉴京东前端代码规范\n\n\n# html 规范\n\n\n# doctype 声明\n\nhtml 文件必须加上 doctype 声明，并统一使用 html5 的文档声明：\n\n<!doctype html>\n\n\n1\n\n\nhtml5 标准模版\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <title>document</title>\n  </head>\n  <body></body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 页面语言 lang\n\n可以省略，也使用属性值 cmn-hans-cn（简体, 中国大陆），但是考虑浏览器和操作系统的兼容性，目前仍然使用 zh-cn 属性值\n\n<html lang="zh-cn"></html>\n\n\n1\n\n\n更多地区语言参考：\n\nzh-sg 中文 (简体, 新加坡)   对应 cmn-hans-sg 普通话 (简体, 新加坡)\nzh-hk 中文 (繁体, 香港)     对应 cmn-hant-hk 普通话 (繁体, 香港)\nzh-mo 中文 (繁体, 澳门)     对应 cmn-hant-mo 普通话 (繁体, 澳门)\nzh-tw 中文 (繁体, 台湾)     对应 cmn-hant-tw 普通话 (繁体, 台湾)\n\n\n1\n2\n3\n4\n\n\n\n# charset 字符集合\n\n一般情况下统一使用 “utf-8” 编码\n\n<meta charset="utf-8" />\n\n\n1\n\n\n由于历史原因，有些业务可能会使用 “gbk” 编码\n\n<meta charset="gbk" />\n\n\n1\n\n\n请尽量统一写成标准的 “utf-8”，不要写成 “utf-8” 或 “utf8” 或 “utf8”。根据 ietf 对 utf-8 的定义，其编码标准的写法是 “utf-8”；而 utf8 或 utf8 的写法只是出现在某些编程系统中，如 .net framework 的类 system.text.encoding 中的一个属性名就叫 utf8。\n\n\n# 书写风格\n\nhtml 标签名、类名、标签属性和大部分属性值统一用小写\n\n推荐：\n\n<div class="demo"></div>\n\n\n1\n\n\n不推荐：\n\n<div class="demo"></div>\n\n<div class="demo"></div>\n\n\n1\n2\n3\n\n\n\n# 类型属性\n\n不需要为 css、js 指定类型属性，html5 中默认已包含\n\n推荐：\n\n<link rel="stylesheet" href="" />\n<script src=""><\/script>\n\n\n1\n2\n\n\n不推荐：\n\n<link rel="stylesheet" type="text/css" href="" />\n<script type="text/javascript" src=""><\/script>\n\n\n1\n2\n\n\n\n# 元素属性\n\n * 元素属性值使用双引号语法\n * 元素属性值可以写上的都写上\n\n推荐：\n\n<input type="text" /> <input type="radio" name="name" checked="checked" />\n\n\n1\n\n\n不推荐：\n\n<input type="text" />\n<input type="text" />\n<input type="radio" name="name" checked />\n\n\n1\n2\n3\n\n\n\n# 特殊字符引用\n\n文本可以和字符引用混合出现。这种方法可以用来转义在文本中不能合法出现的字符。\n\n在 html 中不能使用小于号 “<” 和大于号 “>”特殊字符，浏览器会将它们作为标签解析，若要正确显示，在 html 源代码中使用字符实体\n\n推荐：\n\n<a href="#">more&gt;&gt;</a>\n\n\n1\n\n\n不推荐：\n\n<a href="#">more>></a>\n\n\n1\n\n\n\n# 代码缩进\n\n统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）\n\n<div class="jdc">\n  <a href="#"></a>\n</div>\n\n\n1\n2\n3\n\n\n\n# 代码嵌套\n\n元素嵌套规范，每个块状元素独立一行，内联元素可选\n\n推荐：\n\n<div>\n  <h1></h1>\n  <p></p>\n</div>\n<p><span></span><span></span></p>\n\n\n1\n2\n3\n4\n5\n\n\n不推荐：\n\n<div>\n  <h1></h1>\n  <p></p>\n</div>\n<p>\n  <span></span>\n  <span></span>\n</p>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n段落元素与标题元素只能嵌套内联元素\n\n推荐：\n\n<h1><span></span></h1>\n<p><span></span><span></span></p>\n\n\n1\n2\n\n\n不推荐：\n\n<h1><div></div></h1>\n<p><div></div><div></div></p>\n\n\n1\n2\n\n\n\n# 图片规范\n\n\n# 内容图\n\n内容图多以商品图等照片类图片形式存在，颜色较为丰富，文件体积较大\n\n * 优先考虑 jpeg 格式，条件允许的话优先考虑 webp 格式\n * 尽量不使用 png 格式，png8 色位太低，png24 压缩率低，文件体积大\n * pc 平台单张的图片的大小不应大于 200kb。\n\n\n# 背景图\n\n背景图多为图标等颜色比较简单、文件体积不大、起修饰作用的图片\n\n * png 与 gif 格式，优先考虑使用 png 格式,png 格式允许更多的颜色并提供更好的压缩率\n * 图像颜色比较简单的，如纯色块线条图标，优先考虑使用 png8 格式，避免不使用 jpeg 格式\n * 图像颜色丰富而且图片文件不太大的（40kb 以下）或有半透明效果的优先考虑 png24 格式\n * 图像颜色丰富而且文件比较大的（40kb - 200kb）优先考虑 jpeg 格式\n * 条件允许的，优先考虑 webp 代替 png 和 jpeg 格式\n\n\n# css 规范\n\n\n# 代码格式化\n\n样式书写一般有两种：一种是紧凑格式 (compact)\n\n.jdc {\n  display: block;\n  width: 50px;\n}\n\n\n1\n2\n3\n4\n\n\n一种是展开格式（expanded）\n\n.jdc {\n  display: block;\n  width: 50px;\n}\n\n\n1\n2\n3\n4\n\n\n团队约定：统一使用展开格式书写样式\n\n\n# 代码大小写\n\n样式选择器，属性名，属性值关键字全部使用小写字母书写，属性字符串允许使用大小写。\n\n/* 推荐 */\n.jdc {\n  display: block;\n}\n\n/* 不推荐 */\n.jdc {\n  display: block;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 选择器\n\n * 尽量少用通用选择器 *\n * 不使用 id 选择器\n * 不使用无具体语义定义的标签选择器\n\n/* 推荐 */\n.jdc {\n}\n.jdc li {\n}\n.jdc li p {\n}\n\n/* 不推荐 */\n* {\n}\n#jdc {\n}\n.jdc div {\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 代码缩进\n\n统一使用四个空格进行代码缩进，使得各编辑器表现一致（各编辑器有相关配置）\n\n.jdc {\n  width: 100%;\n  height: 100%;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 分号\n\n每个属性声明末尾都要加分号；\n\n.jdc {\n  width: 100%;\n  height: 100%;\n}\n\n\n1\n2\n3\n4\n\n\n\n# 代码易读性\n\n左括号与类名之间一个空格，冒号与属性值之间一个空格\n\n推荐：\n\n.jdc {\n  width: 100%;\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  width: 100%;\n}\n\n\n1\n2\n3\n\n\n逗号分隔的取值，逗号之后一个空格\n\n推荐：\n\n.jdc {\n  box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  box-shadow: 1px 1px 1px #333, 2px 2px 2px #ccc;\n}\n\n\n1\n2\n3\n\n\n为单个 css 选择器或新申明开启新行\n\n推荐：\n\n.jdc,\n.jdc_logo,\n.jdc_hd {\n  color: #ff0;\n}\n.nav {\n  color: #fff;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n不推荐：\n\n.jdc,\njdc_logo,\n.jdc_hd {\n  color: #ff0;\n}\n.nav {\n  color: #fff;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n颜色值 rgb() rgba() hsl() hsla() rect() 中不需有空格，且取值不要带有不必要的 0\n\n推荐：\n\n.jdc {\n  color: rgba(255, 255, 255, 0.5);\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  color: rgba(255, 255, 255, 0.5);\n}\n\n\n1\n2\n3\n\n\n属性值十六进制数值能用简写的尽量用简写\n\n推荐：\n\n.jdc {\n  color: #fff;\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  color: #ffffff;\n}\n\n\n1\n2\n3\n\n\n不要为 0 指明单位\n\n推荐：\n\n.jdc {\n  margin: 0 10px;\n}\n\n\n1\n2\n3\n\n\n不推荐：\n\n.jdc {\n  margin: 0px 10px;\n}\n\n\n1\n2\n3\n\n\n\n# 属性值引号\n\ncss 属性值需要用到引号时，统一使用单引号\n\n/* 推荐 */\n.jdc {\n  font-family: \'hiragino sans gb\';\n}\n\n/* 不推荐 */\n.jdc {\n  font-family: \'hiragino sans gb\';\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 属性书写顺序\n\n建议遵循以下顺序：\n\n 1. 布局定位属性：display / position / float / clear / visibility / overflow（建议 display 第一个写，毕竟关系到模式）\n 2. 自身属性：width / height / margin / padding / border / background\n 3. 文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word\n 4. 其他属性（css3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …\n\n.jdc {\n  display: block;\n  position: relative;\n  float: left;\n  width: 100px;\n  height: 100px;\n  margin: 0 10px;\n  padding: 20px 0;\n  font-family: arial, \'helvetica neue\', helvetica, sans-serif;\n  color: #333;\n  background: rgba(0, 0, 0, 0.5);\n  -webkit-border-radius: 10px;\n  -moz-border-radius: 10px;\n  -o-border-radius: 10px;\n  -ms-border-radius: 10px;\n  border-radius: 10px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 命名规范\n\n由历史原因及个人习惯引起的 dom 结构、命名不统一，导致不同成员在维护同一页面时，效率低下，迭代、维护成本极高。\n\n\n# 目录命名\n\n * 样式文件夹：css\n * 脚本文件夹：js\n * 样式类图片文件夹：images\n * 产品类图片文件夹（经常更换）： upload\n * 字体类文件夹： fonts\n\n\n# classname 命名\n\nclassname 的命名应该尽量精短、明确，必须以字母开头命名，且全部字母为小写，单词之间统一使用下划线 “_” 连接\n\n.nav_top\n\n# 常用命名推荐\n\n注意：ad、banner、gg、guanggao 等有机会和广告挂勾的不建议直接用来做 classname，因为有些浏览器插件（chrome 的广告拦截插件等）会直接过滤这些类名，因此\n\n<div class="ad"></div>\n\n\n1\n\n\n这种广告的英文或拼音类名不应该出现\n\n另外，敏感不和谐字眼也不应该出现，如：\n\n<div class="fuck"></div>\n<div class="jer"></div>\n<div class="sm"></div>\n<div class="gcd"></div>\n<div class="ass"></div>\n<div class="kmt"></div>\n...\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nclassname                含义\nabout                    关于\naccount                  账户\narrow                    箭头图标\narticle                  文章\naside                    边栏\naudio                    音频\navatar                   头像\nbg,background            背景\nbar                      栏（工具类）\nbranding                 品牌化\ncrumb,breadcrumbs        面包屑\nbtn,button               按钮\ncaption                  标题，说明\ncategory                 分类\nchart                    图表\nclearfix                 清除浮动\nclose                    关闭\ncol,column               列\ncomment                  评论\ncommunity                社区\ncontainer                容器\ncontent                  内容\ncopyright                版权\ncurrent                  当前态，选中态\ndefault                  默认\ndescription              描述\ndetails                  细节\ndisabled                 不可用\nentry                    文章，博文\nerror                    错误\neven                     偶数，常用于多行列表或表格中\nfail                     失败（提示）\nfeature                  专题\nfewer                    收起\nfield                    用于表单的输入区域\nfigure                   图\nfilter                   筛选\nfirst                    第一个，常用于列表中\nfooter                   页脚\nforum                    论坛\ngallery                  画廊\ngroup                    模块，清除浮动\nheader                   页头\nhelp                     帮助\nhide                     隐藏\nhightlight               高亮\nhome                     主页\nicon                     图标\ninfo,information         信息\nlast                     最后一个，常用于列表中\nlinks                    链接\nlogin                    登录\nlogout                   退出\nlogo                     标志\nmain                     主体\nmenu                     菜单\nmeta                     作者、更新时间等信息栏，一般位于标题之下\nmodule                   模块\nmore                     更多（展开）\nmsg,message              消息\nnav,navigation           导航\nnext                     下一页\nnub                      小块\nodd                      奇数，常用于多行列表或表格中\noff                      鼠标离开\non                       鼠标移过\noutput                   输出\npagination               分页\npop,popup                弹窗\npreview                  预览\nprevious                 上一页\nprimary                  主要\nprogress                 进度条\npromotion                促销\nrcommd,recommendations   推荐\nreg,register             注册\nsave                     保存\nsearch                   搜索\nsecondary                次要\nsection                  区块\nselected                 已选\nshare                    分享\nshow                     显示\nsidebar                  边栏，侧栏\nslide                    幻灯片，图片切换\nsort                     排序\nsub                      次级的，子级的\nsubmit                   提交\nsubscribe                订阅\nsubtitle                 副标题\nsuccess                  成功（提示）\nsummary                  摘要\ntab                      标签页\ntable                    表格\ntxt,text                 文本\nthumbnail                缩略图\ntime                     时间\ntips                     提示\ntitle                    标题\nvideo                    视频\nwrap                     容器，包，一般用于最外层\nwrapper                  容器，包，一般用于最外层',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"0 入门-0 入门",frontmatter:{title:"0 入门-0 入门",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/84d48a/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/100.%E5%85%A5%E9%97%A8/101.%E5%85%A5%E9%97%A8.html",relativePath:"1200.JS/100.入门/101.入门.md",key:"v-9888aae6",path:"/pages/84d48a/",headers:[{level:2,title:"JS 与 Java、C# 区别",slug:"js-与-java、c-区别",normalizedTitle:"js 与 java、c# 区别",charIndex:12}],headersStr:"JS 与 Java、C# 区别",content:"# JS 入门\n\n\n# JS 与 Java、C# 区别\n\n对象、原型、函数和闭包的紧密结合组成了JavaScript\n\n * 基于原型的面向对象——不同于其他主流的面向对象语言（例如C#、Java、Ruby）使用基于类的面向对象，JavaScript使用基于原型的面向对象。\n\n * 函数是一等公民（一级对象）。在JavaScript中，函数与其他对象共存，并且能够像任何其他对象一样地使用。\n   \n   * 函数可以通过字面量创建\n   \n   * 可以赋值给变量\n   \n   * 可以作为函数参数进行传递\n   \n   * 甚至可以作为返回值从函数中返回\n\n * 函数闭包。当函数主动维护了在函数内使用的外部的变量，则该函数为一个闭包\n\n * 作用域。依赖函数级别的变量和全局变量（ES6前）",normalizedContent:"# js 入门\n\n\n# js 与 java、c# 区别\n\n对象、原型、函数和闭包的紧密结合组成了javascript\n\n * 基于原型的面向对象——不同于其他主流的面向对象语言（例如c#、java、ruby）使用基于类的面向对象，javascript使用基于原型的面向对象。\n\n * 函数是一等公民（一级对象）。在javascript中，函数与其他对象共存，并且能够像任何其他对象一样地使用。\n   \n   * 函数可以通过字面量创建\n   \n   * 可以赋值给变量\n   \n   * 可以作为函数参数进行传递\n   \n   * 甚至可以作为返回值从函数中返回\n\n * 函数闭包。当函数主动维护了在函数内使用的外部的变量，则该函数为一个闭包\n\n * 作用域。依赖函数级别的变量和全局变量（es6前）",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"0 入门-1 Web 应用的生命周期",frontmatter:{title:"0 入门-1 Web 应用的生命周期",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/e22d1e/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/100.%E5%85%A5%E9%97%A8/102.Web%20%E5%BA%94%E7%94%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"1200.JS/100.入门/102.Web 应用的生命周期.md",key:"v-0572c1aa",path:"/pages/e22d1e/",headers:[{level:2,title:"页面构建阶段",slug:"页面构建阶段",normalizedTitle:"页面构建阶段",charIndex:21},{level:2,title:"事件处理阶段—事件队列",slug:"事件处理阶段-事件队列",normalizedTitle:"事件处理阶段—事件队列",charIndex:281},{level:3,title:"事件处理器概览",slug:"事件处理器概览",normalizedTitle:"事件处理器概览",charIndex:297},{level:4,title:"异步事件",slug:"异步事件",normalizedTitle:"异步事件",charIndex:657},{level:3,title:"注册事件处理器",slug:"注册事件处理器",normalizedTitle:"注册事件处理器",charIndex:950},{level:3,title:"处理事件",slug:"处理事件",normalizedTitle:"处理事件",charIndex:1304}],headersStr:"页面构建阶段 事件处理阶段—事件队列 事件处理器概览 异步事件 注册事件处理器 处理事件",content:"# Web 应用的生命周期 🔥\n\n\n# 页面构建阶段\n\n * 解析 HTML，构建 DOM\n   \n   按顺序解析，即使是 script 标签（只不过会阻塞执行）。遇到标签放置错误，浏览器会修复并放入该放的位置\n\n * 执行 JavaScript（可能会注册事件监听器）\n\n全局 window 对象会存在于整个页面的生存期之间，在它上面存储着所有的 JavaScript 变量。只要还有没处理完的 HTML 元素和没执行完的 JavaScript 代码，上面两个步骤都会一直交替执行。\n\n当浏览器处理完所有 HTML 元素后，页面构建阶段就结束了。\n\n\n# 事件处理阶段—事件队列\n\n\n# 事件处理器概览\n\n在页面构建阶段执行的 JavaScript 代码，除了会影响全局应用状态和修改 DOM外，还会注册事件监听器（或处理器）。这类监听器会在事件发生时，由浏览器调用执行。\n\n浏览器执行环境的核心思想基于：同一时刻只能执行一个代码片段，即所谓的单线程执行模型。事件处理流程如下：\n\n * 浏览器检查事件队列头；\n * 如果浏览器没有在队列中检测到事件，则继续检查；\n * 如果浏览器在队列头中检测到了事件，则取出该事件并执行相应的事件处理器（如果存在）。\n\n在这个过程中，余下的事件在事件队列中耐心等待，直到轮到它们被处理。\n\n重点注意浏览器在这个过程中的机制，其放置事件的队列是在页面构建阶段和事件处理阶段以外的。这个过程对于决定事件何时发生并将其推入事件队列很重要，这个过程不会参与事件处理线程。\n\n# 异步事件\n\n事件可能会以难以预计的时间和顺序发生（强制用户以某个顺序按键或单击是非常奇怪的）。我们对事件的处理，以及处理函数的调用是异步的。如下类型的事件会在其他类型事件中发生。\n\n * 浏览器事件，例如当页面加载完成后或无法加载时；\n * 网络事件，例如来自服务器的响应（Ajax 事件和服务器端事件）；\n * 用户事件，例如鼠标单击、鼠标移动和键盘事件；\n * 计时器事件，当 timeout 时间到期或又触发了一次时间间隔。\n\nWeb 应用的 JavaScript 代码中，大部分内容都是对上述事件的处理！\n\n除了全局代码，页面中的大部分代码都将作为某个事件的结果执行。\n\n\n# 注册事件处理器\n\n事件处理器是当某个特定事件发生后我们希望执行的函数。告知浏览器要处理哪个事件的过程叫做注册事件处理器。\n\n * 通过把函数赋给某个特殊属性。不推荐，因为对于某个事件只能注册一个事件处理器，可能会覆盖掉上一个事件处理器\n   \n   window.onload = function() {}\n   // 当DOM已经就绪并全部构建完成，就会触发这个事件\n   \n   \n   1\n   2\n   \n   \n   document.body.onclick = function() {}\n   // 为在文档中body元素的单击事件注册处理器\n   \n   \n   1\n   2\n   \n\n * 通过使用内置 addEventListener 方法。推荐，可以注册多个事件处理器。\n\n\n# 处理事件\n\n事件处理背后的的主要思想是：当事件发生时，浏览器调用相应的事件处理器。由于单线程执行模型，所以同一时刻只能处理一个事件。任何后面的事件都只能在当前事件处理器完全结束执行后才能被处理！",normalizedContent:"# web 应用的生命周期 🔥\n\n\n# 页面构建阶段\n\n * 解析 html，构建 dom\n   \n   按顺序解析，即使是 script 标签（只不过会阻塞执行）。遇到标签放置错误，浏览器会修复并放入该放的位置\n\n * 执行 javascript（可能会注册事件监听器）\n\n全局 window 对象会存在于整个页面的生存期之间，在它上面存储着所有的 javascript 变量。只要还有没处理完的 html 元素和没执行完的 javascript 代码，上面两个步骤都会一直交替执行。\n\n当浏览器处理完所有 html 元素后，页面构建阶段就结束了。\n\n\n# 事件处理阶段—事件队列\n\n\n# 事件处理器概览\n\n在页面构建阶段执行的 javascript 代码，除了会影响全局应用状态和修改 dom外，还会注册事件监听器（或处理器）。这类监听器会在事件发生时，由浏览器调用执行。\n\n浏览器执行环境的核心思想基于：同一时刻只能执行一个代码片段，即所谓的单线程执行模型。事件处理流程如下：\n\n * 浏览器检查事件队列头；\n * 如果浏览器没有在队列中检测到事件，则继续检查；\n * 如果浏览器在队列头中检测到了事件，则取出该事件并执行相应的事件处理器（如果存在）。\n\n在这个过程中，余下的事件在事件队列中耐心等待，直到轮到它们被处理。\n\n重点注意浏览器在这个过程中的机制，其放置事件的队列是在页面构建阶段和事件处理阶段以外的。这个过程对于决定事件何时发生并将其推入事件队列很重要，这个过程不会参与事件处理线程。\n\n# 异步事件\n\n事件可能会以难以预计的时间和顺序发生（强制用户以某个顺序按键或单击是非常奇怪的）。我们对事件的处理，以及处理函数的调用是异步的。如下类型的事件会在其他类型事件中发生。\n\n * 浏览器事件，例如当页面加载完成后或无法加载时；\n * 网络事件，例如来自服务器的响应（ajax 事件和服务器端事件）；\n * 用户事件，例如鼠标单击、鼠标移动和键盘事件；\n * 计时器事件，当 timeout 时间到期或又触发了一次时间间隔。\n\nweb 应用的 javascript 代码中，大部分内容都是对上述事件的处理！\n\n除了全局代码，页面中的大部分代码都将作为某个事件的结果执行。\n\n\n# 注册事件处理器\n\n事件处理器是当某个特定事件发生后我们希望执行的函数。告知浏览器要处理哪个事件的过程叫做注册事件处理器。\n\n * 通过把函数赋给某个特殊属性。不推荐，因为对于某个事件只能注册一个事件处理器，可能会覆盖掉上一个事件处理器\n   \n   window.onload = function() {}\n   // 当dom已经就绪并全部构建完成，就会触发这个事件\n   \n   \n   1\n   2\n   \n   \n   document.body.onclick = function() {}\n   // 为在文档中body元素的单击事件注册处理器\n   \n   \n   1\n   2\n   \n\n * 通过使用内置 addeventlistener 方法。推荐，可以注册多个事件处理器。\n\n\n# 处理事件\n\n事件处理背后的的主要思想是：当事件发生时，浏览器调用相应的事件处理器。由于单线程执行模型，所以同一时刻只能处理一个事件。任何后面的事件都只能在当前事件处理器完全结束执行后才能被处理！",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"1 理解-0 函数的定义与参数",frontmatter:{title:"1 理解-0 函数的定义与参数",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/ebb062/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/200.%E7%90%86%E8%A7%A3/201.%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%8F%82%E6%95%B0.html",relativePath:"1200.JS/200.理解/201.函数的定义与参数.md",key:"v-6387b2f0",path:"/pages/ebb062/",headers:[{level:2,title:"对象的功能—引入",slug:"对象的功能-引入",normalizedTitle:"对象的功能—引入",charIndex:226},{level:2,title:"函数是第一类对象 🔥",slug:"函数是第一类对象-🔥",normalizedTitle:"函数是第一类对象 🔥",charIndex:804},{level:2,title:"回调函数 🔥",slug:"回调函数-🔥",normalizedTitle:"回调函数 🔥",charIndex:1774},{level:2,title:"函数动态创建和分配属性的应用 🔥",slug:"函数动态创建和分配属性的应用-🔥",normalizedTitle:"函数动态创建和分配属性的应用 🔥",charIndex:2066},{level:3,title:"存储函数",slug:"存储函数",normalizedTitle:"存储函数",charIndex:2116},{level:3,title:"自记忆函数",slug:"自记忆函数",normalizedTitle:"自记忆函数",charIndex:2606},{level:2,title:"函数定义",slug:"函数定义",normalizedTitle:"函数定义",charIndex:2003},{level:3,title:"函数声明 & 函数表达式 🔥",slug:"函数声明-函数表达式-🔥",normalizedTitle:"函数声明 &amp; 函数表达式 🔥",charIndex:null},{level:4,title:"立即调用函数表达式 IIFE 🔥",slug:"立即调用函数表达式-iife-🔥",normalizedTitle:"立即调用函数表达式 iife 🔥",charIndex:4127},{level:3,title:"箭头函数 🔥",slug:"箭头函数-🔥",normalizedTitle:"箭头函数 🔥",charIndex:4827},{level:3,title:"函数构造函数（略过）",slug:"函数构造函数-略过",normalizedTitle:"函数构造函数（略过）",charIndex:5201},{level:3,title:"生成器函数",slug:"生成器函数",normalizedTitle:"生成器函数",charIndex:5321},{level:2,title:"函数的参数",slug:"函数的参数",normalizedTitle:"函数的参数",charIndex:1179},{level:3,title:"函数的形参和实参",slug:"函数的形参和实参",normalizedTitle:"函数的形参和实参",charIndex:5531},{level:3,title:"剩余参数—ES6",slug:"剩余参数-es6",normalizedTitle:"剩余参数—es6",charIndex:5737},{level:3,title:"默认参数—ES6",slug:"默认参数-es6",normalizedTitle:"默认参数—es6",charIndex:6069},{level:2,title:"练习",slug:"练习",normalizedTitle:"练习",charIndex:7317},{level:3,title:"1",slug:"_1",normalizedTitle:"1",charIndex:414}],headersStr:"对象的功能—引入 函数是第一类对象 🔥 回调函数 🔥 函数动态创建和分配属性的应用 🔥 存储函数 自记忆函数 函数定义 函数声明 & 函数表达式 🔥 立即调用函数表达式 IIFE 🔥 箭头函数 🔥 函数构造函数（略过） 生成器函数 函数的参数 函数的形参和实参 剩余参数—ES6 默认参数—ES6 练习 1",content:"# 函数的定义与参数 🔥\n\n先讲函数是为了明确编写 JS 时需要有一颗函数式编程的心，而不是对象。当然也有缺点。\n\nJavaScript中最关键的概念是：函数是第一类对象（first-class objects），或者说它们被称作一等公民（first-class citizens）。函数与对象共存，函数也可以被视为其他任意类型的JavaScript对象。\n\n * 能以字面量形式声明\n * 能被变量引用\n * 甚至能被作为函数参数进行传递\n\n\n# 对象的功能—引入\n\n * 对象可通过字面量来创建{}\n\n * 对象可以赋值给变量、数组项，或其他对象的属性\n   \n   // 为变量赋值一个新对象\n   var ninja = {};\n   // 向数组增加一个新对象\n   ninjaArray.push({});\n   // 给某个对象的属性赋值一个新对象\n   ninja.data = {};\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 对象可以作为参数传递给函数\n   \n   function hide(ninja){\n       ninja.visibility = false;\n   }\n   hide({});\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 对象可以作为函数的返回值\n   \n   function returnNewNinja(){\n       return {};\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 对象能够具有动态创建和分配的属性\n   \n   var ninja = {};\n   ninja.name = \"conanan\";\n   \n   \n   1\n   2\n   \n\n在JavaScript中，我们几乎能够用函数来实现同样的事\n\n\n# 函数是第一类对象 🔥\n\nJavaScript中函数拥有对象的所有能力，也因此函数可被作为任意其他类型对象来对待。当我们说函数是第一类对象的时候，就是说函数也能够实现以下功能。\n\n * 通过字面量创建\n   \n   function ninjaFunction(){}\n   \n   \n   1\n   \n\n * 赋值给变量，数组项或其他对象的属性\n   \n   // 为变量赋值一个新函数\n   var ninja = function(){};\n   // 向数组增加一个新函数\n   ninjaArray.push(function(){});\n   // 给某个对象的属性赋值一个新函数\n   ninja.data = function(){};\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 作为函数的参数来传递\n   \n   function call(ninjaFunction){\n       ninjaFunction();\n   }\n   call(function(){});\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 作为函数的返回值\n   \n   function returnNewNinjaFunction(){\n       return function(){};\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 具有动态创建和分配的属性。这简直令人惊讶！！！🔥\n   \n   var ninjaFunction = function(){};\n   ninjaFunction.ninja = 'conanan';\n   // 上面两个的确实可以打印出正确的结果（注意不要使用name属性，它是函数的名称）\n   \n   function useless(ninjaCallback){\n       return ninjaCallback();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n对象能做的任何一件事，函数也都能做。函数也是对象，唯一的特殊之处在于它是可调用的（invokable），即函数会被调用以便执行某项动作。\n\n\n# 回调函数 🔥\n\n函数是第一类对象，它可以作为函数的参数来传递，这也表明传入函数会在应用程序执行的未来某个时间点才执行，即回调函数\n\n在执行过程中，我们建立的函数会被其他函数（无论是在事件处理阶段通过浏览器（事件）还是通过自己写的其他代码）在稍后的某个合适时间点“再回来调用”。实际中使用的地方很多，如：单击一次按钮、从服务端接收数据，还是UI动画的一部分，都是回调函数！\n\n还可以在表达式出现的任意位置创建函数，除此之外这种方式能使代码更紧凑和易于理解（把函数定义放在函数使用处附近）。当一个函数不会在代码的多处位置被调用时，该特性可以避免用非必须的名字污染全局命名空间。\n\n\n# 函数动态创建和分配属性的应用 🔥\n\n函数具有动态创建和分配的属性，利用此可以解决很多问题\n\n\n# 存储函数\n\n在集合中存储函数使我们轻易管理相关联的函数。例如，某些特定情况下必须调用的回调函数。不能重复！\n\nconst store = {\n    nextId: 1,\n    cache: {},\n    add: function(fn){\n        if(!fn.id){\n            // 动态分配函数属性\n            fn.id = this.nextId++\n            this.cache[fn.id] = fn\n            return true\n        }\n    }\n}\n\nfunction ninja(){}\nassert(store.add(ninja), 'Function was safely added.')\nassert(!store.add(ninja), 'But it was only added once.')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这个方法也不是特别好，后续可以使用 ES6 的 Set 来改进\n\n\n# 自记忆函数\n\n记忆让函数能记住上次计算得到的值，从而提高后续调用的性能。对于动画中的计算、搜索不经常变化的数据或任何耗时的数学计算来说，记忆化这种方式是十分有用的。如下面的素数：\n\nfunction isPrimer(value){\n    if(!isPrimer.answers){\n        // 构建一个结果缓存，它会保存函数每次计算得到的结果\n        isPrimer.answers = {}\n    }\n    \n    // 检查缓存的值\n    if(isPrimer.answers[value] !== undefined){\n        return isPrimer.answers[value]\n    }\n    \n    // 计算素数\n    let prime = value !== 0 && value !== 1 // 0 和 1 都不是素数\n    for(let i = 2; i < value; i++){\n        if(value % i === 0){\n            prime = false\n            break\n        }\n    }\n    \n    // 记录结果缓存，并返回 prime 的值，只是在这之前多个赋值操作\n    return isPrimer.answers[value] = prime\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n优点：\n\n * 由于函数调用时会寻找之前调用所得到的值，所以会有性能收益\n * 它几乎是无缝地发生在后台，最终用户和页面作者都不需要执行任何特殊请求，也不需要做任何额外初始化\n\n缺点：\n\n * 任何类型的缓存都必然会为性能牺牲内存\n * 缓存逻辑不应该和业务逻辑混合，函数或方法只需要把一件事做好。后续改进\n * 对于这类问题很难做负载测试或估计算法复杂度，因为结果依赖于函数之前的输入\n\n\n# 函数定义\n\n\n# 函数声明 & 函数表达式 🔥\n\n函数定义/声明（function declarations）和函数表达式（function expressions）最常用，在定义函数上却有微妙不同的的两种方式\n\n对于函数声明来说，函数名是强制性的，而对于函数表达式来说，函数名则完全是可选的\n\nfunction myFun(){\n    return 1\n}\n\nconst myFun = function(){\n    return 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n函数声明是独立的，是独立的JavaScript代码块（它可以被包含在其他函数中）\n\n让函数包含在另一个函数中可能会因为忽略作用域的标识符解析而引发一些有趣的问题\n\nfunction ninja(){\n    function hiddenNinja(){\n        return 'ninja here'\n    }\n    \n    return hiddenNinja()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n函数表达式 🔥\n\nJavaScript函数通常由函数字面量（function literal）来创建函数值，就像数字字面量创建一个数字值一样，function(){}就是字面量。它通常作为其他语句的一部分\n\nconst a = 3\nmyFunc(3)\n\nconst a = function(){}\nmyFunc(function(){})\n\n\n1\n2\n3\n4\n5\n\n\n# 立即调用函数表达式 IIFE 🔥\n\n也称为立即函数。这一特性能够模拟JavaScript中的模块化，故可以说它是JavaScript开发中的重要理念\n\n(function(num){ \n    console.log(num)\n})(10)\n\n\n1\n2\n3\n\n\n为什么**函数表达式**被包裹在一对括号内\n\n其原因是纯语法层面的。JavaScript解析器必须能够轻易区分函数声明和函数表达式之间的区别。如果去掉包裹函数表达式的括号，把立即调用作为一个独立语句function() {}(3), JavaScript开始解析时便会结束，因为这个独立语句以function开头，那么解析器就会认为它在处理一个函数声明。每个函数声明必须有一个名字（然而这里并没有指定名字），所以程序执行到这里会报错。为了避免错误，函数表达式要放在括号内，为JavaScript解析器指明它正在处理一个函数表达式而不是语句。\n\n还有一种相对简单的替代方案(function(){}(3))也能达到相同目标（然而这种方案有些奇怪，故不常使用）。把立即函数的定义和调用都放在括号内，同样可以为JavaScript解析器指明它正在处理函数表达式。\n\n立即调用函数表达式主题的4个不同版本\n\n+function(){}()\n-function(){}()\n!function(){}()\n~function(){}()\n\n\n1\n2\n3\n4\n\n\n这种做法也是用于向JavaScript引擎指明它处理的是表达式，而不是语句。从计算机的角度来讲，注意应用一元操作符得到的结果没有存储到任何地方并不重要，只有调用IIFE才重要\n\n\n# 箭头函数 🔥\n\n箭头函数（通常被叫做lambda函数），ES6 新增。由于JavaScript中会使用大量函数，增加简化创建函数方式的语法十分有意义\n\nlet arr = [3,1,5,2,9,6]\narr.sort((value1, value2) => value1 - value2)\n\n\n1\n2\n\n\n * 箭头函数的定义以一串可选参数名列表开头，参数名以逗号分隔\n   \n   对于0个或1个以上的参数，括号为必选项；否则括号不是必须的\n\n * 必选的=>\n\n * 如果箭头函数的函数体是一个表达式，则该箭头函数的返回值就是表达式的值\n\n * 如果箭头函数的函数体是一个代码块，则该箭头函数的返回值与普通函数一样（没有 return 语句则是 undefined）\n\n它能帮助我们规避一些在很多标准函数中可能遇到的难以捉摸的缺陷\n\n\n# 函数构造函数（略过）\n\n与构造函数不同！！！\n\n一种不常使用的函数定义方式，能让我们以字符串形式动态构造一个函数，这样得到的函数是动态生成的\n\nnew Function('a', 'b', 'return a + b')\n\n\n1\n\n\n\n# 生成器函数\n\nES6新增功能，能让我们创建不同于普通函数的函数，在应用程序执行过程中，这种函数能够退出再重新进入，在这些再进入之间保留函数内变量的值。我们可以定义生成器版本的函数声明、函数表达式、函数构造函数。\n\nfunction* myGen(){\n    yield 1\n}\n\n\n1\n2\n3\n\n\n函数创建的方式很大程度地影响了函数可被调用的时间、函数的行为以及函数可以在哪个对象上被调用\n\n\n# 函数的参数\n\n\n# 函数的形参和实参\n\n * 形参是我们定义函数时所列举的变量。所有类型的函数都能有形参（函数声明、函数表达式、箭头函数）\n * 实参是我们调用函数时所传递给函数的值\n\n注意\n\n * 实参的数量大于形参时不会报错，额外的实参不会赋值给任何形参。尽管有些实参没有被分配给某个形参名，但依然有一种获取它们的方式（后续补充）\n * 如果形参的数量大于实参，那么那些没有对应实参的形参则会被设为 undefined\n\n\n# 剩余参数—ES6\n\n类似 Java 可变参数。剩余参数是真正的Array实例，arguments不是！\n\nfunction multiMax(first, ...remainingNumbers){\n    const sortedArr = remainingNumbers.sort((value1, value2) => value2 - value1)\n    return first * sortedArr[0]\n}\n\nmultiMax(10,2,6,3,8,3)// 80\n\n\n1\n2\n3\n4\n5\n6\n\n\n只有函数的最后一个参数才能是剩余参数。否则报错 SyntaxError: parameter after rest parameter\n\n\n# 默认参数—ES6\n\n许多网页的UI组件（尤其是jQuery插件）都能被配置。例如，如果正在开发一个轮播组件，我们可能会给用户提供一个选项，用于指定某个项目多久会被另一个项目替代，以及一段在变化发生时间段内的动画。与此同时，可能某些用户并不关心这些问题，而且无论我们提供什么选项他们都乐于使用。对于这类场景，默认参数是完美选择。\n\n一个简单的例子：大部分“忍者”常常是偷偷摸摸地潜行(skulking)，但Yagyu只喜欢简简单单地潜行(sneaking)\n\nfunction performAction(ninja, action){\n    return ninja + \" \" + action\n}\n\nperformAction('conan','skulking')\nperformAction('conanan','skulking')\nperformAction('zhangsan','sneaking')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n每次重复相同的参数skulking是不是看起来相当无聊。在其他编程语言中，这个问题最常用的解决方式是函数重载（再定义一个名字相同但参数不同的函数）。但是 JavaScript不支持函数重载，所以当在过去面临这个问题的时候，开发者通常采用如下方法：\n\nfunction performAction(ninja, action){\n    action = typeof action === 'undefined' ? 'skulking' : 'sneaking'\n    return ninja + \" \" + action\n}\n\nperformAction('conan')\nperformAction('conanan')\nperformAction('zhangsan','sneaking')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nES6 的默认参数解决：\n\nfunction performAction(ninja, action = 'skulking'){\n    return ninja + \" \" + action\n}\n\nperformAction('conan')\nperformAction('conanan')\nperformAction('zhangsan','sneaking')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以为默认参数赋任何值，它既可以是数字或者字符串这样的原始类型，也可以是对象、数组，甚至函数这样的复杂类型。每次函数调用时都会从左到右求得参数的值，并且当对后面的默认参数赋值时可以引用前面的默认参数\n\n// 甚至可以引用前面的参数，不推荐这样写\nfunction performAction(ninja, action = 'skulking', message = ninja + \" \" + action){\n    return message\n}\n\n\n1\n2\n3\n4\n\n\n\n# 练习\n\n\n# 1\n\nvar samurai = (()=> 'tomoe')()\nconsole.log(samurai)// tomoe\n\nvar samurai2 = (()=> {'tomoe'})()\nconsole.log(samurai2)// undefined\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# 函数的定义与参数 🔥\n\n先讲函数是为了明确编写 js 时需要有一颗函数式编程的心，而不是对象。当然也有缺点。\n\njavascript中最关键的概念是：函数是第一类对象（first-class objects），或者说它们被称作一等公民（first-class citizens）。函数与对象共存，函数也可以被视为其他任意类型的javascript对象。\n\n * 能以字面量形式声明\n * 能被变量引用\n * 甚至能被作为函数参数进行传递\n\n\n# 对象的功能—引入\n\n * 对象可通过字面量来创建{}\n\n * 对象可以赋值给变量、数组项，或其他对象的属性\n   \n   // 为变量赋值一个新对象\n   var ninja = {};\n   // 向数组增加一个新对象\n   ninjaarray.push({});\n   // 给某个对象的属性赋值一个新对象\n   ninja.data = {};\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 对象可以作为参数传递给函数\n   \n   function hide(ninja){\n       ninja.visibility = false;\n   }\n   hide({});\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 对象可以作为函数的返回值\n   \n   function returnnewninja(){\n       return {};\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 对象能够具有动态创建和分配的属性\n   \n   var ninja = {};\n   ninja.name = \"conanan\";\n   \n   \n   1\n   2\n   \n\n在javascript中，我们几乎能够用函数来实现同样的事\n\n\n# 函数是第一类对象 🔥\n\njavascript中函数拥有对象的所有能力，也因此函数可被作为任意其他类型对象来对待。当我们说函数是第一类对象的时候，就是说函数也能够实现以下功能。\n\n * 通过字面量创建\n   \n   function ninjafunction(){}\n   \n   \n   1\n   \n\n * 赋值给变量，数组项或其他对象的属性\n   \n   // 为变量赋值一个新函数\n   var ninja = function(){};\n   // 向数组增加一个新函数\n   ninjaarray.push(function(){});\n   // 给某个对象的属性赋值一个新函数\n   ninja.data = function(){};\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 作为函数的参数来传递\n   \n   function call(ninjafunction){\n       ninjafunction();\n   }\n   call(function(){});\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 作为函数的返回值\n   \n   function returnnewninjafunction(){\n       return function(){};\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 具有动态创建和分配的属性。这简直令人惊讶！！！🔥\n   \n   var ninjafunction = function(){};\n   ninjafunction.ninja = 'conanan';\n   // 上面两个的确实可以打印出正确的结果（注意不要使用name属性，它是函数的名称）\n   \n   function useless(ninjacallback){\n       return ninjacallback();\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n对象能做的任何一件事，函数也都能做。函数也是对象，唯一的特殊之处在于它是可调用的（invokable），即函数会被调用以便执行某项动作。\n\n\n# 回调函数 🔥\n\n函数是第一类对象，它可以作为函数的参数来传递，这也表明传入函数会在应用程序执行的未来某个时间点才执行，即回调函数\n\n在执行过程中，我们建立的函数会被其他函数（无论是在事件处理阶段通过浏览器（事件）还是通过自己写的其他代码）在稍后的某个合适时间点“再回来调用”。实际中使用的地方很多，如：单击一次按钮、从服务端接收数据，还是ui动画的一部分，都是回调函数！\n\n还可以在表达式出现的任意位置创建函数，除此之外这种方式能使代码更紧凑和易于理解（把函数定义放在函数使用处附近）。当一个函数不会在代码的多处位置被调用时，该特性可以避免用非必须的名字污染全局命名空间。\n\n\n# 函数动态创建和分配属性的应用 🔥\n\n函数具有动态创建和分配的属性，利用此可以解决很多问题\n\n\n# 存储函数\n\n在集合中存储函数使我们轻易管理相关联的函数。例如，某些特定情况下必须调用的回调函数。不能重复！\n\nconst store = {\n    nextid: 1,\n    cache: {},\n    add: function(fn){\n        if(!fn.id){\n            // 动态分配函数属性\n            fn.id = this.nextid++\n            this.cache[fn.id] = fn\n            return true\n        }\n    }\n}\n\nfunction ninja(){}\nassert(store.add(ninja), 'function was safely added.')\nassert(!store.add(ninja), 'but it was only added once.')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n这个方法也不是特别好，后续可以使用 es6 的 set 来改进\n\n\n# 自记忆函数\n\n记忆让函数能记住上次计算得到的值，从而提高后续调用的性能。对于动画中的计算、搜索不经常变化的数据或任何耗时的数学计算来说，记忆化这种方式是十分有用的。如下面的素数：\n\nfunction isprimer(value){\n    if(!isprimer.answers){\n        // 构建一个结果缓存，它会保存函数每次计算得到的结果\n        isprimer.answers = {}\n    }\n    \n    // 检查缓存的值\n    if(isprimer.answers[value] !== undefined){\n        return isprimer.answers[value]\n    }\n    \n    // 计算素数\n    let prime = value !== 0 && value !== 1 // 0 和 1 都不是素数\n    for(let i = 2; i < value; i++){\n        if(value % i === 0){\n            prime = false\n            break\n        }\n    }\n    \n    // 记录结果缓存，并返回 prime 的值，只是在这之前多个赋值操作\n    return isprimer.answers[value] = prime\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n优点：\n\n * 由于函数调用时会寻找之前调用所得到的值，所以会有性能收益\n * 它几乎是无缝地发生在后台，最终用户和页面作者都不需要执行任何特殊请求，也不需要做任何额外初始化\n\n缺点：\n\n * 任何类型的缓存都必然会为性能牺牲内存\n * 缓存逻辑不应该和业务逻辑混合，函数或方法只需要把一件事做好。后续改进\n * 对于这类问题很难做负载测试或估计算法复杂度，因为结果依赖于函数之前的输入\n\n\n# 函数定义\n\n\n# 函数声明 & 函数表达式 🔥\n\n函数定义/声明（function declarations）和函数表达式（function expressions）最常用，在定义函数上却有微妙不同的的两种方式\n\n对于函数声明来说，函数名是强制性的，而对于函数表达式来说，函数名则完全是可选的\n\nfunction myfun(){\n    return 1\n}\n\nconst myfun = function(){\n    return 1\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n函数声明是独立的，是独立的javascript代码块（它可以被包含在其他函数中）\n\n让函数包含在另一个函数中可能会因为忽略作用域的标识符解析而引发一些有趣的问题\n\nfunction ninja(){\n    function hiddenninja(){\n        return 'ninja here'\n    }\n    \n    return hiddenninja()\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n函数表达式 🔥\n\njavascript函数通常由函数字面量（function literal）来创建函数值，就像数字字面量创建一个数字值一样，function(){}就是字面量。它通常作为其他语句的一部分\n\nconst a = 3\nmyfunc(3)\n\nconst a = function(){}\nmyfunc(function(){})\n\n\n1\n2\n3\n4\n5\n\n\n# 立即调用函数表达式 iife 🔥\n\n也称为立即函数。这一特性能够模拟javascript中的模块化，故可以说它是javascript开发中的重要理念\n\n(function(num){ \n    console.log(num)\n})(10)\n\n\n1\n2\n3\n\n\n为什么**函数表达式**被包裹在一对括号内\n\n其原因是纯语法层面的。javascript解析器必须能够轻易区分函数声明和函数表达式之间的区别。如果去掉包裹函数表达式的括号，把立即调用作为一个独立语句function() {}(3), javascript开始解析时便会结束，因为这个独立语句以function开头，那么解析器就会认为它在处理一个函数声明。每个函数声明必须有一个名字（然而这里并没有指定名字），所以程序执行到这里会报错。为了避免错误，函数表达式要放在括号内，为javascript解析器指明它正在处理一个函数表达式而不是语句。\n\n还有一种相对简单的替代方案(function(){}(3))也能达到相同目标（然而这种方案有些奇怪，故不常使用）。把立即函数的定义和调用都放在括号内，同样可以为javascript解析器指明它正在处理函数表达式。\n\n立即调用函数表达式主题的4个不同版本\n\n+function(){}()\n-function(){}()\n!function(){}()\n~function(){}()\n\n\n1\n2\n3\n4\n\n\n这种做法也是用于向javascript引擎指明它处理的是表达式，而不是语句。从计算机的角度来讲，注意应用一元操作符得到的结果没有存储到任何地方并不重要，只有调用iife才重要\n\n\n# 箭头函数 🔥\n\n箭头函数（通常被叫做lambda函数），es6 新增。由于javascript中会使用大量函数，增加简化创建函数方式的语法十分有意义\n\nlet arr = [3,1,5,2,9,6]\narr.sort((value1, value2) => value1 - value2)\n\n\n1\n2\n\n\n * 箭头函数的定义以一串可选参数名列表开头，参数名以逗号分隔\n   \n   对于0个或1个以上的参数，括号为必选项；否则括号不是必须的\n\n * 必选的=>\n\n * 如果箭头函数的函数体是一个表达式，则该箭头函数的返回值就是表达式的值\n\n * 如果箭头函数的函数体是一个代码块，则该箭头函数的返回值与普通函数一样（没有 return 语句则是 undefined）\n\n它能帮助我们规避一些在很多标准函数中可能遇到的难以捉摸的缺陷\n\n\n# 函数构造函数（略过）\n\n与构造函数不同！！！\n\n一种不常使用的函数定义方式，能让我们以字符串形式动态构造一个函数，这样得到的函数是动态生成的\n\nnew function('a', 'b', 'return a + b')\n\n\n1\n\n\n\n# 生成器函数\n\nes6新增功能，能让我们创建不同于普通函数的函数，在应用程序执行过程中，这种函数能够退出再重新进入，在这些再进入之间保留函数内变量的值。我们可以定义生成器版本的函数声明、函数表达式、函数构造函数。\n\nfunction* mygen(){\n    yield 1\n}\n\n\n1\n2\n3\n\n\n函数创建的方式很大程度地影响了函数可被调用的时间、函数的行为以及函数可以在哪个对象上被调用\n\n\n# 函数的参数\n\n\n# 函数的形参和实参\n\n * 形参是我们定义函数时所列举的变量。所有类型的函数都能有形参（函数声明、函数表达式、箭头函数）\n * 实参是我们调用函数时所传递给函数的值\n\n注意\n\n * 实参的数量大于形参时不会报错，额外的实参不会赋值给任何形参。尽管有些实参没有被分配给某个形参名，但依然有一种获取它们的方式（后续补充）\n * 如果形参的数量大于实参，那么那些没有对应实参的形参则会被设为 undefined\n\n\n# 剩余参数—es6\n\n类似 java 可变参数。剩余参数是真正的array实例，arguments不是！\n\nfunction multimax(first, ...remainingnumbers){\n    const sortedarr = remainingnumbers.sort((value1, value2) => value2 - value1)\n    return first * sortedarr[0]\n}\n\nmultimax(10,2,6,3,8,3)// 80\n\n\n1\n2\n3\n4\n5\n6\n\n\n只有函数的最后一个参数才能是剩余参数。否则报错 syntaxerror: parameter after rest parameter\n\n\n# 默认参数—es6\n\n许多网页的ui组件（尤其是jquery插件）都能被配置。例如，如果正在开发一个轮播组件，我们可能会给用户提供一个选项，用于指定某个项目多久会被另一个项目替代，以及一段在变化发生时间段内的动画。与此同时，可能某些用户并不关心这些问题，而且无论我们提供什么选项他们都乐于使用。对于这类场景，默认参数是完美选择。\n\n一个简单的例子：大部分“忍者”常常是偷偷摸摸地潜行(skulking)，但yagyu只喜欢简简单单地潜行(sneaking)\n\nfunction performaction(ninja, action){\n    return ninja + \" \" + action\n}\n\nperformaction('conan','skulking')\nperformaction('conanan','skulking')\nperformaction('zhangsan','sneaking')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n每次重复相同的参数skulking是不是看起来相当无聊。在其他编程语言中，这个问题最常用的解决方式是函数重载（再定义一个名字相同但参数不同的函数）。但是 javascript不支持函数重载，所以当在过去面临这个问题的时候，开发者通常采用如下方法：\n\nfunction performaction(ninja, action){\n    action = typeof action === 'undefined' ? 'skulking' : 'sneaking'\n    return ninja + \" \" + action\n}\n\nperformaction('conan')\nperformaction('conanan')\nperformaction('zhangsan','sneaking')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nes6 的默认参数解决：\n\nfunction performaction(ninja, action = 'skulking'){\n    return ninja + \" \" + action\n}\n\nperformaction('conan')\nperformaction('conanan')\nperformaction('zhangsan','sneaking')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n可以为默认参数赋任何值，它既可以是数字或者字符串这样的原始类型，也可以是对象、数组，甚至函数这样的复杂类型。每次函数调用时都会从左到右求得参数的值，并且当对后面的默认参数赋值时可以引用前面的默认参数\n\n// 甚至可以引用前面的参数，不推荐这样写\nfunction performaction(ninja, action = 'skulking', message = ninja + \" \" + action){\n    return message\n}\n\n\n1\n2\n3\n4\n\n\n\n# 练习\n\n\n# 1\n\nvar samurai = (()=> 'tomoe')()\nconsole.log(samurai)// tomoe\n\nvar samurai2 = (()=> {'tomoe'})()\nconsole.log(samurai2)// undefined\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"1 理解-1 理解函数调用",frontmatter:{title:"1 理解-1 理解函数调用",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/2a1d9d/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/200.%E7%90%86%E8%A7%A3/202..%E7%90%86%E8%A7%A3%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8.html",relativePath:"1200.JS/200.理解/202..理解函数调用.md",key:"v-45814ce9",path:"/pages/2a1d9d/",headers:[{level:2,title:"隐式函数参数",slug:"隐式函数参数",normalizedTitle:"隐式函数参数",charIndex:16},{level:2,title:"arguments参数",slug:"arguments参数",normalizedTitle:"arguments参数",charIndex:92},{level:2,title:"this—函数上下文",slug:"this-函数上下文",normalizedTitle:"this—函数上下文",charIndex:1472}],headersStr:"隐式函数参数 arguments参数 this—函数上下文",content:"# 理解函数调用 🔥\n\n\n# 隐式函数参数\n\n除了在函数定义中显式声明的参数之外，函数调用时还会传递两个隐式的参数：arguments和this，并且可以在函数内正常访问。\n\n\n# arguments参数\n\narguments参数是传递给函数的所有参数集合。无论是否有明确定义对应的形参，通过它我们都可以访问到函数的所有参数。借此可以实现原生JavaScript并不支持的函数重载特性，而且可以实现接收参数数量可变的可变函数。其实，借助剩余参数（restparameter），对arguments参数的需求已经大大减少了。\n\narguments对象有一个名为length的属性，表示实参的确切个数。通过数组索引的方式可以获取单个参数的值。但是arguments对象仅是一个类数组的结构，避免把它参数当作数组使用，尝试使用数组的方法时会报错！剩余参数是真正的Array实例\n\n实现一个求和函数，来计算任意数量参数的和：\n\nfunction sum(){\n    let sum = 0\n    for(let i = 0; i < arguments.length; i++){\n        sum += arguments[i]\n    }\n    return sum\n}\n\nsum(1,2,3)\nsum(2,3,4,5)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n**arguments对象可以与剩余参数、默认参数和解构赋值参数结合使用注意**\n\n在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变 arguments对象的行为，但是在非严格模式下就有所不同了\n\n当非严格模式中的函数没有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值会跟踪参数的值（反之亦然）\n\nfunction func(a) { \n  arguments[0] = 99;   // 更新了arguments[0] 同样更新了a\n  console.log(a);\n}\nfunc(10); // 99\n\n\n1\n2\n3\n4\n5\n\n\nfunction func(a) { \n  a = 99;              // 更新了a 同样更新了arguments[0] \n  console.log(arguments[0]);\n}\nfunc(10); // 99\n\n\n1\n2\n3\n4\n5\n\n\n当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值不会跟踪参数的值（反之亦然）。相反, arguments反映了调用时提供的参数：\n\nfunction func(a = 55) { \n  arguments[0] = 99; // updating arguments[0] does not also update a\n  console.log(a);\n}\nfunc(10); // 10\n\n\n1\n2\n3\n4\n5\n\n\nfunction func(a = 55) { \n  a = 99; // updating a does not also update arguments[0]\n  console.log(arguments[0]);\n}\nfunc(10); // 10\n\n\n1\n2\n3\n4\n5\n\n\nfunction func(a = 55) { \n  console.log(arguments[0]);\n}\nfunc(); // undefined\n\n\n1\n2\n3\n4\n\n\n\n# this—函数上下文\n\n函数的调用方式对函数内代码的执行有很大的影响，主要体现在this参数以及函数上下文是如何建立的。",normalizedContent:"# 理解函数调用 🔥\n\n\n# 隐式函数参数\n\n除了在函数定义中显式声明的参数之外，函数调用时还会传递两个隐式的参数：arguments和this，并且可以在函数内正常访问。\n\n\n# arguments参数\n\narguments参数是传递给函数的所有参数集合。无论是否有明确定义对应的形参，通过它我们都可以访问到函数的所有参数。借此可以实现原生javascript并不支持的函数重载特性，而且可以实现接收参数数量可变的可变函数。其实，借助剩余参数（restparameter），对arguments参数的需求已经大大减少了。\n\narguments对象有一个名为length的属性，表示实参的确切个数。通过数组索引的方式可以获取单个参数的值。但是arguments对象仅是一个类数组的结构，避免把它参数当作数组使用，尝试使用数组的方法时会报错！剩余参数是真正的array实例\n\n实现一个求和函数，来计算任意数量参数的和：\n\nfunction sum(){\n    let sum = 0\n    for(let i = 0; i < arguments.length; i++){\n        sum += arguments[i]\n    }\n    return sum\n}\n\nsum(1,2,3)\nsum(2,3,4,5)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n**arguments对象可以与剩余参数、默认参数和解构赋值参数结合使用注意**\n\n在严格模式下，剩余参数、默认参数和解构赋值参数的存在不会改变 arguments对象的行为，但是在非严格模式下就有所不同了\n\n当非严格模式中的函数没有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值会跟踪参数的值（反之亦然）\n\nfunction func(a) { \n  arguments[0] = 99;   // 更新了arguments[0] 同样更新了a\n  console.log(a);\n}\nfunc(10); // 99\n\n\n1\n2\n3\n4\n5\n\n\nfunction func(a) { \n  a = 99;              // 更新了a 同样更新了arguments[0] \n  console.log(arguments[0]);\n}\nfunc(10); // 99\n\n\n1\n2\n3\n4\n5\n\n\n当非严格模式中的函数有包含剩余参数、默认参数和解构赋值，那么arguments对象中的值不会跟踪参数的值（反之亦然）。相反, arguments反映了调用时提供的参数：\n\nfunction func(a = 55) { \n  arguments[0] = 99; // updating arguments[0] does not also update a\n  console.log(a);\n}\nfunc(10); // 10\n\n\n1\n2\n3\n4\n5\n\n\nfunction func(a = 55) { \n  a = 99; // updating a does not also update arguments[0]\n  console.log(arguments[0]);\n}\nfunc(10); // 10\n\n\n1\n2\n3\n4\n5\n\n\nfunction func(a = 55) { \n  console.log(arguments[0]);\n}\nfunc(); // undefined\n\n\n1\n2\n3\n4\n\n\n\n# this—函数上下文\n\n函数的调用方式对函数内代码的执行有很大的影响，主要体现在this参数以及函数上下文是如何建立的。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"1 理解-2 this—函数上下文",frontmatter:{title:"1 理解-2 this—函数上下文",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/adb64b/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/200.%E7%90%86%E8%A7%A3/203.this%E2%80%94%E5%87%BD%E6%95%B0%E4%B8%8A%E4%B8%8B%E6%96%87.html",relativePath:"1200.JS/200.理解/203.this—函数上下文.md",key:"v-62ada9b3",path:"/pages/adb64b/",headers:[{level:2,title:"调用位置 🔥",slug:"调用位置-🔥",normalizedTitle:"调用位置 🔥",charIndex:72},{level:2,title:"绑定规则 🔥",slug:"绑定规则-🔥",normalizedTitle:"绑定规则 🔥",charIndex:349},{level:3,title:"默认绑定—独立函数调用",slug:"默认绑定-独立函数调用",normalizedTitle:"默认绑定—独立函数调用",charIndex:361},{level:3,title:"隐式绑定—作为对象的方法被调用",slug:"隐式绑定-作为对象的方法被调用",normalizedTitle:"隐式绑定—作为对象的方法被调用",charIndex:1014},{level:4,title:"隐式丢失—间接引用",slug:"隐式丢失-间接引用",normalizedTitle:"隐式丢失—间接引用",charIndex:2208},{level:4,title:"隐式丢失—间接引用回调函数",slug:"隐式丢失-间接引用回调函数",normalizedTitle:"隐式丢失—间接引用回调函数",charIndex:2900},{level:4,title:"隐式丢失（修改）—事件回调",slug:"隐式丢失-修改-事件回调",normalizedTitle:"隐式丢失（修改）—事件回调",charIndex:3878},{level:3,title:"显式绑定",slug:"显式绑定",normalizedTitle:"显式绑定",charIndex:5202},{level:4,title:"apply & call",slug:"apply-call",normalizedTitle:"apply &amp; call",charIndex:null},{level:4,title:"硬绑定 bind —包裹函数",slug:"硬绑定-bind-包裹函数",normalizedTitle:"硬绑定 bind —包裹函数",charIndex:5965},{level:4,title:"forEach 函数的显示绑定",slug:"foreach-函数的显示绑定",normalizedTitle:"foreach 函数的显示绑定",charIndex:7410},{level:4,title:"手动实现简易版 forEach",slug:"手动实现简易版-foreach",normalizedTitle:"手动实现简易版 foreach",charIndex:7760},{level:3,title:"new 绑定—函数的构造调用",slug:"new-绑定-函数的构造调用",normalizedTitle:"new 绑定—函数的构造调用",charIndex:9136},{level:4,title:"构造函数的返回值",slug:"构造函数的返回值",normalizedTitle:"构造函数的返回值",charIndex:9829},{level:4,title:"编写构造函数的注意事项",slug:"编写构造函数的注意事项",normalizedTitle:"编写构造函数的注意事项",charIndex:10841},{level:2,title:"绑定优先级",slug:"绑定优先级",normalizedTitle:"绑定优先级",charIndex:11413},{level:2,title:"绑定例外 🔥",slug:"绑定例外-🔥",normalizedTitle:"绑定例外 🔥",charIndex:11852},{level:3,title:"被忽略的 this 🔥",slug:"被忽略的-this-🔥",normalizedTitle:"被忽略的 this 🔥",charIndex:11864},{level:3,title:"间接引用 🔥",slug:"间接引用-🔥",normalizedTitle:"间接引用 🔥",charIndex:13216},{level:3,title:"软绑定",slug:"软绑定",normalizedTitle:"软绑定",charIndex:13544},{level:2,title:"this 词法—箭头函数",slug:"this-词法-箭头函数",normalizedTitle:"this 词法—箭头函数",charIndex:14878},{level:3,title:"引用函数",slug:"引用函数",normalizedTitle:"引用函数",charIndex:1188},{level:3,title:"对象字面量 & 箭头函数副作用 🔥",slug:"对象字面量-箭头函数副作用-🔥",normalizedTitle:"对象字面量 &amp; 箭头函数副作用 🔥",charIndex:null},{level:3,title:"构造函数",slug:"构造函数",normalizedTitle:"构造函数",charIndex:326}],headersStr:"调用位置 🔥 绑定规则 🔥 默认绑定—独立函数调用 隐式绑定—作为对象的方法被调用 隐式丢失—间接引用 隐式丢失—间接引用回调函数 隐式丢失（修改）—事件回调 显式绑定 apply & call 硬绑定 bind —包裹函数 forEach 函数的显示绑定 手动实现简易版 forEach new 绑定—函数的构造调用 构造函数的返回值 编写构造函数的注意事项 绑定优先级 绑定例外 🔥 被忽略的 this 🔥 间接引用 🔥 软绑定 this 词法—箭头函数 引用函数 对象字面量 & 箭头函数副作用 🔥 构造函数",content:'# this—函数上下文 🔥\n\n函数的调用方式对函数内代码的执行有很大的影响，主要体现在 this 参数以及函数上下文是如何建立的。\n\n\n# 调用位置 🔥\n\n理解 this 的绑定过程之前，首先要理解调用位置，它就是函数在代码中被调用的位置(而不是声明的位置)\n\n分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中\n\n不同类型函数调用之间的主要区别在于：最终作为函数上下文（可以通过 this 参数隐式引用到）传递给执行函数的对象不同。\n\n * 对于顶级函数而言是 window 或者 undefined（取决于是否处于严格模式下）；\n * 对于方法而言，即为方法所在的对象；\n * 对于构造函数而言是一个新创建的对象实例。\n\n\n# 绑定规则 🔥\n\n\n# 默认绑定—独立函数调用\n\n该函数是独立函数，即不是作为一个对象的属性存在时，就属于这种调用类型\n\n当以这种方式调用时，函数上下文（this 关键字的值）有两种可能性：\n\n * 在非严格模式下，调用位置为全局上下文（window 对象），即 this\n   \n   function whatsMyContext() {\n     console.log(this); // Window...\n   }\n   whatsMyContext()(function() {\n     console.log(this); // Window...\n   })();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 而在严格模式下，它将是undefined\n   \n   // \'use strict\'\n   \n   function whatsMyContext() {\n     "use strict";\n     console.log(this); // undefined\n   }\n   skulk("conanan");\n   \n   (function() {\n     "use strict";\n     console.log(this); // undefined\n   })();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 隐式绑定—作为对象的方法被调用\n\n考虑调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含（严格说并不属于，可以称为地址引用），该对象将会成为函数的上下文。\n\n注意该函数是如何被当作引用属性添加到上下文对象，虽然无论是直接在上下文对象中定义还是先定义再添加为引用属性，这个函数严格来说都不属于上下文对象对象。然而，调用位置会使用该上下文对象来引用函数。\n\n这是JavaScript 实现面向对象编程的主要方式之一，构造函数是另外一种方式\n\n// 函数直接调用\nfunction whatsMyContext() {\n  return this;\n}\nconsole.log(whatsMyContext() === window); // true\n\n// 这里主要指对象字面量\nconst ninja1 = {\n  getMyThis: whatsMyContext,\n  getMyThis2: function() {\n    return this;\n  },\n  getMyThis3: () => {\n    return this;\n  },\n};\nconsole.log(ninja1.getMyThis() === ninja1); // true\nconsole.log(ninja1.getMyThis2() === ninja1); // true\n// 对象字面量 & 箭头函数副作用\nconsole.log(ninja1.getMyThis3() === ninja1); // false，这里是window\n\n// 这里属于new的对象\n// function Ninja() {\n//   this.getMyThis = whatsMyContext\n// }\nclass Ninja {\n  constructor() {\n    this.getMyThis = whatsMyContext;\n  }\n}\nconst ninja2 = new Ninja();\nconsole.log(ninja2.getMyThis() === ninja2); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n对象属性引用链中只有最后一层会影响调用位置\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj2 = {\n  a: 42,\n  foo: foo,\n};\nvar obj1 = {\n  a: 2,\n  obj2: obj2,\n};\nobj1.obj2.foo(); // 42\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 隐式丢失—间接引用\n\n一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj = {\n  a: 2,\n  foo: foo,\n};\nvar bar = obj.foo; // 函数别名!\nvar a = "oops, global"; // a 是全局对象的属性\nobj.foo(); // 2\n// 不同于使用 obj.foo()\nbar(); // "oops, global"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身（印证了不属于的说法，其实是地址引用），因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。最重要的是查看method()前是否有对象。\n\n使用 bind 硬绑定解决如下：\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj = {\n  a: 2,\n};\n\nvar bar = foo.bind(obj);\nbar(); // 2\nsetTimeout(bar, 100); // 2\n// 硬绑定的 bar 不可能再修改它的 this\nbar.call(window); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 隐式丢失—间接引用回调函数\n\n一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时（无论是直接定义还是定义后再引用）\n\nfunction foo() {\n  console.log(this.a);\n}\nfunction doFoo(fn) {\n  // fn 其实引用的是 foo\n  fn(); // <-- 调用位置!\n}\nvar obj = {\n  a: 2,\n  foo: foo,\n};\nvar a = "oops, global"; // a 是全局对象的属性\nobj.foo(); // 2\n\n// 相当于传递 foo 的引用\ndoFoo(obj.foo); // "oops, global"\n\nconst tmp = obj.foo;\ntmp(); // "oops, global"\ndoFoo(tmp); // "oops, global"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上面的一样\n\n函数传入 JS 内置的回调，结果也是一样的\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj = {\n  a: 2,\n  foo: foo,\n};\nvar a = "oops, global"; // a 是全局对象的属性\nsetTimeout(obj.foo, 100); // "oops, global"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用 bind 硬绑定解决如下：\n\nfunction foo() {\n  console.log(this.a);\n}\nfunction doFoo(fn) {\n  // fn 其实引用的是 foo\n  fn(); // <-- 调用位置!\n}\nvar obj = {\n  a: 2,\n};\n\nvar bar = foo.bind(obj);\n\nvar a = "oops, global"; // a 是全局对象的属性\n\ndoFoo(bar); // 2\nbar(); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 隐式丢失（修改）—事件回调\n\n在一些流行的 JavaScript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 DOM 元素上\n\n<body>\n  <button id="btn">点这里</button>\n\n  <script>\n    function Button() {\n      this.clicked = false;\n      this.click = function() {\n        this.clicked = true;\n        // this 指向 button 元素！非对象\n        console.log(this === button); // false\n        console.log(this);\n      };\n    }\n\n    const button = new Button();\n    const $btn = document.getElementById("btn");\n    // 这里会发生隐式丢失\n    $btn.addEventListener("click", button.click);\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这里我们发现 this 和 button 竟然是不同的！本来按照构造函数，this 应该指向 new 出来的对象 button，但是这里由于浏览器的事件（回调函数）系统把调用的上下文定义为事件触发的目标元素，因此上下文将是<button>元素，而非 button 对象\n\n推荐使用箭头函数解决，一定要注意箭头函数&对象字面量时的副作用：暂时不表！\n\n<body>\n  <button id="btn">点这里</button>\n\n  <script>\n    class Button {\n      constructor() {\n        this.clicked = false;\n        this.click = () => {\n          this.clicked = true;\n          // this 指向 button 对象\n          console.log(this === button); // true\n          console.log(this);\n        };\n      }\n    }\n\n    const button = new Button();\n    const $btn = document.getElementById("btn");\n    $btn.addEventListener("click", button.click);\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n也可以 bind 硬绑定实现（当然 apply、call 也可以）\n\n\n# 显式绑定\n\n# apply & call\n\n使用 call、apply 显式地指定任何对象作为函数的上下文，第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。\n\n如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被自动「装箱」转换成它的对象形式（也就是new String(..)、new Boolean(..)或者 new Number(..)）\n\nfunction sum() {\n  let sum = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    sum += arguments[i];\n  }\n  // 最终和存储在该函数上下文对象中\n  this.result = sum;\n}\n\nconst ninja1 = {};\nconst ninja2 = {};\nconst ninja3 = {};\n\nsum.call(ninja1, 1, 2, 3, 4, 5);\nsum.apply(ninja2, [6, 7, 8, 9, 10]);\n// 所有函数均可访问bind方法，可以创建并返回一个新函数，并绑定在传入的对象上，直接调用。也可以使用函数表达式指定名称后调用\nsum.bind(ninja3, 2, 4, 6, 8, 10)();\nconsole.log(ninja1.result); // 15\nconsole.log(ninja2.result); // 40\nconsole.log(ninja3.result); // 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 硬绑定 bind —包裹函数\n\n底层是 apply、call，省去写包裹函数，返回值为函数！类似代理模式\n\n显式绑定仍然无法解决我们之前提出的丢失绑定问题，但是显式绑定的一个变种可以解决这个问题。\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj = {\n  a: 2,\n};\n\n// 包装模式，包裹函数\nvar bar = function() {\n  foo.call(obj);\n};\nbar(); // 2\nsetTimeout(bar, 100); // 2\n// 硬绑定的 bar 不可能再修改它的 this\nbar.call(window); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n创建了函数 bar，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定\n\n硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值\n\nfunction foo(something) {\n  console.log(this.a, something);\n  return this.a + something;\n}\nvar obj = {\n  a: 2,\n};\n// 这里函数不写参数，通过 arguments 接收并返回！！！\nvar bar = function() {\n  return foo.apply(obj, arguments);\n};\nvar b = bar(3); // 2 3\nconsole.log(b); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可能要经常使用，所以创建一个可以重复使用的辅助函数\n\nfunction foo(something) {\n  console.log(this.a, something);\n  return this.a + something;\n}\n// 简单的辅助绑定函数\nfunction bind(fn, obj) {\n  return function() {\n    return fn.apply(obj, arguments);\n  };\n}\n\nvar obj = {\n  a: 2,\n};\n\nvar bar = bind(foo, obj);\nvar b = bar(3); // 2 3\nconsole.log(b); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n由于硬绑定是一种非常常用的模式，所以在 ES5 中提供了内置的方法 Function.prototype.bind\n\nfunction foo(something) {\n  console.log(this.a, something);\n  return this.a + something;\n}\n\nvar obj = {\n  a: 2,\n};\n\nvar bar = foo.bind(obj);\nvar b = bar(3); // 2 3\nconsole.log(b); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# forEach 函数的显示绑定\n\n暂时不讨论箭头函数的 this 词法作用域\n\nconst arr = [1, 3, 2, 6, 4];\narr.forEach(function(value, index) {\n  console.log(value);\n  console.log(this === window); // true\n});\narr.forEach(function(value, index) {\n  console.log(value);\n  console.log(this === arr); // true\n}, arr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n可以通过第二个参数来指定 this 的指向。其底层也是通过 apply & call 来实现的\n\n# 手动实现简易版 forEach\n\n第一版\n\nfunction forEach(array, callback = function(item, index) {}) {\n  for (let index = 0; index < array.length; index++) {\n    const element = array[index];\n    callback(element, index);\n  }\n}\n\nconst arr = [{ type: "dog" }, { type: "cat" }, { type: "bird" }];\n\nforEach(arr, function(item, index) {\n  console.log(index + "===" + item.type);\n  // 此时的 this 为直接函数调用的全局 window\n  console.log(this === arr[index]);\n});\n\nforEach(arr, (item) => {\n  console.log(item.type);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n第二版\n\nfunction forEach(array, callback = function(item, index) {}) {\n  for (let index = 0; index < array.length; index++) {\n    const element = array[index];\n    // 这里注意第一个参数为指定的函数上下文，后俩才是callback参数\n    callback.call(element, element, index);\n  }\n}\n\nconst arr = [{ type: "dog" }, { type: "cat" }, { type: "bird" }];\n\nforEach(arr, function(item, index) {\n  console.log(index + "===" + item.type);\n  // 此时的 this 为 call 显示指定的当前遍历的元素\n  console.log(this === arr[index]);\n});\n\nforEach(arr, (item) => {\n  console.log(item.type);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n在生产环境实现这类函数还需要做一些处理。例如，若传入的第一个参数不是数组该如何处理？若第二个参数不是函数该如何处理？如何允许调用者随时中断循环？作为练习，可以增加函数来处理这些情况。另一个练习任务是，允许调用者向回调函数传入除索引外的任意数量的参数。\n\napply 与 call 的功能类似，但问题是在二者中如何选择？答案与许多其他问题的答案是相似的：选择任意可以精简代码的方法。更实际的答案是选择与现有参数相匹配的方法。如果有一组无关的值，则直接使用 call 方法。若已有参数是数组类型，apply 方法是更佳选择。\n\n\n# new 绑定—函数的构造调用\n\n在 JavaScript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。构造函数的声明和其他函数类似，通过使用函数声明和函数表达式很容易地构造新的对象，唯一的例外是箭头函数，后续介绍。若要通过构造函数的方式调用，需要在函数调用之前使用关键字 new\n\n结论：当通过 new 关键字调用时会创建一个空的对象实例，并将其作为函数上下文（this 参数）传递给函数\n\n// function 方式\n/*\nfunction Ninja() {\n  this.skulk = function () {\n    return this\n  }\n}\n*/\n\n// ES6 Class 方式\nclass Ninja {\n  constructor() {\n    this.skulk = function() {\n      return this;\n    };\n  }\n}\n\nconst ninja1 = new Ninja();\nconst ninja2 = new Ninja();\n\nconsole.log(ninja1.skulk() === ninja1); // true\nconsole.log(ninja2.skulk() === ninja2); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 构造函数的返回值\n\n构造函数的目的是初始化新创建的对象，并且新构造的对象会作为构造函数的调用结果（通过 new 运算符）返回。但当构造函数自身有返回值时会是什么结果？\n\n// function 方式\nfunction Ninja() {\n  this.skulk = function() {\n    return this;\n  };\n  return 1;\n}\n\n// ES6 Class 方式略\n\nconst ninja1 = Ninja();\nconst ninja2 = new Ninja();\n\nconsole.log(ninja1); // 1，正如预期\n\n// 测试后发现，返回值1被忽略了，一个新的被初始化的对象通过 new 关键字返回\nconsole.log(typeof ninja2 === "object"); // true\nconsole.log(typeof ninja2.skulk === "function"); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n如果尝试做一些改变，一个构造函数返回另一个对象\n\nconst puppet = {\n  rules: false,\n};\n\n// function 方式\n/*\nfunction Emperor() {\n  this.rules = true\n  return puppet\n}\n*/\n\n// ES6 Class 方式略\nclass Emperor {\n  constructor() {\n    this.rules = true;\n    return puppet;\n  }\n}\n\nconst emperor = new Emperor();\n\nconsole.log(emperor === puppet); // true\nconsole.log(emperor.rules === false); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n总结：\n\n * 如果构造函数返回一个对象，则该对象将作为整个表达式的值返回，而传入构造函数的 this 将被丢弃。\n * 但是，如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象\n\n# 编写构造函数的注意事项\n\n构造函数的目的是根据初始条件对函数调用创建的新对象进行初始化。虽然这些函数也可以被“正常”调用，或者被赋值为对象属性从而作为方法调用，但这样并没有太大的意义。例如：\n\n// function 方式\n/*\nfunction Ninja() {\n  this.skulk = function () {\n    return this\n  }\n}\n*/\n\n// ES6 Class 方式\nclass Ninja {\n  constructor() {\n    this.skulk = function() {\n      return this;\n    };\n  }\n}\n\nconst ninja = new Ninja();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n如果在非严格模式下调用的话，skulk 属性将创建在 window 对象上——这将引起全局污染。严格模式下情况会更糟，因为在严格模式下 this 为 undefined，因此 JavaScript 应用将会崩溃。推荐使用严格模式。\n\n命名：\n\n * 函数和方法的命名通常以描述其行为的动词开头，且第一个字母小写\n * 构造函数则通常以描述所构造对象的名词命名，并以大写字母开头\n\n\n# 绑定优先级\n\n 1. 函数是否在 new 中调用(new 绑定)?如果是的话 this 绑定的是新创建的对象。\n    \n    var bar = new foo();\n    \n    \n    1\n    \n\n 2. 函数是否通过 call、apply(显式绑定)或者 bind 硬绑定调用?如果是的话，this 绑定的是 指定的对象。\n    \n    var bar = foo.call(obj2);\n    \n    \n    1\n    \n\n 3. 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。\n    \n    var bar = obj1.foo();\n    \n    \n    1\n    \n\n 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。\n    \n    var bar = foo();\n    \n    \n    1\n    \n\n\n# 绑定例外 🔥\n\n\n# 被忽略的 this 🔥\n\n如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则\n\nfunction foo() {\n  console.log(this.a);\n}\nvar a = 2;\nfoo.call(null); // 2\n\n\n1\n2\n3\n4\n5\n\n\n什么情况下你会传入 null 呢？使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..)可以对参数进行柯里化(预先设置一些参数)，这种方法有时非常有用，使用 null 当作占位符\n\nfunction foo(a, b) {\n  console.log("a:" + a + ", b:" + b);\n}\n// 把数组“展开”成参数\nfoo.apply(null, [2, 3]); // a:2, b:3\n// 使用 bind(..) 进行柯里化\nvar bar = foo.bind(null, 2);\nbar(3); // a:2, b:3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在 ES6 中，可以用 ... 操作符代替 apply(..) 来“展开”数组，foo(...[1,2]) 和 foo(1,2) 是一样的，这样可以避免不必要的 this 绑定\n\n然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this(比如第三方库中的一个函数)，那默认绑定规则会把 this 绑定到全局对象(在浏览器中这个对象是 window)，这将导致不可预计的后果(比如修改全局对象)。\n\n显而易见，这种方式可能会导致许多难以分析和追踪的 bug。\n\n一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序产生任何副作用。就像网络(以及军队)一样，我们可以创建一个“DMZ”(demilitarized zone，非军事区)对象——它就是一个空的非委托的对象。\n\n由于这个对象完全是一个空对象，我自己喜欢用变量名 ø(这是数学中表示空集合符号的小写形式)来表示它。在大多数键盘(比如说 Mac 的 US 布局键盘)上都可以使用 ⌥ +o (Option-o)来打出这个符号。\n\n无论你叫它什么，在 JavaScript 中创建一个空对象最简单的方法都是 Object.create(null)。Object.create(null) 和 {} 很像，但是并不会创建 Object.prototype 这个委托，所以它比 {}“更空”:\n\nfunction foo(a, b) {\n  console.log("a:" + a + ", b:" + b);\n}\n// 我们的 DMZ 空对象\nvar ø = Object.create(null); // 把数组展开成参数\nfoo.apply(ø, [2, 3]); // a:2, b:3\n// 使用 bind(..) 进行柯里化\nvar bar = foo.bind(ø, 2);\nbar(3); // a:2, b:3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 间接引用 🔥\n\n你有可能(有意或者无意地)创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生:\n\nfunction foo() {\n  console.log(this.a);\n}\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4 };\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。\n\n\n# 软绑定\n\n硬绑定这种方式可以把 this 强制绑定到指定的对象(除了使用 new 时)，防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。\n\n如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。\n\n可以通过一种被称为软绑定的方法来实现我们想要的效果:\n\nif (!Function.prototype.softBind) {\n  Function.prototype.softBind = function(obj) {\n    var fn = this;\n    // 捕获所有 curried 参数\n    var curried = [].slice.call(arguments, 1);\n    var bound = function() {\n      return fn.apply(\n        !this || this === (window || global) ? obj : this,\n        curried.concat.apply(curried, arguments)\n      );\n    };\n    bound.prototype = Object.create(fn.prototype);\n    return bound;\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n除了软绑定之外，softBind(..) 的其他原理和 ES5 内置的 bind(..) 类似。它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里化。下面我们看看 softBind 是否实现了软绑定功能:\n\nfunction foo() {\n  console.log("name: " + this.name);\n}\nvar obj = { name: "obj" },\n  obj2 = { name: "obj2" },\n  obj3 = { name: "obj3" };\nvar fooOBJ = foo.softBind(obj);\nfooOBJ(); // name: obj\nobj2.foo = foo.softBind(obj);\nobj2.foo(); // name: obj2 <---- 看!!!\nfooOBJ.call(obj3); // name: obj3 <---- 看!\nsetTimeout(obj2.foo, 10); // name: obj <---- 应用了软绑定\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默认绑定，则会将 this 绑定到 obj。\n\n\n# this 词法—箭头函数\n\n绑定的四条规则已经可以包含所有正常的函数。但是 ES6 中介绍了一种无法使用 这些规则的特殊函数类型:箭头函数。\n\n箭头函数会**继承外层函数（或全局）**调用的 this 绑定(无论 this 绑定到什么)。这和 ES6 之前代码中的 self = this 机制一样。\n\n箭头函数没有单独的 this 值（不会隐式传入 this 参数），this 在箭头函数创建时（就是=>出现的地方）确定\n\nfunction foo() {\n  // 返回一个箭头函数\n  return (a) => {\n    //this 继承自 foo()\n    console.log(this.a);\n  };\n}\nvar obj1 = {\n  a: 2,\n};\nvar obj2 = {\n  a: 3,\n};\nvar bar = foo.call(obj1);\nbar.call(obj2); // 2, 不是 3 !\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nfoo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。(new 也不行!)\n\n箭头函数最常用于回调函数中，例如事件处理器或者定时器:\n\nfunction foo() {\n  setTimeout(() => {\n    // 这里的 this 在词法上继承自 foo()\n    console.log(this.a);\n  }, 100);\n}\nvar obj = {\n  a: 2,\n};\nfoo.call(obj); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 ES6 之前我们就已经 在使用一种几乎和箭头函数完全一样的模式。\n\nfunction foo() {\n  var self = this; // lexical capture of this\n  setTimeout(function() {\n    console.log(self.a);\n  }, 100);\n}\nvar obj = {\n  a: 2,\n};\nfoo.call(obj); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。\n\n如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数来否定 this 机制，那你或许应当:\n\n * 只使用词法作用域并完全抛弃错误 this 风格的代码;\n * 完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。\n\n\n# 引用函数\n\nconst whatsMyContext = () => {\n  return this;\n};\n// 函数直接调用\nconsole.log(whatsMyContext() === window); // true\n\n// 对象字面量的方法\nconst ninja1 = {\n  getMyThis: whatsMyContext,\n};\nconsole.log(ninja1.getMyThis() === window); // true\n\n// 构造函数\n// function Ninja() {\n//   this.getMyThis = whatsMyContext\n// }\nclass Ninja {\n  constructor() {\n    this.getMyThis = whatsMyContext;\n  }\n}\nconst ninja2 = new Ninja();\nconsole.log(ninja2.getMyThis() === window); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n可以看出 this 都是在函数创建时已经确定了\n\n\n# 对象字面量 & 箭头函数副作用 🔥\n\n由于 this 值是在箭头函数创建时确定的，所以会导致一些看似奇怪的行为。回到按钮单击示例中，因为只有一个按钮，因此可以假设不需要构造函数。直接使用对象字面量\n\n<body>\n  <button id="btn">点这里</button>\n\n  <script>\n    var button = {\n      clicked: false,\n      click: () => {\n        this.clicked = true;\n        // this 指向 window\n        console.log(this === button); // false\n        console.log(this);\n\n      }\n    }\n\n    const $btn = document.getElementById(\'btn\')\n    $btn.addEventListener(\'click\', button.click)\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n// 对象字面量的方法\nconst ninja3 = {\n  getMyThis: () => {\n    return this;\n  },\n};\nconsole.log(ninja3.getMyThis() === window); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 构造函数\n\n// 构造函数\n// function Ninja2() {\n//   this.getMyThis = () => {\n//     return this\n//   }\n// }\nclass Ninja2 {\n  constructor() {\n    this.getMyThis = () => {\n      return this;\n    };\n  }\n}\nconst ninja4 = new Ninja2();\nconsole.log(ninja4.getMyThis() === ninja4); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'# this—函数上下文 🔥\n\n函数的调用方式对函数内代码的执行有很大的影响，主要体现在 this 参数以及函数上下文是如何建立的。\n\n\n# 调用位置 🔥\n\n理解 this 的绑定过程之前，首先要理解调用位置，它就是函数在代码中被调用的位置(而不是声明的位置)\n\n分析调用栈(就是为了到达当前执行位置所调用的所有函数)。我们关心的调用位置就在当前正在执行的函数的前一个调用中\n\n不同类型函数调用之间的主要区别在于：最终作为函数上下文（可以通过 this 参数隐式引用到）传递给执行函数的对象不同。\n\n * 对于顶级函数而言是 window 或者 undefined（取决于是否处于严格模式下）；\n * 对于方法而言，即为方法所在的对象；\n * 对于构造函数而言是一个新创建的对象实例。\n\n\n# 绑定规则 🔥\n\n\n# 默认绑定—独立函数调用\n\n该函数是独立函数，即不是作为一个对象的属性存在时，就属于这种调用类型\n\n当以这种方式调用时，函数上下文（this 关键字的值）有两种可能性：\n\n * 在非严格模式下，调用位置为全局上下文（window 对象），即 this\n   \n   function whatsmycontext() {\n     console.log(this); // window...\n   }\n   whatsmycontext()(function() {\n     console.log(this); // window...\n   })();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n\n * 而在严格模式下，它将是undefined\n   \n   // \'use strict\'\n   \n   function whatsmycontext() {\n     "use strict";\n     console.log(this); // undefined\n   }\n   skulk("conanan");\n   \n   (function() {\n     "use strict";\n     console.log(this); // undefined\n   })();\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 隐式绑定—作为对象的方法被调用\n\n考虑调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含（严格说并不属于，可以称为地址引用），该对象将会成为函数的上下文。\n\n注意该函数是如何被当作引用属性添加到上下文对象，虽然无论是直接在上下文对象中定义还是先定义再添加为引用属性，这个函数严格来说都不属于上下文对象对象。然而，调用位置会使用该上下文对象来引用函数。\n\n这是javascript 实现面向对象编程的主要方式之一，构造函数是另外一种方式\n\n// 函数直接调用\nfunction whatsmycontext() {\n  return this;\n}\nconsole.log(whatsmycontext() === window); // true\n\n// 这里主要指对象字面量\nconst ninja1 = {\n  getmythis: whatsmycontext,\n  getmythis2: function() {\n    return this;\n  },\n  getmythis3: () => {\n    return this;\n  },\n};\nconsole.log(ninja1.getmythis() === ninja1); // true\nconsole.log(ninja1.getmythis2() === ninja1); // true\n// 对象字面量 & 箭头函数副作用\nconsole.log(ninja1.getmythis3() === ninja1); // false，这里是window\n\n// 这里属于new的对象\n// function ninja() {\n//   this.getmythis = whatsmycontext\n// }\nclass ninja {\n  constructor() {\n    this.getmythis = whatsmycontext;\n  }\n}\nconst ninja2 = new ninja();\nconsole.log(ninja2.getmythis() === ninja2); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n对象属性引用链中只有最后一层会影响调用位置\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj2 = {\n  a: 42,\n  foo: foo,\n};\nvar obj1 = {\n  a: 2,\n  obj2: obj2,\n};\nobj1.obj2.foo(); // 42\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 隐式丢失—间接引用\n\n一个最常见的 this 绑定问题就是被隐式绑定的函数会丢失绑定对象，也就是说它会应用默认绑定，从而把 this 绑定到全局对象或者 undefined 上，取决于是否是严格模式。\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj = {\n  a: 2,\n  foo: foo,\n};\nvar bar = obj.foo; // 函数别名!\nvar a = "oops, global"; // a 是全局对象的属性\nobj.foo(); // 2\n// 不同于使用 obj.foo()\nbar(); // "oops, global"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 foo 函数本身（印证了不属于的说法，其实是地址引用），因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。最重要的是查看method()前是否有对象。\n\n使用 bind 硬绑定解决如下：\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj = {\n  a: 2,\n};\n\nvar bar = foo.bind(obj);\nbar(); // 2\nsettimeout(bar, 100); // 2\n// 硬绑定的 bar 不可能再修改它的 this\nbar.call(window); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 隐式丢失—间接引用回调函数\n\n一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时（无论是直接定义还是定义后再引用）\n\nfunction foo() {\n  console.log(this.a);\n}\nfunction dofoo(fn) {\n  // fn 其实引用的是 foo\n  fn(); // <-- 调用位置!\n}\nvar obj = {\n  a: 2,\n  foo: foo,\n};\nvar a = "oops, global"; // a 是全局对象的属性\nobj.foo(); // 2\n\n// 相当于传递 foo 的引用\ndofoo(obj.foo); // "oops, global"\n\nconst tmp = obj.foo;\ntmp(); // "oops, global"\ndofoo(tmp); // "oops, global"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上面的一样\n\n函数传入 js 内置的回调，结果也是一样的\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj = {\n  a: 2,\n  foo: foo,\n};\nvar a = "oops, global"; // a 是全局对象的属性\nsettimeout(obj.foo, 100); // "oops, global"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n使用 bind 硬绑定解决如下：\n\nfunction foo() {\n  console.log(this.a);\n}\nfunction dofoo(fn) {\n  // fn 其实引用的是 foo\n  fn(); // <-- 调用位置!\n}\nvar obj = {\n  a: 2,\n};\n\nvar bar = foo.bind(obj);\n\nvar a = "oops, global"; // a 是全局对象的属性\n\ndofoo(bar); // 2\nbar(); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n# 隐式丢失（修改）—事件回调\n\n在一些流行的 javascript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 dom 元素上\n\n<body>\n  <button id="btn">点这里</button>\n\n  <script>\n    function button() {\n      this.clicked = false;\n      this.click = function() {\n        this.clicked = true;\n        // this 指向 button 元素！非对象\n        console.log(this === button); // false\n        console.log(this);\n      };\n    }\n\n    const button = new button();\n    const $btn = document.getelementbyid("btn");\n    // 这里会发生隐式丢失\n    $btn.addeventlistener("click", button.click);\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n这里我们发现 this 和 button 竟然是不同的！本来按照构造函数，this 应该指向 new 出来的对象 button，但是这里由于浏览器的事件（回调函数）系统把调用的上下文定义为事件触发的目标元素，因此上下文将是<button>元素，而非 button 对象\n\n推荐使用箭头函数解决，一定要注意箭头函数&对象字面量时的副作用：暂时不表！\n\n<body>\n  <button id="btn">点这里</button>\n\n  <script>\n    class button {\n      constructor() {\n        this.clicked = false;\n        this.click = () => {\n          this.clicked = true;\n          // this 指向 button 对象\n          console.log(this === button); // true\n          console.log(this);\n        };\n      }\n    }\n\n    const button = new button();\n    const $btn = document.getelementbyid("btn");\n    $btn.addeventlistener("click", button.click);\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n也可以 bind 硬绑定实现（当然 apply、call 也可以）\n\n\n# 显式绑定\n\n# apply & call\n\n使用 call、apply 显式地指定任何对象作为函数的上下文，第一个参数是一个对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this。\n\n如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对象，这个原始值会被自动「装箱」转换成它的对象形式（也就是new string(..)、new boolean(..)或者 new number(..)）\n\nfunction sum() {\n  let sum = 0;\n  for (let i = 0; i < arguments.length; i++) {\n    sum += arguments[i];\n  }\n  // 最终和存储在该函数上下文对象中\n  this.result = sum;\n}\n\nconst ninja1 = {};\nconst ninja2 = {};\nconst ninja3 = {};\n\nsum.call(ninja1, 1, 2, 3, 4, 5);\nsum.apply(ninja2, [6, 7, 8, 9, 10]);\n// 所有函数均可访问bind方法，可以创建并返回一个新函数，并绑定在传入的对象上，直接调用。也可以使用函数表达式指定名称后调用\nsum.bind(ninja3, 2, 4, 6, 8, 10)();\nconsole.log(ninja1.result); // 15\nconsole.log(ninja2.result); // 40\nconsole.log(ninja3.result); // 30\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n# 硬绑定 bind —包裹函数\n\n底层是 apply、call，省去写包裹函数，返回值为函数！类似代理模式\n\n显式绑定仍然无法解决我们之前提出的丢失绑定问题，但是显式绑定的一个变种可以解决这个问题。\n\nfunction foo() {\n  console.log(this.a);\n}\nvar obj = {\n  a: 2,\n};\n\n// 包装模式，包裹函数\nvar bar = function() {\n  foo.call(obj);\n};\nbar(); // 2\nsettimeout(bar, 100); // 2\n// 硬绑定的 bar 不可能再修改它的 this\nbar.call(window); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n创建了函数 bar，并在它的内部手动调用 了 foo.call(obj)，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为硬绑定\n\n硬绑定的典型应用场景就是创建一个包裹函数，传入所有的参数并返回接收到的所有值\n\nfunction foo(something) {\n  console.log(this.a, something);\n  return this.a + something;\n}\nvar obj = {\n  a: 2,\n};\n// 这里函数不写参数，通过 arguments 接收并返回！！！\nvar bar = function() {\n  return foo.apply(obj, arguments);\n};\nvar b = bar(3); // 2 3\nconsole.log(b); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n可能要经常使用，所以创建一个可以重复使用的辅助函数\n\nfunction foo(something) {\n  console.log(this.a, something);\n  return this.a + something;\n}\n// 简单的辅助绑定函数\nfunction bind(fn, obj) {\n  return function() {\n    return fn.apply(obj, arguments);\n  };\n}\n\nvar obj = {\n  a: 2,\n};\n\nvar bar = bind(foo, obj);\nvar b = bar(3); // 2 3\nconsole.log(b); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n由于硬绑定是一种非常常用的模式，所以在 es5 中提供了内置的方法 function.prototype.bind\n\nfunction foo(something) {\n  console.log(this.a, something);\n  return this.a + something;\n}\n\nvar obj = {\n  a: 2,\n};\n\nvar bar = foo.bind(obj);\nvar b = bar(3); // 2 3\nconsole.log(b); // 5\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# foreach 函数的显示绑定\n\n暂时不讨论箭头函数的 this 词法作用域\n\nconst arr = [1, 3, 2, 6, 4];\narr.foreach(function(value, index) {\n  console.log(value);\n  console.log(this === window); // true\n});\narr.foreach(function(value, index) {\n  console.log(value);\n  console.log(this === arr); // true\n}, arr);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n可以通过第二个参数来指定 this 的指向。其底层也是通过 apply & call 来实现的\n\n# 手动实现简易版 foreach\n\n第一版\n\nfunction foreach(array, callback = function(item, index) {}) {\n  for (let index = 0; index < array.length; index++) {\n    const element = array[index];\n    callback(element, index);\n  }\n}\n\nconst arr = [{ type: "dog" }, { type: "cat" }, { type: "bird" }];\n\nforeach(arr, function(item, index) {\n  console.log(index + "===" + item.type);\n  // 此时的 this 为直接函数调用的全局 window\n  console.log(this === arr[index]);\n});\n\nforeach(arr, (item) => {\n  console.log(item.type);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n第二版\n\nfunction foreach(array, callback = function(item, index) {}) {\n  for (let index = 0; index < array.length; index++) {\n    const element = array[index];\n    // 这里注意第一个参数为指定的函数上下文，后俩才是callback参数\n    callback.call(element, element, index);\n  }\n}\n\nconst arr = [{ type: "dog" }, { type: "cat" }, { type: "bird" }];\n\nforeach(arr, function(item, index) {\n  console.log(index + "===" + item.type);\n  // 此时的 this 为 call 显示指定的当前遍历的元素\n  console.log(this === arr[index]);\n});\n\nforeach(arr, (item) => {\n  console.log(item.type);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n在生产环境实现这类函数还需要做一些处理。例如，若传入的第一个参数不是数组该如何处理？若第二个参数不是函数该如何处理？如何允许调用者随时中断循环？作为练习，可以增加函数来处理这些情况。另一个练习任务是，允许调用者向回调函数传入除索引外的任意数量的参数。\n\napply 与 call 的功能类似，但问题是在二者中如何选择？答案与许多其他问题的答案是相似的：选择任意可以精简代码的方法。更实际的答案是选择与现有参数相匹配的方法。如果有一组无关的值，则直接使用 call 方法。若已有参数是数组类型，apply 方法是更佳选择。\n\n\n# new 绑定—函数的构造调用\n\n在 javascript 中，构造函数只是一些 使用 new 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类。实际上， 它们甚至都不能说是一种特殊的函数类型，它们只是被 new 操作符调用的普通函数而已。构造函数的声明和其他函数类似，通过使用函数声明和函数表达式很容易地构造新的对象，唯一的例外是箭头函数，后续介绍。若要通过构造函数的方式调用，需要在函数调用之前使用关键字 new\n\n结论：当通过 new 关键字调用时会创建一个空的对象实例，并将其作为函数上下文（this 参数）传递给函数\n\n// function 方式\n/*\nfunction ninja() {\n  this.skulk = function () {\n    return this\n  }\n}\n*/\n\n// es6 class 方式\nclass ninja {\n  constructor() {\n    this.skulk = function() {\n      return this;\n    };\n  }\n}\n\nconst ninja1 = new ninja();\nconst ninja2 = new ninja();\n\nconsole.log(ninja1.skulk() === ninja1); // true\nconsole.log(ninja2.skulk() === ninja2); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n# 构造函数的返回值\n\n构造函数的目的是初始化新创建的对象，并且新构造的对象会作为构造函数的调用结果（通过 new 运算符）返回。但当构造函数自身有返回值时会是什么结果？\n\n// function 方式\nfunction ninja() {\n  this.skulk = function() {\n    return this;\n  };\n  return 1;\n}\n\n// es6 class 方式略\n\nconst ninja1 = ninja();\nconst ninja2 = new ninja();\n\nconsole.log(ninja1); // 1，正如预期\n\n// 测试后发现，返回值1被忽略了，一个新的被初始化的对象通过 new 关键字返回\nconsole.log(typeof ninja2 === "object"); // true\nconsole.log(typeof ninja2.skulk === "function"); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n如果尝试做一些改变，一个构造函数返回另一个对象\n\nconst puppet = {\n  rules: false,\n};\n\n// function 方式\n/*\nfunction emperor() {\n  this.rules = true\n  return puppet\n}\n*/\n\n// es6 class 方式略\nclass emperor {\n  constructor() {\n    this.rules = true;\n    return puppet;\n  }\n}\n\nconst emperor = new emperor();\n\nconsole.log(emperor === puppet); // true\nconsole.log(emperor.rules === false); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n总结：\n\n * 如果构造函数返回一个对象，则该对象将作为整个表达式的值返回，而传入构造函数的 this 将被丢弃。\n * 但是，如果构造函数返回的是非对象类型，则忽略返回值，返回新创建的对象\n\n# 编写构造函数的注意事项\n\n构造函数的目的是根据初始条件对函数调用创建的新对象进行初始化。虽然这些函数也可以被“正常”调用，或者被赋值为对象属性从而作为方法调用，但这样并没有太大的意义。例如：\n\n// function 方式\n/*\nfunction ninja() {\n  this.skulk = function () {\n    return this\n  }\n}\n*/\n\n// es6 class 方式\nclass ninja {\n  constructor() {\n    this.skulk = function() {\n      return this;\n    };\n  }\n}\n\nconst ninja = new ninja();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n如果在非严格模式下调用的话，skulk 属性将创建在 window 对象上——这将引起全局污染。严格模式下情况会更糟，因为在严格模式下 this 为 undefined，因此 javascript 应用将会崩溃。推荐使用严格模式。\n\n命名：\n\n * 函数和方法的命名通常以描述其行为的动词开头，且第一个字母小写\n * 构造函数则通常以描述所构造对象的名词命名，并以大写字母开头\n\n\n# 绑定优先级\n\n 1. 函数是否在 new 中调用(new 绑定)?如果是的话 this 绑定的是新创建的对象。\n    \n    var bar = new foo();\n    \n    \n    1\n    \n\n 2. 函数是否通过 call、apply(显式绑定)或者 bind 硬绑定调用?如果是的话，this 绑定的是 指定的对象。\n    \n    var bar = foo.call(obj2);\n    \n    \n    1\n    \n\n 3. 函数是否在某个上下文对象中调用(隐式绑定)?如果是的话，this 绑定的是那个上 下文对象。\n    \n    var bar = obj1.foo();\n    \n    \n    1\n    \n\n 4. 如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到 全局对象。\n    \n    var bar = foo();\n    \n    \n    1\n    \n\n\n# 绑定例外 🔥\n\n\n# 被忽略的 this 🔥\n\n如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值在调用时会被忽略，实际应用的是默认绑定规则\n\nfunction foo() {\n  console.log(this.a);\n}\nvar a = 2;\nfoo.call(null); // 2\n\n\n1\n2\n3\n4\n5\n\n\n什么情况下你会传入 null 呢？使用 apply(..) 来“展开”一个数组，并当作参数传入一个函数。类似地，bind(..)可以对参数进行柯里化(预先设置一些参数)，这种方法有时非常有用，使用 null 当作占位符\n\nfunction foo(a, b) {\n  console.log("a:" + a + ", b:" + b);\n}\n// 把数组“展开”成参数\nfoo.apply(null, [2, 3]); // a:2, b:3\n// 使用 bind(..) 进行柯里化\nvar bar = foo.bind(null, 2);\nbar(3); // a:2, b:3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在 es6 中，可以用 ... 操作符代替 apply(..) 来“展开”数组，foo(...[1,2]) 和 foo(1,2) 是一样的，这样可以避免不必要的 this 绑定\n\n然而，总是使用 null 来忽略 this 绑定可能产生一些副作用。如果某个函数确实使用了 this(比如第三方库中的一个函数)，那默认绑定规则会把 this 绑定到全局对象(在浏览器中这个对象是 window)，这将导致不可预计的后果(比如修改全局对象)。\n\n显而易见，这种方式可能会导致许多难以分析和追踪的 bug。\n\n一种“更安全”的做法是传入一个特殊的对象，把 this 绑定到这个对象不会对你的程序产生任何副作用。就像网络(以及军队)一样，我们可以创建一个“dmz”(demilitarized zone，非军事区)对象——它就是一个空的非委托的对象。\n\n由于这个对象完全是一个空对象，我自己喜欢用变量名 ø(这是数学中表示空集合符号的小写形式)来表示它。在大多数键盘(比如说 mac 的 us 布局键盘)上都可以使用 ⌥ +o (option-o)来打出这个符号。\n\n无论你叫它什么，在 javascript 中创建一个空对象最简单的方法都是 object.create(null)。object.create(null) 和 {} 很像，但是并不会创建 object.prototype 这个委托，所以它比 {}“更空”:\n\nfunction foo(a, b) {\n  console.log("a:" + a + ", b:" + b);\n}\n// 我们的 dmz 空对象\nvar ø = object.create(null); // 把数组展开成参数\nfoo.apply(ø, [2, 3]); // a:2, b:3\n// 使用 bind(..) 进行柯里化\nvar bar = foo.bind(ø, 2);\nbar(3); // a:2, b:3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 间接引用 🔥\n\n你有可能(有意或者无意地)创建一个函数的“间接引用”，在这 种情况下，调用这个函数会应用默认绑定规则。间接引用最容易在赋值时发生:\n\nfunction foo() {\n  console.log(this.a);\n}\nvar a = 2;\nvar o = { a: 3, foo: foo };\nvar p = { a: 4 };\no.foo(); // 3\n(p.foo = o.foo)(); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是 p.foo() 或者 o.foo()。根据我们之前说过的，这里会应用默认绑定。\n\n\n# 软绑定\n\n硬绑定这种方式可以把 this 强制绑定到指定的对象(除了使用 new 时)，防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。\n\n如果可以给默认绑定指定一个全局对象和 undefined 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。\n\n可以通过一种被称为软绑定的方法来实现我们想要的效果:\n\nif (!function.prototype.softbind) {\n  function.prototype.softbind = function(obj) {\n    var fn = this;\n    // 捕获所有 curried 参数\n    var curried = [].slice.call(arguments, 1);\n    var bound = function() {\n      return fn.apply(\n        !this || this === (window || global) ? obj : this,\n        curried.concat.apply(curried, arguments)\n      );\n    };\n    bound.prototype = object.create(fn.prototype);\n    return bound;\n  };\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n除了软绑定之外，softbind(..) 的其他原理和 es5 内置的 bind(..) 类似。它会对指定的函 数进行封装，首先检查调用时的 this，如果 this 绑定到全局对象或者 undefined，那就把 指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里化。下面我们看看 softbind 是否实现了软绑定功能:\n\nfunction foo() {\n  console.log("name: " + this.name);\n}\nvar obj = { name: "obj" },\n  obj2 = { name: "obj2" },\n  obj3 = { name: "obj3" };\nvar fooobj = foo.softbind(obj);\nfooobj(); // name: obj\nobj2.foo = foo.softbind(obj);\nobj2.foo(); // name: obj2 <---- 看!!!\nfooobj.call(obj3); // name: obj3 <---- 看!\nsettimeout(obj2.foo, 10); // name: obj <---- 应用了软绑定\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n可以看到，软绑定版本的 foo() 可以手动将 this 绑定到 obj2 或者 obj3 上，但如果应用默认绑定，则会将 this 绑定到 obj。\n\n\n# this 词法—箭头函数\n\n绑定的四条规则已经可以包含所有正常的函数。但是 es6 中介绍了一种无法使用 这些规则的特殊函数类型:箭头函数。\n\n箭头函数会**继承外层函数（或全局）**调用的 this 绑定(无论 this 绑定到什么)。这和 es6 之前代码中的 self = this 机制一样。\n\n箭头函数没有单独的 this 值（不会隐式传入 this 参数），this 在箭头函数创建时（就是=>出现的地方）确定\n\nfunction foo() {\n  // 返回一个箭头函数\n  return (a) => {\n    //this 继承自 foo()\n    console.log(this.a);\n  };\n}\nvar obj1 = {\n  a: 2,\n};\nvar obj2 = {\n  a: 3,\n};\nvar bar = foo.call(obj1);\nbar.call(obj2); // 2, 不是 3 !\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nfoo() 内部创建的箭头函数会捕获调用时 foo() 的 this。由于 foo() 的 this 绑定到 obj1， bar(引用箭头函数)的 this 也会绑定到 obj1，箭头函数的绑定无法被修改。(new 也不行!)\n\n箭头函数最常用于回调函数中，例如事件处理器或者定时器:\n\nfunction foo() {\n  settimeout(() => {\n    // 这里的 this 在词法上继承自 foo()\n    console.log(this.a);\n  }, 100);\n}\nvar obj = {\n  a: 2,\n};\nfoo.call(obj); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n箭头函数可以像 bind(..) 一样确保函数的 this 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 this 机制。实际上，在 es6 之前我们就已经 在使用一种几乎和箭头函数完全一样的模式。\n\nfunction foo() {\n  var self = this; // lexical capture of this\n  settimeout(function() {\n    console.log(self.a);\n  }, 100);\n}\nvar obj = {\n  a: 2,\n};\nfoo.call(obj); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n虽然 self = this 和箭头函数看起来都可以取代 bind(..)，但是从本质上来说，它们想替代的是 this 机制。\n\n如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 self = this 或者箭头函数来否定 this 机制，那你或许应当:\n\n * 只使用词法作用域并完全抛弃错误 this 风格的代码;\n * 完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。\n\n\n# 引用函数\n\nconst whatsmycontext = () => {\n  return this;\n};\n// 函数直接调用\nconsole.log(whatsmycontext() === window); // true\n\n// 对象字面量的方法\nconst ninja1 = {\n  getmythis: whatsmycontext,\n};\nconsole.log(ninja1.getmythis() === window); // true\n\n// 构造函数\n// function ninja() {\n//   this.getmythis = whatsmycontext\n// }\nclass ninja {\n  constructor() {\n    this.getmythis = whatsmycontext;\n  }\n}\nconst ninja2 = new ninja();\nconsole.log(ninja2.getmythis() === window); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n可以看出 this 都是在函数创建时已经确定了\n\n\n# 对象字面量 & 箭头函数副作用 🔥\n\n由于 this 值是在箭头函数创建时确定的，所以会导致一些看似奇怪的行为。回到按钮单击示例中，因为只有一个按钮，因此可以假设不需要构造函数。直接使用对象字面量\n\n<body>\n  <button id="btn">点这里</button>\n\n  <script>\n    var button = {\n      clicked: false,\n      click: () => {\n        this.clicked = true;\n        // this 指向 window\n        console.log(this === button); // false\n        console.log(this);\n\n      }\n    }\n\n    const $btn = document.getelementbyid(\'btn\')\n    $btn.addeventlistener(\'click\', button.click)\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n// 对象字面量的方法\nconst ninja3 = {\n  getmythis: () => {\n    return this;\n  },\n};\nconsole.log(ninja3.getmythis() === window); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 构造函数\n\n// 构造函数\n// function ninja2() {\n//   this.getmythis = () => {\n//     return this\n//   }\n// }\nclass ninja2 {\n  constructor() {\n    this.getmythis = () => {\n      return this;\n    };\n  }\n}\nconst ninja4 = new ninja2();\nconsole.log(ninja4.getmythis() === ninja4); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"1 理解-3 作用域",frontmatter:{title:"1 理解-3 作用域",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/0afc0f/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/200.%E7%90%86%E8%A7%A3/204.%E4%BD%9C%E7%94%A8%E5%9F%9F.html",relativePath:"1200.JS/200.理解/204.作用域.md",key:"v-856062ce",path:"/pages/0afc0f/",headers:[{level:2,title:"编译原理",slug:"编译原理",normalizedTitle:"编译原理",charIndex:13},{level:3,title:"分词/词法分析(Tokenizing/Lexing)",slug:"分词-词法分析-tokenizing-lexing",normalizedTitle:"分词/词法分析(tokenizing/lexing)",charIndex:137},{level:3,title:"解析/语法分析(Parsing)",slug:"解析-语法分析-parsing",normalizedTitle:"解析/语法分析(parsing)",charIndex:456},{level:3,title:"代码生成",slug:"代码生成",normalizedTitle:"代码生成",charIndex:736},{level:3,title:"JavaScript 引擎",slug:"javascript-引擎",normalizedTitle:"javascript 引擎",charIndex:878},{level:2,title:"如何理解作用域 🔥",slug:"如何理解作用域-🔥",normalizedTitle:"如何理解作用域 🔥",charIndex:1296},{level:3,title:"作用域是什么？🔥",slug:"作用域是什么-🔥",normalizedTitle:"作用域是什么？🔥",charIndex:1311},{level:3,title:"分析角度",slug:"分析角度",normalizedTitle:"分析角度",charIndex:1428},{level:3,title:"分析过程",slug:"分析过程",normalizedTitle:"分析过程",charIndex:1646},{level:3,title:"编译器的查找—LHS & RHS 🔥",slug:"编译器的查找-lhs-rhs-🔥",normalizedTitle:"编译器的查找—lhs &amp; rhs 🔥",charIndex:null},{level:3,title:"引擎和作用域对话",slug:"引擎和作用域对话",normalizedTitle:"引擎和作用域对话",charIndex:3620},{level:3,title:"作用域嵌套",slug:"作用域嵌套",normalizedTitle:"作用域嵌套",charIndex:4235},{level:3,title:"异常 🔥",slug:"异常-🔥",normalizedTitle:"异常 🔥",charIndex:4496},{level:2,title:"词法作用域 🔥",slug:"词法作用域-🔥",normalizedTitle:"词法作用域 🔥",charIndex:5259},{level:3,title:"词法阶段—分词/词法分析",slug:"词法阶段-分词-词法分析",normalizedTitle:"词法阶段—分词/词法分析",charIndex:5381},{level:3,title:"作用域查找 🔥",slug:"作用域查找-🔥",normalizedTitle:"作用域查找 🔥",charIndex:5581},{level:3,title:"欺骗词法作用域",slug:"欺骗词法作用域",normalizedTitle:"欺骗词法作用域",charIndex:5540},{level:4,title:"eval & setTimeout ...",slug:"eval-settimeout",normalizedTitle:"eval &amp; settimeout ...",charIndex:null},{level:4,title:"with",slug:"with",normalizedTitle:"with",charIndex:7692},{level:4,title:"性能",slug:"性能",normalizedTitle:"性能",charIndex:963},{level:2,title:"函数作用域 🔥",slug:"函数作用域-🔥",normalizedTitle:"函数作用域 🔥",charIndex:9812},{level:3,title:"函数作用域",slug:"函数作用域",normalizedTitle:"函数作用域",charIndex:8142},{level:3,title:"立即执行函数表达式",slug:"立即执行函数表达式",normalizedTitle:"立即执行函数表达式",charIndex:10576},{level:4,title:"用处1",slug:"用处1",normalizedTitle:"用处1",charIndex:10726},{level:4,title:"用处2",slug:"用处2",normalizedTitle:"用处2",charIndex:11457},{level:4,title:"用处3",slug:"用处3",normalizedTitle:"用处3",charIndex:11721},{level:2,title:"块作用域 🔥",slug:"块作用域-🔥",normalizedTitle:"块作用域 🔥",charIndex:12151},{level:3,title:"var—没有块作用域",slug:"var-没有块作用域",normalizedTitle:"var—没有块作用域",charIndex:12193},{level:3,title:"with",slug:"with-2",normalizedTitle:"with",charIndex:7692},{level:3,title:"try/catch",slug:"try-catch",normalizedTitle:"try/catch",charIndex:13896},{level:3,title:"let",slug:"let",normalizedTitle:"let",charIndex:13302},{level:4,title:"let循环",slug:"let循环",normalizedTitle:"let循环",charIndex:15014},{level:4,title:"垃圾收集",slug:"垃圾收集",normalizedTitle:"垃圾收集",charIndex:15347},{level:3,title:"const",slug:"const",normalizedTitle:"const",charIndex:16221},{level:2,title:"声明的提升 🔥",slug:"声明的提升-🔥",normalizedTitle:"声明的提升 🔥",charIndex:16857},{level:4,title:"",slug:"",normalizedTitle:"",charIndex:0}],headersStr:"编译原理 分词/词法分析(Tokenizing/Lexing) 解析/语法分析(Parsing) 代码生成 JavaScript 引擎 如何理解作用域 🔥 作用域是什么？🔥 分析角度 分析过程 编译器的查找—LHS & RHS 🔥 引擎和作用域对话 作用域嵌套 异常 🔥 词法作用域 🔥 词法阶段—分词/词法分析 作用域查找 🔥 欺骗词法作用域 eval & setTimeout ... with 性能 函数作用域 🔥 函数作用域 立即执行函数表达式 用处1 用处2 用处3 块作用域 🔥 var—没有块作用域 with try/catch let let循环 垃圾收集 const 声明的提升 🔥 ",content:'# 作用域 🔥\n\n\n# 编译原理\n\nJavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言，它不是提前编译的，编译结果也不能在分布式系统中进行移植。\n\n在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。\n\n\n# 分词/词法分析(Tokenizing/Lexing)\n\n这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代码块被称为词法单元(token)。例如，考虑程序var a = 2;。这段程序通常会被分解成 为下面这些词法单元:var、a、=、2、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。\n\n分词(tokenizing)和词法分析(Lexing)之间的区别是非常微妙、晦涩的， 主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。\n\n\n# 解析/语法分析(Parsing)\n\n这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(Abstract Syntax Tree，AST)。 var a = 2;的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier(它的值是 a)的子节点，以及一个叫作 AssignmentExpression 的子节点。AssignmentExpression 节点有一个叫作 NumericLiteral(它的值是 2)的子节点。\n\n\n# 代码生成\n\n将 AST 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。 抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。\n\n\n# JavaScript 引擎\n\n比起那些编译过程只有三个步骤的语言的编译器，JavaScript 引擎要复杂得多。例如，在 语法分析 和 代码生成 阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。\n\n首先，JavaScript 引擎不会有大量的(像其他语言编译器那么多的)时间用来进行优化，因为与其他语言不同，JavaScript 的编译过程不是发生在构建之前的。对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内。在我们所要讨论的作用域背后，JavaScript 引擎用尽了各种办法(比如 JIT，可以延迟编译甚至实施重编译)来保证性能最佳。\n\n简单地说，任何 JavaScript 代码片段在执行前都要进行编译(通常就在执行前)。因此， JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。\n\n\n# 如何理解作用域 🔥\n\n\n# 作用域是什么？🔥\n\n储存和访问或修改变量的值的能力使程序有了状态。那么这些变成存储在哪？程序在使用时如何寻找到它？\n\n上述问题说明需要一套设计良好的规则来存储变量，并且之后可以根据名称查到这些变量。 这套规则被称为作用域。\n\n\n# 分析角度\n\n理解作用域需要以如下三个角度来审视问题：\n\n * 引擎\n   \n   从头到尾负责整个 JavaScript 程序的编译及执行过程。\n\n * 编译器\n   \n   引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。\n\n * 作用域\n   \n   引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。\n\n\n# 分析过程\n\nvar a = 2;\n\n\n1\n\n\n上述程序对于引擎来说，他会认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。\n\n编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。\n\n可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括:“为一个变量分配内存，将其命名为 a，然后将值 2 保存进这个变量。”然而，这并不完全正确。事实上编译器会进行如下处理。\n\n 1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。\n 2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，即 LHS，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。\n 3. 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常!\n\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。\n\n简单说：\n\n 1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。\n 2. 接下来，a = 2 会查询(LHS 查询)变量 a 并对其进行赋值。\n\n\n# 编译器的查找—LHS & RHS 🔥\n\n在上述例子中，引擎会为变量 a 进行 LHS 查询。另外一个查找的类型叫作 RHS。当变量出现在赋值操作的左侧时进行 LHS 查询，出现在右侧时进行 RHS 查询。并不一定意味着就是“= 赋值操作符的左侧或右侧”\n\n * LHS 查询则是试图找到变量的容器本身，从而可以对其赋值。\n\n * RHS 查询与简单地查找某个变量的值别无二致，即找值\n   \n   从这个角度说，RHS 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧!!!”。可将其理解为“赋值操作的目标是谁(LHS)”以及“谁是赋值操作的源头(RHS)”。可以将 RHS 理解成 retrieve his source value(取到它的源值)\n\n示例如下：\n\nconsole.log(a);\n\n\n1\n\n\n其中对 a 的引用是一个 RHS 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取得 a 的值，这样才能将值传递给 console.log(..)。\n\na = 2;\n\n\n1\n\n\n这里对 a 的引用则是 LHS 引用，因为实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。\n\nfunction foo(a) { \n  console.log(a); // 2\n}\nfoo(2);\n\n\n1\n2\n3\n4\n\n * 最后一行 foo(..) 函数的调用需要对 foo 进行 RHS 引用，并且 (..) 意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值！\n * 代码中隐式的 a=2 操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给 foo(..) 函数时，2 会被分配给参数 a。为了给参数 a(隐式地)分配值，需要进行一次 LHS 查询。\n * 这里还有对 a 进行的 RHS 引用，并且将得到的值传给了 console.log(..)。console.log(..) 本身也需要一个引用才能执行，因此会对 console 对象进行 RHS 查询，并且检查得到的值中是否有一个叫作 log 的方法。\n * 最后，在概念上可以理解为在 LHS 和 RHS 之间通过对值 2 进行交互来将其传递进 log(..) (通过变量 a 的 RHS 查询)。假设在 log(..) 函数的原生实现中它可以接受参数，在将 2 赋值给其中第一个(也许叫作 arg1)参数之前，这个参数需要进行 LHS 引用查询。\n\n你可能会倾向于将函数声明 function foo(a) {... 概念化为普通的变量声明和赋值，比如 var foo、foo = function(a) {...。如果这样理解的话，这个函数声明将需要进行 LHS 查询。然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo。因此，将函数声明理解成前面讨论的 LHS 查询和赋值的形式并不合适。\n\n\n# 引擎和作用域对话\n\nfunction foo(a) { \n  console.log(a); // 2\n}\nfoo(2);\n\n\n1\n2\n3\n4\n\n\n让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。\n\n * 引擎:我说作用域，我需要为 foo 进行 RHS 引用。你见过它吗?\n\n * 作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。\n\n * 引擎:哥们太够意思了!好吧，我来执行一下 foo。\n\n * 引擎:作用域，还有个事儿。我需要为 a 进行 LHS 引用，这个你见过吗?\n\n * 作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。\n\n * 引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。\n\n * 引擎:哥们，不好意思又来打扰你。我要为 console 进行 RHS 引用，你见过它吗?\n\n * 作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。\n\n * 引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。\n\n * 引擎:哥们，能帮我再找一下对 a 的 RHS 引用吗?虽然我记得它，但想再确认一次。\n\n * 作用域:放心吧，这个变量没有变动过，拿走，不谢。\n\n * 引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。\n\n * ......\n\n\n# 作用域嵌套\n\n当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。\n\nfunction foo(a) { \n  console.log( a + b );\n}\nvar b = 2; \nfoo( 2 ); // 4\n\n\n1\n2\n3\n4\n5\n\n\n对 b 进行的 RHS 引用无法在函数 foo 内部完成，但可以在上一级作用域(在这个例子中就 是全局作用域)中完成。\n\n\n# 异常 🔥\n\n为什么区分 LHS 和 RHS 是一件重要的事情?\n\n因为在变量还没有声明(在任何作用域中都无法找到该变量)的情况下，这两种查询的行为是不一样的。\n\nfunction foo(a) { \n  console.log(a + b); \n  b = a;\n}\nfoo( 2 );\n\n\n1\n2\n3\n4\n5\n\n\nReferenceError\n\n * 第一次对 b 进行 RHS 查询时是无法找到该变量的。这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 ReferenceError 异常。\n\n * 相较之下，当引擎执行 LHS 查询时，如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。\n   \n   ES5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在 严格模式中 LHS 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 RHS 查询 失败时类似的 ReferenceError 异常。\n\nTypeError\n\n * 接下来，如果 RHS 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 TypeError。\n\nReferenceError 同作用域判别失败相关，而 TypeError 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。\n\n\n# 词法作用域 🔥\n\n作用域共有两种主要的工作模型。\n\n * 词法作用域：最为普遍的，被大多数编程语言所采用，我们会对这种作用域进行深入讨论。\n * 动态作用域：仍有一些编程语言在使用(比如 Bash 脚本、Perl 中的一些模式等)。\n\n\n# 词法阶段—分词/词法分析\n\n词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义，即词法分析，否则是分词。\n\n词法作用域就是定义在词法阶段的作用域，换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的，还会有欺骗词法作用域的方法，这些方法在词法分析器处理过后依然可以修改作用域)。\n\n\n# 作用域查找 🔥\n\nfunction foo(a) { \n  var b = a * 2;\n\tfunction bar(c) { \n    console.log( a, b, c );\n\t}\nbar( b * 3 ); \n}   \nfoo( 2 ); // 2, 4, 12\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在上述例子中有三个逐级嵌套的作用域。从最外层开始：\n\n * 包含着整个全局作用域，其中只有一个标识符:foo。\n\n * 包含着 foo 所创建的作用域，其中有三个标识符:a、bar 和 b。\n\n * 包含着 bar 所创建的作用域，其中只有一个标识符:c。\n\n作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。\n\n全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。window.a。通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。\n\n无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\n\n词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz， 词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接 管对 bar 和 baz 属性的访问。\n\n\n# 欺骗词法作用域\n\n如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”(也可以说欺骗)词法作用域呢?JavaScript 中有两种机制来实现这个目的。社区普遍认为在代码中使用这两种机制并不是什么好注意。但是关于它们的争论通常会忽略掉最重要的点:欺骗词法作用域会导致性能下降。\n\n# eval & setTimeout ...\n\nJavaScript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时（词法期）就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。\n\n在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。\n\nfunction foo(str, a) { \n  eval( str ); // 欺骗! \n  console.log( a, b );\n}\nvar b = 2;\nfoo( "var b = 3;", 1 ); // 1, 3\n\n\n1\n2\n3\n4\n5\n6\n\n\n根据原理可知，这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽了外部(全局)作用域中的同名变量。\n\n在这个例子中，为了展示的方便和简洁，我们传递进去的“代码”字符串是固定不变的。而在实际情况中，可以非常容易地根据程序逻辑动态地将字符拼接在一起之后再传递进去。eval(..)通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里更有好处。\n\n默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明(无论是变量还是函数)，就会对 eval(..) 所处的词法作用域进行修改。技术上，通过一些技巧(已经超出我们的讨论范围)可以间接调用 eval(..) 来使其运行在全局作用域中，并对全局作用域进行修改。但无论何种情况，eval(..) 都可以在运行期修改书写期的词法作用域。\n\n但是在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。\n\nfunction foo(str) { \n  "use strict";\n\teval( str );\n\tconsole.log( a ); // ReferenceError: a is not defined \n}\nfoo( "var a = 2" );\n\n\n1\n2\n3\n4\n5\n6\n\n\nJavaScript 中还有其他一些功能效果和eval(..)很相似。setTimeout(..)和 setInterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们!\n\nnew Function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。\n\n在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。\n\n# with\n\nJavaScript 中另一个难以掌握(并且现在也不推荐使用)的用来欺骗词法作用域的功能是 with 关键字。\n\nwith 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。\n\nvar obj = { \n  a: 1,\n  b: 2,\n  c: 3 \n};\n// 单调乏味的重复 "obj" \nobj.a = 2;\nobj.b = 3;\nobj.c = 4;\n// 简单的快捷方式 \nwith (obj) {\n  a = 3;\n  b = 4;\n  c = 5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n但实际上这不仅仅是为了方便地访问对象属性。考虑如下代码:\n\nfunction foo(obj) {\n  with (obj) {\n    a = 2;// 此处是为了给obj对象的a属性赋值，执行LHS\n    var c = 666;// 此处变量不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中\n  }\n  console.log(c)\n}\nvar o1 = {\n  a: 3\n};\nvar o2 = {\n  b: 3\n};\n\nfoo(o1);// 666\nconsole.log(o1.a); // 2\n\nfoo(o2);// 666\nconsole.log(o2.a); // undefined\nconsole.log(a); // 2——不好，a 被泄漏到全局作用域上了!\nconsole.log(c);// ReferenceError, c is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这个例子中创建了 o1 和 o2 两个对象。其中一个具有 a 属性，另外一个没有。foo(..) 函数接受一个obj参数，该参数是一个对象引用，并对这个对象引用执行了with(obj) {..}。 在 with 块内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个 LHS 引用，并将 2 赋值给它。\n\n当我们将 o1 传递进去，a=2 赋值操作找到了 o1.a 并将 2 赋值给它，这在后面的 console. log(o1.a) 中可以体现。而当 o2 传递进去，o2 并没有 a 属性，因此不会创建这个属性， o2.a 保持 undefined。\n\n但是可以注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局的变量 a。这 是怎么回事?\n\nwith 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中；不添加var时且 LHS 查不到会创建全局变量。\n\n可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含 有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符， 因此进行了正常的 LHS 标识符查找。\n\no2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a=2 执行时，自动创建了一个全局变量(因为是非严格模式)。with 这种将对象及其属性放进一个作用域并同时分配标识符的行为很让人费解。\n\neval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。\n\n另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响(限制)。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。\n\n# 性能\n\n如果它们能实现更复杂的功能，并且代码更具有扩展性会更好。其实不然。\n\nJavaScript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。\n\n\n# 函数作用域 🔥\n\n\n# 函数作用域\n\n考虑下面的代码:\n\nfunction foo(a) { \n  var b = 2;\n\t// 一些代码\n\tfunction bar() { \n    // ...\n\t}\n  // 更多的代码 \n  var c = 3;\n}\nbar(); // 失败 ReferenceError\nconsole.log( a, b, c ); // 三个全都失败 ReferenceError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n由于标识符 a、b、c 和 bar 都附属于 foo(..) 的作用域，因此无法从 foo(..) 的外部直接对它们进行访问。但在 foo(..) 的内部都是可以被访问的，同样在 bar(..) 内部也可以被访问（假设 bar(..) 内部没有同名的标识符声明）\n\n * 体现了封装，隐藏内部实现的设计原则\n * 可以规避同名标识符冲突（多个第三方库）。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象 被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。也可以使用模块管理避免同名标识符冲突\n\nfunction foo() { \n  function bar(a) {\n    i = 3; // 修改for循环所属作用域中的i，因为for没有作用域，i被声明在foo中了\n    console.log( a + i );\n  }\n  \n  for (var i=0; i<10; i++) {\n    bar( i * 2 ); // 糟糕，无限循环了!\n  } \n}\nfoo();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 立即执行函数表达式\n\n虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。\n\n * 必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域(在这个例子中是全局作用域)。\n * 必须显式地通过函数名(foo())调用这个函数才能运行其 中的代码。\n\n# 用处1\n\n如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行， 这将会更加理想。如下：\n\nvar a = 2;\n\n(function foo(a) { // <-- 添加这一行，也可以省略foo用做匿名函数\n  var a = 3;\n  console.log(a); // 3 \n})(a); // <-- 以及这一行，可以转递参数\n\n// 也可以这样写\n//(function foo(b) { // <-- 添加这一行，也可以省略foo用做匿名函数\n//  var a = 3;\n//  console.log(a); // 3 \n//}(b)); // <-- 以及这一行，可以转递参数\n\nconsole.log(a); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于函数被包含在一对 ( ) 括号内部，函数会被当作函数表达式而不是一个标准的函数声明来处理，通过在末尾加上另外一个 ( ) 可以立即执行这个函数。即 IIFE(Immediately Invoked Function Expression) 立即执行函数表达式\n\nfoo 被绑定在函数表达式自身的函数中而不是所在作用域中。意味着foo只能在..所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。也可以省略 foo 写作匿名函数表达式。\n\n注意\n\n区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n\n# 用处2\n\n这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)。\n\nundefined = true; // 给其他代码挖了一个大坑!绝对不要这样做! \n(function IIFE(undefined) {\n  var a;\n  if (a === undefined) {\n    console.log("Undefined is safe here!");\n  }\n})();// Undefined is safe here!\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 用处3\n\nIIFE 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 IIFE 执行之后当作参数传递进去。这种模式在 UMD(Universal Module Definition)项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。\n\nvar a = 2;\n(function IIFE( def ) { \n  def( window );\n})(function def( global ) {\n  var a = 3;\n  console.log( a ); // 3 \n  console.log( global.a ); // 2\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 IIFE 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。\n\n\n# 块作用域 🔥\n\n除 JavaScript 外的很多编程语言都支持块作用域\n\n\n# var—没有块作用域\n\n当无论在哪里使用 var 声明变量时，它们最终都会属于外部作用域（函数或全局。for 没有作用域，此处绑定到全局作用域）。\n\nfor (var i=0; i<10; i++) { \n  console.log( i );\n}\n\n\n1\n2\n3\n\n\n我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域(函数或全局)中的事实。\n\n如下例子\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <button>按钮1</button>\n    <button>按钮2</button>\n    <button>按钮3</button>\n    <button>按钮4</button>\n    <button>按钮5</button>\n    <script>\n      var btns = document.getElementsByTagName("button");\n\n      //   var\n      //   for (var i = 0; i < btns.length; i++) {\n      //     btns[i].addEventListener("click", function () {\n      //       console.log(`按了第${i}个按钮`); // 按了第5个按钮。无论怎么都是输出这个\n      //     });\n      //   }\n\n      //   立即执行函数\n      //   for (var i = 0; i < btns.length; i++) {\n      //     (function (i) {\n      //       btns[i].addEventListener("click", function () {\n      //         console.log(`按了第${i}个按钮`); // 正常\n      //       });\n      //     })(i);\n      //   }\n\n      // let\n      for (let i = 0; i < btns.length; i++) {\n        btns[i].addEventListener("click", function () {\n          console.log(`按了第${i}个按钮`); // 正常\n        });\n      }\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n因为函数中的打印语句引用的 i 是一个外部变量，不是传入的参数，不受函数作用域控制，绑定事件的循环中 i 一直在改变，最终输出时，获取到的变量都是 5！全局变量污染！\n\n当使用立即执行函数后，由于i被当作参数传入立即执行函数，此时再去修改i都不会影响函数中的值。\n\n当使用let后，{}中的i也是属于该作用域的，不受外部i的改变而变化\n\n\n# with\n\nwith 关键字。它不仅是一个难于理解的结构，同时也是块作用域的一个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。\n\n\n# try/catch\n\nJavaScript 的 ES3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。\n\ntry {\n  undefined(); // 执行一个非法操作来强制制造一个异常\n}\ncatch (err) {\n  console.log( err ); // 能够正常执行! \n}\nconsole.log( err ); // ReferenceError: err not found\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n尽管这个行为已经被标准化，并且被大部分的标准 JavaScript 环境(除了老版本的 IE 浏览器)所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。 实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部， 但是静态检查工具还是会很烦人地发出警告。\n\n为了避免这个不必要的警告，很多开发者会将 catch 的参数命名为 err1、 err2 等。也有开发者干脆关闭了静态检查工具对重复变量名的检查。\n\n这是向 ES6 中的所有（大部分）功能迁移的首选方式：在从 ES6 之前的环境向 ES6 过渡时，使用代码转换工具来对 ES6 代码进行处理，生成兼容 ES5 的代码。\n\n{\n  let a = 2;\n  console.log( a ); // 2 \n}\nconsole.log( a ); // ReferenceError\n\n\n1\n2\n3\n4\n5\n\n\n这段代码在 ES6 环境中可以正常工作。但是在 ES6 之前的环境中如何才能实现这个效果?可以使用 catch。\n\ntry{\n  throw 2;\n}catch(a){ \n  console.log( a ); // 2\n}\nconsole.log( a ); // ReferenceError\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# let\n\nES6引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中（通常是 {} 内部）。换句话说，let 为其声明的变量隐式地指定了所在的块作用域。\n\nvar foo = true;\nif (foo) {\n  let bar = foo * 2;\n  bar = something( bar ); \n  console.log( bar );\n}\nconsole.log( bar ); // ReferenceError\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# let循环\n\nfor (let i=0; i<10; i++) { \n  console.log( i );\n}\nconsole.log( i ); // ReferenceError\n\n\n1\n2\n3\n4\n\n\nfor 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。\n\n下面通过另一种方式来说明每次迭代时进行重新绑定的行为（用于闭包，不懂）:\n\n{\n  let j;\n  for (j=0; j<10; j++) {\n    let i = j; // 每个迭代重新绑定!\n    console.log( i ); }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 垃圾收集\n\n另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。\n\nfunction process(data) {\n  // 在这里做点有趣的事情\n}\nvar someReallyBigData = { .. };\nprocess( someReallyBigData );\nvar btn = document.getElementById( "my_button" );\nbtn.addEventListener( "click", function click(evt) { \n  console.log("button clicked");\n}, /*capturingPhase=*/false );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nclick 函数的点击回调并不需要 someReallyBigData 变量。理论上这意味着当 process(..) 执 行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成 了一个覆盖整个作用域的闭包，JavaScript 引擎极有可能依然保存着这个结构(取决于具体实现)。块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 someReallyBigData 了:\n\nfunction process(data) {\n  // 在这里做点有趣的事情\n}\n// 在这个块中定义的内容可以销毁了! {\nlet someReallyBigData = { .. }; \nprocess( someReallyBigData );\n}\nvar btn = document.getElementById( "my_button" );\nbtn.addEventListener( "click", function click(evt){ \n  console.log("button clicked");\n}, /*capturingPhase=*/false );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# const\n\nES6 还引入了 const，同样可以用来创建块作用域变量\n\nvar foo = true;\nif (foo) {\n  var a = 2;\n  const b = 3; // 包含在 if 中的块作用域常量\n  a = 3; // 正常!\n  b = 4; // 错误! \n}\nconsole.log( a ); // 3\nconsole.log( b ); // ReferenceError!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n其值是固定的 (常量)。之后任何试图修改值的操作都会引起错误\n\n创建后必须进行初始化，否则报错\n\nconst a = 1;\nconst b;\nb = 1;// Uncaught SyntaxError: Missing initializer in const declaration\nconst c;// Uncaught SyntaxError: Missing initializer in const declaration\n\n\n1\n2\n3\n4\n\n\n常量的含义是指向的对象不能修改，但是可以改变对象内部的属性。数组也一样\n\nconst obj = {\n    name: "conanan",\n    age: 18,\n    sex: "male",\n};\nconsole.log(obj);\nobj.age = 25;\nconsole.log(obj);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 声明的提升 🔥\n\n函数声明和变量声明都会被提升到各自作用域顶端，且函数会首先被提升，然后才是变量。但是函数表达式却不会被提升\n\n看如下代码：\n\na = 2;\nvar a; \nconsole.log( a );// 2\n\n\n1\n2\n3\n\n\nconsole.log( a );// undefined\nvar a = 2;\n\n\n1\n2\n\n\n词法作用域的核心内容：引擎会在解释 JavaScript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。所以变量和函数在内的所有声明都会在任何代码被执行前首先被处理。\n\n所以上述代码编译会进行如下处理：\n\nvar a; \na = 2;\nconsole.log( a );// 2\n\n\n1\n2\n3\n\n\nvar a; \nconsole.log( a ); \na = 2;// undefined\n\n\n1\n2\n3\n\n\n只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。\n\nfoo();\nfunction foo() {\n  console.log( a ); // undefined var a = 2;\n}\n\n\n1\n2\n3\n4\n\n\nfunction foo() { \n  var a;\n  console.log( a ); // undefined\n  a = 2; \n}\nfoo();\n\n\n1\n2\n3\n4\n5\n6\n\n\n函数声明会被提升，但是函数表达式却不会被提升，如下：\n\nfoo(); // 不是 ReferenceError, 而是 TypeError!\nvar foo = function bar() { \n  // ...\n};\n\n\n1\n2\n3\n4\n\n\nvar foo;\nfoo(); // 不是 ReferenceError, 而是 TypeError!\nfoo = function bar() { \n  // ...\n};\n\n\n1\n2\n3\n4\n5\n\n\n变量标识符 foo 被提升并分配给所在作用域(在这里是全局作用域)，因此 foo() 不会导致 ReferenceError。但是 foo 此时并没有赋值(如果它是一个函数声明而不 是函数表达式，那么就会赋值)。foo() 由于对 undefined 值进行函数调用而导致非法操作， 因此抛出 TypeError 异常。\n\n即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用:\n\nfoo(); // TypeError\nbar(); // ReferenceError\nvar foo = function bar() { \n  // ...\n};\n\n\n1\n2\n3\n4\n5\n\n\nvar foo;\nfoo(); // TypeError\nbar(); // ReferenceError\nfoo = function() {\n  var bar = ...self... \n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n函数会首先被提升，然后才是变量，特别注意有多个“重复”声明的代码中：\n\nfoo(); // 1\nvar foo;\nfunction foo() { \n  console.log( 1 );\n}\nfoo = function() { \n  console.log( 2 );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfunction foo() { \n  console.log( 1 );\n}\nfoo(); // 1\nfoo = function() { \n  console.log( 2 );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nvar foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的，如下：\n\nfoo(); // 3\nfunction foo() { \n  console.log( 1 );\n}\nvar foo = function() { \n  console.log( 2 );\n};\nfunction foo() { \n  console.log( 3 );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nfunction foo() { \n  console.log( 1 );\n}\nfunction foo() { \n  console.log( 3 );\n}\nfoo(); // 3\nfoo = function() { \n  console.log( 2 );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由上述说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。\n\n再看个例子\n\nconsole.log(typeof fun === \'function\') // true\nvar fun = 3\nconsole.log(typeof fun === \'number\') // true\nfunction fun() {}\nconsole.log(typeof fun === \'number\') // true`\n\n\n1\n2\n3\n4\n5\n\n\nfunction fun() {}\nvar fun\nconsole.log(typeof fun === \'function\') // true\nfun = 3\nconsole.log(typeof fun === \'number\') // true\nconsole.log(typeof fun === \'number\') // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制。但是需要注意这个行为并不可靠，在 JavaScript 未来的版本中有可能发生改变，因此应该 尽可能避免在块内部声明函数。如下代码已经执行不了了，TypeError: foo is not a function\n\nfoo(); // "b"\nvar a = true; \nif (a) {\n  function foo() { \n    console.log("a"); \n  } \n}else {\n  function foo() { \n    console.log("b"); \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n#',normalizedContent:'# 作用域 🔥\n\n\n# 编译原理\n\njavascript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言，它不是提前编译的，编译结果也不能在分布式系统中进行移植。\n\n在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。\n\n\n# 分词/词法分析(tokenizing/lexing)\n\n这个过程会将由字符组成的字符串分解成(对编程语言来说)有意义的代码块，这些代码块被称为词法单元(token)。例如，考虑程序var a = 2;。这段程序通常会被分解成 为下面这些词法单元:var、a、=、2、;。空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。\n\n分词(tokenizing)和词法分析(lexing)之间的区别是非常微妙、晦涩的， 主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。\n\n\n# 解析/语法分析(parsing)\n\n这个过程是将词法单元流(数组)转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”(abstract syntax tree，ast)。 var a = 2;的抽象语法树中可能会有一个叫作 variabledeclaration 的顶级节点，接下来是一个叫作 identifier(它的值是 a)的子节点，以及一个叫作 assignmentexpression 的子节点。assignmentexpression 节点有一个叫作 numericliteral(它的值是 2)的子节点。\n\n\n# 代码生成\n\n将 ast 转换为可执行代码的过程称被称为代码生成。这个过程与语言、目标平台等息息相关。 抛开具体细节，简单来说就是有某种方法可以将 var a = 2; 的 ast 转化为一组机器指令，用来创建一个叫作 a 的变量(包括分配内存等)，并将一个值储存在 a 中。\n\n\n# javascript 引擎\n\n比起那些编译过程只有三个步骤的语言的编译器，javascript 引擎要复杂得多。例如，在 语法分析 和 代码生成 阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等。\n\n首先，javascript 引擎不会有大量的(像其他语言编译器那么多的)时间用来进行优化，因为与其他语言不同，javascript 的编译过程不是发生在构建之前的。对于 javascript 来说，大部分情况下编译发生在代码执行前的几微秒(甚至更短!)的时间内。在我们所要讨论的作用域背后，javascript 引擎用尽了各种办法(比如 jit，可以延迟编译甚至实施重编译)来保证性能最佳。\n\n简单地说，任何 javascript 代码片段在执行前都要进行编译(通常就在执行前)。因此， javascript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。\n\n\n# 如何理解作用域 🔥\n\n\n# 作用域是什么？🔥\n\n储存和访问或修改变量的值的能力使程序有了状态。那么这些变成存储在哪？程序在使用时如何寻找到它？\n\n上述问题说明需要一套设计良好的规则来存储变量，并且之后可以根据名称查到这些变量。 这套规则被称为作用域。\n\n\n# 分析角度\n\n理解作用域需要以如下三个角度来审视问题：\n\n * 引擎\n   \n   从头到尾负责整个 javascript 程序的编译及执行过程。\n\n * 编译器\n   \n   引擎的好朋友之一，负责语法分析及代码生成等脏活累活(详见前一节的内容)。\n\n * 作用域\n   \n   引擎的另一位好朋友，负责收集并维护由所有声明的标识符(变量)组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。\n\n\n# 分析过程\n\nvar a = 2;\n\n\n1\n\n\n上述程序对于引擎来说，他会认为这里有两个完全不同的声明，一个由编译器在编译时处理，另一个则由引擎在运行时处理。\n\n编译器首先会将这段程序分解成词法单元，然后将词法单元解析成一个树结构。但是当编译器开始进行代码生成时，它对这段程序的处理方式会和预期的有所不同。\n\n可以合理地假设编译器所产生的代码能够用下面的伪代码进行概括:“为一个变量分配内存，将其命名为 a，然后将值 2 保存进这个变量。”然而，这并不完全正确。事实上编译器会进行如下处理。\n\n 1. 遇到 var a，编译器会询问作用域是否已经有一个该名称的变量存在于同一个作用域的集合中。如果是，编译器会忽略该声明，继续进行编译；否则它会要求作用域在当前作用域的集合中声明一个新的变量，并命名为 a。\n 2. 接下来编译器会为引擎生成运行时所需的代码，这些代码被用来处理 a = 2 这个赋值操作。引擎运行时会首先询问作用域，即 lhs，在当前的作用域集合中是否存在一个叫作 a 的 变量。如果是，引擎就会使用这个变量；如果否，引擎会继续查找该变量。\n 3. 如果引擎最终找到了 a 变量，就会将 2 赋值给它。否则引擎就会举手示意并抛出一个异常!\n\n总结：变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量(如果之前没有声明过)，然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。\n\n简单说：\n\n 1. 首先，var a 在其作用域中声明新变量。这会在最开始的阶段，也就是代码执行前进行。\n 2. 接下来，a = 2 会查询(lhs 查询)变量 a 并对其进行赋值。\n\n\n# 编译器的查找—lhs & rhs 🔥\n\n在上述例子中，引擎会为变量 a 进行 lhs 查询。另外一个查找的类型叫作 rhs。当变量出现在赋值操作的左侧时进行 lhs 查询，出现在右侧时进行 rhs 查询。并不一定意味着就是“= 赋值操作符的左侧或右侧”\n\n * lhs 查询则是试图找到变量的容器本身，从而可以对其赋值。\n\n * rhs 查询与简单地查找某个变量的值别无二致，即找值\n   \n   从这个角度说，rhs 并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧!!!”。可将其理解为“赋值操作的目标是谁(lhs)”以及“谁是赋值操作的源头(rhs)”。可以将 rhs 理解成 retrieve his source value(取到它的源值)\n\n示例如下：\n\nconsole.log(a);\n\n\n1\n\n\n其中对 a 的引用是一个 rhs 引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取得 a 的值，这样才能将值传递给 console.log(..)。\n\na = 2;\n\n\n1\n\n\n这里对 a 的引用则是 lhs 引用，因为实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。\n\nfunction foo(a) { \n  console.log(a); // 2\n}\nfoo(2);\n\n\n1\n2\n3\n4\n\n * 最后一行 foo(..) 函数的调用需要对 foo 进行 rhs 引用，并且 (..) 意味着 foo 的值需要被执行，因此它最好真的是一个函数类型的值！\n * 代码中隐式的 a=2 操作可能很容易被你忽略掉。这个操作发生在 2 被当作参数传递给 foo(..) 函数时，2 会被分配给参数 a。为了给参数 a(隐式地)分配值，需要进行一次 lhs 查询。\n * 这里还有对 a 进行的 rhs 引用，并且将得到的值传给了 console.log(..)。console.log(..) 本身也需要一个引用才能执行，因此会对 console 对象进行 rhs 查询，并且检查得到的值中是否有一个叫作 log 的方法。\n * 最后，在概念上可以理解为在 lhs 和 rhs 之间通过对值 2 进行交互来将其传递进 log(..) (通过变量 a 的 rhs 查询)。假设在 log(..) 函数的原生实现中它可以接受参数，在将 2 赋值给其中第一个(也许叫作 arg1)参数之前，这个参数需要进行 lhs 引用查询。\n\n你可能会倾向于将函数声明 function foo(a) {... 概念化为普通的变量声明和赋值，比如 var foo、foo = function(a) {...。如果这样理解的话，这个函数声明将需要进行 lhs 查询。然而还有一个重要的细微差别，编译器可以在代码生成的同时处理声明和值的定义，比如在引擎执行代码时，并不会有线程专门用来将一个函数值“分配给”foo。因此，将函数声明理解成前面讨论的 lhs 查询和赋值的形式并不合适。\n\n\n# 引擎和作用域对话\n\nfunction foo(a) { \n  console.log(a); // 2\n}\nfoo(2);\n\n\n1\n2\n3\n4\n\n\n让我们把上面这段代码的处理过程想象成一段对话，这段对话可能是下面这样的。\n\n * 引擎:我说作用域，我需要为 foo 进行 rhs 引用。你见过它吗?\n\n * 作用域:别说，我还真见过，编译器那小子刚刚声明了它。它是一个函数，给你。\n\n * 引擎:哥们太够意思了!好吧，我来执行一下 foo。\n\n * 引擎:作用域，还有个事儿。我需要为 a 进行 lhs 引用，这个你见过吗?\n\n * 作用域:这个也见过，编译器最近把它声名为 foo 的一个形式参数了，拿去吧。\n\n * 引擎:大恩不言谢，你总是这么棒。现在我要把 2 赋值给 a。\n\n * 引擎:哥们，不好意思又来打扰你。我要为 console 进行 rhs 引用，你见过它吗?\n\n * 作用域:咱俩谁跟谁啊，再说我就是干这个。这个我也有，console 是个内置对象。 给你。\n\n * 引擎:么么哒。我得看看这里面是不是有 log(..)。太好了，找到了，是一个函数。\n\n * 引擎:哥们，能帮我再找一下对 a 的 rhs 引用吗?虽然我记得它，但想再确认一次。\n\n * 作用域:放心吧，这个变量没有变动过，拿走，不谢。\n\n * 引擎:真棒。我来把 a 的值，也就是 2，传递进 log(..)。\n\n * ......\n\n\n# 作用域嵌套\n\n当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量， 或抵达最外层的作用域(也就是全局作用域)为止。\n\nfunction foo(a) { \n  console.log( a + b );\n}\nvar b = 2; \nfoo( 2 ); // 4\n\n\n1\n2\n3\n4\n5\n\n\n对 b 进行的 rhs 引用无法在函数 foo 内部完成，但可以在上一级作用域(在这个例子中就 是全局作用域)中完成。\n\n\n# 异常 🔥\n\n为什么区分 lhs 和 rhs 是一件重要的事情?\n\n因为在变量还没有声明(在任何作用域中都无法找到该变量)的情况下，这两种查询的行为是不一样的。\n\nfunction foo(a) { \n  console.log(a + b); \n  b = a;\n}\nfoo( 2 );\n\n\n1\n2\n3\n4\n5\n\n\nreferenceerror\n\n * 第一次对 b 进行 rhs 查询时是无法找到该变量的。这是一个“未声明”的变量，因为在任何相关的作用域中都无法找到它。如果 rhs 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出 referenceerror 异常。\n\n * 相较之下，当引擎执行 lhs 查询时，如果在顶层(全局作用域)中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，前提是程序运行在非 “严格模式”下。\n   \n   es5 中引入了“严格模式”。同正常模式，或者说宽松 / 懒惰模式相比，严格模式在行为上有很多不同。其中一个不同的行为是严格模式禁止自动或隐式地创建全局变量。因此，在 严格模式中 lhs 查询失败时，并不会创建并返回一个全局变量，引擎会抛出同 rhs 查询 失败时类似的 referenceerror 异常。\n\ntypeerror\n\n * 接下来，如果 rhs 查询找到了一个变量，但是你尝试对这个变量的值进行不合理的操作， 比如试图对一个非函数类型的值进行函数调用，或着引用 null 或 undefined 类型的值中的属性，那么引擎会抛出另外一种类型的异常，叫作 typeerror。\n\nreferenceerror 同作用域判别失败相关，而 typeerror 则代表作用域判别成功了，但是对结果的操作是非法或不合理的。\n\n\n# 词法作用域 🔥\n\n作用域共有两种主要的工作模型。\n\n * 词法作用域：最为普遍的，被大多数编程语言所采用，我们会对这种作用域进行深入讨论。\n * 动态作用域：仍有一些编程语言在使用(比如 bash 脚本、perl 中的一些模式等)。\n\n\n# 词法阶段—分词/词法分析\n\n词法化的过程会对源代码中的字符进行检查，如果是有状态的解析过程，还会赋予单词语义，即词法分析，否则是分词。\n\n词法作用域就是定义在词法阶段的作用域，换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变(大部分情况下是这样的，还会有欺骗词法作用域的方法，这些方法在词法分析器处理过后依然可以修改作用域)。\n\n\n# 作用域查找 🔥\n\nfunction foo(a) { \n  var b = a * 2;\n\tfunction bar(c) { \n    console.log( a, b, c );\n\t}\nbar( b * 3 ); \n}   \nfoo( 2 ); // 2, 4, 12\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n在上述例子中有三个逐级嵌套的作用域。从最外层开始：\n\n * 包含着整个全局作用域，其中只有一个标识符:foo。\n\n * 包含着 foo 所创建的作用域，其中有三个标识符:a、bar 和 b。\n\n * 包含着 bar 所创建的作用域，其中只有一个标识符:c。\n\n作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作“遮蔽效应”(内部的标识符“遮蔽”了外部的标识符)。抛开遮蔽效应， 作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。\n\n全局变量会自动成为全局对象(比如浏览器中的 window 对象)的属性，因此 可以不直接通过全局对象的词法名称，而是间接地通过对全局对象属性的引 用来对其进行访问。window.a。通过这种技术可以访问那些被同名变量所遮蔽的全局变量。但非全局的变量如果被遮蔽了，无论如何都无法被访问到。\n\n无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。\n\n词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 foo.bar.baz， 词法作用域查找只会试图查找 foo 标识符，找到这个变量后，对象属性访问规则会分别接 管对 bar 和 baz 属性的访问。\n\n\n# 欺骗词法作用域\n\n如果词法作用域完全由写代码期间函数所声明的位置来定义，怎样才能在运行时来“修改”(也可以说欺骗)词法作用域呢?javascript 中有两种机制来实现这个目的。社区普遍认为在代码中使用这两种机制并不是什么好注意。但是关于它们的争论通常会忽略掉最重要的点:欺骗词法作用域会导致性能下降。\n\n# eval & settimeout ...\n\njavascript 中的 eval(..) 函数可以接受一个字符串为参数，并将其中的内容视为好像在书写时（词法期）就存在于程序中这个位置的代码。换句话说，可以在你写的代码中用程序生成代码并运行，就好像代码是写在那个位置的一样。\n\n在执行 eval(..) 之后的代码时，引擎并不“知道”或“在意”前面的代码是以动态形式插入进来，并对词法作用域的环境进行修改的。引擎只会如往常地进行词法作用域查找。\n\nfunction foo(str, a) { \n  eval( str ); // 欺骗! \n  console.log( a, b );\n}\nvar b = 2;\nfoo( "var b = 3;", 1 ); // 1, 3\n\n\n1\n2\n3\n4\n5\n6\n\n\n根据原理可知，这段代码实际上在 foo(..) 内部创建了一个变量 b，并遮蔽了外部(全局)作用域中的同名变量。\n\n在这个例子中，为了展示的方便和简洁，我们传递进去的“代码”字符串是固定不变的。而在实际情况中，可以非常容易地根据程序逻辑动态地将字符拼接在一起之后再传递进去。eval(..)通常被用来执行动态创建的代码，因为像例子中这样动态地执行一段固定字符所组成的代码，并没有比直接将代码写在那里更有好处。\n\n默认情况下，如果 eval(..) 中所执行的代码包含有一个或多个声明(无论是变量还是函数)，就会对 eval(..) 所处的词法作用域进行修改。技术上，通过一些技巧(已经超出我们的讨论范围)可以间接调用 eval(..) 来使其运行在全局作用域中，并对全局作用域进行修改。但无论何种情况，eval(..) 都可以在运行期修改书写期的词法作用域。\n\n但是在严格模式的程序中，eval(..) 在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。\n\nfunction foo(str) { \n  "use strict";\n\teval( str );\n\tconsole.log( a ); // referenceerror: a is not defined \n}\nfoo( "var a = 2" );\n\n\n1\n2\n3\n4\n5\n6\n\n\njavascript 中还有其他一些功能效果和eval(..)很相似。settimeout(..)和 setinterval(..) 的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。这些功能已经过时且并不被提倡。不要使用它们!\n\nnew function(..) 函数的行为也很类似，最后一个参数可以接受代码字符串，并将其转化为动态生成的函数(前面的参数是这个新生成的函数的形参)。这种构建函数的语法比 eval(..) 略微安全一些，但也要尽量避免使用。\n\n在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上的损失。\n\n# with\n\njavascript 中另一个难以掌握(并且现在也不推荐使用)的用来欺骗词法作用域的功能是 with 关键字。\n\nwith 通常被当作重复引用同一个对象中的多个属性的快捷方式，可以不需要重复引用对象本身。\n\nvar obj = { \n  a: 1,\n  b: 2,\n  c: 3 \n};\n// 单调乏味的重复 "obj" \nobj.a = 2;\nobj.b = 3;\nobj.c = 4;\n// 简单的快捷方式 \nwith (obj) {\n  a = 3;\n  b = 4;\n  c = 5;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n但实际上这不仅仅是为了方便地访问对象属性。考虑如下代码:\n\nfunction foo(obj) {\n  with (obj) {\n    a = 2;// 此处是为了给obj对象的a属性赋值，执行lhs\n    var c = 666;// 此处变量不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中\n  }\n  console.log(c)\n}\nvar o1 = {\n  a: 3\n};\nvar o2 = {\n  b: 3\n};\n\nfoo(o1);// 666\nconsole.log(o1.a); // 2\n\nfoo(o2);// 666\nconsole.log(o2.a); // undefined\nconsole.log(a); // 2——不好，a 被泄漏到全局作用域上了!\nconsole.log(c);// referenceerror, c is not defined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n这个例子中创建了 o1 和 o2 两个对象。其中一个具有 a 属性，另外一个没有。foo(..) 函数接受一个obj参数，该参数是一个对象引用，并对这个对象引用执行了with(obj) {..}。 在 with 块内部，我们写的代码看起来只是对变量 a 进行简单的词法引用，实际上就是一个 lhs 引用，并将 2 赋值给它。\n\n当我们将 o1 传递进去，a=2 赋值操作找到了 o1.a 并将 2 赋值给它，这在后面的 console. log(o1.a) 中可以体现。而当 o2 传递进去，o2 并没有 a 属性，因此不会创建这个属性， o2.a 保持 undefined。\n\n但是可以注意到一个奇怪的副作用，实际上 a = 2 赋值操作创建了一个全局的变量 a。这 是怎么回事?\n\nwith 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域，因此这个对象的属性也会被处理为定义在这个作用域中的词法标识符。尽管 with 块可以将一个对象处理为词法作用域，但是这个块内部正常的 var 声明并不会被限制在这个块的作用域中，而是被添加到 with 所处的函数作用域中；不添加var时且 lhs 查不到会创建全局变量。\n\n可以这样理解，当我们传递 o1 给 with 时，with 所声明的作用域是 o1，而这个作用域中含 有一个同 o1.a 属性相符的标识符。但当我们将 o2 作为作用域时，其中并没有 a 标识符， 因此进行了正常的 lhs 标识符查找。\n\no2 的作用域、foo(..) 的作用域和全局作用域中都没有找到标识符 a，因此当 a=2 执行时，自动创建了一个全局变量(因为是非严格模式)。with 这种将对象及其属性放进一个作用域并同时分配标识符的行为很让人费解。\n\neval(..) 函数如果接受了含有一个或多个声明的代码，就会修改其所处的词法作用域，而 with 声明实际上是根据你传递给它的对象凭空创建了一个全新的词法作用域。\n\n另外一个不推荐使用 eval(..) 和 with 的原因是会被严格模式所影响(限制)。with 被完全禁止，而在保留核心功能的前提下，间接或非安全地使用 eval(..) 也被禁止了。\n\n# 性能\n\n如果它们能实现更复杂的功能，并且代码更具有扩展性会更好。其实不然。\n\njavascript 引擎会在编译阶段进行数项的性能优化。其中有些优化依赖于能够根据代码的词法进行静态分析，并预先确定所有变量和函数的定义位置，才能在执行过程中快速找到标识符。但如果引擎在代码中发现了 eval(..) 或 with，它只能简单地假设关于标识符位置的判断都是无效的，因为无法在词法分析阶段明确知道 eval(..) 会接收到什么代码，这些代码会如何对作用域进行修改，也无法知道传递给 with 用来创建新词法作用域的对象的内容到底是什么。最悲观的情况是如果出现了 eval(..) 或 with，所有的优化可能都是无意义的，因此最简单的做法就是完全不做任何优化。如果代码中大量使用 eval(..) 或 with，那么运行起来一定会变得非常慢。无论引擎多聪明，试图将这些悲观情况的副作用限制在最小范围内，也无法避免如果没有这些优化，代码会运行得更慢这个事实。\n\n\n# 函数作用域 🔥\n\n\n# 函数作用域\n\n考虑下面的代码:\n\nfunction foo(a) { \n  var b = 2;\n\t// 一些代码\n\tfunction bar() { \n    // ...\n\t}\n  // 更多的代码 \n  var c = 3;\n}\nbar(); // 失败 referenceerror\nconsole.log( a, b, c ); // 三个全都失败 referenceerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n由于标识符 a、b、c 和 bar 都附属于 foo(..) 的作用域，因此无法从 foo(..) 的外部直接对它们进行访问。但在 foo(..) 的内部都是可以被访问的，同样在 bar(..) 内部也可以被访问（假设 bar(..) 内部没有同名的标识符声明）\n\n * 体现了封装，隐藏内部实现的设计原则\n * 可以规避同名标识符冲突（多个第三方库）。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象 被用作库的命名空间，所有需要暴露给外界的功能都会成为这个对象(命名空间)的属性，而不是将自己的标识符暴漏在顶级的词法作用域中。也可以使用模块管理避免同名标识符冲突\n\nfunction foo() { \n  function bar(a) {\n    i = 3; // 修改for循环所属作用域中的i，因为for没有作用域，i被声明在foo中了\n    console.log( a + i );\n  }\n  \n  for (var i=0; i<10; i++) {\n    bar( i * 2 ); // 糟糕，无限循环了!\n  } \n}\nfoo();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 立即执行函数表达式\n\n虽然这种技术可以解决一些问题，但是它并不理想，因为会导致一些额外的问题。\n\n * 必须声明一个具名函数 foo()，意味着 foo 这个名称本身“污染”了所在作用域(在这个例子中是全局作用域)。\n * 必须显式地通过函数名(foo())调用这个函数才能运行其 中的代码。\n\n# 用处1\n\n如果函数不需要函数名（或者至少函数名可以不污染所在作用域），并且能够自动运行， 这将会更加理想。如下：\n\nvar a = 2;\n\n(function foo(a) { // <-- 添加这一行，也可以省略foo用做匿名函数\n  var a = 3;\n  console.log(a); // 3 \n})(a); // <-- 以及这一行，可以转递参数\n\n// 也可以这样写\n//(function foo(b) { // <-- 添加这一行，也可以省略foo用做匿名函数\n//  var a = 3;\n//  console.log(a); // 3 \n//}(b)); // <-- 以及这一行，可以转递参数\n\nconsole.log(a); // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n由于函数被包含在一对 ( ) 括号内部，函数会被当作函数表达式而不是一个标准的函数声明来处理，通过在末尾加上另外一个 ( ) 可以立即执行这个函数。即 iife(immediately invoked function expression) 立即执行函数表达式\n\nfoo 被绑定在函数表达式自身的函数中而不是所在作用域中。意味着foo只能在..所代表的位置中被访问，外部作用域则不行。foo 变量名被隐藏在自身中意味着不会非必要地污染外部作用域。也可以省略 foo 写作匿名函数表达式。\n\n注意\n\n区分函数声明和表达式最简单的方法是看 function 关键字出现在声明中的位置(不仅仅是一行代码，而是整个声明中的位置)。如果 function 是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n\n# 用处2\n\n这个模式的另外一个应用场景是解决 undefined 标识符的默认值被错误覆盖导致的异常(虽然不常见)。\n\nundefined = true; // 给其他代码挖了一个大坑!绝对不要这样做! \n(function iife(undefined) {\n  var a;\n  if (a === undefined) {\n    console.log("undefined is safe here!");\n  }\n})();// undefined is safe here!\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 用处3\n\niife 还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在 iife 执行之后当作参数传递进去。这种模式在 umd(universal module definition)项目中被广泛使用。尽管这种模式略显冗长，但有些人认为它更易理解。\n\nvar a = 2;\n(function iife( def ) { \n  def( window );\n})(function def( global ) {\n  var a = 3;\n  console.log( a ); // 3 \n  console.log( global.a ); // 2\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n函数表达式 def 定义在片段的第二部分，然后当作参数(这个参数也叫作 def)被传递进 iife 函数定义的第一部分中。最后，参数 def(也就是传递进去的函数)被调用，并将 window 传入当作 global 参数的值。\n\n\n# 块作用域 🔥\n\n除 javascript 外的很多编程语言都支持块作用域\n\n\n# var—没有块作用域\n\n当无论在哪里使用 var 声明变量时，它们最终都会属于外部作用域（函数或全局。for 没有作用域，此处绑定到全局作用域）。\n\nfor (var i=0; i<10; i++) { \n  console.log( i );\n}\n\n\n1\n2\n3\n\n\n我们在 for 循环的头部直接定义了变量 i，通常是因为只想在 for 循环内部的上下文中使用 i，而忽略了 i 会被绑定在外部作用域(函数或全局)中的事实。\n\n如下例子\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    <button>按钮1</button>\n    <button>按钮2</button>\n    <button>按钮3</button>\n    <button>按钮4</button>\n    <button>按钮5</button>\n    <script>\n      var btns = document.getelementsbytagname("button");\n\n      //   var\n      //   for (var i = 0; i < btns.length; i++) {\n      //     btns[i].addeventlistener("click", function () {\n      //       console.log(`按了第${i}个按钮`); // 按了第5个按钮。无论怎么都是输出这个\n      //     });\n      //   }\n\n      //   立即执行函数\n      //   for (var i = 0; i < btns.length; i++) {\n      //     (function (i) {\n      //       btns[i].addeventlistener("click", function () {\n      //         console.log(`按了第${i}个按钮`); // 正常\n      //       });\n      //     })(i);\n      //   }\n\n      // let\n      for (let i = 0; i < btns.length; i++) {\n        btns[i].addeventlistener("click", function () {\n          console.log(`按了第${i}个按钮`); // 正常\n        });\n      }\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n因为函数中的打印语句引用的 i 是一个外部变量，不是传入的参数，不受函数作用域控制，绑定事件的循环中 i 一直在改变，最终输出时，获取到的变量都是 5！全局变量污染！\n\n当使用立即执行函数后，由于i被当作参数传入立即执行函数，此时再去修改i都不会影响函数中的值。\n\n当使用let后，{}中的i也是属于该作用域的，不受外部i的改变而变化\n\n\n# with\n\nwith 关键字。它不仅是一个难于理解的结构，同时也是块作用域的一个例子(块作用域的一种形式)，用 with 从对象中创建出的作用域仅在 with 声明中而非外部作用域中有效。\n\n\n# try/catch\n\njavascript 的 es3 规范中规定 try/catch 的 catch 分句会创建一个块作用域，其中声明的变量仅在 catch 内部有效。\n\ntry {\n  undefined(); // 执行一个非法操作来强制制造一个异常\n}\ncatch (err) {\n  console.log( err ); // 能够正常执行! \n}\nconsole.log( err ); // referenceerror: err not found\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n注意\n\n尽管这个行为已经被标准化，并且被大部分的标准 javascript 环境(除了老版本的 ie 浏览器)所支持，但是当同一个作用域中的两个或多个 catch 分句 用同样的标识符名称声明错误变量时，很多静态检查工具还是会发出警告。 实际上这并不是重复定义，因为所有变量都被安全地限制在块作用域内部， 但是静态检查工具还是会很烦人地发出警告。\n\n为了避免这个不必要的警告，很多开发者会将 catch 的参数命名为 err1、 err2 等。也有开发者干脆关闭了静态检查工具对重复变量名的检查。\n\n这是向 es6 中的所有（大部分）功能迁移的首选方式：在从 es6 之前的环境向 es6 过渡时，使用代码转换工具来对 es6 代码进行处理，生成兼容 es5 的代码。\n\n{\n  let a = 2;\n  console.log( a ); // 2 \n}\nconsole.log( a ); // referenceerror\n\n\n1\n2\n3\n4\n5\n\n\n这段代码在 es6 环境中可以正常工作。但是在 es6 之前的环境中如何才能实现这个效果?可以使用 catch。\n\ntry{\n  throw 2;\n}catch(a){ \n  console.log( a ); // 2\n}\nconsole.log( a ); // referenceerror\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# let\n\nes6引入了新的 let 关键字，提供了除 var 以外的另一种变量声明方式。let 关键字可以将变量绑定到所在的任意作用域中（通常是 {} 内部）。换句话说，let 为其声明的变量隐式地指定了所在的块作用域。\n\nvar foo = true;\nif (foo) {\n  let bar = foo * 2;\n  bar = something( bar ); \n  console.log( bar );\n}\nconsole.log( bar ); // referenceerror\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# let循环\n\nfor (let i=0; i<10; i++) { \n  console.log( i );\n}\nconsole.log( i ); // referenceerror\n\n\n1\n2\n3\n4\n\n\nfor 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值。\n\n下面通过另一种方式来说明每次迭代时进行重新绑定的行为（用于闭包，不懂）:\n\n{\n  let j;\n  for (j=0; j<10; j++) {\n    let i = j; // 每个迭代重新绑定!\n    console.log( i ); }\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n# 垃圾收集\n\n另一个块作用域非常有用的原因和闭包及回收内存垃圾的回收机制相关。\n\nfunction process(data) {\n  // 在这里做点有趣的事情\n}\nvar somereallybigdata = { .. };\nprocess( somereallybigdata );\nvar btn = document.getelementbyid( "my_button" );\nbtn.addeventlistener( "click", function click(evt) { \n  console.log("button clicked");\n}, /*capturingphase=*/false );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nclick 函数的点击回调并不需要 somereallybigdata 变量。理论上这意味着当 process(..) 执 行后，在内存中占用大量空间的数据结构就可以被垃圾回收了。但是，由于 click 函数形成 了一个覆盖整个作用域的闭包，javascript 引擎极有可能依然保存着这个结构(取决于具体实现)。块作用域可以打消这种顾虑，可以让引擎清楚地知道没有必要继续保存 somereallybigdata 了:\n\nfunction process(data) {\n  // 在这里做点有趣的事情\n}\n// 在这个块中定义的内容可以销毁了! {\nlet somereallybigdata = { .. }; \nprocess( somereallybigdata );\n}\nvar btn = document.getelementbyid( "my_button" );\nbtn.addeventlistener( "click", function click(evt){ \n  console.log("button clicked");\n}, /*capturingphase=*/false );\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# const\n\nes6 还引入了 const，同样可以用来创建块作用域变量\n\nvar foo = true;\nif (foo) {\n  var a = 2;\n  const b = 3; // 包含在 if 中的块作用域常量\n  a = 3; // 正常!\n  b = 4; // 错误! \n}\nconsole.log( a ); // 3\nconsole.log( b ); // referenceerror!\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n其值是固定的 (常量)。之后任何试图修改值的操作都会引起错误\n\n创建后必须进行初始化，否则报错\n\nconst a = 1;\nconst b;\nb = 1;// uncaught syntaxerror: missing initializer in const declaration\nconst c;// uncaught syntaxerror: missing initializer in const declaration\n\n\n1\n2\n3\n4\n\n\n常量的含义是指向的对象不能修改，但是可以改变对象内部的属性。数组也一样\n\nconst obj = {\n    name: "conanan",\n    age: 18,\n    sex: "male",\n};\nconsole.log(obj);\nobj.age = 25;\nconsole.log(obj);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 声明的提升 🔥\n\n函数声明和变量声明都会被提升到各自作用域顶端，且函数会首先被提升，然后才是变量。但是函数表达式却不会被提升\n\n看如下代码：\n\na = 2;\nvar a; \nconsole.log( a );// 2\n\n\n1\n2\n3\n\n\nconsole.log( a );// undefined\nvar a = 2;\n\n\n1\n2\n\n\n词法作用域的核心内容：引擎会在解释 javascript 代码之前首先对其进行编译。编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。所以变量和函数在内的所有声明都会在任何代码被执行前首先被处理。\n\n所以上述代码编译会进行如下处理：\n\nvar a; \na = 2;\nconsole.log( a );// 2\n\n\n1\n2\n3\n\n\nvar a; \nconsole.log( a ); \na = 2;// undefined\n\n\n1\n2\n3\n\n\n只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。\n\nfoo();\nfunction foo() {\n  console.log( a ); // undefined var a = 2;\n}\n\n\n1\n2\n3\n4\n\n\nfunction foo() { \n  var a;\n  console.log( a ); // undefined\n  a = 2; \n}\nfoo();\n\n\n1\n2\n3\n4\n5\n6\n\n\n函数声明会被提升，但是函数表达式却不会被提升，如下：\n\nfoo(); // 不是 referenceerror, 而是 typeerror!\nvar foo = function bar() { \n  // ...\n};\n\n\n1\n2\n3\n4\n\n\nvar foo;\nfoo(); // 不是 referenceerror, 而是 typeerror!\nfoo = function bar() { \n  // ...\n};\n\n\n1\n2\n3\n4\n5\n\n\n变量标识符 foo 被提升并分配给所在作用域(在这里是全局作用域)，因此 foo() 不会导致 referenceerror。但是 foo 此时并没有赋值(如果它是一个函数声明而不 是函数表达式，那么就会赋值)。foo() 由于对 undefined 值进行函数调用而导致非法操作， 因此抛出 typeerror 异常。\n\n即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中使用:\n\nfoo(); // typeerror\nbar(); // referenceerror\nvar foo = function bar() { \n  // ...\n};\n\n\n1\n2\n3\n4\n5\n\n\nvar foo;\nfoo(); // typeerror\nbar(); // referenceerror\nfoo = function() {\n  var bar = ...self... \n  // ...\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n函数会首先被提升，然后才是变量，特别注意有多个“重复”声明的代码中：\n\nfoo(); // 1\nvar foo;\nfunction foo() { \n  console.log( 1 );\n}\nfoo = function() { \n  console.log( 2 );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nfunction foo() { \n  console.log( 1 );\n}\nfoo(); // 1\nfoo = function() { \n  console.log( 2 );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\nvar foo 尽管出现在 function foo()... 的声明之前，但它是重复的声明(因此被忽略了)，因为函数声明会被提升到普通变量之前。尽管重复的 var 声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的，如下：\n\nfoo(); // 3\nfunction foo() { \n  console.log( 1 );\n}\nvar foo = function() { \n  console.log( 2 );\n};\nfunction foo() { \n  console.log( 3 );\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\nfunction foo() { \n  console.log( 1 );\n}\nfunction foo() { \n  console.log( 3 );\n}\nfoo(); // 3\nfoo = function() { \n  console.log( 2 );\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n由上述说明了在同一个作用域中进行重复定义是非常糟糕的，而且经常会导致各种奇怪的问题。\n\n再看个例子\n\nconsole.log(typeof fun === \'function\') // true\nvar fun = 3\nconsole.log(typeof fun === \'number\') // true\nfunction fun() {}\nconsole.log(typeof fun === \'number\') // true`\n\n\n1\n2\n3\n4\n5\n\n\nfunction fun() {}\nvar fun\nconsole.log(typeof fun === \'function\') // true\nfun = 3\nconsole.log(typeof fun === \'number\') // true\nconsole.log(typeof fun === \'number\') // true\n\n\n1\n2\n3\n4\n5\n6\n\n\n一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制。但是需要注意这个行为并不可靠，在 javascript 未来的版本中有可能发生改变，因此应该 尽可能避免在块内部声明函数。如下代码已经执行不了了，typeerror: foo is not a function\n\nfoo(); // "b"\nvar a = true; \nif (a) {\n  function foo() { \n    console.log("a"); \n  } \n}else {\n  function foo() { \n    console.log("b"); \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n#',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"1 理解-4 闭包",frontmatter:{title:"1 理解-4 闭包",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/f616f1/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/200.%E7%90%86%E8%A7%A3/205.%E9%97%AD%E5%8C%85.html",relativePath:"1200.JS/200.理解/205.闭包.md",key:"v-07a1b0b5",path:"/pages/f616f1/",headers:[{level:2,title:"实质问题",slug:"实质问题",normalizedTitle:"实质问题",charIndex:420},{level:2,title:"理解闭包 🔥",slug:"理解闭包-🔥",normalizedTitle:"理解闭包 🔥",charIndex:2285},{level:2,title:"使用闭包 🔥",slug:"使用闭包-🔥",normalizedTitle:"使用闭包 🔥",charIndex:2988},{level:3,title:"封装私有变量",slug:"封装私有变量",normalizedTitle:"封装私有变量",charIndex:3e3},{level:3,title:"回调函数",slug:"回调函数",normalizedTitle:"回调函数",charIndex:372}],headersStr:"实质问题 理解闭包 🔥 使用闭包 🔥 封装私有变量 回调函数",content:"# 闭包 🔥\n\n了解词法作用域对于理解闭包的概念几乎是不言自明的！\n\n闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。\n\n当**函数可以记住并访问所在的词法作用域（包括其中的变量、函数等）**时，就产生了闭包，即使函数是在当前词法作用域之外执行。\n\nvar outerValue = 'ninja'\nfunction outerFunction() {\n  console.log(outerValue)\n}\nouterFunction()\n\n\n1\n2\n3\n4\n5\n\n\n使用闭包，不仅可以通过减少代码数量和复杂度来添加高级特性，还能实现不太可能完成的功能:\n\n * 如果没有闭包，事件处理和动画等包含回调函数的任务，它们的实现将变得复杂得多\n * 如果没有闭包，将完全不可能实现私有变量\n\n\n# 实质问题\n\nfunction foo() {\n  var a = 2\n  function bar() {\n    console.log(a) // 2\n  }\n  bar()\n}\nfoo()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n基于词法作用域的查找规则，函数 bar() 可以访问外部作用域中的变量 a（这个例子中的是一个 RHS 引用查询）。这是闭包吗 ? 技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。(但却是非常重要的一部分!)\n\n从纯学术的角度说，在上面的代码片段中，函数 bar() 具有一个涵盖 foo() 作用域的闭包 (事实上，涵盖了它能访问的所有作用域，比如全局作用域)。也可以认为 bar() 被封闭在了 foo() 的作用域中。为什么呢?原因简单明了，因为 bar() 嵌套在 foo() 内部。\n\n但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是如何工作的。我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影里，并不那么容易理解。\n\n下面的代码清晰地展示了闭包:\n\nfunction foo() {\n  var a = 2\n  function bar() {\n    console.log(a)\n  }\n  return bar\n}\nvar baz = foo()\nbaz() // 2 —— 朋友，这就是闭包的效果。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后，其返回值(也就是内部的 bar() 函数)赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。\n\n在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域? 原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。\n\nbar() 依然持有对该作用域的引用，而这个引用就叫作闭包。\n\n因此，在几微秒之后变量 baz 被实际调用(调用内部函数 bar)，不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。\n\n当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。\n\nfunction foo() {\n  var a = 2\n  function baz() {\n    console.log(a) // 2\n  }\n  bar(baz)\n}\nfunction bar(fn) {\n  fn() // 妈妈快看呀，这就是闭包!\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n把内部函数 baz 传递给 bar，当调用这个内部函数时(现在叫作 fn)，它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a。\n\n传递函数当然也可以是间接的。\n\nvar fn\nfunction foo() {\n  var a = 2\n  function baz() {\n    console.log(a)\n  }\n  fn = baz // 将 baz 分配给全局变量\n}\nfunction bar() {\n  fn() // 妈妈快看呀，这就是闭包!\n}\nfoo()\nbar() // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n\n\n# 理解闭包 🔥\n\n上面的看不懂？继续\n\n闭包允许函数访问并操作函数外部的变量或函数。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。记住，所声明的函数可以在声明之后的任何时间被调用，甚至当该函数声明的作用域消失之后仍然可以调用\n\nvar outerValue = 'samurai'\nvar later\n\nfunction outerFunction() {\n  var innerValue = 'ninja'\n\n  function innerFunction() {\n    console.log(outerValue === 'samurai') // true\n    console.log(innerValue === 'ninja') // true\n  }\n  later = innerFunction\n}\n\nouterFunction()\nlater()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nouterFunction 都执行完毕了，按理说其中的 innerValue 已经不存在，但是为什么 later 执行后还能打印？\n\n当在外部函数中声明内部函数时，不仅定义了函数的声明，而且还创建了一个闭包。该闭包不仅包含了函数的声明，还包含了在函数声明时该作用域中的所有变量。当最终执行内部函数时，尽管声明时的作用域已经消失了，但是通过闭包，仍然能够访问到原始作用域（包括变量和函数）\n\n谨记每一个通过闭包访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息，存储和引用这些信息会直接影响性能。\n\n\n# 使用闭包 🔥\n\n\n# 封装私有变量\n\n原生 JavaScript 不支持私有变量。但是，通过使用闭包，我们可以实现很接近的的私有变量（可以 getter 访问）\n\nfunction Ninja() {\n  var feints = 0\n  this.getFeints = function() {\n    return feints\n  }\n  this.feint = function() {\n    feints++\n  }\n}\n\nvar ninja1 = new Ninja()\nninja1.feint()\nconsole.log(ninja1.feints) // undefined，feints无法直接访问\nconsole.log(ninja1.getFeints() === 1) // true\n\nvar ninja2 = new Ninja()\nconsole.log(ninja2.getFeints() === 0) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n通过使用闭包，可以通过方法对 ninja 的状态进行维护，而不允许用户直接访问——这是因为闭包内部的变量可以通过闭包内的方法访问，构造器外部的代码则不能访问闭包内部的变量。\n\n\n# 回调函数\n\n<body>\n  <div id=\"box1\" style=\"margin: 0;\">First Box</div>\n  <div id=\"box2\" style=\"margin: 10;\">Second Box</div>\n  <div id=\"box3\" style=\"margin: 20;\">Third Box</div>\n\n  <script>\n    function animateIt(elementId) {\n      var elem = document.getElementById(elementId)\n      var tick = 0\n      var timer = setInterval(() => {\n        if (tick < 100) {\n          elem.style.marginLeft = elem.style.marginTop = tick + 'px'\n          tick++\n        } else {\n          clearInterval(timer)\n          console.log(tick === 100)\n          console.log(elem)\n          console.log(timer)\n        }\n      }, 10)\n    }\n\n    animateIt('box1')\n    animateIt('box2')\n    animateIt('box3')\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n若将 animateIt 函数中三个变量移到全局作用域，也可以工作，但是会污染全局作用域，使用闭包，可以很好处理这事。特别是多个动画时，每次调用 animateIt 函数都会创建一个新的词法作用域，其中的变量等都是独立的。",normalizedContent:"# 闭包 🔥\n\n了解词法作用域对于理解闭包的概念几乎是不言自明的！\n\n闭包是基于词法作用域书写代码时所产生的自然结果，你甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。\n\n当**函数可以记住并访问所在的词法作用域（包括其中的变量、函数等）**时，就产生了闭包，即使函数是在当前词法作用域之外执行。\n\nvar outervalue = 'ninja'\nfunction outerfunction() {\n  console.log(outervalue)\n}\nouterfunction()\n\n\n1\n2\n3\n4\n5\n\n\n使用闭包，不仅可以通过减少代码数量和复杂度来添加高级特性，还能实现不太可能完成的功能:\n\n * 如果没有闭包，事件处理和动画等包含回调函数的任务，它们的实现将变得复杂得多\n * 如果没有闭包，将完全不可能实现私有变量\n\n\n# 实质问题\n\nfunction foo() {\n  var a = 2\n  function bar() {\n    console.log(a) // 2\n  }\n  bar()\n}\nfoo()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n基于词法作用域的查找规则，函数 bar() 可以访问外部作用域中的变量 a（这个例子中的是一个 rhs 引用查询）。这是闭包吗 ? 技术上来讲，也许是。但根据前面的定义，确切地说并不是。我认为最准确地用来解释 bar() 对 a 的引用的方法是词法作用域的查找规则，而这些规则只是闭包的一部分。(但却是非常重要的一部分!)\n\n从纯学术的角度说，在上面的代码片段中，函数 bar() 具有一个涵盖 foo() 作用域的闭包 (事实上，涵盖了它能访问的所有作用域，比如全局作用域)。也可以认为 bar() 被封闭在了 foo() 的作用域中。为什么呢?原因简单明了，因为 bar() 嵌套在 foo() 内部。\n\n但是通过这种方式定义的闭包并不能直接进行观察，也无法明白在这个代码片段中闭包是如何工作的。我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影里，并不那么容易理解。\n\n下面的代码清晰地展示了闭包:\n\nfunction foo() {\n  var a = 2\n  function bar() {\n    console.log(a)\n  }\n  return bar\n}\nvar baz = foo()\nbaz() // 2 —— 朋友，这就是闭包的效果。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n函数 bar() 的词法作用域能够访问 foo() 的内部作用域。然后我们将 bar() 函数本身当作一个值类型进行传递。在这个例子中，我们将 bar 所引用的函数对象本身当作返回值。在 foo() 执行后，其返回值(也就是内部的 bar() 函数)赋值给变量 baz 并调用 baz()，实际上只是通过不同的标识符引用调用了内部的函数 bar()。bar() 显然可以被正常执行。但是在这个例子中，它在自己定义的词法作用域以外的地方执行。\n\n在 foo() 执行后，通常会期待 foo() 的整个内部作用域都被销毁，因为我们知道引擎有垃圾回收器用来释放不再使用的内存空间。由于看上去 foo() 的内容不会再被使用，所以很自然地会考虑对其进行回收。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此没有被回收。谁在使用这个内部作用域? 原来是 bar() 本身在使用。拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。\n\nbar() 依然持有对该作用域的引用，而这个引用就叫作闭包。\n\n因此，在几微秒之后变量 baz 被实际调用(调用内部函数 bar)，不出意料它可以访问定义时的词法作用域，因此它也可以如预期般访问变量 a。这个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。\n\n当然，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。\n\nfunction foo() {\n  var a = 2\n  function baz() {\n    console.log(a) // 2\n  }\n  bar(baz)\n}\nfunction bar(fn) {\n  fn() // 妈妈快看呀，这就是闭包!\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n把内部函数 baz 传递给 bar，当调用这个内部函数时(现在叫作 fn)，它涵盖的 foo() 内部作用域的闭包就可以观察到了，因为它能够访问 a。\n\n传递函数当然也可以是间接的。\n\nvar fn\nfunction foo() {\n  var a = 2\n  function baz() {\n    console.log(a)\n  }\n  fn = baz // 将 baz 分配给全局变量\n}\nfunction bar() {\n  fn() // 妈妈快看呀，这就是闭包!\n}\nfoo()\nbar() // 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包。\n\n\n# 理解闭包 🔥\n\n上面的看不懂？继续\n\n闭包允许函数访问并操作函数外部的变量或函数。只要变量或函数存在于声明函数时的作用域内，闭包即可使函数能够访问这些变量或函数。记住，所声明的函数可以在声明之后的任何时间被调用，甚至当该函数声明的作用域消失之后仍然可以调用\n\nvar outervalue = 'samurai'\nvar later\n\nfunction outerfunction() {\n  var innervalue = 'ninja'\n\n  function innerfunction() {\n    console.log(outervalue === 'samurai') // true\n    console.log(innervalue === 'ninja') // true\n  }\n  later = innerfunction\n}\n\nouterfunction()\nlater()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nouterfunction 都执行完毕了，按理说其中的 innervalue 已经不存在，但是为什么 later 执行后还能打印？\n\n当在外部函数中声明内部函数时，不仅定义了函数的声明，而且还创建了一个闭包。该闭包不仅包含了函数的声明，还包含了在函数声明时该作用域中的所有变量。当最终执行内部函数时，尽管声明时的作用域已经消失了，但是通过闭包，仍然能够访问到原始作用域（包括变量和函数）\n\n谨记每一个通过闭包访问变量的函数都具有一个作用域链，作用域链包含闭包的全部信息，存储和引用这些信息会直接影响性能。\n\n\n# 使用闭包 🔥\n\n\n# 封装私有变量\n\n原生 javascript 不支持私有变量。但是，通过使用闭包，我们可以实现很接近的的私有变量（可以 getter 访问）\n\nfunction ninja() {\n  var feints = 0\n  this.getfeints = function() {\n    return feints\n  }\n  this.feint = function() {\n    feints++\n  }\n}\n\nvar ninja1 = new ninja()\nninja1.feint()\nconsole.log(ninja1.feints) // undefined，feints无法直接访问\nconsole.log(ninja1.getfeints() === 1) // true\n\nvar ninja2 = new ninja()\nconsole.log(ninja2.getfeints() === 0) // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n通过使用闭包，可以通过方法对 ninja 的状态进行维护，而不允许用户直接访问——这是因为闭包内部的变量可以通过闭包内的方法访问，构造器外部的代码则不能访问闭包内部的变量。\n\n\n# 回调函数\n\n<body>\n  <div id=\"box1\" style=\"margin: 0;\">first box</div>\n  <div id=\"box2\" style=\"margin: 10;\">second box</div>\n  <div id=\"box3\" style=\"margin: 20;\">third box</div>\n\n  <script>\n    function animateit(elementid) {\n      var elem = document.getelementbyid(elementid)\n      var tick = 0\n      var timer = setinterval(() => {\n        if (tick < 100) {\n          elem.style.marginleft = elem.style.margintop = tick + 'px'\n          tick++\n        } else {\n          clearinterval(timer)\n          console.log(tick === 100)\n          console.log(elem)\n          console.log(timer)\n        }\n      }, 10)\n    }\n\n    animateit('box1')\n    animateit('box2')\n    animateit('box3')\n  <\/script>\n</body>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n若将 animateit 函数中三个变量移到全局作用域，也可以工作，但是会污染全局作用域，使用闭包，可以很好处理这事。特别是多个动画时，每次调用 animateit 函数都会创建一个新的词法作用域，其中的变量等都是独立的。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"2 语法-1 基础语法",frontmatter:{title:"2 语法-1 基础语法",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/f59f90/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/301.%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html",relativePath:"1200.JS/300.语法/301.基础语法.md",key:"v-7152c6bb",path:"/pages/f59f90/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:11},{level:2,title:"与 HTML 组合",slug:"与-html-组合",normalizedTitle:"与 html 组合",charIndex:628},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:1167},{level:3,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:949},{level:3,title:"判断值的类型",slug:"判断值的类型",normalizedTitle:"判断值的类型",charIndex:1951},{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:1199},{level:2,title:"常量",slug:"常量",normalizedTitle:"常量",charIndex:2927},{level:2,title:"运算符",slug:"运算符",normalizedTitle:"运算符",charIndex:2002},{level:3,title:"赋值运算符",slug:"赋值运算符",normalizedTitle:"赋值运算符",charIndex:2979},{level:3,title:"一元运算符",slug:"一元运算符",normalizedTitle:"一元运算符",charIndex:2998},{level:3,title:"三元运算符",slug:"三元运算符",normalizedTitle:"三元运算符",charIndex:3188},{level:3,title:"算术运算符",slug:"算术运算符",normalizedTitle:"算术运算符",charIndex:3211},{level:3,title:"比较运算符",slug:"比较运算符",normalizedTitle:"比较运算符",charIndex:3258},{level:3,title:"逻辑运算符",slug:"逻辑运算符",normalizedTitle:"逻辑运算符",charIndex:3533},{level:3,title:"位运算符",slug:"位运算符",normalizedTitle:"位运算符",charIndex:3967},{level:3,title:"位移运算符",slug:"位移运算符",normalizedTitle:"位移运算符",charIndex:4107},{level:2,title:"流程控制",slug:"流程控制",normalizedTitle:"流程控制",charIndex:4336},{level:2,title:"Other（未整理好）",slug:"other-未整理好",normalizedTitle:"other（未整理好）",charIndex:4886},{level:3,title:"基本类型的包装对象",slug:"基本类型的包装对象",normalizedTitle:"基本类型的包装对象",charIndex:4902},{level:3,title:"Global",slug:"global",normalizedTitle:"global",charIndex:5463},{level:3,title:"Base64",slug:"base64",normalizedTitle:"base64",charIndex:6179}],headersStr:"简介 与 HTML 组合 数据类型 定义 判断值的类型 变量 常量 运算符 赋值运算符 一元运算符 三元运算符 算术运算符 比较运算符 逻辑运算符 位运算符 位移运算符 流程控制 Other（未整理好） 基本类型的包装对象 Global Base64",content:'# 基础语法\n\n\n# 简介\n\nJavaScript 是一种轻量级的脚本语言。脚本语言指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。\n\nJavaScript 也是一种嵌入式（embedded）语言。它提供的核心语法不算很多，只能用来做一些数学和逻辑运算。JavaScript 本身不提供任何与 I/O（输入/输出）相关的 API，都要靠宿主环境（host）提供，所以它只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 API。目前，已经嵌入 JavaScript 的宿主环境有：浏览器，Node 服务器环境。\n\n从语法角度看，JavaScript 语言是一种“对象模型”语言，还支持函数式编程。\n\nJavaScript 的核心语法部分相当精简，只包括两个部分：\n\n * 基本的语法构造（比如操作符、控制结构、语句）\n * 标准库（就是一系列具有各种功能的对象比如Array、Date、Math等）\n\n各种宿主环境提供额外的 API（即只能在该环境使用的接口），以便 JavaScript 调用。\n\n浏览器提供的额外 API 可以分成三大类：\n\n * 浏览器控制类：操作浏览器\n * DOM 类：操作网页的各种元素\n * Web 类：实现互联网的各种功能\n\nNode 环境会提供操作系统的 API，比如文件操作 API、网络通信 API等等\n\n组成：ECMAScript + BOM + DOM\n\n\n# 与 HTML 组合\n\n * 内部引入\n   \n   <script>  \n   js代码; \n   <\/script>\n   \n   \n   1\n   2\n   3\n   \n   \n   在HTML标签中写入<img src="img/1.jpg" id="img1" onclick="javascript:fun2();">\n\n * 外部引入\n   \n   <script src="js/a.js"><\/script>    \x3c!--  type="text/javascript"可省略  --\x3e\n   <script src="js/b.js"><\/script>\n   \n   \n   1\n   2\n   \n\n提示\n\nhead 中定义的 JavaScript 将会在页面加载前执行，会阻塞页面加载，除非该JS需在网页全部加载完成前就可以调用，否则推荐定义在 </body> 闭合标签之前\n\nChrome进入 Console 途径：\n\n * Mac：Command + option + j；Win：Ctrl + Shift + j\n * Mac：Command + option + i；Win：Ctrl + Shift + i再选择 Console 面板\n\n\n# 数据类型\n\n\n# 定义\n\n * undefined(未定义)：若变量未初始化则默认值为undefined或直接赋值undefined\n\n * number(数值)：不区分整数和小数、NaN（not a number）。\n   \n   所有数字都是以64位浮点数形式储存；位运算只有整数才能完成，此时 JavaScript 会自动转成32位整数，然后运算\n\n * string(字符串)：单引和双引都可以\n\n * boolean(布尔)：true和false\n\n * null(空)：即此处的值为空。一个对象为空的占位符或直接赋值null\n   \n   typeof null返回Object，JS最初的错误被ECMAScript沿用。现在 null 被认为是对象的占位符，从而解释了该矛盾\n\n * object(对象)：各种值组成的集合，可以分成三个子类型\n   \n   * object(狭义的对象)\n   * array(数组)\n   * function(函数)\n\n提示\n\nES5 只有 6 种，ES6 即 ECMAScript 2015 添加了一种Symbol\n\n通常number、string、boolean这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。\n\n注意小数的计算精度\n\nconsole.log(0.1 + 0.2 === 0.3); // false\nconsole.log(0.3 / 0.1); // 2.9999999999999996\nconsole.log(0.3 - 0.2 === 0.2 - 0.1); // false\n\n\n1\n2\n3\n\n\n\n# 判断值的类型\n\nJavaScript 有三种方法，可以确定一个值到底是什么类型。\n\n * typeof运算符\n   \n   console.log(typeof undefiend); // undefiend，用来检查一个没有声明的变量，而不报错。\n   console.log(typeof 123); // number\n   console.log(typeof "123"); // string\n   console.log(typeof false); // boolean\n   console.log(typeof null); // object\n   console.log(typeof {}); // object\n   console.log(typeof [1]); // object\n   console.log(typeof function name(params) {}); // function\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * instanceof运算符，面向对象使用\n\n * Object.prototype.toString方法\n\n\n# 变量\n\n弱类型，区分大小写，但是变量一般都用小写字母开头的驼峰表示法表示\n\n全局变量：在script标签里面定义一个变量，这个变量在页面中js部分都可以使用\n\n 1. 在任何方法之外放置的var语句；var foo = value;\n 2. 给全局对象添加一个属性：windows.foo = value;\n 3. 直接使用未经声明的变量(隐式全局变量)：foo = value;，不建议使用\n\n局部变量：ES6之前在函数内部定义一个变量，只能在方法内部使用：var foo = value;，其他查看作用域和闭包章节。\n\n声明的提升：详细查看“作用域和闭包中声明的提升章节”，\n\n//原本语句如下：\nconsole.log(a); //不会报错，会输出undefined\nvar a = 1;\n\n//真正运行的代码如下：\nvar a;\nconsole.log(a); //会输出undefined，表示a已经声明，但为赋值\na = 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 常量\n\nES6添加。使用const定义，采取全大写并用下划线分割。值不可改变！\n\n\n# 运算符\n\n\n# 赋值运算符\n\n=、+=、-=\n\n\n# 一元运算符\n\n++(自增)、--(自减)、+(正号，二元运算时可做拼接字符串)、-(负号)\n\n注意：在JS中，一元运算符如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。\n\n * string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）\n * boolean转number：true转为1，false转为0\n\n\n# 三元运算符\n\n表达式? 值1:值2;\n\n\n# 算术运算符\n\n+、-、*、/、%（取余，余数趋于0）、**（指数操作，如2^2=4）\n\n\n# 比较运算符\n\n>、<、>=、<=、==、===(全等于)，比较方式如下：\n\n * 类型相同：直接比较\n   * 字符串：按照字典顺序(ASCII)比较。按位逐一比较，直到得出大小为止。\n * 类型不同：先进行类型转换，再比较\n   * ==：比较的只是值（会执行类型转换）\n   * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false\n\nconsole.log(undefined == null); // true\nconsole.log(undefined === null); // false\n\n\n1\n2\n\n\n\n# 逻辑运算符\n\n&&、||、!\n\nJS 中代表 false的值有（对应数据类型即可记忆）：undefined, NaN, 0, "", false, null\n\n其他类型转boolean\n\n * number：0或NaN为假，其他为真\n * string：除了空字符串("")，其他都是true。注意空格占位的不是空字符串\n * null&undefined：都是false\n * 对象：所有对象都为true。判断空指针异常（若是字符串都不用判断长度）时直接写if(obj)\n\nconsole.log(true && "hello");// hello\nconsole.log(false || "default"); // default，可用于默认值\nconsole.log(1 + 2 || "default"); // 3\nconsole.log(!4); // false\nconsole.log(!!4); // true\n\n\n1\n2\n3\n4\n5\n\n\n\n# 位运算符\n\n&、|、~、^，转为32位二进制补码进行计算\n\nconsole.log(5 & 3); //1\nconsole.log(5 | 3); //7\nconsole.log(~5); // -6\nconsole.log(5 ^ 3); //6\n\n\n1\n2\n3\n4\n\n\n\n# 位移运算符\n\n位移运算符：不改变原变量数值。输入输出都是对整数类型的二进制补码进行的运算！如下解释以及画图时也应用补码来解释！\n\n * <<左移，被移除的高位丢弃，低位空缺位补0。当顶替掉符号位时数值正负改变。\n * >>右移，被移位的二进制最高位是0，右移后所有空缺位补0；最高位是1，所有空缺位补1。\n * >>>无符号右移，使用“零扩展”（zero extension），即被移位二进制最高位无论是0或者是1，空缺位都用0补。C/C++ 没有\n\n\n# 流程控制\n\n * if...else...(同Java)\n * while...、do...while...(同Java)\n * switch case default\n   * Java中switch可以接收的数据类型：byte、short、char、int、Enum(1.5) 、String(1.7)\n   * JavaScript中switch可以接收任意的原始数据类型\n   * 都有 break 关键字\n * for：var定义的变量不是局部变量，无论布尔表达式是否满足，步进表达式都会执行。所以可以用let来来限制作用范围。\n   * for...in：遍历数组或者对象的属性：for (变量 in 对象)\n   * for...of：遍历iterable类型，如Array、Map和Set的值，for (变量 of 对象)\n * 跳出循环：（break、continue只针对最内层循环）\n   * break语句用于跳出代码块或循环\n   * continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环\n   * label标签通常与break语句和continue语句配合使用，跳出特定的循环\n   * return虽然也可以跳出，但是通常用来返回方法\n\n\n# Other（未整理好）\n\n\n# 基本类型的包装对象\n\n * String\n   \n   * 创建对象var str = "abc";\n   * 属性：length，字符串长度\n   * 方法：\n   1. 与html相关的方法\n      * bold()：加粗\n      * fontcolor(): 设置字符串的颜色\n      * fontsize(): 设置字体的大小\n      * link(): 将字符串显示成超链接 str4.link("hello.html")\n      * sub() sup(): 下标和上标\n   2. 与Java相似的方法\n      * concat(): 连接字符串\n      * charAt():返回指定指定位置的字符串，若字符位置不存在，返回空字符串\n      * indexOf()：返回字符串位置\n      * split()：切分字符串，成数组\n      * replace()：替换字符串，传递两个参数：原始字符、要替换成的字符\n      * substr()：从第几位开始，向后截取几位\n      * substring()：[从第几位开始，到第几位结束)\n\n * Boolean：var flag = new Boolean(true);，不传值时默认为false\n\n\n# Global\n\n * 特点：全局对象，这个Global中封装的方法不需要对象就可以方法名();直接调用。\n\n * 方法：\n   \n   * encodeURI()：对字符进行url编码，返回另一个字符。不编码字符有82个\n   \n   * decodeURI()：对字符进行url解码，返回另一个字符\n   \n   * encodeURIComponent()：对字符进行url编码，编码的字符更多。不编码字符有71个\n   \n   * decodeURIComponent()：对字符进行url解码\n     \n     传智播客 =  %E4%BC%A0%E6%99%BA%E6%92%AD%E5%AE%A2\n     \n     \n     1\n     \n   \n   * parseInt()：将字符串转为数字；进制转换 * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number，第一个也不是数字则为NaN * parseInt(\'11\',2)，返回3\n   \n   * isNaN()：判断一个值是否是NaN - NaN六亲不认，连自己都不认。NaN参与的==比较全部返回false\n   \n   * eval()：==将JavaScript字符串，作为脚本代码来执行==，若字符串不是脚本代码则不执行\n     \n     var str = "alert(\'1234\');";\n     alert(str);    //alert(\'1234\');\n     eval(str);    //1234\n     \n     \n     1\n     2\n     3\n     \n\n\n# Base64\n\n使用场景\n\n * 文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号，可以使用 Base64 编码转成可以打印的字符。\n * 需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。\n\n所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。JS提供了如下全局函数\n\n * btoa()：任意值转为 Base64 编码\n * atob()：Base64 编码转为原来的值\n\nvar str = "hello world";\nconsole.log(btoa(str)); // aGVsbG8gd29ybGQ\nconsole.log(atob("aGVsbG8gd29ybGQ")); // hello world\n\n\n1\n2\n3\n\n\n注意，这两个方法不适合非 ASCII 码的字符，如中文字符，会报错。要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个URL转码环节，JS提供如下全局函数，再使用这两个方法\n\nfunction b64Encode(str) {\n  return btoa(encodeURIComponent(str));\n}\n\nfunction b64Decode(str) {\n  return decodeURIComponent(atob(str));\n}\n\nconsole.log(b64Encode("你好")); // "JUU0JUJEJUEwJUU1JUE1JUJE"\nconsole.log(b64Decode("JUU0JUJEJUEwJUU1JUE1JUJE")); // "你好"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# 基础语法\n\n\n# 简介\n\njavascript 是一种轻量级的脚本语言。脚本语言指的是它不具备开发操作系统的能力，而是只用来编写控制其他大型应用程序（比如浏览器）的“脚本”。\n\njavascript 也是一种嵌入式（embedded）语言。它提供的核心语法不算很多，只能用来做一些数学和逻辑运算。javascript 本身不提供任何与 i/o（输入/输出）相关的 api，都要靠宿主环境（host）提供，所以它只合适嵌入更大型的应用程序环境，去调用宿主环境提供的底层 api。目前，已经嵌入 javascript 的宿主环境有：浏览器，node 服务器环境。\n\n从语法角度看，javascript 语言是一种“对象模型”语言，还支持函数式编程。\n\njavascript 的核心语法部分相当精简，只包括两个部分：\n\n * 基本的语法构造（比如操作符、控制结构、语句）\n * 标准库（就是一系列具有各种功能的对象比如array、date、math等）\n\n各种宿主环境提供额外的 api（即只能在该环境使用的接口），以便 javascript 调用。\n\n浏览器提供的额外 api 可以分成三大类：\n\n * 浏览器控制类：操作浏览器\n * dom 类：操作网页的各种元素\n * web 类：实现互联网的各种功能\n\nnode 环境会提供操作系统的 api，比如文件操作 api、网络通信 api等等\n\n组成：ecmascript + bom + dom\n\n\n# 与 html 组合\n\n * 内部引入\n   \n   <script>  \n   js代码; \n   <\/script>\n   \n   \n   1\n   2\n   3\n   \n   \n   在html标签中写入<img src="img/1.jpg" id="img1" onclick="javascript:fun2();">\n\n * 外部引入\n   \n   <script src="js/a.js"><\/script>    \x3c!--  type="text/javascript"可省略  --\x3e\n   <script src="js/b.js"><\/script>\n   \n   \n   1\n   2\n   \n\n提示\n\nhead 中定义的 javascript 将会在页面加载前执行，会阻塞页面加载，除非该js需在网页全部加载完成前就可以调用，否则推荐定义在 </body> 闭合标签之前\n\nchrome进入 console 途径：\n\n * mac：command + option + j；win：ctrl + shift + j\n * mac：command + option + i；win：ctrl + shift + i再选择 console 面板\n\n\n# 数据类型\n\n\n# 定义\n\n * undefined(未定义)：若变量未初始化则默认值为undefined或直接赋值undefined\n\n * number(数值)：不区分整数和小数、nan（not a number）。\n   \n   所有数字都是以64位浮点数形式储存；位运算只有整数才能完成，此时 javascript 会自动转成32位整数，然后运算\n\n * string(字符串)：单引和双引都可以\n\n * boolean(布尔)：true和false\n\n * null(空)：即此处的值为空。一个对象为空的占位符或直接赋值null\n   \n   typeof null返回object，js最初的错误被ecmascript沿用。现在 null 被认为是对象的占位符，从而解释了该矛盾\n\n * object(对象)：各种值组成的集合，可以分成三个子类型\n   \n   * object(狭义的对象)\n   * array(数组)\n   * function(函数)\n\n提示\n\nes5 只有 6 种，es6 即 ecmascript 2015 添加了一种symbol\n\n通常number、string、boolean这三种类型，合称为原始类型（primitive type）的值，即它们是最基本的数据类型，不能再细分了。对象则称为合成类型（complex type）的值，因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。\n\n注意小数的计算精度\n\nconsole.log(0.1 + 0.2 === 0.3); // false\nconsole.log(0.3 / 0.1); // 2.9999999999999996\nconsole.log(0.3 - 0.2 === 0.2 - 0.1); // false\n\n\n1\n2\n3\n\n\n\n# 判断值的类型\n\njavascript 有三种方法，可以确定一个值到底是什么类型。\n\n * typeof运算符\n   \n   console.log(typeof undefiend); // undefiend，用来检查一个没有声明的变量，而不报错。\n   console.log(typeof 123); // number\n   console.log(typeof "123"); // string\n   console.log(typeof false); // boolean\n   console.log(typeof null); // object\n   console.log(typeof {}); // object\n   console.log(typeof [1]); // object\n   console.log(typeof function name(params) {}); // function\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * instanceof运算符，面向对象使用\n\n * object.prototype.tostring方法\n\n\n# 变量\n\n弱类型，区分大小写，但是变量一般都用小写字母开头的驼峰表示法表示\n\n全局变量：在script标签里面定义一个变量，这个变量在页面中js部分都可以使用\n\n 1. 在任何方法之外放置的var语句；var foo = value;\n 2. 给全局对象添加一个属性：windows.foo = value;\n 3. 直接使用未经声明的变量(隐式全局变量)：foo = value;，不建议使用\n\n局部变量：es6之前在函数内部定义一个变量，只能在方法内部使用：var foo = value;，其他查看作用域和闭包章节。\n\n声明的提升：详细查看“作用域和闭包中声明的提升章节”，\n\n//原本语句如下：\nconsole.log(a); //不会报错，会输出undefined\nvar a = 1;\n\n//真正运行的代码如下：\nvar a;\nconsole.log(a); //会输出undefined，表示a已经声明，但为赋值\na = 1;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 常量\n\nes6添加。使用const定义，采取全大写并用下划线分割。值不可改变！\n\n\n# 运算符\n\n\n# 赋值运算符\n\n=、+=、-=\n\n\n# 一元运算符\n\n++(自增)、--(自减)、+(正号，二元运算时可做拼接字符串)、-(负号)\n\n注意：在js中，一元运算符如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换。\n\n * string转number：按照字面值转换。如果字面值不是数字，则转为nan（不是数字的数字）\n * boolean转number：true转为1，false转为0\n\n\n# 三元运算符\n\n表达式? 值1:值2;\n\n\n# 算术运算符\n\n+、-、*、/、%（取余，余数趋于0）、**（指数操作，如2^2=4）\n\n\n# 比较运算符\n\n>、<、>=、<=、==、===(全等于)，比较方式如下：\n\n * 类型相同：直接比较\n   * 字符串：按照字典顺序(ascii)比较。按位逐一比较，直到得出大小为止。\n * 类型不同：先进行类型转换，再比较\n   * ==：比较的只是值（会执行类型转换）\n   * ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false\n\nconsole.log(undefined == null); // true\nconsole.log(undefined === null); // false\n\n\n1\n2\n\n\n\n# 逻辑运算符\n\n&&、||、!\n\njs 中代表 false的值有（对应数据类型即可记忆）：undefined, nan, 0, "", false, null\n\n其他类型转boolean\n\n * number：0或nan为假，其他为真\n * string：除了空字符串("")，其他都是true。注意空格占位的不是空字符串\n * null&undefined：都是false\n * 对象：所有对象都为true。判断空指针异常（若是字符串都不用判断长度）时直接写if(obj)\n\nconsole.log(true && "hello");// hello\nconsole.log(false || "default"); // default，可用于默认值\nconsole.log(1 + 2 || "default"); // 3\nconsole.log(!4); // false\nconsole.log(!!4); // true\n\n\n1\n2\n3\n4\n5\n\n\n\n# 位运算符\n\n&、|、~、^，转为32位二进制补码进行计算\n\nconsole.log(5 & 3); //1\nconsole.log(5 | 3); //7\nconsole.log(~5); // -6\nconsole.log(5 ^ 3); //6\n\n\n1\n2\n3\n4\n\n\n\n# 位移运算符\n\n位移运算符：不改变原变量数值。输入输出都是对整数类型的二进制补码进行的运算！如下解释以及画图时也应用补码来解释！\n\n * <<左移，被移除的高位丢弃，低位空缺位补0。当顶替掉符号位时数值正负改变。\n * >>右移，被移位的二进制最高位是0，右移后所有空缺位补0；最高位是1，所有空缺位补1。\n * >>>无符号右移，使用“零扩展”（zero extension），即被移位二进制最高位无论是0或者是1，空缺位都用0补。c/c++ 没有\n\n\n# 流程控制\n\n * if...else...(同java)\n * while...、do...while...(同java)\n * switch case default\n   * java中switch可以接收的数据类型：byte、short、char、int、enum(1.5) 、string(1.7)\n   * javascript中switch可以接收任意的原始数据类型\n   * 都有 break 关键字\n * for：var定义的变量不是局部变量，无论布尔表达式是否满足，步进表达式都会执行。所以可以用let来来限制作用范围。\n   * for...in：遍历数组或者对象的属性：for (变量 in 对象)\n   * for...of：遍历iterable类型，如array、map和set的值，for (变量 of 对象)\n * 跳出循环：（break、continue只针对最内层循环）\n   * break语句用于跳出代码块或循环\n   * continue语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环\n   * label标签通常与break语句和continue语句配合使用，跳出特定的循环\n   * return虽然也可以跳出，但是通常用来返回方法\n\n\n# other（未整理好）\n\n\n# 基本类型的包装对象\n\n * string\n   \n   * 创建对象var str = "abc";\n   * 属性：length，字符串长度\n   * 方法：\n   1. 与html相关的方法\n      * bold()：加粗\n      * fontcolor(): 设置字符串的颜色\n      * fontsize(): 设置字体的大小\n      * link(): 将字符串显示成超链接 str4.link("hello.html")\n      * sub() sup(): 下标和上标\n   2. 与java相似的方法\n      * concat(): 连接字符串\n      * charat():返回指定指定位置的字符串，若字符位置不存在，返回空字符串\n      * indexof()：返回字符串位置\n      * split()：切分字符串，成数组\n      * replace()：替换字符串，传递两个参数：原始字符、要替换成的字符\n      * substr()：从第几位开始，向后截取几位\n      * substring()：[从第几位开始，到第几位结束)\n\n * boolean：var flag = new boolean(true);，不传值时默认为false\n\n\n# global\n\n * 特点：全局对象，这个global中封装的方法不需要对象就可以方法名();直接调用。\n\n * 方法：\n   \n   * encodeuri()：对字符进行url编码，返回另一个字符。不编码字符有82个\n   \n   * decodeuri()：对字符进行url解码，返回另一个字符\n   \n   * encodeuricomponent()：对字符进行url编码，编码的字符更多。不编码字符有71个\n   \n   * decodeuricomponent()：对字符进行url解码\n     \n     传智播客 =  %e4%bc%a0%e6%99%ba%e6%92%ad%e5%ae%a2\n     \n     \n     1\n     \n   \n   * parseint()：将字符串转为数字；进制转换 * 逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number，第一个也不是数字则为nan * parseint(\'11\',2)，返回3\n   \n   * isnan()：判断一个值是否是nan - nan六亲不认，连自己都不认。nan参与的==比较全部返回false\n   \n   * eval()：==将javascript字符串，作为脚本代码来执行==，若字符串不是脚本代码则不执行\n     \n     var str = "alert(\'1234\');";\n     alert(str);    //alert(\'1234\');\n     eval(str);    //1234\n     \n     \n     1\n     2\n     3\n     \n\n\n# base64\n\n使用场景\n\n * 文本里面包含一些不可打印的符号，比如 ascii 码0到31的符号，可以使用 base64 编码转成可以打印的字符。\n * 需要以文本格式传递二进制数据，那么也可以使用 base64 编码。\n\n所谓 base64 就是一种编码方法，可以将任意值转成 0～9、a～z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。js提供了如下全局函数\n\n * btoa()：任意值转为 base64 编码\n * atob()：base64 编码转为原来的值\n\nvar str = "hello world";\nconsole.log(btoa(str)); // agvsbg8gd29ybgq\nconsole.log(atob("agvsbg8gd29ybgq")); // hello world\n\n\n1\n2\n3\n\n\n注意，这两个方法不适合非 ascii 码的字符，如中文字符，会报错。要将非 ascii 码字符转为 base64 编码，必须中间插入一个url转码环节，js提供如下全局函数，再使用这两个方法\n\nfunction b64encode(str) {\n  return btoa(encodeuricomponent(str));\n}\n\nfunction b64decode(str) {\n  return decodeuricomponent(atob(str));\n}\n\nconsole.log(b64encode("你好")); // "juu0jujejuewjuu1jue1juje"\nconsole.log(b64decode("juu0jujejuewjuu1jue1juje")); // "你好"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"2 语法-1 ES6",frontmatter:{title:"2 语法-1 ES6",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/c65afb/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/302.ES6.html",relativePath:"1200.JS/300.语法/302.ES6.md",key:"v-739f697e",path:"/pages/c65afb/",headers:[{level:2,title:"什么是 ES6",slug:"什么是-es6",normalizedTitle:"什么是 es6",charIndex:10},{level:2,title:"Node.js中使用ES6",slug:"node-js中使用es6",normalizedTitle:"node.js中使用es6",charIndex:541},{level:2,title:"变量声明 let",slug:"变量声明-let",normalizedTitle:"变量声明 let",charIndex:834},{level:2,title:"常量声明const",slug:"常量声明const",normalizedTitle:"常量声明const",charIndex:1813},{level:2,title:"模板字符串",slug:"模板字符串",normalizedTitle:"模板字符串",charIndex:1899},{level:2,title:"函数默认参数",slug:"函数默认参数",normalizedTitle:"函数默认参数",charIndex:2344},{level:2,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:2528},{level:2,title:"对象初始化简写",slug:"对象初始化简写",normalizedTitle:"对象初始化简写",charIndex:2787},{level:2,title:"解构",slug:"解构",normalizedTitle:"解构",charIndex:3045},{level:2,title:"Spread Operator...",slug:"spread-operator",normalizedTitle:"spread operator...",charIndex:3642},{level:2,title:"import 和 export",slug:"import-和-export",normalizedTitle:"import 和 export",charIndex:4037},{level:2,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:4647}],headersStr:"什么是 ES6 Node.js中使用ES6 变量声明 let 常量声明const 模板字符串 函数默认参数 箭头函数 对象初始化简写 解构 Spread Operator... import 和 export Promise",content:"# ES6\n\n\n# 什么是 ES6\n\n编程语言JavaScript是ECMAScript的实现和扩展 。ECMAScript是由ECMA（一个类似W3C的标准组织）参与进行标准化的语法规范。ECMAScript定义了：\n\n * 语言语法 – 语法解析规则、关键字、语句、声明、运算符等。\n\n * 类型 – 布尔型、数字、字符串、对象等。\n\n * 原型和继承\n\n * 内建对象和函数的标准库 – JSON、Math、数组方法、对象自省方法等。\n\nECMAScript标准不定义HTML或CSS的相关功能，也不定义类似DOM（文档对象模型）的Web API，这些都在独立的标准中进行定义。ECMAScript涵盖了各种环境中JS的使用场景，无论是浏览器环境还是类似node.js的非浏览器环境。\n\n2009年发布改进版ES5，引入了Object.create()、Object.defineProperty()、getters和setters、严格模式以及JSON对象。\n\nECMAScript 6.0（以下简称ES6）是JavaScript语言的下一代标准，2015年6月正式发布。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n\n# Node.js中使用ES6\n\nES6+ 太棒了,但是很多高级功能node是不支持的,就需要使用babel转换成ES5\n\n（1）babel转换配置,项目根目录添加.babelrc 文件\n\n{\n  \"presets\" : ['es2015']\n}\n\n\n1\n2\n3\n\n\n（2）安装es6转换模块。但是好像过时了deprecate\n\ncnpm install babel-preset-es2015 --save-dev\n\n\n1\n\n\n（3）全局安装命令行工具\n\ncnpm install  babel-cli -g\n\n\n1\n\n\n（4）使用\n\nbabel-node js文件名\n\n\n1\n\n\n\n# 变量声明 let\n\nlet 关键字可以将变量绑定到所在的任意作用域中，通常是{ }内部。换句话说，let 将其声明的变量隐式地附加在一个已经存在的块作用域。\n\nvar foo = true;\n\nif (foo) {\n  let bar = foo * 2;\n  bar = something( bar ); \n  console.log( bar );\n}\nconsole.log( bar ); // ReferenceError\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们都是知道在ES6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如\n\n  function aa() {\n    if(bool) {\n        var test = 'hello man'\n    } else {\n        console.log(test)\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n以上的代码实际上是:\n\nfunction aa() {\n    var test // 变量提升\n    if(bool) {\n        test = 'hello man'\n    } else {\n        //此处访问test 值为undefined\n        console.log(test)\n    }\n    //此处访问test 值为undefined\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n所以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。\n\n接下来ES6主角登场：\n\n我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？在一个函数内部 ，在一个代码块内部。看以下代码\n\n function aa() {\n    if(bool) {\n       let test = 'hello man'\n    } else {\n        //test 在此处访问不到\n        console.log(test)\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 常量声明const\n\nconst 用于声明常量，看以下代码\n\nconst name = 'lux'\nname = 'joe' //再次赋值此时会报错\n\n\n1\n2\n\n\n\n# 模板字符串\n\nes6模板字符简直是开发者的福音啊，解决了ES5在字符串功能上的痛点。\n\n第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。\n\n    //es5 \n    var name = 'lux'\n    console.log('hello' + name)\n    //es6\n    const name = 'lux'\n    console.log(`hello ${name}`) //hello lux\n\n\n1\n2\n3\n4\n5\n6\n\n\n第二个用途，在ES5时我们通过反斜杠(\\)来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定。\n\n    // es5\n    var msg = \"Hi \\\n    man!\"\n    // es6\n    const template = `<div>\n        <span>hello world</span>\n    </div>`\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 函数默认参数\n\nES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。\n\n看例子代码\n\n    function action(num = 200) {\n        console.log(num)\n    }\n    action() //200\n    action(300) //300\n\n\n1\n2\n3\n4\n5\n\n\n\n# 箭头函数\n\nES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。箭头函数最直观的三个特点。\n\n1不需要function关键字来创建函数\n\n2省略return关键字。当大括号中只有一句代码，可以省略大括号和return\n\n3继承当前上下文的 this 关键字\n\n看下面代码（ES6）\n\n (response,message) => {\n    .......\n }\n\n\n1\n2\n3\n\n\n相当于ES5代码\n\nfunction(response,message){\n    ......\n}\n\n\n1\n2\n3\n\n\n\n# 对象初始化简写\n\nES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如\n\nfunction people(name, age) {\n    return {\n        name: name,\n        age: age\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上代码可以简写为\n\nfunction people(name, age) {\n    return {\n        name,\n        age\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 解构\n\n数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，是将一个数据结构分解为更小的部分的过程\n\nES5我们提取对象中的信息形式如下\n\nconst people = {\n    name: 'lux',\n    age: 20\n}\nconst name = people.name\nconst age = people.age\nconsole.log(name + ' --- ' + age)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，ES6的解构能让我们从对象或者数组里取出数据存为变量，例如\n\n//对象\nconst people = {\n    name: 'lux',\n    age: 20\n}\nconst { name, age } = people\nconsole.log(`${name} --- ${age}`)\n//数组\nconst color = ['red', 'blue']\nconst [first, second] = color;//就得用first/second...\nconsole.log(first) //'red'\nconsole.log(second) //'blue'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Spread Operator...\n\nES6中另外一个好玩的特性就是Spread Operator 也是三个点儿...接下来就展示一下它的用途。 组装对象或者数组\n\n//数组\nconst color = ['red', 'yellow']\nconst colorful = [...color, 'green', 'pink']\nconsole.log(colorful) //[red, yellow, green, pink]\n\n//对象\nconst alp = { fist: 'a', second: 'b'}\nconst alphabets = { ...alp, third: 'c' }\nconsole.log(alphabets) //{ \"fist\": \"a\", \"second\": \"b\", \"third\": \"c\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# import 和 export\n\n> ES5中导出/导入\n> \n> exports.add = () =>{\n>  console.log('hello...add');\n> }\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> let {add} = require('./test1');\n> let test1 = require('./test1');\n> add();\n> test1.add();\n> \n> \n> 1\n> 2\n> 3\n> 4\n\nimport导入模块、export导出模块（在导出.vue中vue模块时，可以使用export default...）\n\ntest1.js\n\nexport let add = () =>{\n    console.log('hello...add');\n}\n// export {add as ad};这样统一写也可以，可以起别名\n\n\n1\n2\n3\n4\n\n\ntest2.js\n\nimport {add} from './test1';\nimport * as test1 from './demo9.js';\n\nadd();\ntest1.add();\n\n\n1\n2\n3\n4\n5\n\n\n注意：node(v10.x)还是不支持import关键字，所以我们需要使用babel的命令行工具来执行（配置详见6.2小节内容）\n\nbabel-node demo9\n\n\n1\n\n\n\n# Promise\n\nPromise 是异步编程的一种解决方案（将异步请求用Promise包裹），比传统的解决方案–回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了语法，原生提供了Promise。\n\nPromise是ES6提供的用于异步处理的对象，因为axios提交是异步提交，这里使用promise作为返回值。Promise使用方法如下：\n\nPromise对象在处理过程中有三种状态：\n\n * pending：进行中\n * resolved：操作成功\n * rejected: 操作失败\n\nPromise的构建方法如下：\n\nconst promise = new Promise(function(resolve,reject){\n    //...TODO...\n    if(操作成功){\n        resolve(value);\n    }else{\n        reject(error);\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上边的构造方法function(resolve,reject)执行流程如下： 1）方法执行一些业务逻辑。 2）如果操作成功将Promise的状态由pending变为resolved，并将操作结果传出去 3）如果操作失败会将promise的状态由pending变为rejected，并将失败结果传出去。\n\n上边说的操作成功将操作结果传给谁了呢？操作失败将失败结果传给谁了呢？通过promise的then、catch来指定\n\npromise.then(function (result) {\n    console.log('操作成功：' + result);\n});\npromise.catch(function (reason) {\n    console.log('操作失败：' + reason);\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n例如：\n\n定义一个方法，返回promise对象\n\ntestpromise(i){\n    return new Promise((resolve,reject)=>{\n        if(i % 2==0){\n            resolve('成功了')\n        }else{\n            reject('拒绝了')\n        }\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n调用此方法：向方法传入偶数、奇数进行测试\n\nthis.testpromise(3).then(res=>{//在then中对成功结果进行处理\n    alert(res)\n}).catch(res=>{//在catch中对操作失败结果进行处理\n    alert(res)\n})\n\n\n1\n2\n3\n4\n5\n",normalizedContent:"# es6\n\n\n# 什么是 es6\n\n编程语言javascript是ecmascript的实现和扩展 。ecmascript是由ecma（一个类似w3c的标准组织）参与进行标准化的语法规范。ecmascript定义了：\n\n * 语言语法 – 语法解析规则、关键字、语句、声明、运算符等。\n\n * 类型 – 布尔型、数字、字符串、对象等。\n\n * 原型和继承\n\n * 内建对象和函数的标准库 – json、math、数组方法、对象自省方法等。\n\necmascript标准不定义html或css的相关功能，也不定义类似dom（文档对象模型）的web api，这些都在独立的标准中进行定义。ecmascript涵盖了各种环境中js的使用场景，无论是浏览器环境还是类似node.js的非浏览器环境。\n\n2009年发布改进版es5，引入了object.create()、object.defineproperty()、getters和setters、严格模式以及json对象。\n\necmascript 6.0（以下简称es6）是javascript语言的下一代标准，2015年6月正式发布。它的目标，是使得javascript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n\n# node.js中使用es6\n\nes6+ 太棒了,但是很多高级功能node是不支持的,就需要使用babel转换成es5\n\n（1）babel转换配置,项目根目录添加.babelrc 文件\n\n{\n  \"presets\" : ['es2015']\n}\n\n\n1\n2\n3\n\n\n（2）安装es6转换模块。但是好像过时了deprecate\n\ncnpm install babel-preset-es2015 --save-dev\n\n\n1\n\n\n（3）全局安装命令行工具\n\ncnpm install  babel-cli -g\n\n\n1\n\n\n（4）使用\n\nbabel-node js文件名\n\n\n1\n\n\n\n# 变量声明 let\n\nlet 关键字可以将变量绑定到所在的任意作用域中，通常是{ }内部。换句话说，let 将其声明的变量隐式地附加在一个已经存在的块作用域。\n\nvar foo = true;\n\nif (foo) {\n  let bar = foo * 2;\n  bar = something( bar ); \n  console.log( bar );\n}\nconsole.log( bar ); // referenceerror\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n我们都是知道在es6以前，var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如\n\n  function aa() {\n    if(bool) {\n        var test = 'hello man'\n    } else {\n        console.log(test)\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n以上的代码实际上是:\n\nfunction aa() {\n    var test // 变量提升\n    if(bool) {\n        test = 'hello man'\n    } else {\n        //此处访问test 值为undefined\n        console.log(test)\n    }\n    //此处访问test 值为undefined\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n所以不用关心bool是否为true or false。实际上，无论如何test都会被创建声明。\n\n接下来es6主角登场：\n\n我们通常用let和const来声明，let表示变量、const表示常量。let和const都是块级作用域。怎么理解这个块级作用域？在一个函数内部 ，在一个代码块内部。看以下代码\n\n function aa() {\n    if(bool) {\n       let test = 'hello man'\n    } else {\n        //test 在此处访问不到\n        console.log(test)\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 常量声明const\n\nconst 用于声明常量，看以下代码\n\nconst name = 'lux'\nname = 'joe' //再次赋值此时会报错\n\n\n1\n2\n\n\n\n# 模板字符串\n\nes6模板字符简直是开发者的福音啊，解决了es5在字符串功能上的痛点。\n\n第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。\n\n    //es5 \n    var name = 'lux'\n    console.log('hello' + name)\n    //es6\n    const name = 'lux'\n    console.log(`hello ${name}`) //hello lux\n\n\n1\n2\n3\n4\n5\n6\n\n\n第二个用途，在es5时我们通过反斜杠(\\)来做多行字符串或者字符串一行行拼接。es6反引号(``)直接搞定。\n\n    // es5\n    var msg = \"hi \\\n    man!\"\n    // es6\n    const template = `<div>\n        <span>hello world</span>\n    </div>`\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 函数默认参数\n\nes6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。\n\n看例子代码\n\n    function action(num = 200) {\n        console.log(num)\n    }\n    action() //200\n    action(300) //300\n\n\n1\n2\n3\n4\n5\n\n\n\n# 箭头函数\n\nes6很有意思的一部分就是函数的快捷写法。也就是箭头函数。箭头函数最直观的三个特点。\n\n1不需要function关键字来创建函数\n\n2省略return关键字。当大括号中只有一句代码，可以省略大括号和return\n\n3继承当前上下文的 this 关键字\n\n看下面代码（es6）\n\n (response,message) => {\n    .......\n }\n\n\n1\n2\n3\n\n\n相当于es5代码\n\nfunction(response,message){\n    ......\n}\n\n\n1\n2\n3\n\n\n\n# 对象初始化简写\n\nes5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如\n\nfunction people(name, age) {\n    return {\n        name: name,\n        age: age\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n以上代码可以简写为\n\nfunction people(name, age) {\n    return {\n        name,\n        age\n    };\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 解构\n\n数组和对象是js中最常用也是最重要表示形式。为了简化提取信息，es6新增了解构，是将一个数据结构分解为更小的部分的过程\n\nes5我们提取对象中的信息形式如下\n\nconst people = {\n    name: 'lux',\n    age: 20\n}\nconst name = people.name\nconst age = people.age\nconsole.log(name + ' --- ' + age)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n是不是觉得很熟悉，没错，在es6之前我们就是这样获取对象信息的，一个一个获取。现在，es6的解构能让我们从对象或者数组里取出数据存为变量，例如\n\n//对象\nconst people = {\n    name: 'lux',\n    age: 20\n}\nconst { name, age } = people\nconsole.log(`${name} --- ${age}`)\n//数组\nconst color = ['red', 'blue']\nconst [first, second] = color;//就得用first/second...\nconsole.log(first) //'red'\nconsole.log(second) //'blue'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# spread operator...\n\nes6中另外一个好玩的特性就是spread operator 也是三个点儿...接下来就展示一下它的用途。 组装对象或者数组\n\n//数组\nconst color = ['red', 'yellow']\nconst colorful = [...color, 'green', 'pink']\nconsole.log(colorful) //[red, yellow, green, pink]\n\n//对象\nconst alp = { fist: 'a', second: 'b'}\nconst alphabets = { ...alp, third: 'c' }\nconsole.log(alphabets) //{ \"fist\": \"a\", \"second\": \"b\", \"third\": \"c\"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# import 和 export\n\n> es5中导出/导入\n> \n> exports.add = () =>{\n>  console.log('hello...add');\n> }\n> \n> \n> 1\n> 2\n> 3\n> \n> \n> let {add} = require('./test1');\n> let test1 = require('./test1');\n> add();\n> test1.add();\n> \n> \n> 1\n> 2\n> 3\n> 4\n\nimport导入模块、export导出模块（在导出.vue中vue模块时，可以使用export default...）\n\ntest1.js\n\nexport let add = () =>{\n    console.log('hello...add');\n}\n// export {add as ad};这样统一写也可以，可以起别名\n\n\n1\n2\n3\n4\n\n\ntest2.js\n\nimport {add} from './test1';\nimport * as test1 from './demo9.js';\n\nadd();\ntest1.add();\n\n\n1\n2\n3\n4\n5\n\n\n注意：node(v10.x)还是不支持import关键字，所以我们需要使用babel的命令行工具来执行（配置详见6.2小节内容）\n\nbabel-node demo9\n\n\n1\n\n\n\n# promise\n\npromise 是异步编程的一种解决方案（将异步请求用promise包裹），比传统的解决方案–回调函数和事件——更合理和更强大。它由社区最早提出和实现，es6将其写进了语言标准，统一了语法，原生提供了promise。\n\npromise是es6提供的用于异步处理的对象，因为axios提交是异步提交，这里使用promise作为返回值。promise使用方法如下：\n\npromise对象在处理过程中有三种状态：\n\n * pending：进行中\n * resolved：操作成功\n * rejected: 操作失败\n\npromise的构建方法如下：\n\nconst promise = new promise(function(resolve,reject){\n    //...todo...\n    if(操作成功){\n        resolve(value);\n    }else{\n        reject(error);\n    }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上边的构造方法function(resolve,reject)执行流程如下： 1）方法执行一些业务逻辑。 2）如果操作成功将promise的状态由pending变为resolved，并将操作结果传出去 3）如果操作失败会将promise的状态由pending变为rejected，并将失败结果传出去。\n\n上边说的操作成功将操作结果传给谁了呢？操作失败将失败结果传给谁了呢？通过promise的then、catch来指定\n\npromise.then(function (result) {\n    console.log('操作成功：' + result);\n});\npromise.catch(function (reason) {\n    console.log('操作失败：' + reason);\n});\n\n\n1\n2\n3\n4\n5\n6\n\n\n例如：\n\n定义一个方法，返回promise对象\n\ntestpromise(i){\n    return new promise((resolve,reject)=>{\n        if(i % 2==0){\n            resolve('成功了')\n        }else{\n            reject('拒绝了')\n        }\n    })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n调用此方法：向方法传入偶数、奇数进行测试\n\nthis.testpromise(3).then(res=>{//在then中对成功结果进行处理\n    alert(res)\n}).catch(res=>{//在catch中对操作失败结果进行处理\n    alert(res)\n})\n\n\n1\n2\n3\n4\n5\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"2 语法-2 Function",frontmatter:{title:"2 语法-2 Function",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/ea650c/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/303.Function.html",relativePath:"1200.JS/300.语法/303.Function.md",key:"v-585525e0",path:"/pages/ea650c/",headers:[{level:2,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:15},{level:2,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:426},{level:2,title:"无函数重载 & arguments",slug:"无函数重载-arguments",normalizedTitle:"无函数重载 &amp; arguments",charIndex:null},{level:2,title:"默认参数",slug:"默认参数",normalizedTitle:"默认参数",charIndex:891},{level:2,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:354},{level:2,title:"箭头函数（匿名函数）",slug:"箭头函数-匿名函数",normalizedTitle:"箭头函数（匿名函数）",charIndex:1191},{level:2,title:"柯里化（curry）",slug:"柯里化-curry",normalizedTitle:"柯里化（curry）",charIndex:1484},{level:2,title:"自执行函数",slug:"自执行函数",normalizedTitle:"自执行函数",charIndex:1907},{level:2,title:"回调函数",slug:"回调函数",normalizedTitle:"回调函数",charIndex:2046}],headersStr:"创建 属性 无函数重载 & arguments 默认参数 作用域 箭头函数（匿名函数） 柯里化（curry） 自执行函数 回调函数",content:'# Function\n\n\n# 创建\n\n * Function\n   \n   var fun = new Function(形式参数列表,方法体);// 括号里面的都必须是string类型。忘掉吧！\n   \n   \n   1\n   \n\n * 函数声明\n   \n   function 方法名称(形式参数列表){ \n       方法体\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 函数表达式\n   \n   var 方法名 = function(形式参数列表){ //匿名函数\n       方法体\n   }\n   \n   \n   1\n   2\n   3\n   \n\n方法定义时，形参的类型var不用写，返回值类型var也不写。\n\n提示\n\n函数声明在JS解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。\n\n函数表达式的值是在JS运行时确定，并且在表达式赋值完成后，该函数才能调用。\n\n\n# 属性\n\nlength代表形参的个数\n\n\n# 无函数重载 & arguments\n\n 1. 在JavaScript中，方法的调用只与方法的名称有关，和参数列表无关（传递多少个参数无所谓）\n\n 2. 方法是一个对象，如果定义名称相同的方法，会覆盖（可以从对象引用理解），所以没有函数重载\n\n 3. 在方法声明中有一个隐藏的内置对象（数组）arguments，封装所有的实际参数。同Java中可变参数类似\n\n 4. 可以把传递的参数保存到 arguments数组里面来模拟函数重载\n    \n    var add = function(){\n        let sum = 0;\n        for(let i = 0;i<arguments.length;i++){\n            sum+=arguments[i];\n        }\n        return sum;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n\n# 默认参数\n\nfunction hello(name = "world") {\n  console.log(name);\n}\nhello(); // world\nhello(undefined); // world\nhello(null); // null\nhello("kitty"); // kitty\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 作用域\n\n * 在函数内部定义的变量只能在函数内部使用，ES6之前主要的作用域就是函数，其他查看“作用域和闭包”章节。\n\n * 函数内部变量与全局变量冲突则会覆盖全局变量\n\n * let 会在{}中自动生成一个局部作用域，var 没有这个作用\n\n\n# 箭头函数（匿名函数）\n\nvar add = (a, b) => {\n  return a + b;\n};\n\nvar greet = name => {\n  console.log("hello", name);\n};\n\nvar greet2 = name => console.log("hello", name);\n\nconsole.log(add(1, 2)); // 3\ngreet("world"); // hello world\ngreet2("world"); // hello world\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 柯里化（curry）\n\nfunction add(a, b, c) {\n  return a + b + c;\n}\nconsole.log(add(1, 2, 3)); // 6\n\n// curry 就是将函数之前的值保存，缓存吗\nfunction addCurry(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\nvar towAdd = addCurry(1)(2);\nconsole.log(towAdd); // f\nconsole.log(towAdd(3)); // 6\nconsole.log(towAdd(4)); // 7\nconsole.log(towAdd(5)); // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 自执行函数\n\n有自己的作用域\n\nvar num1 = 10;\n(function() {\n  var num1 = 20;\n  console.log(num1); // 20\n})();\nconsole.log(num1); // 10\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 回调函数\n\nfunction request(callback) {\n  console.log("请求数据");\n  callback("success");\n  console.log("请求结束");\n}\n\n// 可复用\n// function callback(msg) {\n//   console.log("执行回调函数");\n//   console.log("执行结果是：" + msg);\n// }\n\nrequest(msg => {\n  console.log("执行回调函数");\n  console.log("执行结果是：" + msg);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',normalizedContent:'# function\n\n\n# 创建\n\n * function\n   \n   var fun = new function(形式参数列表,方法体);// 括号里面的都必须是string类型。忘掉吧！\n   \n   \n   1\n   \n\n * 函数声明\n   \n   function 方法名称(形式参数列表){ \n       方法体\n   }\n   \n   \n   1\n   2\n   3\n   \n\n * 函数表达式\n   \n   var 方法名 = function(形式参数列表){ //匿名函数\n       方法体\n   }\n   \n   \n   1\n   2\n   3\n   \n\n方法定义时，形参的类型var不用写，返回值类型var也不写。\n\n提示\n\n函数声明在js解析时进行函数提升，因此在同一个作用域内，不管函数声明在哪里定义，该函数都可以进行调用。\n\n函数表达式的值是在js运行时确定，并且在表达式赋值完成后，该函数才能调用。\n\n\n# 属性\n\nlength代表形参的个数\n\n\n# 无函数重载 & arguments\n\n 1. 在javascript中，方法的调用只与方法的名称有关，和参数列表无关（传递多少个参数无所谓）\n\n 2. 方法是一个对象，如果定义名称相同的方法，会覆盖（可以从对象引用理解），所以没有函数重载\n\n 3. 在方法声明中有一个隐藏的内置对象（数组）arguments，封装所有的实际参数。同java中可变参数类似\n\n 4. 可以把传递的参数保存到 arguments数组里面来模拟函数重载\n    \n    var add = function(){\n        let sum = 0;\n        for(let i = 0;i<arguments.length;i++){\n            sum+=arguments[i];\n        }\n        return sum;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    \n\n\n# 默认参数\n\nfunction hello(name = "world") {\n  console.log(name);\n}\nhello(); // world\nhello(undefined); // world\nhello(null); // null\nhello("kitty"); // kitty\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 作用域\n\n * 在函数内部定义的变量只能在函数内部使用，es6之前主要的作用域就是函数，其他查看“作用域和闭包”章节。\n\n * 函数内部变量与全局变量冲突则会覆盖全局变量\n\n * let 会在{}中自动生成一个局部作用域，var 没有这个作用\n\n\n# 箭头函数（匿名函数）\n\nvar add = (a, b) => {\n  return a + b;\n};\n\nvar greet = name => {\n  console.log("hello", name);\n};\n\nvar greet2 = name => console.log("hello", name);\n\nconsole.log(add(1, 2)); // 3\ngreet("world"); // hello world\ngreet2("world"); // hello world\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 柯里化（curry）\n\nfunction add(a, b, c) {\n  return a + b + c;\n}\nconsole.log(add(1, 2, 3)); // 6\n\n// curry 就是将函数之前的值保存，缓存吗\nfunction addcurry(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    };\n  };\n}\n\nvar towadd = addcurry(1)(2);\nconsole.log(towadd); // f\nconsole.log(towadd(3)); // 6\nconsole.log(towadd(4)); // 7\nconsole.log(towadd(5)); // 8\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 自执行函数\n\n有自己的作用域\n\nvar num1 = 10;\n(function() {\n  var num1 = 20;\n  console.log(num1); // 20\n})();\nconsole.log(num1); // 10\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 回调函数\n\nfunction request(callback) {\n  console.log("请求数据");\n  callback("success");\n  console.log("请求结束");\n}\n\n// 可复用\n// function callback(msg) {\n//   console.log("执行回调函数");\n//   console.log("执行结果是：" + msg);\n// }\n\nrequest(msg => {\n  console.log("执行回调函数");\n  console.log("执行结果是：" + msg);\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"3 标准内置对象-1 Object",frontmatter:{title:"3 标准内置对象-1 Object",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/fa990b/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/304.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-1Object.html",relativePath:"1200.JS/300.语法/304.标准内置对象-1Object.md",key:"v-efd22a0a",path:"/pages/fa990b/",headers:[{level:2,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:20},{level:2,title:"构造函数创建",slug:"构造函数创建",normalizedTitle:"构造函数创建",charIndex:574},{level:2,title:"ES6 对象字面量增强写法",slug:"es6-对象字面量增强写法",normalizedTitle:"es6 对象字面量增强写法",charIndex:1155},{level:2,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:1566},{level:3,title:"属性的定义和访问",slug:"属性的定义和访问",normalizedTitle:"属性的定义和访问",charIndex:1573},{level:3,title:"遍历对象属性",slug:"遍历对象属性",normalizedTitle:"遍历对象属性",charIndex:2005},{level:3,title:"删除对象属性",slug:"删除对象属性",normalizedTitle:"删除对象属性",charIndex:2291},{level:2,title:"this",slug:"this",normalizedTitle:"this",charIndex:623},{level:2,title:"getter & setter",slug:"getter-setter",normalizedTitle:"getter &amp; setter",charIndex:null},{level:2,title:"__proto__ 原型",slug:"proto-原型",normalizedTitle:"<strong>proto</strong> 原型",charIndex:null},{level:2,title:"Object.create",slug:"object-create",normalizedTitle:"object.create",charIndex:5334},{level:2,title:"原型链",slug:"原型链",normalizedTitle:"原型链",charIndex:6372},{level:2,title:"修改原型链指向",slug:"修改原型链指向",normalizedTitle:"修改原型链指向",charIndex:7379},{level:2,title:"Spread 操作符",slug:"spread-操作符",normalizedTitle:"spread 操作符",charIndex:8161},{level:2,title:"destructuring & rest 解构",slug:"destructuring-rest-解构",normalizedTitle:"destructuring &amp; rest 解构",charIndex:null},{level:2,title:"值传递与引用传递",slug:"值传递与引用传递",normalizedTitle:"值传递与引用传递",charIndex:10667},{level:2,title:"call & apply & bind",slug:"call-apply-bind",normalizedTitle:"call &amp; apply &amp; bind",charIndex:null}],headersStr:"创建 构造函数创建 ES6 对象字面量增强写法 属性 属性的定义和访问 遍历对象属性 删除对象属性 this getter & setter __proto__ 原型 Object.create 原型链 修改原型链指向 Spread 操作符 destructuring & rest 解构 值传递与引用传递 call & apply & bind",content:'# 标准内置对象—Object\n\n\n# 创建\n\n// 创建对象 1\nvar employee1 = {\n  name: "conanan",\n  age: 18,\n  position: "程序员",\n  signIn: function() {\n    console.log("conanan 打卡上班");\n  }\n};\nconsole.log(employee1.name); // conanan\nemployee1.signIn(); // conanan 打卡上班\n\n// 创建对象 2\nvar employee2 = new Object();\nemployee2["name"] = "apple54whn";\nemployee2["signIn"] = function() {\n  console.log("apple54whn 打卡上班");\n};\nconsole.log(employee2["name"]); // apple54whn\nemployee2.signIn(); // apple54whn 打卡上班\nconsole.log(employee2.age); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 构造函数创建\n\n// 方式1\nfunction Employee1(name, age) {\n  this.name = name;\n  this.age = age;\n  this.signIn = () => {\n    console.log(this.name + "去签到");\n  };\n}\n\n// 方式2，使用ES2015方式，推荐\nclass Employee2 {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.signIn = () => {\n      console.log(this.name + "去签到");\n    }\n  }\n}\n\nvar employee1 = new Employee1("conanan", 18);\nconsole.log(employee1.name); // conanan\n\nvar employee2 = new Employee2("apple54whn", 20);\nconsole.log(employee2.age); // 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# ES6 对象字面量增强写法\n\n// new 方式，非字面量\nconst obj1 = new Object();\n\nlet name = "conanan";\nlet age = 18;\n\n// ES5\nconst obj2 = {\n    name: name,\n    age: age,\n    eat: function () {\n        console.log("eat");\n    },\n};\nconsole.log(obj2);\n\n// ES6\nconst obj3 = {\n    name,\n    age,\n    eat() {\n        console.log("eat");\n    },\n};\nconsole.log(obj3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 属性\n\n\n# 属性的定义和访问\n\n * 直接使用.或[\'key\']定义即可\n\n * 属性值可以使用.或[\'key\']访问\n\n * 属性定义时，若key为一个连接单词，则只能通过\'birty-day\'引号括起来，且访问时也只能用[\'key\']访问。不推荐这样命令，一般采用驼峰命名即可！\n\n * 若属性名和值相同，则可以省略；函数也可以省略成如下：\n   \n   var name = "conanan";\n   var employee3 = {\n     name,\n     signIn() {\n       console.log("conanan 打卡");\n     }\n   };\n   console.log(employee3.name); // conanan\n   employee3.signIn(); // conanan 打卡\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 遍历对象属性\n\nvar name = "conanan";\nvar employee3 = {\n  name,\n  signIn() {\n    console.log("conanan 打卡");\n  }\n};\n\n// 遍历 1\nconsole.log(Object.keys(employee3)); // ["name","signIn"]\n// 遍历 2\nfor (const key in employee3) {\n  console.log(key); // 上面的分开输出\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 删除对象属性\n\ndelete employee3.name;\nconsole.log(employee3.name); // undefined\n\n\n1\n2\n\n\n\n# this\n\nvar employee = {\n  fullName: "apple54whn",\n  age: 18,\n  signIn: function() {\n    console.log(this.fullName + "上班打卡");\n  }\n};\nemployee.signIn(); // conanan上班打卡\n\nemployee.goToWork = function() {\n  console.log(this.fullName + "去上班");\n};\nemployee.goToWork(); // conanan去上班\n\n// 发现问题，且不推荐使用箭头函数定义对象的方法\nemployee.goHome = () => {\n  console.log(this.fullName + "回家"); \n  console.log(this); // 此时this指向的是包裹this对象的作用域对象，此时包裹它的作用域为全局对象，浏览器中为Window\n};\nemployee.goHome(); // undefined回家\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意使用箭头函数时 this 指向问题。但是定义对象字面量时不推荐使用箭头函数定义方法，应采用普通方法来定义！\n\n// 若定义在构造函数中，则指向包裹this对象的作用域即构造函数\nclass Employee2 {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.goHome = function() {\n      console.log(this.name + "回家");\n    };\n    // 能解决问题但不推荐使用箭头函数定义对象的方法\n    this.signIn = () => {\n      console.log(this.name + "去签到");\n    };\n  }\n}\nvar emp = new Employee2("app", 8);\nemp.signIn(); // app去签到\nemp.goHome();// app回家\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# getter & setter\n\n直接使用字面值创建 Object 的 getter & setter 定义\n\nvar person = {\n  firstNmae: "三",\n  lastName: "张",\n  get fullName() {\n    return this.lastName + this.firstNmae;\n  },\n  set fullName(fullName) {\n    let [lastName, firstNmae] = fullName.split(",");\n    this.lastName = lastName;\n    this.firstNmae = firstNmae;\n  }\n};\n\nconsole.log(person.fullName); // 张三\nperson.fullName = "李,四";\nconsole.log(person.fullName); // 李四\nconsole.log(person.lastName, person.firstNmae); // 李 四\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用构造函数创建的 Object 对象的 getter & setter 定义需要使用Object.defineProperty()来实现\n\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\nvar p = new Person("app", 8);\nObject.defineProperty(p, "info", {\n  get: function() {\n    return this.name + " " + this.age;\n  },\n  set: function(info) {\n    let [name, age] = info.split(" ");\n    this.name = name;\n    this.age = age;\n  }\n});\n\nconsole.log(p.info); // app 8\np.info = "haha 18";\nconsole.log(p.info); // haha 18\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# __proto__ 原型\n\n类似于Java中继承得来的的静态域或静态方法\n\nclass Employee {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.goHome = function() {\n      console.log(this.name + "回家");\n    };\n  }\n}\n\nvar emp1 = new Employee("conan", 22);\nvar emp2 = new Employee("lan", 21);\nconsole.log(emp1);\nconsole.log(emp2);\n// 上述打印的对象都有个“__proto__”属性\n\nEmployee.prototype.schoolName = "米花小学";\nEmployee.prototype.printInfo = function() {\n  console.log(this.name + " " + this.age + " " + this.schoolName);\n};\nemp1.printInfo(); // conan 22 米花小学\nemp2.printInfo(); // lan 21 米花小学\n\n// 获取对象和类的原型，他们都是一样的\nconsole.log(emp1.__proto__);\nconsole.log(Employee.prototype);\nconsole.log(emp1.__proto__ === Employee.prototype); // true\nconsole.log(Object.getPrototypeOf(emp2) === Employee.prototype); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# Object.create\n\n类似继承\n\nclass Employee {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.goHome = function() {\n      console.log(this.name + "回家");\n    };\n  }\n}\nEmployee.prototype.schoolName = "米花小学";\nEmployee.prototype.printInfo = function() {\n  console.log(this.name + " " + this.age + " " + this.schoolName);\n};\n\nvar emp1 = new Employee("conan", 22);\nconsole.log(emp1); // 原型中的需在__proto__中查看\nfor (const key in emp1) {\n  console.log(key); // 将所有属性方法，包括原型中的都打印出了\n}\n\n// Object.create\nvar emp2 = Object.create(emp1);\nconsole.log(emp2); // 因为时继承的，所以从emp1继承的都在__protp__中，且__proto__中还有一个__proto__，是对象的原型\nfor (const key in emp2) {\n  console.log(key); // 将所有属性方法，包括所有原型中的都打印出了\n}\n// 此时要使用需给其赋自己的值，因为name等都是继承的\nconsole.log(emp2.name); // conan\nemp2.goHome(); // conan回家\nemp2.name = "lan";\nconsole.log(emp2.name); // lan\nemp2.goHome(); // lan回家\n// 获取属于自己的属性和方法\nconsole.log(Object.getOwnPropertyNames(emp2)); // ["name"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 原型链\n\nclass Employee {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.goHome = function() {\n      console.log(this.name + "回家");\n    };\n  }\n}\nEmployee.prototype.schoolName = "米花小学";\nEmployee.prototype.printInfo = function() {\n  console.log(this.name + " " + this.age + " " + this.schoolName);\n};\n\nvar emp1 = new Employee("conan", 22);\n// Object.create\nvar emp2 = Object.create(emp1);\n\n// 原型链开始\nconsole.log(emp2);\nvar proto1 = Object.getPrototypeOf(emp2);\nconsole.log(proto1); // 原型指向 emp1\nvar proto2 = Object.getPrototypeOf(proto1);\nconsole.log(proto2); // 原型指向 Employee 构造函数\nvar proto3 = Object.getPrototypeOf(proto2);\nconsole.log(proto3); // 原型指向 Object 的原型即 Object.prototype，而不是 Object。我也懵了\nvar proto4 = Object.getPrototypeOf(proto3);\nconsole.log(proto4); // null，即原型链的顶端\n// 也可以通过这个方式获取\n// console.log(Object.prototype);\nconsole.log(Object.getPrototypeOf(Object.prototype)); // null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 修改原型链指向\n\nclass Employee {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.goHome = function() {\n      console.log(this.name + "回家");\n    };\n  }\n}\nEmployee.prototype.schoolName = "米花小学";\nEmployee.prototype.printInfo = function() {\n  console.log(this.name + " " + this.age + " " + this.schoolName);\n};\n\nvar emp1 = new Employee("conan", 22);\n// Object.create\nvar emp2 = Object.create(emp1);\n\n// 修改原型指向\nclass Manager {}\nManager.prototype.department = "技术部";\nObject.setPrototypeOf(emp2, Manager.prototype);\nconsole.log(emp2.department);\nconsole.log(Object.getPrototypeOf(emp2)); // 此时发现其原型已经改变，不再继承emp1\nfor (const key in emp2) {\n  console.log(key); // 只有继承 Manager的属性和自己本身的属性\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# Spread 操作符\n\n将对象或数组的属性分离，扩展为单个项目，克隆\n\nvar post = {\n  id: 1,\n  title: "标题1",\n  content: "内容"\n};\nconsole.log(post); // {id: 1, title: "标题1", content: "内容"}\n\nvar postClone = { ...post };\nconsole.log(postClone); // {id: 1, title: "标题1", content: "内容"}\nconsole.log(post === postClone); // false\n\nvar post2 = {\n  ...post,\n  author: "conanan"\n};\nconsole.log(post2); // {id: 1, title: "标题1", content: "内容", author: "conanan"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nvar arr = [1, 2, 3];\nvar arrClone = [...arr];\nconsole.log(arrClone); // [1, 2, 3]\n\nvar arr2 = [...arr, 4, 5, 6];\nconsole.log(arr2);// [1, 2, 3, 4, 5, 6]\n\n\n1\n2\n3\n4\n5\n6\n\n\nfunction savePost(id, title, content) {\n  console.log("保存了文章：", id, title, content);\n}\nsavePost(...[2, "标题", "内容"]); // 保存了文章： 2 标题 内容\n\n\n1\n2\n3\n4\n\n\n\n# destructuring & rest 解构\n\nvar post = {\n  id: 1,\n  title: "标题1",\n  content: "内容"\n  // comments: null\n};\nvar { id, title, content } = post; // 变量名必须和属性名一致。但可以使用别名\nconsole.log(id, title, content); // 1 "标题1" "内容"\n\nvar { id, title: tit, content: con } = post; // 变量名必须和属性名一致。但可以使用别名\nconsole.log(id, tit, con); // 1 "标题1" "内容"\n\nvar { id, title: tit, comments = "没有评论" } = post; // 使用默认值。需注意null没有默认值，若post对象的注释打开，则下面的打印输出null\nconsole.log(comments); // 没有评论\n\nvar [a, b = 2] = [1];\nconsole.log(a, b); // 1 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可用于解构复杂内容\n\nvar post = {\n  id: 1,\n  title: "标题1",\n  content: "内容",\n  comments: [\n    {\n      userId: 1,\n      comment: "评论1"\n    },\n    {\n      userId: 2,\n      comment: "评论2"\n    },\n    {\n      userId: 3,\n      comment: "评论3"\n    }\n  ]\n};\n\nvar {\n  comments: [, { comment }]\n} = post;\nconsole.log(comment); // 评论2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n获取动态的值\n\nfunction getId(idKey, obj) {\n  let { [idKey]: id } = obj;\n  return id; // id是个别名\n}\nconsole.log(getId("userId", { userId: 3 })); // 3\n\n\n1\n2\n3\n4\n5\n\n\nrest 解构\n\nvar post = {\n  id: 1,\n  title: "标题1",\n  content: "内容",\n  comments: [\n    {\n      userId: 1,\n      comment: "评论1"\n    },\n    {\n      userId: 2,\n      comment: "评论2"\n    },\n    {\n      userId: 3,\n      comment: "评论3"\n    }\n  ]\n};\nvar { comments, ...rest } = post;\nconsole.log(rest); // {id: 1, title: "标题1", content: "内容"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nfunction savePostObj({ id, title, content, ...rest }) {\n  console.log("保存了文章：", id, title, content);\n  console.log(rest);\n}\nsavePostObj({ id: 1, title: "标题1", content: "内容", author: "conanan" });\n// 保存了文章： 1 标题1 内容\n// {author: "conanan"}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 值传递与引用传递\n\n基本类型如 Number 和 Boolean 等按值传递。\n\nArray 和 Object 在函数中按引用（内存地址）传递\n\nString 虽然按引用传递，但是被赋值时重新构造了一个对象，没有修改原来的\n\n以上基本和 Java 一致\n\n\n# call & apply & bind\n\n都可以修改 this 指向\n\n正常情况如下，谁调用则 this 指向谁\n\nvar emp = {\n  id: 1,\n  name: "conan",\n  printInfo: function() {\n    console.log("员工姓名: " + this.name);\n  },\n  department: {\n    name: "技术部",\n    printInfo: function() {\n      console.log("部门名称: " + this.name);\n    }\n  }\n};\nemp.printInfo(); // 员工姓名: conan\nemp.department.printInfo(); // 部门名称: 技术部\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n修改代码后\n\nvar emp = {\n  id: 1,\n  fullName: "conan"\n};\n\nfunction printInfo(dep1, dep2, dep3) {\n  console.log("员工姓名: " + this.fullName, dep1, dep2, dep3);\n}\n// printInfo(); // 员工姓名: undefined undefined undefined undefined\nprintInfo.call(emp, "技术部", "IT事业部", "总裁办公室"); // 员工姓名: conan 技术部 IT事业部 总裁办公室\n// 使用apply可以传递数组\nprintInfo.apply(emp, ["技术部", "IT事业部", "总裁办公室"]); // 员工姓名: conan 技术部 IT事业部 总裁办公室\n// bind和call使用一样，但是返回的是函数，供之后调用\nvar empprintInfo = printInfo.bind(emp, "技术部", "IT事业部", "总裁办公室");\nempprintInfo(); // 员工姓名: conan 技术部 IT事业部 总裁办公室\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',normalizedContent:'# 标准内置对象—object\n\n\n# 创建\n\n// 创建对象 1\nvar employee1 = {\n  name: "conanan",\n  age: 18,\n  position: "程序员",\n  signin: function() {\n    console.log("conanan 打卡上班");\n  }\n};\nconsole.log(employee1.name); // conanan\nemployee1.signin(); // conanan 打卡上班\n\n// 创建对象 2\nvar employee2 = new object();\nemployee2["name"] = "apple54whn";\nemployee2["signin"] = function() {\n  console.log("apple54whn 打卡上班");\n};\nconsole.log(employee2["name"]); // apple54whn\nemployee2.signin(); // apple54whn 打卡上班\nconsole.log(employee2.age); // undefined\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 构造函数创建\n\n// 方式1\nfunction employee1(name, age) {\n  this.name = name;\n  this.age = age;\n  this.signin = () => {\n    console.log(this.name + "去签到");\n  };\n}\n\n// 方式2，使用es2015方式，推荐\nclass employee2 {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.signin = () => {\n      console.log(this.name + "去签到");\n    }\n  }\n}\n\nvar employee1 = new employee1("conanan", 18);\nconsole.log(employee1.name); // conanan\n\nvar employee2 = new employee2("apple54whn", 20);\nconsole.log(employee2.age); // 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# es6 对象字面量增强写法\n\n// new 方式，非字面量\nconst obj1 = new object();\n\nlet name = "conanan";\nlet age = 18;\n\n// es5\nconst obj2 = {\n    name: name,\n    age: age,\n    eat: function () {\n        console.log("eat");\n    },\n};\nconsole.log(obj2);\n\n// es6\nconst obj3 = {\n    name,\n    age,\n    eat() {\n        console.log("eat");\n    },\n};\nconsole.log(obj3);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 属性\n\n\n# 属性的定义和访问\n\n * 直接使用.或[\'key\']定义即可\n\n * 属性值可以使用.或[\'key\']访问\n\n * 属性定义时，若key为一个连接单词，则只能通过\'birty-day\'引号括起来，且访问时也只能用[\'key\']访问。不推荐这样命令，一般采用驼峰命名即可！\n\n * 若属性名和值相同，则可以省略；函数也可以省略成如下：\n   \n   var name = "conanan";\n   var employee3 = {\n     name,\n     signin() {\n       console.log("conanan 打卡");\n     }\n   };\n   console.log(employee3.name); // conanan\n   employee3.signin(); // conanan 打卡\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# 遍历对象属性\n\nvar name = "conanan";\nvar employee3 = {\n  name,\n  signin() {\n    console.log("conanan 打卡");\n  }\n};\n\n// 遍历 1\nconsole.log(object.keys(employee3)); // ["name","signin"]\n// 遍历 2\nfor (const key in employee3) {\n  console.log(key); // 上面的分开输出\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 删除对象属性\n\ndelete employee3.name;\nconsole.log(employee3.name); // undefined\n\n\n1\n2\n\n\n\n# this\n\nvar employee = {\n  fullname: "apple54whn",\n  age: 18,\n  signin: function() {\n    console.log(this.fullname + "上班打卡");\n  }\n};\nemployee.signin(); // conanan上班打卡\n\nemployee.gotowork = function() {\n  console.log(this.fullname + "去上班");\n};\nemployee.gotowork(); // conanan去上班\n\n// 发现问题，且不推荐使用箭头函数定义对象的方法\nemployee.gohome = () => {\n  console.log(this.fullname + "回家"); \n  console.log(this); // 此时this指向的是包裹this对象的作用域对象，此时包裹它的作用域为全局对象，浏览器中为window\n};\nemployee.gohome(); // undefined回家\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n注意使用箭头函数时 this 指向问题。但是定义对象字面量时不推荐使用箭头函数定义方法，应采用普通方法来定义！\n\n// 若定义在构造函数中，则指向包裹this对象的作用域即构造函数\nclass employee2 {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.gohome = function() {\n      console.log(this.name + "回家");\n    };\n    // 能解决问题但不推荐使用箭头函数定义对象的方法\n    this.signin = () => {\n      console.log(this.name + "去签到");\n    };\n  }\n}\nvar emp = new employee2("app", 8);\nemp.signin(); // app去签到\nemp.gohome();// app回家\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# getter & setter\n\n直接使用字面值创建 object 的 getter & setter 定义\n\nvar person = {\n  firstnmae: "三",\n  lastname: "张",\n  get fullname() {\n    return this.lastname + this.firstnmae;\n  },\n  set fullname(fullname) {\n    let [lastname, firstnmae] = fullname.split(",");\n    this.lastname = lastname;\n    this.firstnmae = firstnmae;\n  }\n};\n\nconsole.log(person.fullname); // 张三\nperson.fullname = "李,四";\nconsole.log(person.fullname); // 李四\nconsole.log(person.lastname, person.firstnmae); // 李 四\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n使用构造函数创建的 object 对象的 getter & setter 定义需要使用object.defineproperty()来实现\n\nclass person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\nvar p = new person("app", 8);\nobject.defineproperty(p, "info", {\n  get: function() {\n    return this.name + " " + this.age;\n  },\n  set: function(info) {\n    let [name, age] = info.split(" ");\n    this.name = name;\n    this.age = age;\n  }\n});\n\nconsole.log(p.info); // app 8\np.info = "haha 18";\nconsole.log(p.info); // haha 18\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# __proto__ 原型\n\n类似于java中继承得来的的静态域或静态方法\n\nclass employee {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.gohome = function() {\n      console.log(this.name + "回家");\n    };\n  }\n}\n\nvar emp1 = new employee("conan", 22);\nvar emp2 = new employee("lan", 21);\nconsole.log(emp1);\nconsole.log(emp2);\n// 上述打印的对象都有个“__proto__”属性\n\nemployee.prototype.schoolname = "米花小学";\nemployee.prototype.printinfo = function() {\n  console.log(this.name + " " + this.age + " " + this.schoolname);\n};\nemp1.printinfo(); // conan 22 米花小学\nemp2.printinfo(); // lan 21 米花小学\n\n// 获取对象和类的原型，他们都是一样的\nconsole.log(emp1.__proto__);\nconsole.log(employee.prototype);\nconsole.log(emp1.__proto__ === employee.prototype); // true\nconsole.log(object.getprototypeof(emp2) === employee.prototype); // true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\n\n# object.create\n\n类似继承\n\nclass employee {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.gohome = function() {\n      console.log(this.name + "回家");\n    };\n  }\n}\nemployee.prototype.schoolname = "米花小学";\nemployee.prototype.printinfo = function() {\n  console.log(this.name + " " + this.age + " " + this.schoolname);\n};\n\nvar emp1 = new employee("conan", 22);\nconsole.log(emp1); // 原型中的需在__proto__中查看\nfor (const key in emp1) {\n  console.log(key); // 将所有属性方法，包括原型中的都打印出了\n}\n\n// object.create\nvar emp2 = object.create(emp1);\nconsole.log(emp2); // 因为时继承的，所以从emp1继承的都在__protp__中，且__proto__中还有一个__proto__，是对象的原型\nfor (const key in emp2) {\n  console.log(key); // 将所有属性方法，包括所有原型中的都打印出了\n}\n// 此时要使用需给其赋自己的值，因为name等都是继承的\nconsole.log(emp2.name); // conan\nemp2.gohome(); // conan回家\nemp2.name = "lan";\nconsole.log(emp2.name); // lan\nemp2.gohome(); // lan回家\n// 获取属于自己的属性和方法\nconsole.log(object.getownpropertynames(emp2)); // ["name"]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 原型链\n\nclass employee {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.gohome = function() {\n      console.log(this.name + "回家");\n    };\n  }\n}\nemployee.prototype.schoolname = "米花小学";\nemployee.prototype.printinfo = function() {\n  console.log(this.name + " " + this.age + " " + this.schoolname);\n};\n\nvar emp1 = new employee("conan", 22);\n// object.create\nvar emp2 = object.create(emp1);\n\n// 原型链开始\nconsole.log(emp2);\nvar proto1 = object.getprototypeof(emp2);\nconsole.log(proto1); // 原型指向 emp1\nvar proto2 = object.getprototypeof(proto1);\nconsole.log(proto2); // 原型指向 employee 构造函数\nvar proto3 = object.getprototypeof(proto2);\nconsole.log(proto3); // 原型指向 object 的原型即 object.prototype，而不是 object。我也懵了\nvar proto4 = object.getprototypeof(proto3);\nconsole.log(proto4); // null，即原型链的顶端\n// 也可以通过这个方式获取\n// console.log(object.prototype);\nconsole.log(object.getprototypeof(object.prototype)); // null\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 修改原型链指向\n\nclass employee {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n    this.gohome = function() {\n      console.log(this.name + "回家");\n    };\n  }\n}\nemployee.prototype.schoolname = "米花小学";\nemployee.prototype.printinfo = function() {\n  console.log(this.name + " " + this.age + " " + this.schoolname);\n};\n\nvar emp1 = new employee("conan", 22);\n// object.create\nvar emp2 = object.create(emp1);\n\n// 修改原型指向\nclass manager {}\nmanager.prototype.department = "技术部";\nobject.setprototypeof(emp2, manager.prototype);\nconsole.log(emp2.department);\nconsole.log(object.getprototypeof(emp2)); // 此时发现其原型已经改变，不再继承emp1\nfor (const key in emp2) {\n  console.log(key); // 只有继承 manager的属性和自己本身的属性\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# spread 操作符\n\n将对象或数组的属性分离，扩展为单个项目，克隆\n\nvar post = {\n  id: 1,\n  title: "标题1",\n  content: "内容"\n};\nconsole.log(post); // {id: 1, title: "标题1", content: "内容"}\n\nvar postclone = { ...post };\nconsole.log(postclone); // {id: 1, title: "标题1", content: "内容"}\nconsole.log(post === postclone); // false\n\nvar post2 = {\n  ...post,\n  author: "conanan"\n};\nconsole.log(post2); // {id: 1, title: "标题1", content: "内容", author: "conanan"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\nvar arr = [1, 2, 3];\nvar arrclone = [...arr];\nconsole.log(arrclone); // [1, 2, 3]\n\nvar arr2 = [...arr, 4, 5, 6];\nconsole.log(arr2);// [1, 2, 3, 4, 5, 6]\n\n\n1\n2\n3\n4\n5\n6\n\n\nfunction savepost(id, title, content) {\n  console.log("保存了文章：", id, title, content);\n}\nsavepost(...[2, "标题", "内容"]); // 保存了文章： 2 标题 内容\n\n\n1\n2\n3\n4\n\n\n\n# destructuring & rest 解构\n\nvar post = {\n  id: 1,\n  title: "标题1",\n  content: "内容"\n  // comments: null\n};\nvar { id, title, content } = post; // 变量名必须和属性名一致。但可以使用别名\nconsole.log(id, title, content); // 1 "标题1" "内容"\n\nvar { id, title: tit, content: con } = post; // 变量名必须和属性名一致。但可以使用别名\nconsole.log(id, tit, con); // 1 "标题1" "内容"\n\nvar { id, title: tit, comments = "没有评论" } = post; // 使用默认值。需注意null没有默认值，若post对象的注释打开，则下面的打印输出null\nconsole.log(comments); // 没有评论\n\nvar [a, b = 2] = [1];\nconsole.log(a, b); // 1 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n可用于解构复杂内容\n\nvar post = {\n  id: 1,\n  title: "标题1",\n  content: "内容",\n  comments: [\n    {\n      userid: 1,\n      comment: "评论1"\n    },\n    {\n      userid: 2,\n      comment: "评论2"\n    },\n    {\n      userid: 3,\n      comment: "评论3"\n    }\n  ]\n};\n\nvar {\n  comments: [, { comment }]\n} = post;\nconsole.log(comment); // 评论2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n获取动态的值\n\nfunction getid(idkey, obj) {\n  let { [idkey]: id } = obj;\n  return id; // id是个别名\n}\nconsole.log(getid("userid", { userid: 3 })); // 3\n\n\n1\n2\n3\n4\n5\n\n\nrest 解构\n\nvar post = {\n  id: 1,\n  title: "标题1",\n  content: "内容",\n  comments: [\n    {\n      userid: 1,\n      comment: "评论1"\n    },\n    {\n      userid: 2,\n      comment: "评论2"\n    },\n    {\n      userid: 3,\n      comment: "评论3"\n    }\n  ]\n};\nvar { comments, ...rest } = post;\nconsole.log(rest); // {id: 1, title: "标题1", content: "内容"}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nfunction savepostobj({ id, title, content, ...rest }) {\n  console.log("保存了文章：", id, title, content);\n  console.log(rest);\n}\nsavepostobj({ id: 1, title: "标题1", content: "内容", author: "conanan" });\n// 保存了文章： 1 标题1 内容\n// {author: "conanan"}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 值传递与引用传递\n\n基本类型如 number 和 boolean 等按值传递。\n\narray 和 object 在函数中按引用（内存地址）传递\n\nstring 虽然按引用传递，但是被赋值时重新构造了一个对象，没有修改原来的\n\n以上基本和 java 一致\n\n\n# call & apply & bind\n\n都可以修改 this 指向\n\n正常情况如下，谁调用则 this 指向谁\n\nvar emp = {\n  id: 1,\n  name: "conan",\n  printinfo: function() {\n    console.log("员工姓名: " + this.name);\n  },\n  department: {\n    name: "技术部",\n    printinfo: function() {\n      console.log("部门名称: " + this.name);\n    }\n  }\n};\nemp.printinfo(); // 员工姓名: conan\nemp.department.printinfo(); // 部门名称: 技术部\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n修改代码后\n\nvar emp = {\n  id: 1,\n  fullname: "conan"\n};\n\nfunction printinfo(dep1, dep2, dep3) {\n  console.log("员工姓名: " + this.fullname, dep1, dep2, dep3);\n}\n// printinfo(); // 员工姓名: undefined undefined undefined undefined\nprintinfo.call(emp, "技术部", "it事业部", "总裁办公室"); // 员工姓名: conan 技术部 it事业部 总裁办公室\n// 使用apply可以传递数组\nprintinfo.apply(emp, ["技术部", "it事业部", "总裁办公室"]); // 员工姓名: conan 技术部 it事业部 总裁办公室\n// bind和call使用一样，但是返回的是函数，供之后调用\nvar empprintinfo = printinfo.bind(emp, "技术部", "it事业部", "总裁办公室");\nempprintinfo(); // 员工姓名: conan 技术部 it事业部 总裁办公室\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"3 标准内置对象-2 String",frontmatter:{title:"3 标准内置对象-2 String",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/b412ad/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/305.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-2String.html",relativePath:"1200.JS/300.语法/305.标准内置对象-2String.md",key:"v-25e5648a",path:"/pages/b412ad/",headers:[{level:2,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:20},{level:2,title:"遍历",slug:"遍历",normalizedTitle:"遍历",charIndex:253},{level:2,title:"切片",slug:"切片",normalizedTitle:"切片",charIndex:507},{level:2,title:"拼接",slug:"拼接",normalizedTitle:"拼接",charIndex:1254},{level:2,title:"大小写转换",slug:"大小写转换",normalizedTitle:"大小写转换",charIndex:1407},{level:2,title:"去首尾空格",slug:"去首尾空格",normalizedTitle:"去首尾空格",charIndex:1523},{level:2,title:"模版字符串",slug:"模版字符串",normalizedTitle:"模版字符串",charIndex:1577},{level:2,title:"匹配",slug:"匹配",normalizedTitle:"匹配",charIndex:2168},{level:2,title:"未完",slug:"未完",normalizedTitle:"未完",charIndex:2213}],headersStr:"定义 遍历 切片 拼接 大小写转换 去首尾空格 模版字符串 匹配 未完",content:'# 标准内置对象—String\n\n\n# 定义\n\nvar str1 = "hello";\nconsole.log(str1); // hello\n\nvar str2 = new String("world");\nconsole.log(str2); // String {"world"}\n\n// 转义字符 \\\nvar str3 = "hello\\\\\\nworld";\nconsole.log(str3);\n// hello\\\n// world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 遍历\n\nvar str1 = "hello";\nfor (let index = 0; index < str1.length; index++) {\n  console.log(str1[index]);\n}\n\nfor (const iterator of str1) {\n  console.log(iterator);\n}\n\nfor (const key in str1) {\n  console.log(str1[key]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 切片\n\n和数组一样，推荐使用splice。不改变原有字符串\n\nvar str1 = "hello world";\nconsole.log(str1.slice(1, 4)); // ell，第二个值是索引值，左闭右开\nconsole.log(str1.slice(4)); // o world\nconsole.log(str1.slice(6, -2)); // wor\nconsole.log(str1.slice(-7, -2)); // o wor\nconsole.log(str1.slice(7, 1)); // 空字符串\n\n//------------------------------\n// 1 表示子字符串开头的从零开始的索引号。\n// 2 表示子字符串结束的从零开始的索引号。子字符串包括字符到end所表示的字符，但不包括end所表示的字符。如果省略end，则返回原始字符串从开始到结束的所有字符。\nconsole.log(str1.substring(1, 4)); // ell，第二个值是索引值，左闭右开\nconsole.log(str1.substring(4)); // o world\nconsole.log(str1.substring(6, -2)); // hello[ ]，不接收负数，负数转为0，左边大于右边则替换，即 0,6\nconsole.log(str1.substring(-7, -2)); // 空字符串，不接收负数，都转为 0\nconsole.log(str1.substring(7, 1)); // ello w，左边大于右边则替换，即 1,7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 拼接\n\nMDN 推荐使用+性能好。不改变原有字符串\n\nvar str1 = "hello";\nvar str2 = "world";\nconsole.log(str1 + str2);\nconsole.log(str1.concat(str2).concat("hh"));\n\n\n1\n2\n3\n4\n\n\n\n# 大小写转换\n\n不改变原有字符串\n\nvar str1 = "hello";\nconsole.log(str1.toUpperCase());\nconsole.log(str1.toLowerCase());\n\n\n1\n2\n3\n\n\n\n# 去首尾空格\n\nconsole.log(" hello world  ".trim());\n\n\n1\n\n\n\n# 模版字符串\n\n按原样输出\n\nvar longStr = `sfsfafasfsfsf  sfsf ssfsfas safa as as\nasfsfsafasfsa fsf \nasfsa fsa \nsafsf `;\nconsole.log(longStr);\n\n\n1\n2\n3\n4\n5\n\n\n支持变量占位符\n\nvar str = `hello,${name}`;\nvar name = "conan";\nconsole.log(str); // hello,conan\n\n\n1\n2\n3\n\n\n类似React中用法\n\nfunction greeting(strings, gender) {\n  let genderStr = "";\n  if (gender === "M") {\n    genderStr = "先生";\n  } else if (gender === "F") {\n    genderStr = "女士";\n  }\n  return `${strings[0]}${genderStr}`;\n}\nvar gender = "M";\nvar result = greeting`hello,conan${gender}`;\nconsole.log(result); // hello,conan先生\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 匹配\n\n * match(reg)：根据正则匹配，返回匹配的内容（数组表示多条）\n\n\n# 未完',normalizedContent:'# 标准内置对象—string\n\n\n# 定义\n\nvar str1 = "hello";\nconsole.log(str1); // hello\n\nvar str2 = new string("world");\nconsole.log(str2); // string {"world"}\n\n// 转义字符 \\\nvar str3 = "hello\\\\\\nworld";\nconsole.log(str3);\n// hello\\\n// world\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 遍历\n\nvar str1 = "hello";\nfor (let index = 0; index < str1.length; index++) {\n  console.log(str1[index]);\n}\n\nfor (const iterator of str1) {\n  console.log(iterator);\n}\n\nfor (const key in str1) {\n  console.log(str1[key]);\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 切片\n\n和数组一样，推荐使用splice。不改变原有字符串\n\nvar str1 = "hello world";\nconsole.log(str1.slice(1, 4)); // ell，第二个值是索引值，左闭右开\nconsole.log(str1.slice(4)); // o world\nconsole.log(str1.slice(6, -2)); // wor\nconsole.log(str1.slice(-7, -2)); // o wor\nconsole.log(str1.slice(7, 1)); // 空字符串\n\n//------------------------------\n// 1 表示子字符串开头的从零开始的索引号。\n// 2 表示子字符串结束的从零开始的索引号。子字符串包括字符到end所表示的字符，但不包括end所表示的字符。如果省略end，则返回原始字符串从开始到结束的所有字符。\nconsole.log(str1.substring(1, 4)); // ell，第二个值是索引值，左闭右开\nconsole.log(str1.substring(4)); // o world\nconsole.log(str1.substring(6, -2)); // hello[ ]，不接收负数，负数转为0，左边大于右边则替换，即 0,6\nconsole.log(str1.substring(-7, -2)); // 空字符串，不接收负数，都转为 0\nconsole.log(str1.substring(7, 1)); // ello w，左边大于右边则替换，即 1,7\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 拼接\n\nmdn 推荐使用+性能好。不改变原有字符串\n\nvar str1 = "hello";\nvar str2 = "world";\nconsole.log(str1 + str2);\nconsole.log(str1.concat(str2).concat("hh"));\n\n\n1\n2\n3\n4\n\n\n\n# 大小写转换\n\n不改变原有字符串\n\nvar str1 = "hello";\nconsole.log(str1.touppercase());\nconsole.log(str1.tolowercase());\n\n\n1\n2\n3\n\n\n\n# 去首尾空格\n\nconsole.log(" hello world  ".trim());\n\n\n1\n\n\n\n# 模版字符串\n\n按原样输出\n\nvar longstr = `sfsfafasfsfsf  sfsf ssfsfas safa as as\nasfsfsafasfsa fsf \nasfsa fsa \nsafsf `;\nconsole.log(longstr);\n\n\n1\n2\n3\n4\n5\n\n\n支持变量占位符\n\nvar str = `hello,${name}`;\nvar name = "conan";\nconsole.log(str); // hello,conan\n\n\n1\n2\n3\n\n\n类似react中用法\n\nfunction greeting(strings, gender) {\n  let genderstr = "";\n  if (gender === "m") {\n    genderstr = "先生";\n  } else if (gender === "f") {\n    genderstr = "女士";\n  }\n  return `${strings[0]}${genderstr}`;\n}\nvar gender = "m";\nvar result = greeting`hello,conan${gender}`;\nconsole.log(result); // hello,conan先生\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 匹配\n\n * match(reg)：根据正则匹配，返回匹配的内容（数组表示多条）\n\n\n# 未完',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"3 标准内置对象-3 Array",frontmatter:{title:"3 标准内置对象-3 Array",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/e7e591/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/306.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-3Array.html",relativePath:"1200.JS/300.语法/306.标准内置对象-3Array.md",key:"v-e5df6596",path:"/pages/e7e591/",headers:[{level:2,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:39},{level:2,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:312},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:848},{level:3,title:"遍历 & 取值",slug:"遍历-取值",normalizedTitle:"遍历 &amp; 取值",charIndex:null},{level:3,title:"添加",slug:"添加",normalizedTitle:"添加",charIndex:953},{level:3,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:994},{level:3,title:"反转、分割、拼接、连接",slug:"反转、分割、拼接、连接",normalizedTitle:"反转、分割、拼接、连接",charIndex:2566},{level:3,title:"排序",slug:"排序",normalizedTitle:"排序",charIndex:3444},{level:3,title:"slice 切片",slug:"slice-切片",normalizedTitle:"slice 切片",charIndex:3719},{level:3,title:"map & reduce & filter",slug:"map-reduce-filter",normalizedTitle:"map &amp; reduce &amp; filter",charIndex:null},{level:3,title:"every some 条件测试",slug:"every-some-条件测试",normalizedTitle:"every some 条件测试",charIndex:5295},{level:3,title:"destructuring 解构",slug:"destructuring-解构",normalizedTitle:"destructuring 解构",charIndex:5699},{level:3,title:"rest 解构",slug:"rest-解构",normalizedTitle:"rest 解构",charIndex:6405}],headersStr:"创建 属性 方法 遍历 & 取值 添加 删除 反转、分割、拼接、连接 排序 slice 切片 map & reduce & filter every some 条件测试 destructuring 解构 rest 解构",content:'# 标准内置对象—Array\n\n数组对象，继承自iterable类型\n\n\n# 创建\n\n总共四种方式\n\n// 下面4种打印值都一样\nvar arr1 = [1, 2, 3];\nconsole.log(arr1);\n\nvar arr2 = new Array(1, 2, 3);\nconsole.log(arr2);\n\nvar arr3 = Array(1, 2, 3);\nconsole.log(arr3);\n\nvar arr4 = Array.of(1, 2, 3);\nconsole.log(arr4);\n// ======================================\n// 下面打印的都是lenght属性值为5的空数组\nvar arr5 = new Array(5);\nconsole.log(arr5);\n\nvar arr6 = Array(5);\nconsole.log(arr6);\n// 下面才可以创建单个值的数组\nvar arr7 = [5];\nconsole.log(arr7);\n\nvar arr8 = Array.of(5);\nconsole.log(arr8);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n多维数组\n\nvar arr = [];\nfor (let i = 0; i < 5; i++) {\n  arr[i] = [];\n  for (let j = 0; j < 4; j++) {\n    arr[i][j] = i + j;\n  }\n}\nconsole.log(arr); // 5*4二维数组\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 属性\n\n * length：数组的长度=最大角标+1\n   \n   与 Java 不同的是数组长度可变可以设置值为 0从而清空，数组元素的类型可变；Java 中是final长度不可修改\n\n\n# 方法\n\n\n# 遍历 & 取值\n\n * 借助length\n\n * 使用for ... in遍历的是属性。对于数组遍历其 length，也可以便利属性的 key\n\n * 使用for ... of遍历的是值，ES6 添加的方法，只用来遍历iterable类型\n\n * peek()取最后一个元素，不删除\n\n * forEach\n   \n   var arr1 = [1, 2, 3];\n   \n   for (let index = 0; index < arr1.length; index++) {\n     const element = arr1[index];\n     console.log(element);\n   }\n   \n   for (const index in arr1) {\n     if (arr1.hasOwnProperty(index)) {\n       const element = arr1[index];\n       console.log(element);\n     }\n   }\n   \n   for (const iterator of arr1) {\n     console.log(iterator);\n   }\n   \n   // self 为数组本身\n   arr1.forEach((element, index, self) => {\n     console.log(element, index, self);\n   });\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 添加\n\n * 直接访问不存在的数组下标，即可在该下标添加元素，其他空的为undefined，如arr[99]=5\n\n * push()：向数组的末尾添加一个或更多元素，并返回新的长度。栈模式（FILO）\n   \n   如果添加的是一个数组，这个时候把数组当做一个整体字符串添加进去，类似 java 中的 add\n\n * unshift(num...)：向数组前面添加元素，可多个\n   \n   var arr1 = [1, 2, 3];\n   var arr2 = [4, 5, 6];\n   \n   console.log(arr1.push(4)); // 4（长度）\n   console.log(arr1.pop()); // 4（值）\n   console.log(arr1.push(arr2)); // 4（长度）\n   console.log(arr1); // [1, 2, 3, Array(3)]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n\n# 删除\n\n * 通过length属性，可以截断数组甚至清空\n\n * splice(index,n[, num...])：从 index 位置开始删除 n 个元素，并添加任意个元素，index 为 0 时为添加元素\n   \n   它可以进行增删改操作！\n   \n   var arr1 = [1, 2, 3];\n   console.log(arr1); // [1,2,3]\n   \n   arr1.splice(0, 0, -1, 0);\n   console.log(arr1); // [-1,0,1,2,3]\n   \n   arr1.splice(1, 2, 6, 7, 8);\n   console.log(arr1); // [-1,6,7,8,2,3]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * pop()：删除最后一个元素，返回删除的那个元素。栈模式（FILO）\n\n * shift()：删除第一个元素，返回删除的那个元素。队列模式（FIFO）\n\n\n# 反转、分割、拼接、连接\n\n * reverse()：颠倒数组中的元素的顺序，改变原有数组顺序。\n\n * split(参数)：将字符串按照指定的分隔符分割为数组，不传参则整个字符串变为数组，原有字符串不变\n\n * join(参数)：将数组中的元素按照指定的分隔符拼接为字符串。不传参数默认按,拼接，不改变原数组\n\n * concat：数组的连接，类似 Java 中的 addAll，但是不改变原数组\n   \n   var s = "hello world";\n   console.log(s); // hello world\n   \n   // 此处没改变原数组顺序是由于split()函数不改变顺序，所以需要用变量接收\n   var ss = s\n     .split("")\n     .reverse()\n     .join("");\n   console.log(ss); // dlrow olleh\n   \n   var arr1 = [1, 2, 3];\n   arr1.reverse();\n   console.log(arr1); // [3,2,1]\n   \n   var str = "1,2,3";\n   console.log(str.split(",")); // ["1","2","3"]\n   \n   var arr1 = [5, 1, 2, 3];\n   var arr2 = [5, 2, 7];\n   var arr3 = arr1.concat(arr2);\n   console.log(arr1); // [5, 1, 2, 3]\n   console.log(arr3); // [5, 1, 2, 3, 5, 2, 7]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 排序\n\n * sort()，默认升序。改变原数组\n   \n   var arr1 = [5, 1, 2, 3];\n   arr1.sort();\n   console.log(arr1); // [1,2,3,5]\n   \n   arr1.sort((a, b) => {\n     return b - a; // 数字可以直接减，但是其他的都得比较\n   });\n   console.log(arr1); // [5,3,2,1]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# slice 切片\n\n * slice()，和splice()单词删除很像\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   console.log(arr1.slice(1, 2)); // [2]，第二个参数为索引，不是长度\n   console.log(arr1.slice(1, -2)); // [2,3]，第二个参数负数时代表倒数第几个，从-1开始，还是左闭右开\n   console.log(arr1.slice(1)); // [2,3,4,5]，第二个参数不传递则到尾部\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# map & reduce & filter\n\n * map，原数组不变\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var arr2 = arr1.map((item, index, arr) => {\n     return item * 2;\n   });\n   console.log(arr2); // [2,4,6,8,10]\n   // 简写 item=> item*2\n   var arr3 = arr1.map(item => item * 2);\n   console.log(arr3);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * reduce，归纳（用于汇总），原数组不变\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var arr2 = arr1.reduce((previous, current, index, arr1) => {\n       return previous + current;\n   });\n   console.log(arr2); // 15\n   //==========================================================\n   // 0为初始值\n   var arr3 = arr1.reduce((previous, current, index, arr1) => {\n       return previous + current;\n   }, 0);\n   console.log(arr3); // 15\n   //==========================================================\n   // 注意reduce对象\n   return this.books.reduce((previous, current, index, arr) => {\n       return previous + current.price * current.count;\n   }, 0);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * filter，过滤，返回 boolean 值，为 true 的当前值才能保留，原数组不变\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var arr2 = arr1.filter((item, index, arr1) => {\n     return item % 2 === 0;\n   });\n   console.log(arr2); // [2,4]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# every some 条件测试\n\n * every ，some\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var b1 = arr1.every((item, index, arr1) => {\n     return item > 1;\n   });\n   console.log(b1); // false，所有都得大于1\n   //===================================\n   var b2 = arr1.some((item, index, arr) => {\n     return item >= 5;\n   });\n   console.log(b2); // true，只要有一个大于等于5\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n\n# destructuring 解构\n\n * 构造数组的反向操作\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var [a1, b1] = arr1;\n   var [a2, b2, c2, d2, e2] = arr1;\n   var [a3, b3, c3, d3, e3, f3] = arr1;\n   var [, b4] = arr1;\n   var [, b4, , d4] = arr1;\n   \n   console.log(a1); // 1\n   console.log(e2); // 5\n   console.log(f3); // undefined\n   console.log(b4, d4); // 2 4\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   可用于接受返回多个参数数组的方法并解构\n   \n   function multipleReturns() {\n     let name = "conanan";\n     let age = 18;\n     return [name, age];\n   }\n   var [myName, myAge] = multipleReturns();\n   console.log(myName); // conanan\n   console.log(myAge); // 18\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# rest 解构\n\n * 接收多个参数\n   \n   var arr = [1, 2, 3, 4, 5];\n   \n   var [a1, b1, ...arr1] = arr;\n   console.log(a1); // 1\n   console.log(arr1); // [3,4,5]\n   \n   var [a2, , c2, ...arr2] = arr;\n   console.log(c2); // 3\n   console.log(arr2); // [4,5]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   可用于函数接收不确定个数参数\n   \n   function multipleParams(...arr) {\n     console.log(arr);\n   }\n   multipleParams(1, 2, 3); //[1,2,3]\n   \n   \n   1\n   2\n   3\n   4\n   ',normalizedContent:'# 标准内置对象—array\n\n数组对象，继承自iterable类型\n\n\n# 创建\n\n总共四种方式\n\n// 下面4种打印值都一样\nvar arr1 = [1, 2, 3];\nconsole.log(arr1);\n\nvar arr2 = new array(1, 2, 3);\nconsole.log(arr2);\n\nvar arr3 = array(1, 2, 3);\nconsole.log(arr3);\n\nvar arr4 = array.of(1, 2, 3);\nconsole.log(arr4);\n// ======================================\n// 下面打印的都是lenght属性值为5的空数组\nvar arr5 = new array(5);\nconsole.log(arr5);\n\nvar arr6 = array(5);\nconsole.log(arr6);\n// 下面才可以创建单个值的数组\nvar arr7 = [5];\nconsole.log(arr7);\n\nvar arr8 = array.of(5);\nconsole.log(arr8);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n多维数组\n\nvar arr = [];\nfor (let i = 0; i < 5; i++) {\n  arr[i] = [];\n  for (let j = 0; j < 4; j++) {\n    arr[i][j] = i + j;\n  }\n}\nconsole.log(arr); // 5*4二维数组\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 属性\n\n * length：数组的长度=最大角标+1\n   \n   与 java 不同的是数组长度可变可以设置值为 0从而清空，数组元素的类型可变；java 中是final长度不可修改\n\n\n# 方法\n\n\n# 遍历 & 取值\n\n * 借助length\n\n * 使用for ... in遍历的是属性。对于数组遍历其 length，也可以便利属性的 key\n\n * 使用for ... of遍历的是值，es6 添加的方法，只用来遍历iterable类型\n\n * peek()取最后一个元素，不删除\n\n * foreach\n   \n   var arr1 = [1, 2, 3];\n   \n   for (let index = 0; index < arr1.length; index++) {\n     const element = arr1[index];\n     console.log(element);\n   }\n   \n   for (const index in arr1) {\n     if (arr1.hasownproperty(index)) {\n       const element = arr1[index];\n       console.log(element);\n     }\n   }\n   \n   for (const iterator of arr1) {\n     console.log(iterator);\n   }\n   \n   // self 为数组本身\n   arr1.foreach((element, index, self) => {\n     console.log(element, index, self);\n   });\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 添加\n\n * 直接访问不存在的数组下标，即可在该下标添加元素，其他空的为undefined，如arr[99]=5\n\n * push()：向数组的末尾添加一个或更多元素，并返回新的长度。栈模式（filo）\n   \n   如果添加的是一个数组，这个时候把数组当做一个整体字符串添加进去，类似 java 中的 add\n\n * unshift(num...)：向数组前面添加元素，可多个\n   \n   var arr1 = [1, 2, 3];\n   var arr2 = [4, 5, 6];\n   \n   console.log(arr1.push(4)); // 4（长度）\n   console.log(arr1.pop()); // 4（值）\n   console.log(arr1.push(arr2)); // 4（长度）\n   console.log(arr1); // [1, 2, 3, array(3)]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n\n# 删除\n\n * 通过length属性，可以截断数组甚至清空\n\n * splice(index,n[, num...])：从 index 位置开始删除 n 个元素，并添加任意个元素，index 为 0 时为添加元素\n   \n   它可以进行增删改操作！\n   \n   var arr1 = [1, 2, 3];\n   console.log(arr1); // [1,2,3]\n   \n   arr1.splice(0, 0, -1, 0);\n   console.log(arr1); // [-1,0,1,2,3]\n   \n   arr1.splice(1, 2, 6, 7, 8);\n   console.log(arr1); // [-1,6,7,8,2,3]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * pop()：删除最后一个元素，返回删除的那个元素。栈模式（filo）\n\n * shift()：删除第一个元素，返回删除的那个元素。队列模式（fifo）\n\n\n# 反转、分割、拼接、连接\n\n * reverse()：颠倒数组中的元素的顺序，改变原有数组顺序。\n\n * split(参数)：将字符串按照指定的分隔符分割为数组，不传参则整个字符串变为数组，原有字符串不变\n\n * join(参数)：将数组中的元素按照指定的分隔符拼接为字符串。不传参数默认按,拼接，不改变原数组\n\n * concat：数组的连接，类似 java 中的 addall，但是不改变原数组\n   \n   var s = "hello world";\n   console.log(s); // hello world\n   \n   // 此处没改变原数组顺序是由于split()函数不改变顺序，所以需要用变量接收\n   var ss = s\n     .split("")\n     .reverse()\n     .join("");\n   console.log(ss); // dlrow olleh\n   \n   var arr1 = [1, 2, 3];\n   arr1.reverse();\n   console.log(arr1); // [3,2,1]\n   \n   var str = "1,2,3";\n   console.log(str.split(",")); // ["1","2","3"]\n   \n   var arr1 = [5, 1, 2, 3];\n   var arr2 = [5, 2, 7];\n   var arr3 = arr1.concat(arr2);\n   console.log(arr1); // [5, 1, 2, 3]\n   console.log(arr3); // [5, 1, 2, 3, 5, 2, 7]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   \n\n\n# 排序\n\n * sort()，默认升序。改变原数组\n   \n   var arr1 = [5, 1, 2, 3];\n   arr1.sort();\n   console.log(arr1); // [1,2,3,5]\n   \n   arr1.sort((a, b) => {\n     return b - a; // 数字可以直接减，但是其他的都得比较\n   });\n   console.log(arr1); // [5,3,2,1]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# slice 切片\n\n * slice()，和splice()单词删除很像\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   console.log(arr1.slice(1, 2)); // [2]，第二个参数为索引，不是长度\n   console.log(arr1.slice(1, -2)); // [2,3]，第二个参数负数时代表倒数第几个，从-1开始，还是左闭右开\n   console.log(arr1.slice(1)); // [2,3,4,5]，第二个参数不传递则到尾部\n   \n   \n   1\n   2\n   3\n   4\n   \n\n\n# map & reduce & filter\n\n * map，原数组不变\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var arr2 = arr1.map((item, index, arr) => {\n     return item * 2;\n   });\n   console.log(arr2); // [2,4,6,8,10]\n   // 简写 item=> item*2\n   var arr3 = arr1.map(item => item * 2);\n   console.log(arr3);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n * reduce，归纳（用于汇总），原数组不变\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var arr2 = arr1.reduce((previous, current, index, arr1) => {\n       return previous + current;\n   });\n   console.log(arr2); // 15\n   //==========================================================\n   // 0为初始值\n   var arr3 = arr1.reduce((previous, current, index, arr1) => {\n       return previous + current;\n   }, 0);\n   console.log(arr3); // 15\n   //==========================================================\n   // 注意reduce对象\n   return this.books.reduce((previous, current, index, arr) => {\n       return previous + current.price * current.count;\n   }, 0);\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   \n\n * filter，过滤，返回 boolean 值，为 true 的当前值才能保留，原数组不变\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var arr2 = arr1.filter((item, index, arr1) => {\n     return item % 2 === 0;\n   });\n   console.log(arr2); // [2,4]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# every some 条件测试\n\n * every ，some\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var b1 = arr1.every((item, index, arr1) => {\n     return item > 1;\n   });\n   console.log(b1); // false，所有都得大于1\n   //===================================\n   var b2 = arr1.some((item, index, arr) => {\n     return item >= 5;\n   });\n   console.log(b2); // true，只要有一个大于等于5\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   \n\n\n# destructuring 解构\n\n * 构造数组的反向操作\n   \n   var arr1 = [1, 2, 3, 4, 5];\n   var [a1, b1] = arr1;\n   var [a2, b2, c2, d2, e2] = arr1;\n   var [a3, b3, c3, d3, e3, f3] = arr1;\n   var [, b4] = arr1;\n   var [, b4, , d4] = arr1;\n   \n   console.log(a1); // 1\n   console.log(e2); // 5\n   console.log(f3); // undefined\n   console.log(b4, d4); // 2 4\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   \n   \n   可用于接受返回多个参数数组的方法并解构\n   \n   function multiplereturns() {\n     let name = "conanan";\n     let age = 18;\n     return [name, age];\n   }\n   var [myname, myage] = multiplereturns();\n   console.log(myname); // conanan\n   console.log(myage); // 18\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   \n\n\n# rest 解构\n\n * 接收多个参数\n   \n   var arr = [1, 2, 3, 4, 5];\n   \n   var [a1, b1, ...arr1] = arr;\n   console.log(a1); // 1\n   console.log(arr1); // [3,4,5]\n   \n   var [a2, , c2, ...arr2] = arr;\n   console.log(c2); // 3\n   console.log(arr2); // [4,5]\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n   \n   可用于函数接收不确定个数参数\n   \n   function multipleparams(...arr) {\n     console.log(arr);\n   }\n   multipleparams(1, 2, 3); //[1,2,3]\n   \n   \n   1\n   2\n   3\n   4\n   ',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"3 标准内置对象-4 RegExp",frontmatter:{title:"3 标准内置对象-4 RegExp",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/267da2/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/307.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-4RegExp.html",relativePath:"1200.JS/300.语法/307.标准内置对象-4RegExp.md",key:"v-693092bb",path:"/pages/267da2/",headers:[{level:2,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:20},{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:49},{level:2,title:"规则",slug:"规则",normalizedTitle:"规则",charIndex:38},{level:3,title:"单个字符",slug:"单个字符",normalizedTitle:"单个字符",charIndex:930},{level:3,title:"量词符号",slug:"量词符号",normalizedTitle:"量词符号",charIndex:1048},{level:3,title:"开始结束符号",slug:"开始结束符号",normalizedTitle:"开始结束符号",charIndex:1166}],headersStr:"创建 使用 规则 单个字符 量词符号 开始结束符号",content:'# 标准内置对象—RegExp\n\n\n# 创建\n\n正则表达式：定义字符串的组成规则\n\n * 字面量（使用多）\n   \n   var reg = /正则表达式/;\n   \n   \n   1\n   \n\n * 利用 RegExp 对象，需要注意字符串中的转义字符\n   \n   var reg = new RegExp("正则表达式");\n   \n   \n   1\n   \n\n\n# 使用\n\n * test(str)：验证指定的字符串是否符合正则定义的规范，返回 boolean 值\n\n * exec(str)：返回匹配到的第一个的内容。只有给正则后添加g并多次调用即可多次匹配！\n   \n   var str = "where when what";\n   var reg = /wha/;\n   var reg2 = /wh/g;\n   \n   console.log(reg.exec(str)); // ["wha", index: 11, input: "where when what", groups: undefined]\n   \n   console.log(reg2.exec(str)); // ["wh", index: 0, input: "where when what", groups: undefined]\n   console.log(reg2.exec(str)); // ["wh", index: 6, input: "where when what", groups: undefined]\n   console.log(reg2.exec(str)); // ["wh", index: 11, input: "where when what", groups: undefined]\n   console.log(reg2.exec(str)); // null\n   \n   console.log(reg.test(str)); // true\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 规则\n\n\n# 单个字符\n\n如 a、ab(a或b)、a~zA~Z0~9_。特殊符号代表特殊含义的单个字符：\n\n * .：单个任意字符\n * \\d：单个数字字符0~9\n * \\w：单个单词字符a~zA~Z0~9_\n * \\s：单个如空格、换行符\n\n\n# 量词符号\n\n * ?：表示出现0次或1次\n * *：表示出现0次或多次\n * +：出现1次或多次\n * {m,n}：表示 m<= 数量 <= n\n   * m如果缺省： {,n}最多n次\n   * n如果缺省：{m,}最少m次\n\n\n# 开始结束符号\n\n * ^：开始\n * $：结束',normalizedContent:'# 标准内置对象—regexp\n\n\n# 创建\n\n正则表达式：定义字符串的组成规则\n\n * 字面量（使用多）\n   \n   var reg = /正则表达式/;\n   \n   \n   1\n   \n\n * 利用 regexp 对象，需要注意字符串中的转义字符\n   \n   var reg = new regexp("正则表达式");\n   \n   \n   1\n   \n\n\n# 使用\n\n * test(str)：验证指定的字符串是否符合正则定义的规范，返回 boolean 值\n\n * exec(str)：返回匹配到的第一个的内容。只有给正则后添加g并多次调用即可多次匹配！\n   \n   var str = "where when what";\n   var reg = /wha/;\n   var reg2 = /wh/g;\n   \n   console.log(reg.exec(str)); // ["wha", index: 11, input: "where when what", groups: undefined]\n   \n   console.log(reg2.exec(str)); // ["wh", index: 0, input: "where when what", groups: undefined]\n   console.log(reg2.exec(str)); // ["wh", index: 6, input: "where when what", groups: undefined]\n   console.log(reg2.exec(str)); // ["wh", index: 11, input: "where when what", groups: undefined]\n   console.log(reg2.exec(str)); // null\n   \n   console.log(reg.test(str)); // true\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   \n\n\n# 规则\n\n\n# 单个字符\n\n如 a、ab(a或b)、a~za~z0~9_。特殊符号代表特殊含义的单个字符：\n\n * .：单个任意字符\n * \\d：单个数字字符0~9\n * \\w：单个单词字符a~za~z0~9_\n * \\s：单个如空格、换行符\n\n\n# 量词符号\n\n * ?：表示出现0次或1次\n * *：表示出现0次或多次\n * +：出现1次或多次\n * {m,n}：表示 m<= 数量 <= n\n   * m如果缺省： {,n}最多n次\n   * n如果缺省：{m,}最少m次\n\n\n# 开始结束符号\n\n * ^：开始\n * $：结束',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"3 标准内置对象-5 Number",frontmatter:{title:"3 标准内置对象-5 Number",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/c814e7/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/308.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-5Number.html",relativePath:"1200.JS/300.语法/308.标准内置对象-5Number.md",key:"v-3334fcbb",path:"/pages/c814e7/",headersStr:null,content:'# 标准内置对象—Number—G\n\n全局对象包括Number，可以直接调用函数\n\nNumber.parseInt("15");// 默认字符串是十进制，第二个参数可以修改进制。返回十进制整数\nNumber.parseFloat("15.21");\nNumber.isInteger(1); // 如果传递的值是整数，则返回true，否则返回false。\nNumber.isNaN(1); // 返回一个布尔值，该值指示一个值是否是保留值NaN(不是数字)。与全局isNaN()不同，number.isNaN()并不强制将参数转换为数字。只有类型number(也是NaN)的值才会导致true。\nNumber.isSafeInteger(1); // 如果传递的值是一个安全的整数，则返回true。\n\n\n1\n2\n3\n4\n5\n\n\nPrototype.Number方法\n\n(12.3354).toFixed(2); // 小数点后的位数。必须在0 - 20之间，包括0 - 20。返回一个用定点表示法表示数字的字符串。会四舍五入，返回字符串\n\n\n1\n',normalizedContent:'# 标准内置对象—number—g\n\n全局对象包括number，可以直接调用函数\n\nnumber.parseint("15");// 默认字符串是十进制，第二个参数可以修改进制。返回十进制整数\nnumber.parsefloat("15.21");\nnumber.isinteger(1); // 如果传递的值是整数，则返回true，否则返回false。\nnumber.isnan(1); // 返回一个布尔值，该值指示一个值是否是保留值nan(不是数字)。与全局isnan()不同，number.isnan()并不强制将参数转换为数字。只有类型number(也是nan)的值才会导致true。\nnumber.issafeinteger(1); // 如果传递的值是一个安全的整数，则返回true。\n\n\n1\n2\n3\n4\n5\n\n\nprototype.number方法\n\n(12.3354).tofixed(2); // 小数点后的位数。必须在0 - 20之间，包括0 - 20。返回一个用定点表示法表示数字的字符串。会四舍五入，返回字符串\n\n\n1\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"3 标准内置对象-6 Math",frontmatter:{title:"3 标准内置对象-6 Math",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/00d50a/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/309.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-6Math.html",relativePath:"1200.JS/300.语法/309.标准内置对象-6Math.md",key:"v-0caf1fdb",path:"/pages/00d50a/",headersStr:null,content:"# 标准内置对象—Math\n\n * 里面的都是静态方法，使用可以直接使用Math.方法()\n\n * 属性：\n   \n   * PI：π\n\n * 方法：\n   \n   * random()：得到 [0,1) 之间的随机数（伪随机数）\n   * ceil(x)：对数进行向上舍入，大于等于 x，并且与它最接近的整数\n   * floor(x)：对数进行向下舍入，小于等于 x，且与 x 最接近的整数\n   * trunc(f)：对小数进行截断，返回整数，不牵扯四舍五入\n   * round(x)：把数四舍五入为最接近的整数\n   * abs(x)：绝对值\n   * pow(x,n)：x 的 n 次方",normalizedContent:"# 标准内置对象—math\n\n * 里面的都是静态方法，使用可以直接使用math.方法()\n\n * 属性：\n   \n   * pi：π\n\n * 方法：\n   \n   * random()：得到 [0,1) 之间的随机数（伪随机数）\n   * ceil(x)：对数进行向上舍入，大于等于 x，并且与它最接近的整数\n   * floor(x)：对数进行向下舍入，小于等于 x，且与 x 最接近的整数\n   * trunc(f)：对小数进行截断，返回整数，不牵扯四舍五入\n   * round(x)：把数四舍五入为最接近的整数\n   * abs(x)：绝对值\n   * pow(x,n)：x 的 n 次方",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"3 标准内置对象-7 Date",frontmatter:{title:"3 标准内置对象-7 Date",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/fbbc79/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/310.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-7Date.html",relativePath:"1200.JS/300.语法/310.标准内置对象-7Date.md",key:"v-507dad0a",path:"/pages/fbbc79/",headers:[{level:2,title:"创建",slug:"创建",normalizedTitle:"创建",charIndex:18},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:53},{level:2,title:"常用操作",slug:"常用操作",normalizedTitle:"常用操作",charIndex:1119},{level:3,title:"获取指定格式 DateTime",slug:"获取指定格式-datetime",normalizedTitle:"获取指定格式 datetime",charIndex:1128},{level:3,title:"将秒格式化",slug:"将秒格式化",normalizedTitle:"将秒格式化",charIndex:1756}],headersStr:"创建 方法 常用操作 获取指定格式 DateTime 将秒格式化",content:'# 标准内置对象—Date\n\n\n# 创建\n\nvar now = new Date();\n\n\n1\n\n\n\n# 方法\n\n * getTime()：获取时间戳的毫秒值。返回的是1970.1.1零点至今的毫秒数\n   \n   使用毫秒数处理缓存的效果（没有缓存）http://www.baidu.com?毫秒数\n\n * toLocaleString()：返回当前date对象对应的时间本地字符串格式。不调用默认为英文格式\n\n * 获取当前的年：getFullYear()\n\n * 获取当前的月(0~11)：getMonth()+1\n\n * 获取一个月中的某一日(1~31)：getDate()\n\n * 获取一周中的某一天(0~6)：.getDay()，周日为0\n\n * 获取当前的小时(0~23)：getHours()\n\n * 获取当前的分钟(0~59)：getMinutes()\n\n * 获取当前的秒(0~59)：getSecondes()\n\nvar now = new Date();\nconsole.log(now); // Sun Mar 08 2020 01:32:22 GMT+0800 (中国标准时间)\nconsole.log(now.toDateString()); // Sun Mar 08 2020\nconsole.log(now.toTimeString()); // 01:33:40 GMT+0800 (中国标准时间)\nconsole.log(now.toLocaleString()); // 2020/3/8 上午1:34:52\nconsole.log(now.toLocaleDateString()); // 2020/3/8\nconsole.log(now.toLocaleTimeString()); // 上午1:34:52\nconsole.log(now.getTime()); // 1583602691147\n\nconsole.log(now.getTimezoneOffset()); // -480,获取本地计算机上的时间与通用协调时间(UTC)之间的分钟差。\nconsole.log(now.toUTCString()); // Sat, 07 Mar 2020 17:34:24 GMT\nconsole.log(now.toISOString()); // 2020-03-07T17:33:55.955Z\nconsole.log(now.toJSON()); // 2020-03-07T17:32:59.121Z\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 常用操作\n\n\n# 获取指定格式 DateTime\n\npattern 为 yyyy-MM-dd HH:mm:ss\n\ngetDateTime() {\n  var date = new Date();\n  var year = date.getFullYear();\n  var month = date.getMonth() + 1;\n  month = month < 10 ? "0" + month : month;\n  var day = date.getDate();\n  day = day < 10 ? "0" + day : day;\n  var hour = date.getHours();\n  hour = hour < 10 ? "0" + hour : hour;\n  var minute = date.getMinutes();\n  minute = minute < 10 ? "0" + minute : minute;\n  var second = date.getSeconds();\n  second = second < 10 ? "0" + second : second;\n  return year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 将秒格式化\n\n可用于倒计时\n\nformatSeconds(totalSecond) {\n  let second = totalSecond % 60;\n  let minute = totalSecond / 60 % 60;\n  let hour = totalSecond / 60 / 60;\n  let result = parseInt(second) + "秒";\n  result = minute > 0 ? parseInt(minute) + "分" + result : result;\n  result = hour > 0 ? parseInt(hour) + "小时" + result : result;\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# 标准内置对象—date\n\n\n# 创建\n\nvar now = new date();\n\n\n1\n\n\n\n# 方法\n\n * gettime()：获取时间戳的毫秒值。返回的是1970.1.1零点至今的毫秒数\n   \n   使用毫秒数处理缓存的效果（没有缓存）http://www.baidu.com?毫秒数\n\n * tolocalestring()：返回当前date对象对应的时间本地字符串格式。不调用默认为英文格式\n\n * 获取当前的年：getfullyear()\n\n * 获取当前的月(0~11)：getmonth()+1\n\n * 获取一个月中的某一日(1~31)：getdate()\n\n * 获取一周中的某一天(0~6)：.getday()，周日为0\n\n * 获取当前的小时(0~23)：gethours()\n\n * 获取当前的分钟(0~59)：getminutes()\n\n * 获取当前的秒(0~59)：getsecondes()\n\nvar now = new date();\nconsole.log(now); // sun mar 08 2020 01:32:22 gmt+0800 (中国标准时间)\nconsole.log(now.todatestring()); // sun mar 08 2020\nconsole.log(now.totimestring()); // 01:33:40 gmt+0800 (中国标准时间)\nconsole.log(now.tolocalestring()); // 2020/3/8 上午1:34:52\nconsole.log(now.tolocaledatestring()); // 2020/3/8\nconsole.log(now.tolocaletimestring()); // 上午1:34:52\nconsole.log(now.gettime()); // 1583602691147\n\nconsole.log(now.gettimezoneoffset()); // -480,获取本地计算机上的时间与通用协调时间(utc)之间的分钟差。\nconsole.log(now.toutcstring()); // sat, 07 mar 2020 17:34:24 gmt\nconsole.log(now.toisostring()); // 2020-03-07t17:33:55.955z\nconsole.log(now.tojson()); // 2020-03-07t17:32:59.121z\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 常用操作\n\n\n# 获取指定格式 datetime\n\npattern 为 yyyy-mm-dd hh:mm:ss\n\ngetdatetime() {\n  var date = new date();\n  var year = date.getfullyear();\n  var month = date.getmonth() + 1;\n  month = month < 10 ? "0" + month : month;\n  var day = date.getdate();\n  day = day < 10 ? "0" + day : day;\n  var hour = date.gethours();\n  hour = hour < 10 ? "0" + hour : hour;\n  var minute = date.getminutes();\n  minute = minute < 10 ? "0" + minute : minute;\n  var second = date.getseconds();\n  second = second < 10 ? "0" + second : second;\n  return year + "-" + month + "-" + day + " " + hour + ":" + minute + ":" + second;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 将秒格式化\n\n可用于倒计时\n\nformatseconds(totalsecond) {\n  let second = totalsecond % 60;\n  let minute = totalsecond / 60 % 60;\n  let hour = totalsecond / 60 / 60;\n  let result = parseint(second) + "秒";\n  result = minute > 0 ? parseint(minute) + "分" + result : result;\n  result = hour > 0 ? parseint(hour) + "小时" + result : result;\n  return result;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"5 异常",frontmatter:{title:"5 异常",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/085b49/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/315.%E5%BC%82%E5%B8%B8.html",relativePath:"1200.JS/300.语法/315.异常.md",key:"v-0eff529f",path:"/pages/085b49/",headers:[{level:2,title:"常见异常",slug:"常见异常",normalizedTitle:"常见异常",charIndex:9},{level:2,title:"try...catch",slug:"try-catch",normalizedTitle:"try...catch",charIndex:216},{level:2,title:"throw",slug:"throw",normalizedTitle:"throw",charIndex:612}],headersStr:"常见异常 try...catch throw",content:'# 异常\n\n\n# 常见异常\n\nconsole.log(a); // Uncaught ReferenceError: a is not defined.跑异常后面的代码其实不会执行了\n\nvar emp = undefined;\nconsole.log(emp.name); // Uncaught TypeError: Cannot read property \'name\' of undefined\n\n\n1\n2\n3\n4\n\n\n\n# try...catch\n\ntry {\n  console.log(a);\n} catch (error) {\n  console.error(error); // Uncaught ReferenceError: a is not defined\n} finally {\n  console.log("总会执行");\n}\n\ntry {\n  var emp = undefined;\n  console.log(emp.name);\n} catch (error) {\n  console.error(error); // TypeError: Cannot read property \'name\' of undefined\n} finally {\n  console.log("总会执行");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# throw\n\nclass ApiError extends Error {\n  constructor(url, ...params) {\n    super(...params);\n    this.name = "ApiError";\n    this.url = url;\n  }\n}\n\nfunction fetchData() {\n  console.log("获取数据...");\n  console.log(a);\n  throw new ApiError("/api/hello", "404"); //不推荐，应该继承异常对象\n}\n\ntry {\n  fetchData();\n} catch (error) {\n  if (error instanceof ReferenceError) {\n    console.log("程序异常");\n  } else if (error instanceof ApiError) {\n    console.error(error);\n    console.error(error.name); // ApiError\n    console.error(error.message); // 404\n    console.error(error.url); // /api/hello\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n',normalizedContent:'# 异常\n\n\n# 常见异常\n\nconsole.log(a); // uncaught referenceerror: a is not defined.跑异常后面的代码其实不会执行了\n\nvar emp = undefined;\nconsole.log(emp.name); // uncaught typeerror: cannot read property \'name\' of undefined\n\n\n1\n2\n3\n4\n\n\n\n# try...catch\n\ntry {\n  console.log(a);\n} catch (error) {\n  console.error(error); // uncaught referenceerror: a is not defined\n} finally {\n  console.log("总会执行");\n}\n\ntry {\n  var emp = undefined;\n  console.log(emp.name);\n} catch (error) {\n  console.error(error); // typeerror: cannot read property \'name\' of undefined\n} finally {\n  console.log("总会执行");\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# throw\n\nclass apierror extends error {\n  constructor(url, ...params) {\n    super(...params);\n    this.name = "apierror";\n    this.url = url;\n  }\n}\n\nfunction fetchdata() {\n  console.log("获取数据...");\n  console.log(a);\n  throw new apierror("/api/hello", "404"); //不推荐，应该继承异常对象\n}\n\ntry {\n  fetchdata();\n} catch (error) {\n  if (error instanceof referenceerror) {\n    console.log("程序异常");\n  } else if (error instanceof apierror) {\n    console.error(error);\n    console.error(error.name); // apierror\n    console.error(error.message); // 404\n    console.error(error.url); // /api/hello\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"3 标准内置对象-8 JSON",frontmatter:{title:"3 标准内置对象-8 JSON",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/45bd67/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/311.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-8JSON.html",relativePath:"1200.JS/300.语法/311.标准内置对象-8JSON.md",key:"v-68c0f48a",path:"/pages/45bd67/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:18},{level:3,title:"定义",slug:"定义",normalizedTitle:"定义",charIndex:25},{level:3,title:"基本规则",slug:"基本规则",normalizedTitle:"基本规则",charIndex:216},{level:3,title:"获取数据",slug:"获取数据",normalizedTitle:"获取数据",charIndex:481},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:626}],headersStr:"简介 定义 基本规则 获取数据 方法",content:'# 标准内置对象—JSON\n\n\n# 简介\n\n\n# 定义\n\nJSON（JavaScript Object Notation）：JavaScript对象表示法。随着ES5的发布，新的标准内置了JSON对象，用于JSON对象和JSON字符串之间的转换操作。JSON是一种与语言无关的数据交换的格式，作用：\n\n * JSON现在多用于存储和交换文本信息的语法\n * 进行数据的传输\n * JSON 比 XML 更小、更快，更易解析\n\n\n# 基本规则\n\n * 数据在名称/值对中，键用双引号（严格模式）引起来。顶级可以是对象或数组\n * 值的取值类型：\n   1. 数字（整数或浮点数）\n   2. 字符串（在双引号中）\n   3. 逻辑值（true 或 false）\n   4. 数组（在方括号中） {"persons":[{},{}]}\n   5. 对象（在花括号中） {"address":{"province"："陕西"....}}\n   6. null\n * 数据由逗号分隔：多个键值对由逗号分隔\n * 花括号保存对象：{}\n * 方括号保存数组：[]\n\n\n# 获取数据\n\nJSON 是 JavaScript 的原生内容，也就是JavaScript可以直接取出JSON 对象中的数据\n\n 1. JSON对象.键名\n\n 2. JSON对象["键名"]\n\n 3. 数组对象[索引]\n\n 4. 遍历：for...in、for...of、普通等都可以\n\n\n# 方法\n\nJSON作为全局对象，我们可以直接调用，它有如下两个函数：\n\n * JSON.parse(string)：负责将字符串转换为JOSN对象并返回\n\n * JSON.stringify(value[, replacer[, space]])：负责将数据转换为JSON字符串并返回\n   \n   * value 就是我们需要转换的对象。可以是null, boolean, number, string, JSONObject, JSONArray\n   \n   * replacer 可以是一个数组或者一个函数，如果传入一个数组，则相当于一个白名单，只有出现在数组中的属性名对应的键值对才会出现结果中，如果指定一个函数，我们可以实现一些逻辑来过滤或更改将要出现在结果中的数据。可为null\n   \n   * space 是缩进空格，我们可以指定一个数字，表示缩进几个空格，还可以指定一个字符串，表示以指定字符串代替空格出现在缩进中',normalizedContent:'# 标准内置对象—json\n\n\n# 简介\n\n\n# 定义\n\njson（javascript object notation）：javascript对象表示法。随着es5的发布，新的标准内置了json对象，用于json对象和json字符串之间的转换操作。json是一种与语言无关的数据交换的格式，作用：\n\n * json现在多用于存储和交换文本信息的语法\n * 进行数据的传输\n * json 比 xml 更小、更快，更易解析\n\n\n# 基本规则\n\n * 数据在名称/值对中，键用双引号（严格模式）引起来。顶级可以是对象或数组\n * 值的取值类型：\n   1. 数字（整数或浮点数）\n   2. 字符串（在双引号中）\n   3. 逻辑值（true 或 false）\n   4. 数组（在方括号中） {"persons":[{},{}]}\n   5. 对象（在花括号中） {"address":{"province"："陕西"....}}\n   6. null\n * 数据由逗号分隔：多个键值对由逗号分隔\n * 花括号保存对象：{}\n * 方括号保存数组：[]\n\n\n# 获取数据\n\njson 是 javascript 的原生内容，也就是javascript可以直接取出json 对象中的数据\n\n 1. json对象.键名\n\n 2. json对象["键名"]\n\n 3. 数组对象[索引]\n\n 4. 遍历：for...in、for...of、普通等都可以\n\n\n# 方法\n\njson作为全局对象，我们可以直接调用，它有如下两个函数：\n\n * json.parse(string)：负责将字符串转换为josn对象并返回\n\n * json.stringify(value[, replacer[, space]])：负责将数据转换为json字符串并返回\n   \n   * value 就是我们需要转换的对象。可以是null, boolean, number, string, jsonobject, jsonarray\n   \n   * replacer 可以是一个数组或者一个函数，如果传入一个数组，则相当于一个白名单，只有出现在数组中的属性名对应的键值对才会出现结果中，如果指定一个函数，我们可以实现一些逻辑来过滤或更改将要出现在结果中的数据。可为null\n   \n   * space 是缩进空格，我们可以指定一个数字，表示缩进几个空格，还可以指定一个字符串，表示以指定字符串代替空格出现在缩进中',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"6 异步-1 定时器",frontmatter:{title:"6 异步-1 定时器",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/925f93/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/400.%E5%BC%82%E6%AD%A5/401.%E5%BC%82%E6%AD%A5-1%E5%AE%9A%E6%97%B6%E5%99%A8.html",relativePath:"1200.JS/400.异步/401.异步-1定时器.md",key:"v-34aa7b86",path:"/pages/925f93/",headers:[{level:2,title:"setTimeout",slug:"settimeout",normalizedTitle:"settimeout",charIndex:10},{level:2,title:"setInterval",slug:"setinterval",normalizedTitle:"setinterval",charIndex:417}],headersStr:"setTimeout setInterval",content:"# 定时器\n\n\n# setTimeout\n\n采用\n\nsetTimeout(handler: TimerHandler, timeout?: number, ...arguments: any[])\n\n * 在 millisec 毫秒后只执行一次函数或代码串\n\n * 推荐传递函数或者函数的引用\n\n * 不推荐代码串，因为会涉及欺骗词法作用域，造成 JS 引擎认为该内容视为好像在书写时（词法期）就存在于程序中这个位置的代码，且性能下降\n\nclearTimeout()：清除setTimeout设置的定时器\n\n// var id = setTimeout(\"alert('abc');\", 1000); // 不推荐\n\n// 返回的 timer 是定时器的顺序，如1，2，3\nvar timer = setTimeout(() => {\n  console.log(666);\n}, 1000);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# setInterval\n\nsetInterval(code,millisec)\n\n * 每隔 millisec 毫秒执行一次函数或代码串\n\n * 推荐传递函数或者函数的引用\n\n * 不推荐代码串，因为会涉及欺骗词法作用域，造成 JS 引擎认为该内容视为好像在书写时（词法期）就存在于程序中这个位置的代码，且性能下降\n\nclearInterval()：清除setInterval设置的定时器\n\n// var id = setTimeout(\"alert('abc');\", 1000); // 不推荐\n\n// 返回的 timer 是定时器的顺序，如1，2，3\nvar timer = setInterval(() => {\n  console.log(666);\n}, 1000);\n\n// 清除定时器\nsetTimeout(() => {\n  clearInterval(timer);\n}, 5000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",normalizedContent:"# 定时器\n\n\n# settimeout\n\n采用\n\nsettimeout(handler: timerhandler, timeout?: number, ...arguments: any[])\n\n * 在 millisec 毫秒后只执行一次函数或代码串\n\n * 推荐传递函数或者函数的引用\n\n * 不推荐代码串，因为会涉及欺骗词法作用域，造成 js 引擎认为该内容视为好像在书写时（词法期）就存在于程序中这个位置的代码，且性能下降\n\ncleartimeout()：清除settimeout设置的定时器\n\n// var id = settimeout(\"alert('abc');\", 1000); // 不推荐\n\n// 返回的 timer 是定时器的顺序，如1，2，3\nvar timer = settimeout(() => {\n  console.log(666);\n}, 1000);\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# setinterval\n\nsetinterval(code,millisec)\n\n * 每隔 millisec 毫秒执行一次函数或代码串\n\n * 推荐传递函数或者函数的引用\n\n * 不推荐代码串，因为会涉及欺骗词法作用域，造成 js 引擎认为该内容视为好像在书写时（词法期）就存在于程序中这个位置的代码，且性能下降\n\nclearinterval()：清除setinterval设置的定时器\n\n// var id = settimeout(\"alert('abc');\", 1000); // 不推荐\n\n// 返回的 timer 是定时器的顺序，如1，2，3\nvar timer = setinterval(() => {\n  console.log(666);\n}, 1000);\n\n// 清除定时器\nsettimeout(() => {\n  clearinterval(timer);\n}, 5000);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"6 异步-2 Promise",frontmatter:{title:"6 异步-2 Promise",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/0e6a48/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/400.%E5%BC%82%E6%AD%A5/402.%E5%BC%82%E6%AD%A5-2Promise.html",relativePath:"1200.JS/400.异步/402.异步-2Promise.md",key:"v-09038db5",path:"/pages/0e6a48/",headers:[{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:14},{level:2,title:"多个 Promise 同时执行",slug:"多个-promise-同时执行",normalizedTitle:"多个 promise 同时执行",charIndex:734}],headersStr:"使用 多个 Promise 同时执行",content:'# Promise\n\n\n# 使用\n\n// 每次调用 Promise 的方法后，会返回 Promise 对象，可以链式调用\nvar promise = new Promise((resolve, reject) => {\n  // 模拟耗时操作\n  setTimeout(() => {\n    resolve("1 执行成功，返回结果");\n  }, 2000);\n})\n  .then(res => {\n    console.log(res); // 1 执行成功，返回结果\n    // 也可返回对 res 操作后的值\n    return "2 执行成功，返回结果";\n  })\n  .then(res => {\n    console.log(res); // 2 执行成功，返回结果\n    return new Promise((resolve, reject) => {\n      resolve("3 执行成功，返回结果");\n    });\n  })\n  .then(res => {\n    console.log(res); // 3 执行成功，返回结果\n    throw new Error("1 执行失败，返回失败信息");\n  })\n  .catch(error => {\n    console.log(error); // Error: 执行失败，返回失败信息\n    throw "2 执行失败，返回失败信息";\n  });\n// 后面哈可以继续 then、catch\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 多个 Promise 同时执行\n\nvar p1 = new Promise(resolve => {\n  setTimeout(() => {\n    console.log("p1");\n    resolve(1);\n  }, 1000);\n});\n\nvar p2 = new Promise(resolve => {\n  setTimeout(() => {\n    console.log("p2");\n    resolve(2);\n  }, 2000);\n});\n\nvar p3 = new Promise(resolve => {\n  setTimeout(() => {\n    console.log("p3");\n    resolve(3);\n  }, 500);\n});\n\nPromise.all([p1, p2, p3]).then(values => {\n  let [v1, v2, v3] = values;\n  console.log(v1, v2, v3); // 1 2 3\n});\n\n// 最终返回：\n// p3\n// p1\n// p2\n// 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',normalizedContent:'# promise\n\n\n# 使用\n\n// 每次调用 promise 的方法后，会返回 promise 对象，可以链式调用\nvar promise = new promise((resolve, reject) => {\n  // 模拟耗时操作\n  settimeout(() => {\n    resolve("1 执行成功，返回结果");\n  }, 2000);\n})\n  .then(res => {\n    console.log(res); // 1 执行成功，返回结果\n    // 也可返回对 res 操作后的值\n    return "2 执行成功，返回结果";\n  })\n  .then(res => {\n    console.log(res); // 2 执行成功，返回结果\n    return new promise((resolve, reject) => {\n      resolve("3 执行成功，返回结果");\n    });\n  })\n  .then(res => {\n    console.log(res); // 3 执行成功，返回结果\n    throw new error("1 执行失败，返回失败信息");\n  })\n  .catch(error => {\n    console.log(error); // error: 执行失败，返回失败信息\n    throw "2 执行失败，返回失败信息";\n  });\n// 后面哈可以继续 then、catch\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 多个 promise 同时执行\n\nvar p1 = new promise(resolve => {\n  settimeout(() => {\n    console.log("p1");\n    resolve(1);\n  }, 1000);\n});\n\nvar p2 = new promise(resolve => {\n  settimeout(() => {\n    console.log("p2");\n    resolve(2);\n  }, 2000);\n});\n\nvar p3 = new promise(resolve => {\n  settimeout(() => {\n    console.log("p3");\n    resolve(3);\n  }, 500);\n});\n\npromise.all([p1, p2, p3]).then(values => {\n  let [v1, v2, v3] = values;\n  console.log(v1, v2, v3); // 1 2 3\n});\n\n// 最终返回：\n// p3\n// p1\n// p2\n// 1 2 3\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"6 异步-3 async & await",frontmatter:{title:"6 异步-3 async & await",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/9ef7a8/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/400.%E5%BC%82%E6%AD%A5/403.%E5%BC%82%E6%AD%A5-3async&await.html",relativePath:"1200.JS/400.异步/403.异步-3async&await.md",key:"v-083b3713",path:"/pages/9ef7a8/",headersStr:null,content:'# async & await\n\n是也不完全是 Promise 的语法糖，以同步的写法来执行异步代码，直观。使用 async 即也是创建了 Promise 对象。\n\nasync function async1() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve("执行成功，返回结果");\n    }, 1000);\n  });\n}\n\nasync function async2() {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      reject("执行失败，返回错误信息");\n    }, 500);\n  });\n}\n\n// await is only valid（有效）in async function\nasync function asyncMain() {\n  let result1 = await async1();\n  console.log(result1);\n\n  try {\n    let result2 = await async2();\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nasyncMain();\n// 执行成功，返回结果\n// 执行失败，返回错误信息\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',normalizedContent:'# async & await\n\n是也不完全是 promise 的语法糖，以同步的写法来执行异步代码，直观。使用 async 即也是创建了 promise 对象。\n\nasync function async1() {\n  return new promise(resolve => {\n    settimeout(() => {\n      resolve("执行成功，返回结果");\n    }, 1000);\n  });\n}\n\nasync function async2() {\n  return new promise((resolve, reject) => {\n    settimeout(() => {\n      reject("执行失败，返回错误信息");\n    }, 500);\n  });\n}\n\n// await is only valid（有效）in async function\nasync function asyncmain() {\n  let result1 = await async1();\n  console.log(result1);\n\n  try {\n    let result2 = await async2();\n  } catch (error) {\n    console.log(error);\n  }\n}\n\nasyncmain();\n// 执行成功，返回结果\n// 执行失败，返回错误信息\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"7 模块化-1 ES6模块化",frontmatter:{title:"7 模块化-1 ES6模块化",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/8313cc/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/500.%E6%A8%A1%E5%9D%97%E5%8C%96/501.%E6%A8%A1%E5%9D%97%E5%8C%96-1ES6%E6%A8%A1%E5%9D%97%E5%8C%96.html",relativePath:"1200.JS/500.模块化/501.模块化-1ES6模块化.md",key:"v-24eb3483",path:"/pages/8313cc/",headers:[{level:2,title:"基本导入导出",slug:"基本导入导出",normalizedTitle:"基本导入导出",charIndex:30},{level:2,title:"default 导入导出",slug:"default-导入导出",normalizedTitle:"default 导入导出",charIndex:119},{level:2,title:"* 导入",slug:"导入",normalizedTitle:"* 导入",charIndex:214},{level:2,title:"综合示例",slug:"综合示例",normalizedTitle:"综合示例",charIndex:263}],headersStr:"基本导入导出 default 导入导出 * 导入 综合示例",content:'# ES6 模块化 export & import\n\n\n# 基本导入导出\n\nHTML 中引入 JS 时需要注明 type 属性值为 module，声明每个文件都是单独一个模块（此时使用var都不会产生全局变量问题），否则无法导入\n\n\n# default 导入导出\n\n * 某些情况下，一个模块中包含某个功能需要导出，但我们并不希望给这个功能命名，希望让导入者自己来命名\n * default 在同一个模块中只能有一个！\n\n\n# * 导入\n\n希望将某个模块的所以信息都导入，一个个写很麻烦，可以使用 * 导入，并起别名\n\n\n# 综合示例\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    \x3c!-- HTML 中引入 JS 时需要注明 type 属性值为 module，声明每个文件都是单独一个模块 --\x3e\n    <script src="./js/utils.js" type="module"><\/script>\n    <script src="./js/main.js" type="module"><\/script>\n    <script src="./js/poem.js" type="module"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n导出\n\n// ./js/utils.js\n\n// 导出方式1:直接写在 变量、函数、类等之前\n/**\n * 每年的天数\n */\nexport const DAY_OF_YEAR = 365;\n\n/**\n * 格式化时间\n * @param {Date} date\n */\nfunction formatDate(date) {\n  return `${date.getFullYear()}-${\n    date.getMonth() + 1 < 10 ? "0" + (date.getMonth() + 1) : date.getMonth() + 1\n  }-${date.getDate() < 10 ? "0" + date.getDate() : date.getDate()} ${\n    date.getHours() < 10 ? "0" + date.getHours() : date.getHours()\n  }:${date.getMinutes() < 10 ? "0" + date.getMinutes() : date.getMinutes()}:${\n    date.getSeconds() < 10 ? "0" + date.getSeconds() : date.getSeconds()\n  }`;\n}\n\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  say() {\n    console.log("姓名：" + this.name + "，年龄：" + this.age);\n  }\n}\n\nfunction add(num1, num2) {\n  console.log(num1 + "+" + num2 + "=" + (num1 + num2));\n}\n\n// 导出方式2（推荐）\nexport { formatDate, Person };\n\n// default导出，也可以直接写在变量、函数、类等之前\nexport default add;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n// ./js/poem.js\n\nconst SPRING =\n  "天街小雨润如酥，草色遥看近却无。最是一年春好处，绝胜烟柳满皇都。";\nconst SUMMER =\n  "毕竟西湖六月中，风光不与四时同。接天莲叶无穷碧，映日荷花别样红。";\nconst AUTUMN =\n  "银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星。";\nconst WINTER = "日暮苍山远，天寒白屋贫。柴门闻犬吠，风雪夜归人。";\n\nexport { SPRING, SUMMER, AUTUMN, WINTER };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n导入\n\n// ./js/main.js\n\n// 都可以使用 as 起别名（default导入的直接就可以自定义名称，且导入的只有一个）\nimport plus, {\n  formatDate as format,\n  DAY_OF_YEAR as DAY,\n  Person,\n} from "./utils.js";\n\n// 统一全部导入\nimport * as poem from "./poem.js";\n\nconsole.log(DAY);\n\nconsole.log(format(new Date()));\n\nconst student = new Person("张三", 13);\nstudent.say();\n\nplus(1, 2);\n\nconsole.log(poem.AUTUMN);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',normalizedContent:'# es6 模块化 export & import\n\n\n# 基本导入导出\n\nhtml 中引入 js 时需要注明 type 属性值为 module，声明每个文件都是单独一个模块（此时使用var都不会产生全局变量问题），否则无法导入\n\n\n# default 导入导出\n\n * 某些情况下，一个模块中包含某个功能需要导出，但我们并不希望给这个功能命名，希望让导入者自己来命名\n * default 在同一个模块中只能有一个！\n\n\n# * 导入\n\n希望将某个模块的所以信息都导入，一个个写很麻烦，可以使用 * 导入，并起别名\n\n\n# 综合示例\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    \x3c!-- html 中引入 js 时需要注明 type 属性值为 module，声明每个文件都是单独一个模块 --\x3e\n    <script src="./js/utils.js" type="module"><\/script>\n    <script src="./js/main.js" type="module"><\/script>\n    <script src="./js/poem.js" type="module"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n导出\n\n// ./js/utils.js\n\n// 导出方式1:直接写在 变量、函数、类等之前\n/**\n * 每年的天数\n */\nexport const day_of_year = 365;\n\n/**\n * 格式化时间\n * @param {date} date\n */\nfunction formatdate(date) {\n  return `${date.getfullyear()}-${\n    date.getmonth() + 1 < 10 ? "0" + (date.getmonth() + 1) : date.getmonth() + 1\n  }-${date.getdate() < 10 ? "0" + date.getdate() : date.getdate()} ${\n    date.gethours() < 10 ? "0" + date.gethours() : date.gethours()\n  }:${date.getminutes() < 10 ? "0" + date.getminutes() : date.getminutes()}:${\n    date.getseconds() < 10 ? "0" + date.getseconds() : date.getseconds()\n  }`;\n}\n\nclass person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  say() {\n    console.log("姓名：" + this.name + "，年龄：" + this.age);\n  }\n}\n\nfunction add(num1, num2) {\n  console.log(num1 + "+" + num2 + "=" + (num1 + num2));\n}\n\n// 导出方式2（推荐）\nexport { formatdate, person };\n\n// default导出，也可以直接写在变量、函数、类等之前\nexport default add;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n// ./js/poem.js\n\nconst spring =\n  "天街小雨润如酥，草色遥看近却无。最是一年春好处，绝胜烟柳满皇都。";\nconst summer =\n  "毕竟西湖六月中，风光不与四时同。接天莲叶无穷碧，映日荷花别样红。";\nconst autumn =\n  "银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星。";\nconst winter = "日暮苍山远，天寒白屋贫。柴门闻犬吠，风雪夜归人。";\n\nexport { spring, summer, autumn, winter };\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n导入\n\n// ./js/main.js\n\n// 都可以使用 as 起别名（default导入的直接就可以自定义名称，且导入的只有一个）\nimport plus, {\n  formatdate as format,\n  day_of_year as day,\n  person,\n} from "./utils.js";\n\n// 统一全部导入\nimport * as poem from "./poem.js";\n\nconsole.log(day);\n\nconsole.log(format(new date()));\n\nconst student = new person("张三", 13);\nstudent.say();\n\nplus(1, 2);\n\nconsole.log(poem.autumn);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"7 模块化-2 ES5模块化",frontmatter:{title:"7 模块化-2 ES5模块化",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/e5923d/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/500.%E6%A8%A1%E5%9D%97%E5%8C%96/502.%E6%A8%A1%E5%9D%97%E5%8C%96-2ES5%E6%A8%A1%E5%9D%97%E5%8C%96.html",relativePath:"1200.JS/500.模块化/502.模块化-2ES5模块化.md",key:"v-5426fc63",path:"/pages/e5923d/",headersStr:null,content:'# ES5模块化—立即执行函数封装\n\n可以利用立即执行函数解决全局变量命名重复和模块化问题\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <script src="./js/a.js"><\/script>\n    <script src="./js/b.js"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n// js/a.js\nvar ModuleA = (function () {\n  var name = "aaa";\n  var flag = true;\n  var sum = function (num1, num2) {\n    return num1 + num2;\n  };\n\n  var obj = {};\n  obj.name = name;\n  obj.flag = flag;\n  obj.sum = sum;\n\n  return obj;\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n// js/b.js\nvar ModuleB = (function () {\n  var name = "bbb";\n  console.log(ModuleA.name);\n  console.log(ModuleA.flag);\n  console.log(ModuleA.sum(1, 2));\n\n  console.log("bbbbbb comoe on");\n\n  var obj = {};\n  obj.name = name;\n\n  return obj;\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上述就是模块化的最基础封装',normalizedContent:'# es5模块化—立即执行函数封装\n\n可以利用立即执行函数解决全局变量命名重复和模块化问题\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    <script src="./js/a.js"><\/script>\n    <script src="./js/b.js"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n// js/a.js\nvar modulea = (function () {\n  var name = "aaa";\n  var flag = true;\n  var sum = function (num1, num2) {\n    return num1 + num2;\n  };\n\n  var obj = {};\n  obj.name = name;\n  obj.flag = flag;\n  obj.sum = sum;\n\n  return obj;\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n// js/b.js\nvar moduleb = (function () {\n  var name = "bbb";\n  console.log(modulea.name);\n  console.log(modulea.flag);\n  console.log(modulea.sum(1, 2));\n\n  console.log("bbbbbb comoe on");\n\n  var obj = {};\n  obj.name = name;\n\n  return obj;\n})();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n上述就是模块化的最基础封装',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"4 面向对象",frontmatter:{title:"4 面向对象",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/cb9d10/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/314.%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",relativePath:"1200.JS/300.语法/314.面向对象.md",key:"v-358d6d7e",path:"/pages/cb9d10/",headers:[{level:2,title:"class",slug:"class",normalizedTitle:"class",charIndex:38},{level:2,title:"extends",slug:"extends",normalizedTitle:"extends",charIndex:688},{level:2,title:"成员变量 ⚠️",slug:"成员变量-⚠️",normalizedTitle:"成员变量 ⚠️",charIndex:1620},{level:2,title:"静态成员 ⚠️",slug:"静态成员-⚠️",normalizedTitle:"静态成员 ⚠️",charIndex:1890},{level:2,title:"私有成员 ⚠️",slug:"私有成员-⚠️",normalizedTitle:"私有成员 ⚠️",charIndex:2127}],headersStr:"class extends 成员变量 ⚠️ 静态成员 ⚠️ 私有成员 ⚠️",content:'# 面向对象\n\n只是语法糖，内部还是使用 Prototype 实现\n\n\n# class\n\nclass Emp {\n  // 构造函数\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  // 普通方法\n  signIn() {\n    console.log(this.name + "打卡上班");\n  }\n  // 属性的 getter setter，实际调用属性不是方法\n  get info() {\n    return this.name + " " + this.age;\n  }\n\n  set info(info) {\n    let [name, age] = info.split(" ");\n    this.name = name;\n    this.age = age;\n  }\n}\nvar emp = new Emp("conan", 11);\n\nconsole.log(emp); // Emp {name: "conan", age: 11}\nemp.signIn(); // conan打卡上班\nconsole.log(emp.info); // conan 11\nemp.info = "lan 18";\nconsole.log(emp.info); // lan 18\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# extends\n\nclass Emp {\n  // 构造函数\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  // 普通方法\n  signIn() {\n    console.log(this.name + "打卡上班");\n  }\n  // 属性的 getter setter，实际调用属性不是方法\n  get info() {\n    return this.name + " " + this.age;\n  }\n\n  set info(info) {\n    let [name, age] = info.split(" ");\n    this.name = name;\n    this.age = age;\n  }\n}\n\n// 只能单继承\nclass Manager extends Emp {\n  constructor(name, age, dept) {\n    super(name, age);\n    this.dept = dept;\n  }\n\n  signIn() {\n    super.signIn();\n    console.log("经理主持会议");\n  }\n}\n\n// var manager = new Manager("kid", 20);// 不建议在子类没有构造函数时这样调用，应给子类添加构造函数\nvar manager = new Manager("kid", 20, "技术部"); // 不建议在子类没有构造函数时这样调用，应给子类添加构造函数\nconsole.log(manager); // Manager {name: "kid", age: 20, dept: "技术部"}\nmanager.signIn();\n// kid打卡上班\n// 经理主持会议\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 成员变量 ⚠️\n\n还没发布，只有部分浏览器支持，或使用babel转换\n\nclass Employee {\n  company = "qq";\n  constructor(name) {\n    this.name = "hello" + name;\n  }\n}\nvar emp = new Employee("conan");\nconsole.log(emp.company); // qq\nconsole.log(new Employee("haha").company); // qq\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 静态成员 ⚠️\n\n还没发布，只有部分浏览器支持，或使用babel转换\n\n只能通过类来调用\n\nclass Ticket {\n  static count = 0;\n  constructor(name) {\n    this.name = name + "卖票了";\n  }\n}\nvar t1 = new Ticket("conan");\nTicket.count++;\nconsole.log(Ticket.count);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 私有成员 ⚠️\n\n略',normalizedContent:'# 面向对象\n\n只是语法糖，内部还是使用 prototype 实现\n\n\n# class\n\nclass emp {\n  // 构造函数\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  // 普通方法\n  signin() {\n    console.log(this.name + "打卡上班");\n  }\n  // 属性的 getter setter，实际调用属性不是方法\n  get info() {\n    return this.name + " " + this.age;\n  }\n\n  set info(info) {\n    let [name, age] = info.split(" ");\n    this.name = name;\n    this.age = age;\n  }\n}\nvar emp = new emp("conan", 11);\n\nconsole.log(emp); // emp {name: "conan", age: 11}\nemp.signin(); // conan打卡上班\nconsole.log(emp.info); // conan 11\nemp.info = "lan 18";\nconsole.log(emp.info); // lan 18\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# extends\n\nclass emp {\n  // 构造函数\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n  // 普通方法\n  signin() {\n    console.log(this.name + "打卡上班");\n  }\n  // 属性的 getter setter，实际调用属性不是方法\n  get info() {\n    return this.name + " " + this.age;\n  }\n\n  set info(info) {\n    let [name, age] = info.split(" ");\n    this.name = name;\n    this.age = age;\n  }\n}\n\n// 只能单继承\nclass manager extends emp {\n  constructor(name, age, dept) {\n    super(name, age);\n    this.dept = dept;\n  }\n\n  signin() {\n    super.signin();\n    console.log("经理主持会议");\n  }\n}\n\n// var manager = new manager("kid", 20);// 不建议在子类没有构造函数时这样调用，应给子类添加构造函数\nvar manager = new manager("kid", 20, "技术部"); // 不建议在子类没有构造函数时这样调用，应给子类添加构造函数\nconsole.log(manager); // manager {name: "kid", age: 20, dept: "技术部"}\nmanager.signin();\n// kid打卡上班\n// 经理主持会议\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 成员变量 ⚠️\n\n还没发布，只有部分浏览器支持，或使用babel转换\n\nclass employee {\n  company = "qq";\n  constructor(name) {\n    this.name = "hello" + name;\n  }\n}\nvar emp = new employee("conan");\nconsole.log(emp.company); // qq\nconsole.log(new employee("haha").company); // qq\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 静态成员 ⚠️\n\n还没发布，只有部分浏览器支持，或使用babel转换\n\n只能通过类来调用\n\nclass ticket {\n  static count = 0;\n  constructor(name) {\n    this.name = name + "卖票了";\n  }\n}\nvar t1 = new ticket("conan");\nticket.count++;\nconsole.log(ticket.count);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 私有成员 ⚠️\n\n略',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"7 模块化-3 常见模块化规范",frontmatter:{title:"7 模块化-3 常见模块化规范",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/c8b589/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/500.%E6%A8%A1%E5%9D%97%E5%8C%96/503.%E6%A8%A1%E5%9D%97%E5%8C%96-3%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9D%97%E5%8C%96%E8%A7%84%E8%8C%83.html",relativePath:"1200.JS/500.模块化/503.模块化-3常见模块化规范.md",key:"v-85c4362a",path:"/pages/c8b589/",headers:[{level:2,title:"CommonJS—exports & require",slug:"commonjs-exports-require",normalizedTitle:"commonjs—exports &amp; require",charIndex:null},{level:2,title:"AMD",slug:"amd",normalizedTitle:"amd",charIndex:469},{level:2,title:"CMD",slug:"cmd",normalizedTitle:"cmd",charIndex:477},{level:2,title:"ES6 的 Modules",slug:"es6-的-modules",normalizedTitle:"es6 的 modules",charIndex:485}],headersStr:"CommonJS—exports & require AMD CMD ES6 的 Modules",content:"# 常见模块化规范\n\n\n# CommonJS—exports & require\n\nWebpack 和 NodeJS 都是使用 CommonJS 来做模块化的\n\n导出（只展示语法，需要解析）：\n\n// js/a.js\nvar name = \"aaa\";\nvar flag = true;\nvar sum = function (num1, num2) {\n    return num1 + num2;\n};\n\n// ES5写法，也可以使用ES6对象增强写法（不再赘述）\nmodule.exports = {\n    name: name,\n    flag: flag,\n    sum: sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n导入\n\n// js/b.js\nvar a = require('./a.js')\n// 也可以使用对象解构语法\nvar {name, flag, sum} = require('./a.js')\nconsole.log(name)\n\n\n1\n2\n3\n4\n5\n\n\n\n# AMD\n\n\n# CMD\n\n\n# ES6 的 Modules",normalizedContent:"# 常见模块化规范\n\n\n# commonjs—exports & require\n\nwebpack 和 nodejs 都是使用 commonjs 来做模块化的\n\n导出（只展示语法，需要解析）：\n\n// js/a.js\nvar name = \"aaa\";\nvar flag = true;\nvar sum = function (num1, num2) {\n    return num1 + num2;\n};\n\n// es5写法，也可以使用es6对象增强写法（不再赘述）\nmodule.exports = {\n    name: name,\n    flag: flag,\n    sum: sum\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n导入\n\n// js/b.js\nvar a = require('./a.js')\n// 也可以使用对象解构语法\nvar {name, flag, sum} = require('./a.js')\nconsole.log(name)\n\n\n1\n2\n3\n4\n5\n\n\n\n# amd\n\n\n# cmd\n\n\n# es6 的 modules",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"DOM",frontmatter:{title:"DOM",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/39c4a3/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/700.DOM&BOM/701.DOM.html",relativePath:"1200.JS/700.DOM&BOM/701.DOM.md",key:"v-72766126",path:"/pages/39c4a3/",headers:[{level:2,title:"Node 🔥",slug:"node-🔥",normalizedTitle:"node 🔥",charIndex:526},{level:3,title:"Node 接口 🔥",slug:"node-接口-🔥",normalizedTitle:"node 接口 🔥",charIndex:868},{level:3,title:"NodeList 接口（了解）",slug:"nodelist-接口-了解",normalizedTitle:"nodelist 接口（了解）",charIndex:1986},{level:3,title:"HTMLCollection 接口（了解）",slug:"htmlcollection-接口-了解",normalizedTitle:"htmlcollection 接口（了解）",charIndex:2288},{level:3,title:"ParentNode 接口（注意 IE 基本不支持）",slug:"parentnode-接口-注意-ie-基本不支持",normalizedTitle:"parentnode 接口（注意 ie 基本不支持）",charIndex:2772},{level:3,title:"ChildNode 接口",slug:"childnode-接口",normalizedTitle:"childnode 接口",charIndex:3316},{level:2,title:"Document 🔥",slug:"document-🔥",normalizedTitle:"document 🔥",charIndex:3611},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3627},{level:3,title:"常用属性（好像不太常用）",slug:"常用属性-好像不太常用",normalizedTitle:"常用属性（好像不太常用）",charIndex:3710},{level:3,title:"常用 CRUD 方法 🔥",slug:"常用-crud-方法-🔥",normalizedTitle:"常用 crud 方法 🔥",charIndex:3984},{level:4,title:"获取 Element 对象",slug:"获取-element-对象",normalizedTitle:"获取 element 对象",charIndex:4001},{level:4,title:"添加 DOM 对象",slug:"添加-dom-对象",normalizedTitle:"添加 dom 对象",charIndex:4692},{level:4,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:540},{level:2,title:"Element 🔥",slug:"element-🔥",normalizedTitle:"element 🔥",charIndex:4966},{level:3,title:"常用属性",slug:"常用属性",normalizedTitle:"常用属性",charIndex:3710},{level:3,title:"常用 Attribute 方法",slug:"常用-attribute-方法",normalizedTitle:"常用 attribute 方法",charIndex:5362},{level:2,title:"Event",slug:"event",normalizedTitle:"event",charIndex:5501},{level:3,title:"加载事件",slug:"加载事件",normalizedTitle:"加载事件",charIndex:5511},{level:3,title:"点击事件",slug:"点击事件",normalizedTitle:"点击事件",charIndex:5769},{level:3,title:"焦点事件(表单校验)",slug:"焦点事件-表单校验",normalizedTitle:"焦点事件(表单校验)",charIndex:5818},{level:3,title:"改变事件",slug:"改变事件",normalizedTitle:"改变事件",charIndex:5907},{level:3,title:"表单事件",slug:"表单事件",normalizedTitle:"表单事件",charIndex:5973},{level:3,title:"鼠标事件",slug:"鼠标事件",normalizedTitle:"鼠标事件",charIndex:6112},{level:3,title:"键盘事件",slug:"键盘事件",normalizedTitle:"键盘事件",charIndex:6311},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:6392},{level:3,title:"动态显示时间",slug:"动态显示时间",normalizedTitle:"动态显示时间",charIndex:6399},{level:3,title:"轮播图(正常不这么做)",slug:"轮播图-正常不这么做",normalizedTitle:"轮播图(正常不这么做)",charIndex:6574},{level:3,title:"定时弹出广告(style.display)",slug:"定时弹出广告-style-display",normalizedTitle:"定时弹出广告(style.display)",charIndex:6757},{level:3,title:"动态增删表格",slug:"动态增删表格",normalizedTitle:"动态增删表格",charIndex:7119},{level:3,title:"全选/全不选/反选/高亮",slug:"全选-全不选-反选-高亮",normalizedTitle:"全选/全不选/反选/高亮",charIndex:8269},{level:3,title:"表单校验",slug:"表单校验",normalizedTitle:"表单校验",charIndex:5823},{level:3,title:"左右列表",slug:"左右列表",normalizedTitle:"左右列表",charIndex:9873},{level:3,title:"表格隔行换色(tBodies、rows)",slug:"表格隔行换色-tbodies、rows",normalizedTitle:"表格隔行换色(tbodies、rows)",charIndex:10490},{level:3,title:"省市联动(this.value)",slug:"省市联动-this-value",normalizedTitle:"省市联动(this.value)",charIndex:10940},{level:2,title:"DOM 操作 🔥",slug:"dom-操作-🔥",normalizedTitle:"dom 操作 🔥",charIndex:11478},{level:3,title:"表单值获取 🔥",slug:"表单值获取-🔥",normalizedTitle:"表单值获取 🔥",charIndex:11492},{level:3,title:"动态增删表单",slug:"动态增删表单",normalizedTitle:"动态增删表单",charIndex:14030},{level:3,title:"动态增删表单 & 拖动 & 单击移动",slug:"动态增删表单-拖动-单击移动",normalizedTitle:"动态增删表单 &amp; 拖动 &amp; 单击移动",charIndex:null}],headersStr:"Node 🔥 Node 接口 🔥 NodeList 接口（了解） HTMLCollection 接口（了解） ParentNode 接口（注意 IE 基本不支持） ChildNode 接口 Document 🔥 简介 常用属性（好像不太常用） 常用 CRUD 方法 🔥 获取 Element 对象 添加 DOM 对象 其他 Element 🔥 常用属性 常用 Attribute 方法 Event 加载事件 点击事件 焦点事件(表单校验) 改变事件 表单事件 鼠标事件 键盘事件 案例 动态显示时间 轮播图(正常不这么做) 定时弹出广告(style.display) 动态增删表格 全选/全不选/反选/高亮 表单校验 左右列表 表格隔行换色(tBodies、rows) 省市联动(this.value) DOM 操作 🔥 表单值获取 🔥 动态增删表单 动态增删表单 & 拖动 & 单击移动",content:"# DOM\n\nDOM（document object model）：将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行 CRUD 的动态操作\n\nW3C DOM 标准被分为 3 个不同的部分：\n\n * 核心 DOM - 针对任何结构化文档的标准模型\n   * Node：原生节点对象，以下节点对象都继承于此\n   * Document：文档对象，整个文档树的顶层节点\n   * DocumentType：doctype标签（比如<!DOCTYPE html>\n   * Element：元素对象，网页的各种 HTML 标签（比如<body>、<a>等）\n   * Attribute：属性对象，网页元素的属性（比如class=\"right\"）\n   * Text：文本对象，标签之间或标签包含的文本\n   * Comment：注释对象\n   * DocumentFragment：文档的片段\n * XML DOM - 针对 XML 文档的标准模型\n * HTML DOM - 针对 HTML 文档的标准模型\n\n解析过程：根据 html 的层级结构，在内存中分配一个树形结构，需要把 html 中的每部分封装成对象\n\n\n\n\n# Node 🔥\n\n节点对象，其他对象的父对象。所有 dom 对象都可以被认为是一个节点\n\nJS 中有宿主对象 document（文档对象本身），是 window 对象的属性。DOM 中的对象又称为节点对象，4 种常用节点：\n\nNODENAME         NODETYPE    NODEVALUE   \nDocument 文档节点    #document   9           null\nElement 元素节点     标签名         1           null\nAttribute 属性节点   属性名         2           属性值\nText 文本节点        #text       3           文本内容\n\n\n# Node 接口 🔥\n\n属性：\n\n * nodeType：一个整数值表示==节点的类型==。如 Element 为 1、Attribute 为 2、Text 为 3、Document 为 9\n * nodeName：节点的名称。如 Element 为大写标签名、Attribute 为属性名、Text 为#text、Document 为#document\n * nodeValue：一个字符串，表示当前节点本身的文本值。只有 Attribute、Text、Comment 有值，其余返回null\n * textContent：当前节点和它的所有后代节点的==所有文本内容==，自动忽略当前节点内部的 HTML 标签\n * baseURI：一个字符串，表示当前网页的绝对路径\n * ownerDocument：当前节点所在的顶层文档对象，document 本身的这个属性为null。与getRootNode()一样作用\n * previousSiblin：当前节点==前==面的、距离最近的一个同级节点，没有同级节点则返回null\n * nextSibling：紧跟在当前节点==后==面的第一个同级节点，没有同级节点则返回null\n * parentNode：==当前节点的父节点==，可能有三种类型，如 Document、Element、DocumentFragment\n * parentElement：当前节点的父元素节点，排除了上述类型中首尾两个\n\n方法(CRUD DOM 树)：\n\n * appendChild(newNode)：==将其作为最后一个子节点，插入当前节点==。若newNode为 DOM 中已存在的，相当于剪贴\n\n * insertBefore(newNode,oldNode)：节点之前插入一个新的节点，没有 insertAfter()方法可以结合nextSibling实现\n\n * removeChild(Node)：通过父节点删除指定子节点，并返回被删除的节点。不存在 DOM 中，但在内存中仍可使用\n\n * replaceChild(newNode,oldNode)：通过父节点用新节点替换一个子节点\n\n * cloneNode(boolean b)：复制节点返回新节点，boolean 表示是否复制子节点，会丧失该节点上的事件回调函数\n\n * > childNodes：当前节点的所有子节点的NodeList集合，但是包括 Text、Commnet！空格之类的都包括！别用！\n   > \n   > hasChildNodes()：当前节点是否有子节点，也是包括所有类型节点！空格也算！别用！\n\n\n# NodeList 接口（了解）\n\n * NodeList实例是一个类似数组不是数组的对象，它的成员是节点对象。通过以下方法可以得到NodeList实例\n   * Node.childNodes：说了别用！省的没注意空格！\n   * document.querySelectorAll()等节点搜索方法\n * 属性：\n   * length，NodeList 实例包含的节点数量\n * 方法：\n   * forEach，也可以使用 for 循环。没 pop、pust 等方法哦！\n   * item(index)：接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。\n * 。。。懒得看了\n\n\n# HTMLCollection 接口（了解）\n\n * HTMLCollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与NodeList接口不同，HTMLCollection没有forEach方法，只能使用for循环遍历\n * 返回HTMLCollection实例的，主要是一些Document对象的集合属性，比如document.links、docuement.forms、document.images、document.styleSheets、document.scripts等\n * HTMLCollection实例都是动态集合，节点的变化会实时反映在集合中\n * 属性\n   * length：返回HTMLCollection实例包含的成员数量\n * 方法\n   * item()：接受一个整数值作为参数，表示成员的位置，返回该位置上的成员\n   * namedItem()：参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有则返回null\n\n\n# ParentNode 接口（注意 IE 基本不支持）\n\n * 只有元素节点（element）、文档节点（document）和文档片段节点（documentFragment）拥有子节点，因此只有这三类节点会继承ParentNode接口\n * 属性\n   * children：返回一个HTMLCollection实例，成员是当前节点的所有元素子节点。该属性只读。\n   * firstElementChild：当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null\n   * lastElementChild：当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null\n   * childElementCount：返回一个整数表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点则返回0\n * ==方法（如下方法都没有返回值）==\n   * append()：为当前节点的最后一个元素子节点后追加一个或多个子节点。可以添加元素子节点、文本子节点。IE 全不支持！！！\n   * prepend()：为当前节点的的第一个元素子节点前追加一个或多个子节点。同 append()方法\n     * 若是若newNode为 DOM 中已存在的，相当于剪贴\n\n\n# ChildNode 接口\n\n * 如果一个节点有父节点，那么该节点就继承了ChildNode接口\n * ==方法（都是本节点调用方法）==\n   * remove()：==用于从父节点移除当前节点，自己调用删除自己！因为已知本节点有父节点==\n   * before()：当前节点的前面，插入一个或多个同级节点，两者拥有相同的父节点。可以插入元素节点、文本节点\n   * after()：在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。同 before()方法\n   * replaceWith()：使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点\n\n\n# Document 🔥\n\n\n# 简介\n\n在 HTML DOM 模型中有宿主对象document，它是window对象的属性（也可以省略）。\n\n继承了 Node、ParentNode 等接口\n\n\n# 常用属性（好像不太常用）\n\n * body\n   \n   该属性封装的是 body 元素对象的引用\n\n * documentElement\n   \n   属性值为 HTML 元素对象\n\n * all\n   \n   属性值为当前页面中的所有元素节点的数组。这个属性值本身为undefined，它的typeof值也为undefined\n\n * URL\n   \n   获取当前页面的 url\n\n * domain\n   \n   获取当前页面的域名部分\n\n * referrer\n   \n   获取是哪个页面链接跳转到当前页面，没有则返回空字符串\n\n\n# 常用 CRUD 方法 🔥\n\n# 获取 Element 对象\n\n注意\n\n可以使用Document对象和Element对象调用如下函数。但是~ById()函数只能用在Document对象上\n\n注意\n\n如下方法都支持 IE8 及以上\n\n * querySelector()：CSS 选择器为参数，如果有多个节点满足匹配条件，则返回第一个匹配的节点，没有则返回 null\n\n * querySelectorAll()：返回一个NodeList对象，包含所有匹配给定选择器的节点。用法同上\n   \n   【注意】不支持 CSS 伪元素选择器和伪类选择器\n\n * getElementById(\"id\")：根据 ID 属性获取一个元素对象，效率比querySelector()高\n\n * getElementsByClassName(\"className\")：标签的 class 的属性值得到元素集合（HTMLCollection实例）\n\n * getElementsByTagName(\"tagName\")：标签名称得到元素集合（HTMLCollection实例）\n\n * getElementsByName(\"name\")：标签的 name 属性值得到元素集合（NodeList实例），radio、checkBox 等\n   \n   只有一个标签时通过document.getElementsByTag/ClassName(\"input\")[0]获取元素对象\n   \n   获取标签下面的子孙标签的唯一有效办法，使用父节点**getElementsByTagName()**方法，不使用 childNodes 属性\n\n# 添加 DOM 对象\n\n * createElement(\"元素名称\")：创建元素节点，参数为 tagName 属性，对 HTML 不区分大小写，但不能加尖括号\n * createTextNode(\"文本内容\")：创建文本节点，可以在内容中添加标签。不能对属性赋值，不会转义单双引\n * createAttribute(name)：创建拥有指定名称的属性节点，并返回新的 Attr 对象。通过 Node 来设置属性\n * createComment()：创建注释节点\n\n# 其他\n\n * write()：向页面输出变量（值）、html 代码\n\n\n# Element 🔥\n\n通过document来获取和创建\n\n\n# 常用属性\n\n * innerHTML：返回一个字符串，等同于该元素包含的所有 HTML 代码，该属性可读写。用来设置某个节点的内容\n\n * innerText：同上，但是只显示文本代码，不带标签的！！，设置内容也不会解析为 HTML\n\n * textContent：显示文本或插入的是文本时使用来替代上面方法。原样显示，不像上面方法会转为&**;来显示\n\n * value：代表的是元素的 value 属性，一般用于**input标签值的获取**，**select**标签值也可以使用\n\n * style：用来读写该元素的行内样式信息，配合 CSS。如 display 可取值 none、block、inner\n   \n   也可以提前定义好类选择器的样式，通过元素的className属性来设置其class属性值。\n\n\n# 常用 Attribute 方法\n\n * getAttribute(\"name\")：获取属性里面的值\n * setAttribute(\"name\",\"value\")：设置属性的值\n * removeAttribute(\"name\")：删除属性，不能删除 value 属性\n\n\n# Event\n\n\n# 加载事件\n\n * onload\n   \n   文档被浏览器加载时触发，只能写一次；一般在 body 标签中注册函数；或用 window 来调用。此时可以操作 DOM 元素**。\n   \n   window.onload = function() {\n     document.getElementById('btn').onclick = function() {\n       alert('haha')\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 点击事件\n\n * onclick：点击事件(按钮)\n * ondblclick：双击事件\n\n\n# 焦点事件(表单校验)\n\n * onfocus：组件获得焦点事件(输入框/单选/多选/下拉) ，光标闪动\n * onblur：组件失去焦点事件(输入框/单选/多选/下拉)\n\n\n# 改变事件\n\n * onchange：域的内容改变/选择的值发生变化事件(输入框/下拉)\n * onselect：文本被选中\n\n\n# 表单事件\n\n * onsubmit：表单提交按钮按下时触发的事件(表单校验)在 form 后注册函数，有返回值 true/false，控制提交与否\n   \n   必须写return 函数名否则不能获取到返回的 boolean 值\n\n * onreset：重置按钮按下时\n\n\n# 鼠标事件\n\n * onmouseover()：鼠标移动到组件上时触发\n\n * onmouseout：鼠标移出组件时触发\n\n * onmousemove：鼠标移动就触发\n\n * onmousedown：鼠标按键按下时触发\n   \n   定义方法时，定义一个形参来接收event对象，它的button属性可以获取鼠标哪个按钮被点击(0，1，2)\n\n * onmouseup：鼠标按键松开时触发\n\n\n# 键盘事件\n\n * onkeydown：某个键盘按键被按下\n * onkeyup：某个键盘按键被松开\n * onkeypress：某个键盘按键被按下并松开\n\n\n# 案例\n\n\n# 动态显示时间\n\nlet ele = document.getElementById('h1')\nfunction setTime() {\n  let s = new Date().toLocaleString()\n  ele.innerText = s\n}\nsetInterval(setTime, 1000)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 轮播图(正常不这么做)\n\nvar i = 1\nfunction changeImg() {\n  i++\n  if (i > 3) i = 1\n  document.getElementById('img1').src = 'img/' + i + '.jpg'\n}\nsetInterval(changeImg, 5000)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 定时弹出广告(style.display)\n\nshowTime = setTimeout(showAd, 3000) //定义为全局变量\n\nfunction showAd() {\n  document.getElementById('adImg').style.display = 'block'\n  clearTimeout(showTime)\n  hiddenTime = setTimeout(hiddenAd, 3000)\n}\n\nfunction hiddenAd() {\n  document.getElementById('adImg').style.display = 'none'\n  clearTimeout(hiddenTime)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 动态增删表格\n\ndocument.getElementById('btn').onclick = function() {\n  let id = document.getElementById('id').value\n  let name = document.getElementById('name').value\n  let sex = document.getElementById('sex').value\n  //thead\n  let tbd = document.getElementsByTagName('thead')[0]\n\n  document.getElementById('btn').onclick = function() {\n    let id = document.getElementById('id').value\n    let name = document.getElementById('name').value\n    let sex = document.getElementById('sex').value\n\n    let thd = document.getElementsByTagName('thead')[0]\n\n    thd.innerHTML +=\n      '<tr>\\n' +\n      '        <td>' +\n      id +\n      '</td>\\n' +\n      '        <td>' +\n      name +\n      '</td>\\n' +\n      '        <td>' +\n      sex +\n      '</td>\\n' +\n      '        <td><a href=\"javascript:void(0);\" onclick=\"delTr(this);\" >删除</a></td>\\n' +\n      '    </tr>'\n    //使用方法一个个添加也行，但是麻烦\n  }\n  function delTr(obj) {\n    var parentNode = obj.parentNode.parentNode.parentNode\n    var deleteNode = obj.parentNode.parentNode\n    parentNode.removeChild(deleteNode)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 全选/全不选/反选/高亮\n\nlet inputs = document.getElementsByClassName('check-box')\n//全选\ndocument.getElementById('selectAll').onclick = function() {\n  for (let i in inputs) {\n    inputs[i].checked = true\n  }\n}\n//全不选\ndocument.getElementById('notSelect').onclick = function() {\n  for (let i in inputs) {\n    inputs[i].checked = false\n  }\n}\n//反选\ndocument.getElementById('reverseSelect').onclick = function() {\n  for (let i in inputs) {\n    inputs[i].checked = !inputs[i].checked\n  }\n}\n//左上角选择\ndocument.getElementById('ck1').onclick = function() {\n  for (let i in inputs) {\n    inputs[i].checked = this.checked\n  }\n}\n//表格行高亮\nlet trs = document.getElementsByTagName('tr')\nfor (let t in trs) {\n  trs[t].onmouseover = function() {\n    this.style.backgroundColor = 'gray'\n  }\n  trs[t].onmouseout = function() {\n    this.style.backgroundColor = 'white'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 表单校验\n\nwindow.onload = function () {\n    //表单校验\n    document.getElementById(\"form\").onsubmit = function () {\n        return checkUsername();//可添加密码校验\n    }\n    document.getElementById(\"username\").onblur = checkUsername;//可添加密码校验\n\n}\n//用户名校验\nfunction checkUsername() {\n    var username = document.getElementById(\"username\").value;\n    var reg = /^\\w{6,12}$/;\n    let flag = reg.test(username);\n    if (flag) {\n        document.getElementById(\"usernameSpan\").innerHTML = \"✔\";\n    } else {\n        document.getElementById(\"usernameSpan\").innerHTML = \"用户名格式有误\";\n    }\n    return flag;\n}\n//可添加密码校验等等\n。。。。。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 左右列表\n\n * select、option、multiple、selected=true/false、appendChild()剪贴的 length 变化\n\nvar left = document.getElementById('left')\nvar leftlist = left.getElementsByTagName('option')\nvar right = document.getElementById('right')\nvar rightlist = right.getElementsByTagName('option')\n\nvar toRight = function() {\n  for (let i = 0; i < leftlist.length; i++) {\n    if (leftlist[i].selected) {\n      right.appendChild(leftlist[i])\n      i--\n    }\n  }\n}\nvar allToRight = function() {\n  for (let i = 0; i < leftlist.length; i++) {\n    right.appendChild(leftlist[i])\n    i--\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 表格隔行换色(tBodies、rows)\n\n//这样也可以获得行数\n//var tbody = document.getElementsByTagName(\"tbody\")[0];\n//var rows = tbody.getElementsByTagName(\"tr\").length;\n\nvar tb = document.getElementById('table1')\nvar rows = tb.tBodies[0].rows.length\nfor (let i = 0; i < rows; i++) {\n  if (i % 2 === 0) {\n    tb.tBodies[0].rows[i].style.backgroundColor = 'gray'\n  } else {\n    tb.tBodies[0].rows[i].style.backgroundColor = 'yellow'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 省市联动(this.value)\n\nlet arr = [\n  ['陕西', '西安', '商洛', '延安', '安康'],\n  ['河北', '石家庄', '廊坊', '秦皇岛', '雄安'],\n  ['广东', '深圳', '珠海', '广州', '不知道'],\n]\n\ndocument.getElementById('sheng').onchange = function() {\n  let option = document.getElementById('shi') //不能直接使用innerHTML来赋值\n  option.innerHTML = '' //每次改变时要清空\n  for (let i in arr) {\n    if (arr[i][0] === this.value) {\n      for (let j = 1; j < arr[i].length; j++) {\n        option.innerHTML += '<option>' + arr[i][j] + '</option>'\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# DOM 操作 🔥\n\n\n# 表单值获取 🔥\n\n<html>\n  <div id=\"radio\">\n    <h2>radio值获取</h2>\n    <div>\n      <input type=\"radio\" value=\"0\" name=\"radioStatus\" checked=\"checked\" />好评\n      <input type=\"radio\" value=\"1\" name=\"radioStatus\" />差评\n\n      <button id=\"getRadioStatus\">getRadioStatus</button>\n    </div>\n  </div>\n\n  <div id=\"checkbox\">\n    <h2>checkbox值获取</h2>\n    <div>\n      <input type=\"checkbox\" value=\"0\" name=\"checkboxStatus\" checked />唱\n      <input type=\"checkbox\" value=\"1\" name=\"checkboxStatus\" />跳\n      <input type=\"checkbox\" value=\"2\" name=\"checkboxStatus\" />rap\n      <input type=\"checkbox\" value=\"3\" name=\"checkboxStatus\" />篮球\n\n      <button id=\"getCheckboxStatus\">getCheckboxStatus</button>\n    </div>\n  </div>\n\n  <div id=\"select\">\n    <h2>select值获取</h2>\n    <div>\n      <select name=\"selectStatus\" id=\"selectStatus\">\n        <option value=\"1\">1</option>\n        <option value=\"2\">2</option>\n        <option value=\"3\">3</option>\n      </select>\n\n      <button id=\"getSelectStatus\">getSelectStatus</button>\n    </div>\n  </div>\n</html>\n<script>\n  const getRadioStatus = document.getElementById('getRadioStatus')\n  getRadioStatus.addEventListener('click', function() {\n    // $('input:radio[name=\"status\"]:checked').val()// jQuery方式，除了:radio外其实是CSS选择器\n    const test = document.querySelector('input[name=\"radioStatus\"]:checked') //CSS选择器，type=radio一般命名规范时可以省略\n    console.log(test.value)\n  })\n\n  const getCheckboxStatus = document.getElementById('getCheckboxStatus')\n  getCheckboxStatus.addEventListener('click', function() {\n    // $('input:checkbox').each(function() {\n    //     if ($(this).attr('checked') ==true) {\n    //         alert($(this).val());\n    //     }\n    // });\n    let nodeList = document.querySelectorAll(\n      'input[name=\"checkboxStatus\"]:checked'\n    )\n    console.log(nodeList) // NodeList 是对象，不是数组，无法使用 .map 流\n    nodeList.forEach((item) => console.log(item.value))\n  })\n\n  const getSelectStatus = document.getElementById('getSelectStatus')\n  getSelectStatus.addEventListener('click', function() {\n    // $('select[name=\"selectStatus\"]).val()// jQuery，就是CSS选择器，直接使用 #id 也可以！！！\n    const select = document.querySelector('select[name=\"selectStatus\"]') //CSS选择器，直接使用 #id 也可以！！！\n    console.log(select.value)\n\n    const index = select.selectedIndex // 索引，从0开始\n    const value = select.options[index].value //要的值\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n\n# 动态增删表单\n\n<html>\n  <button id=\"add\">add dom</button>\n  <div id=\"container\"></div>\n</html>\n<script>\n  const add = document.getElementById('add')\n  add.addEventListener('click', function() {\n    const container = document.getElementById('container')\n\n    const id = Date.now()\n    const div = document.createElement('div')\n    div.setAttribute('id', id)\n\n    const input = document.createElement('input')\n    input.setAttribute('type', 'text')\n    div.appendChild(input)\n\n    const button = document.createElement('button')\n    button.innerText = 'del dom'\n    div.appendChild(button)\n\n    button.addEventListener('click', function() {\n      const delEl = document.getElementById(id)\n      delEl.remove() // IE全不支持\n      // delEl.parentNode.removeChild(delEl)// 都支持\n    })\n\n    // innerHTML += 会导致重新渲染！！！\n    // container.innerHTML += html\n\n    container.append(div) // IE全不支持\n    // container.appendChild(div)// 都支持\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n\n# 动态增删表单 & 拖动 & 单击移动\n\nSee the Pen DOM crud&drag by apple54whn (@conanan) on CodePen.",normalizedContent:"# dom\n\ndom（document object model）：将标记语言文档的各个组成部分，封装为对象。可以使用这些对象，对标记语言文档进行 crud 的动态操作\n\nw3c dom 标准被分为 3 个不同的部分：\n\n * 核心 dom - 针对任何结构化文档的标准模型\n   * node：原生节点对象，以下节点对象都继承于此\n   * document：文档对象，整个文档树的顶层节点\n   * documenttype：doctype标签（比如<!doctype html>\n   * element：元素对象，网页的各种 html 标签（比如<body>、<a>等）\n   * attribute：属性对象，网页元素的属性（比如class=\"right\"）\n   * text：文本对象，标签之间或标签包含的文本\n   * comment：注释对象\n   * documentfragment：文档的片段\n * xml dom - 针对 xml 文档的标准模型\n * html dom - 针对 html 文档的标准模型\n\n解析过程：根据 html 的层级结构，在内存中分配一个树形结构，需要把 html 中的每部分封装成对象\n\n\n\n\n# node 🔥\n\n节点对象，其他对象的父对象。所有 dom 对象都可以被认为是一个节点\n\njs 中有宿主对象 document（文档对象本身），是 window 对象的属性。dom 中的对象又称为节点对象，4 种常用节点：\n\nnodename         nodetype    nodevalue   \ndocument 文档节点    #document   9           null\nelement 元素节点     标签名         1           null\nattribute 属性节点   属性名         2           属性值\ntext 文本节点        #text       3           文本内容\n\n\n# node 接口 🔥\n\n属性：\n\n * nodetype：一个整数值表示==节点的类型==。如 element 为 1、attribute 为 2、text 为 3、document 为 9\n * nodename：节点的名称。如 element 为大写标签名、attribute 为属性名、text 为#text、document 为#document\n * nodevalue：一个字符串，表示当前节点本身的文本值。只有 attribute、text、comment 有值，其余返回null\n * textcontent：当前节点和它的所有后代节点的==所有文本内容==，自动忽略当前节点内部的 html 标签\n * baseuri：一个字符串，表示当前网页的绝对路径\n * ownerdocument：当前节点所在的顶层文档对象，document 本身的这个属性为null。与getrootnode()一样作用\n * previoussiblin：当前节点==前==面的、距离最近的一个同级节点，没有同级节点则返回null\n * nextsibling：紧跟在当前节点==后==面的第一个同级节点，没有同级节点则返回null\n * parentnode：==当前节点的父节点==，可能有三种类型，如 document、element、documentfragment\n * parentelement：当前节点的父元素节点，排除了上述类型中首尾两个\n\n方法(crud dom 树)：\n\n * appendchild(newnode)：==将其作为最后一个子节点，插入当前节点==。若newnode为 dom 中已存在的，相当于剪贴\n\n * insertbefore(newnode,oldnode)：节点之前插入一个新的节点，没有 insertafter()方法可以结合nextsibling实现\n\n * removechild(node)：通过父节点删除指定子节点，并返回被删除的节点。不存在 dom 中，但在内存中仍可使用\n\n * replacechild(newnode,oldnode)：通过父节点用新节点替换一个子节点\n\n * clonenode(boolean b)：复制节点返回新节点，boolean 表示是否复制子节点，会丧失该节点上的事件回调函数\n\n * > childnodes：当前节点的所有子节点的nodelist集合，但是包括 text、commnet！空格之类的都包括！别用！\n   > \n   > haschildnodes()：当前节点是否有子节点，也是包括所有类型节点！空格也算！别用！\n\n\n# nodelist 接口（了解）\n\n * nodelist实例是一个类似数组不是数组的对象，它的成员是节点对象。通过以下方法可以得到nodelist实例\n   * node.childnodes：说了别用！省的没注意空格！\n   * document.queryselectorall()等节点搜索方法\n * 属性：\n   * length，nodelist 实例包含的节点数量\n * 方法：\n   * foreach，也可以使用 for 循环。没 pop、pust 等方法哦！\n   * item(index)：接受一个整数值作为参数，表示成员的位置，返回该位置上的成员。\n * 。。。懒得看了\n\n\n# htmlcollection 接口（了解）\n\n * htmlcollection是一个节点对象的集合，只能包含元素节点（element），不能包含其他类型的节点。它的返回值是一个类似数组的对象，但是与nodelist接口不同，htmlcollection没有foreach方法，只能使用for循环遍历\n * 返回htmlcollection实例的，主要是一些document对象的集合属性，比如document.links、docuement.forms、document.images、document.stylesheets、document.scripts等\n * htmlcollection实例都是动态集合，节点的变化会实时反映在集合中\n * 属性\n   * length：返回htmlcollection实例包含的成员数量\n * 方法\n   * item()：接受一个整数值作为参数，表示成员的位置，返回该位置上的成员\n   * nameditem()：参数是一个字符串，表示id属性或name属性的值，返回对应的元素节点。如果没有则返回null\n\n\n# parentnode 接口（注意 ie 基本不支持）\n\n * 只有元素节点（element）、文档节点（document）和文档片段节点（documentfragment）拥有子节点，因此只有这三类节点会继承parentnode接口\n * 属性\n   * children：返回一个htmlcollection实例，成员是当前节点的所有元素子节点。该属性只读。\n   * firstelementchild：当前节点的第一个元素子节点。如果没有任何元素子节点，则返回null\n   * lastelementchild：当前节点的最后一个元素子节点，如果不存在任何元素子节点，则返回null\n   * childelementcount：返回一个整数表示当前节点的所有元素子节点的数目。如果不包含任何元素子节点则返回0\n * ==方法（如下方法都没有返回值）==\n   * append()：为当前节点的最后一个元素子节点后追加一个或多个子节点。可以添加元素子节点、文本子节点。ie 全不支持！！！\n   * prepend()：为当前节点的的第一个元素子节点前追加一个或多个子节点。同 append()方法\n     * 若是若newnode为 dom 中已存在的，相当于剪贴\n\n\n# childnode 接口\n\n * 如果一个节点有父节点，那么该节点就继承了childnode接口\n * ==方法（都是本节点调用方法）==\n   * remove()：==用于从父节点移除当前节点，自己调用删除自己！因为已知本节点有父节点==\n   * before()：当前节点的前面，插入一个或多个同级节点，两者拥有相同的父节点。可以插入元素节点、文本节点\n   * after()：在当前节点的后面，插入一个或多个同级节点，两者拥有相同的父节点。同 before()方法\n   * replacewith()：使用参数节点，替换当前节点。参数可以是元素节点，也可以是文本节点\n\n\n# document 🔥\n\n\n# 简介\n\n在 html dom 模型中有宿主对象document，它是window对象的属性（也可以省略）。\n\n继承了 node、parentnode 等接口\n\n\n# 常用属性（好像不太常用）\n\n * body\n   \n   该属性封装的是 body 元素对象的引用\n\n * documentelement\n   \n   属性值为 html 元素对象\n\n * all\n   \n   属性值为当前页面中的所有元素节点的数组。这个属性值本身为undefined，它的typeof值也为undefined\n\n * url\n   \n   获取当前页面的 url\n\n * domain\n   \n   获取当前页面的域名部分\n\n * referrer\n   \n   获取是哪个页面链接跳转到当前页面，没有则返回空字符串\n\n\n# 常用 crud 方法 🔥\n\n# 获取 element 对象\n\n注意\n\n可以使用document对象和element对象调用如下函数。但是~byid()函数只能用在document对象上\n\n注意\n\n如下方法都支持 ie8 及以上\n\n * queryselector()：css 选择器为参数，如果有多个节点满足匹配条件，则返回第一个匹配的节点，没有则返回 null\n\n * queryselectorall()：返回一个nodelist对象，包含所有匹配给定选择器的节点。用法同上\n   \n   【注意】不支持 css 伪元素选择器和伪类选择器\n\n * getelementbyid(\"id\")：根据 id 属性获取一个元素对象，效率比queryselector()高\n\n * getelementsbyclassname(\"classname\")：标签的 class 的属性值得到元素集合（htmlcollection实例）\n\n * getelementsbytagname(\"tagname\")：标签名称得到元素集合（htmlcollection实例）\n\n * getelementsbyname(\"name\")：标签的 name 属性值得到元素集合（nodelist实例），radio、checkbox 等\n   \n   只有一个标签时通过document.getelementsbytag/classname(\"input\")[0]获取元素对象\n   \n   获取标签下面的子孙标签的唯一有效办法，使用父节点**getelementsbytagname()**方法，不使用 childnodes 属性\n\n# 添加 dom 对象\n\n * createelement(\"元素名称\")：创建元素节点，参数为 tagname 属性，对 html 不区分大小写，但不能加尖括号\n * createtextnode(\"文本内容\")：创建文本节点，可以在内容中添加标签。不能对属性赋值，不会转义单双引\n * createattribute(name)：创建拥有指定名称的属性节点，并返回新的 attr 对象。通过 node 来设置属性\n * createcomment()：创建注释节点\n\n# 其他\n\n * write()：向页面输出变量（值）、html 代码\n\n\n# element 🔥\n\n通过document来获取和创建\n\n\n# 常用属性\n\n * innerhtml：返回一个字符串，等同于该元素包含的所有 html 代码，该属性可读写。用来设置某个节点的内容\n\n * innertext：同上，但是只显示文本代码，不带标签的！！，设置内容也不会解析为 html\n\n * textcontent：显示文本或插入的是文本时使用来替代上面方法。原样显示，不像上面方法会转为&**;来显示\n\n * value：代表的是元素的 value 属性，一般用于**input标签值的获取**，**select**标签值也可以使用\n\n * style：用来读写该元素的行内样式信息，配合 css。如 display 可取值 none、block、inner\n   \n   也可以提前定义好类选择器的样式，通过元素的classname属性来设置其class属性值。\n\n\n# 常用 attribute 方法\n\n * getattribute(\"name\")：获取属性里面的值\n * setattribute(\"name\",\"value\")：设置属性的值\n * removeattribute(\"name\")：删除属性，不能删除 value 属性\n\n\n# event\n\n\n# 加载事件\n\n * onload\n   \n   文档被浏览器加载时触发，只能写一次；一般在 body 标签中注册函数；或用 window 来调用。此时可以操作 dom 元素**。\n   \n   window.onload = function() {\n     document.getelementbyid('btn').onclick = function() {\n       alert('haha')\n     }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# 点击事件\n\n * onclick：点击事件(按钮)\n * ondblclick：双击事件\n\n\n# 焦点事件(表单校验)\n\n * onfocus：组件获得焦点事件(输入框/单选/多选/下拉) ，光标闪动\n * onblur：组件失去焦点事件(输入框/单选/多选/下拉)\n\n\n# 改变事件\n\n * onchange：域的内容改变/选择的值发生变化事件(输入框/下拉)\n * onselect：文本被选中\n\n\n# 表单事件\n\n * onsubmit：表单提交按钮按下时触发的事件(表单校验)在 form 后注册函数，有返回值 true/false，控制提交与否\n   \n   必须写return 函数名否则不能获取到返回的 boolean 值\n\n * onreset：重置按钮按下时\n\n\n# 鼠标事件\n\n * onmouseover()：鼠标移动到组件上时触发\n\n * onmouseout：鼠标移出组件时触发\n\n * onmousemove：鼠标移动就触发\n\n * onmousedown：鼠标按键按下时触发\n   \n   定义方法时，定义一个形参来接收event对象，它的button属性可以获取鼠标哪个按钮被点击(0，1，2)\n\n * onmouseup：鼠标按键松开时触发\n\n\n# 键盘事件\n\n * onkeydown：某个键盘按键被按下\n * onkeyup：某个键盘按键被松开\n * onkeypress：某个键盘按键被按下并松开\n\n\n# 案例\n\n\n# 动态显示时间\n\nlet ele = document.getelementbyid('h1')\nfunction settime() {\n  let s = new date().tolocalestring()\n  ele.innertext = s\n}\nsetinterval(settime, 1000)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# 轮播图(正常不这么做)\n\nvar i = 1\nfunction changeimg() {\n  i++\n  if (i > 3) i = 1\n  document.getelementbyid('img1').src = 'img/' + i + '.jpg'\n}\nsetinterval(changeimg, 5000)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 定时弹出广告(style.display)\n\nshowtime = settimeout(showad, 3000) //定义为全局变量\n\nfunction showad() {\n  document.getelementbyid('adimg').style.display = 'block'\n  cleartimeout(showtime)\n  hiddentime = settimeout(hiddenad, 3000)\n}\n\nfunction hiddenad() {\n  document.getelementbyid('adimg').style.display = 'none'\n  cleartimeout(hiddentime)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 动态增删表格\n\ndocument.getelementbyid('btn').onclick = function() {\n  let id = document.getelementbyid('id').value\n  let name = document.getelementbyid('name').value\n  let sex = document.getelementbyid('sex').value\n  //thead\n  let tbd = document.getelementsbytagname('thead')[0]\n\n  document.getelementbyid('btn').onclick = function() {\n    let id = document.getelementbyid('id').value\n    let name = document.getelementbyid('name').value\n    let sex = document.getelementbyid('sex').value\n\n    let thd = document.getelementsbytagname('thead')[0]\n\n    thd.innerhtml +=\n      '<tr>\\n' +\n      '        <td>' +\n      id +\n      '</td>\\n' +\n      '        <td>' +\n      name +\n      '</td>\\n' +\n      '        <td>' +\n      sex +\n      '</td>\\n' +\n      '        <td><a href=\"javascript:void(0);\" onclick=\"deltr(this);\" >删除</a></td>\\n' +\n      '    </tr>'\n    //使用方法一个个添加也行，但是麻烦\n  }\n  function deltr(obj) {\n    var parentnode = obj.parentnode.parentnode.parentnode\n    var deletenode = obj.parentnode.parentnode\n    parentnode.removechild(deletenode)\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 全选/全不选/反选/高亮\n\nlet inputs = document.getelementsbyclassname('check-box')\n//全选\ndocument.getelementbyid('selectall').onclick = function() {\n  for (let i in inputs) {\n    inputs[i].checked = true\n  }\n}\n//全不选\ndocument.getelementbyid('notselect').onclick = function() {\n  for (let i in inputs) {\n    inputs[i].checked = false\n  }\n}\n//反选\ndocument.getelementbyid('reverseselect').onclick = function() {\n  for (let i in inputs) {\n    inputs[i].checked = !inputs[i].checked\n  }\n}\n//左上角选择\ndocument.getelementbyid('ck1').onclick = function() {\n  for (let i in inputs) {\n    inputs[i].checked = this.checked\n  }\n}\n//表格行高亮\nlet trs = document.getelementsbytagname('tr')\nfor (let t in trs) {\n  trs[t].onmouseover = function() {\n    this.style.backgroundcolor = 'gray'\n  }\n  trs[t].onmouseout = function() {\n    this.style.backgroundcolor = 'white'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 表单校验\n\nwindow.onload = function () {\n    //表单校验\n    document.getelementbyid(\"form\").onsubmit = function () {\n        return checkusername();//可添加密码校验\n    }\n    document.getelementbyid(\"username\").onblur = checkusername;//可添加密码校验\n\n}\n//用户名校验\nfunction checkusername() {\n    var username = document.getelementbyid(\"username\").value;\n    var reg = /^\\w{6,12}$/;\n    let flag = reg.test(username);\n    if (flag) {\n        document.getelementbyid(\"usernamespan\").innerhtml = \"✔\";\n    } else {\n        document.getelementbyid(\"usernamespan\").innerhtml = \"用户名格式有误\";\n    }\n    return flag;\n}\n//可添加密码校验等等\n。。。。。\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# 左右列表\n\n * select、option、multiple、selected=true/false、appendchild()剪贴的 length 变化\n\nvar left = document.getelementbyid('left')\nvar leftlist = left.getelementsbytagname('option')\nvar right = document.getelementbyid('right')\nvar rightlist = right.getelementsbytagname('option')\n\nvar toright = function() {\n  for (let i = 0; i < leftlist.length; i++) {\n    if (leftlist[i].selected) {\n      right.appendchild(leftlist[i])\n      i--\n    }\n  }\n}\nvar alltoright = function() {\n  for (let i = 0; i < leftlist.length; i++) {\n    right.appendchild(leftlist[i])\n    i--\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 表格隔行换色(tbodies、rows)\n\n//这样也可以获得行数\n//var tbody = document.getelementsbytagname(\"tbody\")[0];\n//var rows = tbody.getelementsbytagname(\"tr\").length;\n\nvar tb = document.getelementbyid('table1')\nvar rows = tb.tbodies[0].rows.length\nfor (let i = 0; i < rows; i++) {\n  if (i % 2 === 0) {\n    tb.tbodies[0].rows[i].style.backgroundcolor = 'gray'\n  } else {\n    tb.tbodies[0].rows[i].style.backgroundcolor = 'yellow'\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 省市联动(this.value)\n\nlet arr = [\n  ['陕西', '西安', '商洛', '延安', '安康'],\n  ['河北', '石家庄', '廊坊', '秦皇岛', '雄安'],\n  ['广东', '深圳', '珠海', '广州', '不知道'],\n]\n\ndocument.getelementbyid('sheng').onchange = function() {\n  let option = document.getelementbyid('shi') //不能直接使用innerhtml来赋值\n  option.innerhtml = '' //每次改变时要清空\n  for (let i in arr) {\n    if (arr[i][0] === this.value) {\n      for (let j = 1; j < arr[i].length; j++) {\n        option.innerhtml += '<option>' + arr[i][j] + '</option>'\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# dom 操作 🔥\n\n\n# 表单值获取 🔥\n\n<html>\n  <div id=\"radio\">\n    <h2>radio值获取</h2>\n    <div>\n      <input type=\"radio\" value=\"0\" name=\"radiostatus\" checked=\"checked\" />好评\n      <input type=\"radio\" value=\"1\" name=\"radiostatus\" />差评\n\n      <button id=\"getradiostatus\">getradiostatus</button>\n    </div>\n  </div>\n\n  <div id=\"checkbox\">\n    <h2>checkbox值获取</h2>\n    <div>\n      <input type=\"checkbox\" value=\"0\" name=\"checkboxstatus\" checked />唱\n      <input type=\"checkbox\" value=\"1\" name=\"checkboxstatus\" />跳\n      <input type=\"checkbox\" value=\"2\" name=\"checkboxstatus\" />rap\n      <input type=\"checkbox\" value=\"3\" name=\"checkboxstatus\" />篮球\n\n      <button id=\"getcheckboxstatus\">getcheckboxstatus</button>\n    </div>\n  </div>\n\n  <div id=\"select\">\n    <h2>select值获取</h2>\n    <div>\n      <select name=\"selectstatus\" id=\"selectstatus\">\n        <option value=\"1\">1</option>\n        <option value=\"2\">2</option>\n        <option value=\"3\">3</option>\n      </select>\n\n      <button id=\"getselectstatus\">getselectstatus</button>\n    </div>\n  </div>\n</html>\n<script>\n  const getradiostatus = document.getelementbyid('getradiostatus')\n  getradiostatus.addeventlistener('click', function() {\n    // $('input:radio[name=\"status\"]:checked').val()// jquery方式，除了:radio外其实是css选择器\n    const test = document.queryselector('input[name=\"radiostatus\"]:checked') //css选择器，type=radio一般命名规范时可以省略\n    console.log(test.value)\n  })\n\n  const getcheckboxstatus = document.getelementbyid('getcheckboxstatus')\n  getcheckboxstatus.addeventlistener('click', function() {\n    // $('input:checkbox').each(function() {\n    //     if ($(this).attr('checked') ==true) {\n    //         alert($(this).val());\n    //     }\n    // });\n    let nodelist = document.queryselectorall(\n      'input[name=\"checkboxstatus\"]:checked'\n    )\n    console.log(nodelist) // nodelist 是对象，不是数组，无法使用 .map 流\n    nodelist.foreach((item) => console.log(item.value))\n  })\n\n  const getselectstatus = document.getelementbyid('getselectstatus')\n  getselectstatus.addeventlistener('click', function() {\n    // $('select[name=\"selectstatus\"]).val()// jquery，就是css选择器，直接使用 #id 也可以！！！\n    const select = document.queryselector('select[name=\"selectstatus\"]') //css选择器，直接使用 #id 也可以！！！\n    console.log(select.value)\n\n    const index = select.selectedindex // 索引，从0开始\n    const value = select.options[index].value //要的值\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n\n# 动态增删表单\n\n<html>\n  <button id=\"add\">add dom</button>\n  <div id=\"container\"></div>\n</html>\n<script>\n  const add = document.getelementbyid('add')\n  add.addeventlistener('click', function() {\n    const container = document.getelementbyid('container')\n\n    const id = date.now()\n    const div = document.createelement('div')\n    div.setattribute('id', id)\n\n    const input = document.createelement('input')\n    input.setattribute('type', 'text')\n    div.appendchild(input)\n\n    const button = document.createelement('button')\n    button.innertext = 'del dom'\n    div.appendchild(button)\n\n    button.addeventlistener('click', function() {\n      const delel = document.getelementbyid(id)\n      delel.remove() // ie全不支持\n      // delel.parentnode.removechild(delel)// 都支持\n    })\n\n    // innerhtml += 会导致重新渲染！！！\n    // container.innerhtml += html\n\n    container.append(div) // ie全不支持\n    // container.appendchild(div)// 都支持\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n\n# 动态增删表单 & 拖动 & 单击移动\n\nsee the pen dom crud&drag by apple54whn (@conanan) on codepen.",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"8 网络-1 Ajax",frontmatter:{title:"8 网络-1 Ajax",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/560afc/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/600.%E7%BD%91%E7%BB%9C/601.Ajax.html",relativePath:"1200.JS/600.网络/601.Ajax.md",key:"v-ac8c93d4",path:"/pages/560afc/",headers:[{level:2,title:"Ajax概述",slug:"ajax概述",normalizedTitle:"ajax概述",charIndex:11},{level:2,title:"JS 原生的 Ajax 技术",slug:"js-原生的-ajax-技术",normalizedTitle:"js 原生的 ajax 技术",charIndex:606},{level:2,title:"jQuery 的 Ajax 技术",slug:"jquery-的-ajax-技术",normalizedTitle:"jquery 的 ajax 技术",charIndex:1953},{level:2,title:"JSON",slug:"json",normalizedTitle:"json",charIndex:3018},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:3366},{level:3,title:"JSON和Java对象的转换",slug:"json和java对象的转换",normalizedTitle:"json和java对象的转换",charIndex:4491},{level:4,title:"Java对象转换JSON",slug:"java对象转换json",normalizedTitle:"java对象转换json",charIndex:4646},{level:4,title:"JSON转为Java对象",slug:"json转为java对象",normalizedTitle:"json转为java对象",charIndex:5109},{level:2,title:"案例",slug:"案例",normalizedTitle:"案例",charIndex:5181},{level:3,title:"异步校验用户名是否存在",slug:"异步校验用户名是否存在",normalizedTitle:"异步校验用户名是否存在",charIndex:5188},{level:3,title:"站内搜索",slug:"站内搜索",normalizedTitle:"站内搜索",charIndex:6679}],headersStr:"Ajax概述 JS 原生的 Ajax 技术 jQuery 的 Ajax 技术 JSON 简介 JSON和Java对象的转换 Java对象转换JSON JSON转为Java对象 案例 异步校验用户名是否存在 站内搜索",content:'# Ajax\n\n\n# Ajax概述\n\n * Ajax(asynchronous javascript and xml)：异步的javascript 和xml。它能使用javascript 异步访问服务器\n\n * 同步和异步：客户端和服务器端相互通信的基础上，客户端发送请求到服务器端\n   \n   * 同步：客户端必须等待服务器端的响应，在等待的期间客户端不能做其他操作\n   * 异步：客户端不需要等待服务器端的响应，在服务器处理请求的过程中，客户端可以进行其他的操作\n\n * Ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，提升用户的体验。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。\n\n * Ajax运行原理\n   \n   页面发起请求，会将请求发送给==浏览器内核中的Ajax引擎==，Ajax引擎会提交请求到服务器端，在这段时间里，客户端可以任意进行任意操作，直到服务器端将数据返回给Ajax引擎后，会触发你设置的事件，从而执行自定义的js逻辑代码完成某种页面功能\n\n * Ajax应用场景\n   \n   * 谷歌/百度的搜索框自动补全\n   * 用户注册时（校验用户名是否被注册过）\n   * 下拉框联动\n\n\n# JS 原生的 Ajax 技术\n\nJS 原生的Ajax其实就是围绕浏览器内内置的Ajax引擎对象进行学习的，使用js原生的Ajax完成异步操作：\n\n 1. 创建Ajax引擎对象XHR\n    \n    var xmlHttp = new XMLHttpRequest();\n    //var xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");//IE5和IE6,现在基本没了吧\n    \n    \n    1\n    2\n    \n\n 2. 为Ajax引擎对象绑定监听onreadystatechange（监听服务器已将数据响应给引擎），每当 readyState 改变时，就会触发 onreadystatechange 事件\n    \n    xmlhttp.onreadystatechange=function(){\n    \tif (xmlhttp.readyState==4 && xmlhttp.status==200){\n        \tdocument.getElementById("myDiv").innerHTML=xmlhttp.responseText;\n    \t\t//还有responseXml这个方法\n    \t}\n    }\n    /*    readyState有如下5个状态\n     - 0: 请求未初始化\n     - 1: 服务器连接已建立\n     - 2: 请求已接收\n     - 3: 请求处理中\n     - 4: 请求已完成，且响应已就绪*/\n    \n    /*  status情况\n      - 200: "OK"\n      - 404: 未找到页面*/\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 3. 绑定提交地址open\n    \n    xmlHttp.open("GET", "/day23_1/AServlet", true);\n    //- 请求方式：可以是GET或POST\n    //- 请求的URL：指定服务器端资源，例如；/day23_1/AServlet\n    //- 请求是否为异步：如果为true表示发送异步请求，否则同步请求！\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 发送请求\n    \n    //如果是发送POST请求，需要设置Content-Type请求头\n    xmlHttp.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");\n    xmlHttp.send();//POST请求参数写在方法里；如果是GET请求参数可以写在open中URL后\n    \n    \n    1\n    2\n    3\n    \n\n 5. 接受响应数据：写在onreadystatechange事件函数中\n\n\n# jQuery 的 Ajax 技术\n\njQuery是一个优秀的js框架，自然对js原生的ajax进行了封装，封装后的ajax的操作方法更简洁，功能更强大，与ajax操作相关的jQuery方法有如下几种，但开发中经常使用的有三种\n\n$.ajax( url [, settings ] )：是ajax在jquery中的底层实现，最复杂，最强功能。url必须有，也可在settings中设置\n\n$.ajax({\n    url: "AjaxServlet", //请求路径，不加/\n    type: "POST", //请求方式\n    async: true, //是否异步\n    data: {"name": "zhangsan", "age": 22},\n    //contentType: 设置发送信息的MIME类型，可以不设置，默认application/x-www-form-urlencoded\n    success: function (data) {\n        alert(data.name);\n    },\n    error: function () {\n        alert("请求失败");\n    },\n    dataType: "json" //服务器返回的数据类型，若不指定S将根据HTTP包MIME信息来智能判断\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n$.get( url [, data ] [, success ] [, dataType ] )：发送get请求\n\n$.post( url [, data ] [, success ] [, dataType ] )：发送post请求\n\n$.get( //$.post和get没区别\n    "AjaxServlet",  //url：待载入页面的URL地址，不加/\n    {"name":"zhangsan","age":22},  //data：待发送 Key/value 参数\n    function (data) {  //callback：载入成功时回调函数;data是接收服务端发送的数据\n        alert(data.name+":"+data.age)\n    },\n    "json"  //type：返回内容格式xml, html, script, json, text, _default\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$.getJSON( url [, data ] [, success ] )：getJSON专门用于请求json数据\n\n$.getScript(url[,callback])\n\nload(url[,data][,callback])\n\n * GET和POST提交基本差不多，有一个地方不一样就是提交的数据是中文的话，Servlet需要编码，解码\n   * 若是POST提交，可以设置request.setCharacterEncoding("utf-8")或者不用管，Ajax本身就解决了\n   * 若是GET提交，则需要编码解码\n\nserialize()：jQuery中序列表单内容为字符串。可用于Ajax提交表单\n\nAjax的其他delete、put等查看HTML章节介绍\n\n\n# JSON\n\n\n# 简介\n\nJSON（JavaScript Object Notation）：JavaScript对象表示法\n\nJSON是一种与语言无关的数据交换的格式，作用：\n\n * JSON现在多用于存储和交换文本信息的语法\n * 进行数据的传输\n * JSON 比 XML 更小、更快，更易解析\n\n语法\n\n 1. 基本规则\n    \n    * 数据在名称/值对中，**键用双引号（严格模式，但在js中可以不用）**引起来\n    * 值的取值类型：\n      1. 数字（整数或浮点数）\n      2. 字符串（在双引号中）\n      3. 逻辑值（true 或 false）\n      4. 数组（在方括号中） {"persons":[{},{}]}\n      5. 对象（在花括号中） {"address":{"province"："陕西"....}}\n      6. null\n    * 数据由逗号分隔：多个键值对由逗号分隔\n    * 花括号保存对象：使用{}定义json 格式\n    * 方括号保存数组：[]\n\n 2. 获取数据：JSON 是JavaScript的原生内容，也就是JavaScript可以直接取出JSON 对象中的数据\n    \n    1. JSON对象.键名\n    \n    2. JSON对象["键名"]\n    \n    3. 数组对象[索引]\n    \n    4. 遍历：\n       \n       1. for...in：遍历属性，即key字符串。普通for循环也可以\n          \n          for(let key in person){    \n              //alert(key + ":" + person.key); //这样不能获取到。因为key值为字符串，相当于person."name"\n              alert(key+":"+person[key]);\n          }\n          \n          \n          1\n          2\n          3\n          4\n          \n       \n       2. for...of：遍历值\n          \n          for(let value of person){\n              alert(value.name);\n          }\n          \n          \n          1\n          2\n          3\n          \n\n\n# JSON和Java对象的转换\n\n * 常见的JSON解析器：Jsonlib，Gson（谷歌），fastjson（阿里），jackson（Spring内置）\n * 使用步骤\n   1. 导入jackson的相关jar包\n   2. 创建Jackson核心对象 ObjectMapper\n   3. 如下：\n\n# Java对象转换JSON\n\n * 调用ObjectMapper的相关方法进行转换\n   1. 转换方法\n      1. writeValueAsString(obj)：将对象转为json字符串\n      2. writeValue(参数1，obj)，参数1如下：\n         * File：将obj对象转换为JSON字符串，并保存到指定的文件中\n         * Writer：将obj对象转换为JSON字符串，并将json数据填充到字符输出流中\n         * OutputStream：将obj对象转换为JSON字符串，并将json数据填充到字节输出流中\n   2. 注解（在JavaBean的属性上注解）\n      1. @JsonIgnore：排除属性\n      2. @JsonFormat(pattern = "yyyy-MM-dd")：属性值得格式化，pattern自定义\n   3. 复杂java对象转换\n      1. List：数组\n      2. Map：对象格式一致\n\n# JSON转为Java对象\n\n * 调用ObjectMapper的相关方法进行转换：readValue(json字符串数据,Class)\n\n\n# 案例\n\n\n# 异步校验用户名是否存在\n\n$("#inputusername").blur(function () {\n    var username = $(this).val();\n    //期望服务器响应回的数据格式：{"userExsit":true,"msg":"此用户名太受欢迎,请更换一个"}\n    //                         {"userExsit":false,"msg":"用户名可用"}\n    $.post(\n        "/CheckServlet",\n        {"username":username},\n        function(data){\n            if(data.userExsit){\n                $("#usernameTag").text(data.msg);\n                $("#usernameTag").css("color","red")\n            } else {\n                $("#usernameTag").text(data.msg);\n                $("#usernameTag").css("color","green")\n            }\n        },\n        "json"\n    )\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n//设置响应的数据格式为json\nresponse.setContentType("application/json;charset=utf-8");\nString username = request.getParameter("username");//获取用户名\n//期望服务器响应回的数据格式：{"userExsit":true,"msg":"此用户名太受欢迎,请更换一个"}\n//                         {"userExsit":false,"msg":"用户名可用"}\nMap<String,Object> map = new HashMap<String,Object>();\nif("tom".equals(username)){ //存在    \n    map.put("userExsit",true);\n    map.put("msg","此用户名太受欢迎,请更换一个");\n}else{ //不存在\n    map.put("userExsit",false);\n    map.put("msg","用户名可用");\n}\n\n//将map转为json，并且传递给客户端\nObjectMapper mapper = new ObjectMapper();\nmapper.writeValue(response.getWriter(),map);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：\n   1. $.get()或$.post()或$.ajax()：将参数dataType指定为"json"\n   2. 在服务器端设置MIME类型response.setContentType("application/json;charset=utf-8");\n\n\n# 站内搜索',normalizedContent:'# ajax\n\n\n# ajax概述\n\n * ajax(asynchronous javascript and xml)：异步的javascript 和xml。它能使用javascript 异步访问服务器\n\n * 同步和异步：客户端和服务器端相互通信的基础上，客户端发送请求到服务器端\n   \n   * 同步：客户端必须等待服务器端的响应，在等待的期间客户端不能做其他操作\n   * 异步：客户端不需要等待服务器端的响应，在服务器处理请求的过程中，客户端可以进行其他的操作\n\n * ajax 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新，提升用户的体验。传统的网页（不使用 ajax）如果需要更新内容，必须重载整个网页页面。\n\n * ajax运行原理\n   \n   页面发起请求，会将请求发送给==浏览器内核中的ajax引擎==，ajax引擎会提交请求到服务器端，在这段时间里，客户端可以任意进行任意操作，直到服务器端将数据返回给ajax引擎后，会触发你设置的事件，从而执行自定义的js逻辑代码完成某种页面功能\n\n * ajax应用场景\n   \n   * 谷歌/百度的搜索框自动补全\n   * 用户注册时（校验用户名是否被注册过）\n   * 下拉框联动\n\n\n# js 原生的 ajax 技术\n\njs 原生的ajax其实就是围绕浏览器内内置的ajax引擎对象进行学习的，使用js原生的ajax完成异步操作：\n\n 1. 创建ajax引擎对象xhr\n    \n    var xmlhttp = new xmlhttprequest();\n    //var xmlhttp = new activexobject("microsoft.xmlhttp");//ie5和ie6,现在基本没了吧\n    \n    \n    1\n    2\n    \n\n 2. 为ajax引擎对象绑定监听onreadystatechange（监听服务器已将数据响应给引擎），每当 readystate 改变时，就会触发 onreadystatechange 事件\n    \n    xmlhttp.onreadystatechange=function(){\n    \tif (xmlhttp.readystate==4 && xmlhttp.status==200){\n        \tdocument.getelementbyid("mydiv").innerhtml=xmlhttp.responsetext;\n    \t\t//还有responsexml这个方法\n    \t}\n    }\n    /*    readystate有如下5个状态\n     - 0: 请求未初始化\n     - 1: 服务器连接已建立\n     - 2: 请求已接收\n     - 3: 请求处理中\n     - 4: 请求已完成，且响应已就绪*/\n    \n    /*  status情况\n      - 200: "ok"\n      - 404: 未找到页面*/\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 3. 绑定提交地址open\n    \n    xmlhttp.open("get", "/day23_1/aservlet", true);\n    //- 请求方式：可以是get或post\n    //- 请求的url：指定服务器端资源，例如；/day23_1/aservlet\n    //- 请求是否为异步：如果为true表示发送异步请求，否则同步请求！\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 发送请求\n    \n    //如果是发送post请求，需要设置content-type请求头\n    xmlhttp.setrequestheader("content-type", "application/x-www-form-urlencoded");\n    xmlhttp.send();//post请求参数写在方法里；如果是get请求参数可以写在open中url后\n    \n    \n    1\n    2\n    3\n    \n\n 5. 接受响应数据：写在onreadystatechange事件函数中\n\n\n# jquery 的 ajax 技术\n\njquery是一个优秀的js框架，自然对js原生的ajax进行了封装，封装后的ajax的操作方法更简洁，功能更强大，与ajax操作相关的jquery方法有如下几种，但开发中经常使用的有三种\n\n$.ajax( url [, settings ] )：是ajax在jquery中的底层实现，最复杂，最强功能。url必须有，也可在settings中设置\n\n$.ajax({\n    url: "ajaxservlet", //请求路径，不加/\n    type: "post", //请求方式\n    async: true, //是否异步\n    data: {"name": "zhangsan", "age": 22},\n    //contenttype: 设置发送信息的mime类型，可以不设置，默认application/x-www-form-urlencoded\n    success: function (data) {\n        alert(data.name);\n    },\n    error: function () {\n        alert("请求失败");\n    },\n    datatype: "json" //服务器返回的数据类型，若不指定s将根据http包mime信息来智能判断\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n$.get( url [, data ] [, success ] [, datatype ] )：发送get请求\n\n$.post( url [, data ] [, success ] [, datatype ] )：发送post请求\n\n$.get( //$.post和get没区别\n    "ajaxservlet",  //url：待载入页面的url地址，不加/\n    {"name":"zhangsan","age":22},  //data：待发送 key/value 参数\n    function (data) {  //callback：载入成功时回调函数;data是接收服务端发送的数据\n        alert(data.name+":"+data.age)\n    },\n    "json"  //type：返回内容格式xml, html, script, json, text, _default\n);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n$.getjson( url [, data ] [, success ] )：getjson专门用于请求json数据\n\n$.getscript(url[,callback])\n\nload(url[,data][,callback])\n\n * get和post提交基本差不多，有一个地方不一样就是提交的数据是中文的话，servlet需要编码，解码\n   * 若是post提交，可以设置request.setcharacterencoding("utf-8")或者不用管，ajax本身就解决了\n   * 若是get提交，则需要编码解码\n\nserialize()：jquery中序列表单内容为字符串。可用于ajax提交表单\n\najax的其他delete、put等查看html章节介绍\n\n\n# json\n\n\n# 简介\n\njson（javascript object notation）：javascript对象表示法\n\njson是一种与语言无关的数据交换的格式，作用：\n\n * json现在多用于存储和交换文本信息的语法\n * 进行数据的传输\n * json 比 xml 更小、更快，更易解析\n\n语法\n\n 1. 基本规则\n    \n    * 数据在名称/值对中，**键用双引号（严格模式，但在js中可以不用）**引起来\n    * 值的取值类型：\n      1. 数字（整数或浮点数）\n      2. 字符串（在双引号中）\n      3. 逻辑值（true 或 false）\n      4. 数组（在方括号中） {"persons":[{},{}]}\n      5. 对象（在花括号中） {"address":{"province"："陕西"....}}\n      6. null\n    * 数据由逗号分隔：多个键值对由逗号分隔\n    * 花括号保存对象：使用{}定义json 格式\n    * 方括号保存数组：[]\n\n 2. 获取数据：json 是javascript的原生内容，也就是javascript可以直接取出json 对象中的数据\n    \n    1. json对象.键名\n    \n    2. json对象["键名"]\n    \n    3. 数组对象[索引]\n    \n    4. 遍历：\n       \n       1. for...in：遍历属性，即key字符串。普通for循环也可以\n          \n          for(let key in person){    \n              //alert(key + ":" + person.key); //这样不能获取到。因为key值为字符串，相当于person."name"\n              alert(key+":"+person[key]);\n          }\n          \n          \n          1\n          2\n          3\n          4\n          \n       \n       2. for...of：遍历值\n          \n          for(let value of person){\n              alert(value.name);\n          }\n          \n          \n          1\n          2\n          3\n          \n\n\n# json和java对象的转换\n\n * 常见的json解析器：jsonlib，gson（谷歌），fastjson（阿里），jackson（spring内置）\n * 使用步骤\n   1. 导入jackson的相关jar包\n   2. 创建jackson核心对象 objectmapper\n   3. 如下：\n\n# java对象转换json\n\n * 调用objectmapper的相关方法进行转换\n   1. 转换方法\n      1. writevalueasstring(obj)：将对象转为json字符串\n      2. writevalue(参数1，obj)，参数1如下：\n         * file：将obj对象转换为json字符串，并保存到指定的文件中\n         * writer：将obj对象转换为json字符串，并将json数据填充到字符输出流中\n         * outputstream：将obj对象转换为json字符串，并将json数据填充到字节输出流中\n   2. 注解（在javabean的属性上注解）\n      1. @jsonignore：排除属性\n      2. @jsonformat(pattern = "yyyy-mm-dd")：属性值得格式化，pattern自定义\n   3. 复杂java对象转换\n      1. list：数组\n      2. map：对象格式一致\n\n# json转为java对象\n\n * 调用objectmapper的相关方法进行转换：readvalue(json字符串数据,class)\n\n\n# 案例\n\n\n# 异步校验用户名是否存在\n\n$("#inputusername").blur(function () {\n    var username = $(this).val();\n    //期望服务器响应回的数据格式：{"userexsit":true,"msg":"此用户名太受欢迎,请更换一个"}\n    //                         {"userexsit":false,"msg":"用户名可用"}\n    $.post(\n        "/checkservlet",\n        {"username":username},\n        function(data){\n            if(data.userexsit){\n                $("#usernametag").text(data.msg);\n                $("#usernametag").css("color","red")\n            } else {\n                $("#usernametag").text(data.msg);\n                $("#usernametag").css("color","green")\n            }\n        },\n        "json"\n    )\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n//设置响应的数据格式为json\nresponse.setcontenttype("application/json;charset=utf-8");\nstring username = request.getparameter("username");//获取用户名\n//期望服务器响应回的数据格式：{"userexsit":true,"msg":"此用户名太受欢迎,请更换一个"}\n//                         {"userexsit":false,"msg":"用户名可用"}\nmap<string,object> map = new hashmap<string,object>();\nif("tom".equals(username)){ //存在    \n    map.put("userexsit",true);\n    map.put("msg","此用户名太受欢迎,请更换一个");\n}else{ //不存在\n    map.put("userexsit",false);\n    map.put("msg","用户名可用");\n}\n\n//将map转为json，并且传递给客户端\nobjectmapper mapper = new objectmapper();\nmapper.writevalue(response.getwriter(),map);\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n * 服务器响应的数据，在客户端使用时，要想当做json数据格式使用。有两种解决方案：\n   1. $.get()或$.post()或$.ajax()：将参数datatype指定为"json"\n   2. 在服务器端设置mime类型response.setcontenttype("application/json;charset=utf-8");\n\n\n# 站内搜索',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"BOM",frontmatter:{title:"BOM",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/3b0c3a/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/700.DOM&BOM/702.BOM.html",relativePath:"1200.JS/700.DOM&BOM/702.BOM.md",key:"v-342bb966",path:"/pages/3b0c3a/",headers:[{level:2,title:"window 🔥",slug:"window-🔥",normalizedTitle:"window 🔥",charIndex:46},{level:3,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:81},{level:3,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:84},{level:2,title:"location 🔥",slug:"location-🔥",normalizedTitle:"location 🔥",charIndex:503},{level:3,title:"属性",slug:"属性-2",normalizedTitle:"属性",charIndex:81},{level:3,title:"方法",slug:"方法-2",normalizedTitle:"方法",charIndex:84},{level:2,title:"screen 🔥❎",slug:"screen-🔥❎",normalizedTitle:"screen 🔥❎",charIndex:777},{level:2,title:"history",slug:"history",normalizedTitle:"history",charIndex:852},{level:3,title:"属性",slug:"属性-3",normalizedTitle:"属性",charIndex:81},{level:3,title:"方法",slug:"方法-3",normalizedTitle:"方法",charIndex:84},{level:2,title:"navigator",slug:"navigator",normalizedTitle:"navigator",charIndex:1080}],headersStr:"window 🔥 属性 方法 location 🔥 属性 方法 screen 🔥❎ history 属性 方法 navigator",content:'# BOM\n\nBOM（browser object model）：浏览器对象模型。\n\n\n# window 🔥\n\n代表浏览器窗口并且保存浏览器的全局对象（直接使用属性、方法，可以不带window）\n\n\n# 属性\n\n * 获取其他BOM对象\n * 获取DOM对象\n * opener：返回对创建此窗口的窗口的引用\n\n\n# 方法\n\n * alert()\n   \n   显示带有一段消息和一个确认按钮的警告框。一般调试还是用**console.log()**\n\n * confirm()\n   \n   带有一段消息以及确认、取消按钮的对话框。返回boolean：window.confirm("确认删除？");\n\n * prompt()\n   \n   显示可提示用户输入的对话框：prompt("输入您的年龄",0);\n\n * open()\n   \n   打开一个新的窗口，并返回此对象：window.open(URL,name,features,replace)，都是可选参数\n   \n   当弹窗被浏览器内置工具屏蔽时会返回null，被工具屏蔽会报错\n\n * close()\n   \n   关闭窗口\n\n\n# location 🔥\n\n表示其链接到的对象的位置（URL）。如果直接打印location，则能获取到当前地址栏的信息\n\n\n# 属性\n\n- `href`\n    \n    设置或返回完整的 URL（绝对或相对），随后浏览器会进行跳转\n    \n    ```js\n    location.href="https://www.baidu.com"\n    ```\n\n\n * search\n   \n   设置或返回从?开始的URL（即查询部分）。可用于获取参数🔥\n\n\n# 方法\n\n * reload()：重新加载当前文档\n * 其他看文档\n\n\n# screen 🔥❎\n\n客户端显示屏幕的信息 document.write(screen.width+"*"+screen.height);\n\n\n# history\n\n包含用户（在浏览器窗口中）访问过的 URL，不是历史记录\n\n\n# 属性\n\n * length：返回当前窗口历史列表中的 URL 数量\n\n\n# 方法\n\n * back()：加载 history 列表中的前一个 URL\n * forward()：加载 history 列表中的下一个 URL\n * go(number | URL)：加载 history 列表中的某个具体页面。go(-1);、go(1);等同于上述方法，可以传其他值\n\n\n# navigator\n\n代表浏览器信息\n\n由于许多属性都是实验性的，且许多属性获取的值不能保证正确性，所以不推荐使用。如：\n\n * userAgent\n   \n   可以判断浏览器类型，不推荐',normalizedContent:'# bom\n\nbom（browser object model）：浏览器对象模型。\n\n\n# window 🔥\n\n代表浏览器窗口并且保存浏览器的全局对象（直接使用属性、方法，可以不带window）\n\n\n# 属性\n\n * 获取其他bom对象\n * 获取dom对象\n * opener：返回对创建此窗口的窗口的引用\n\n\n# 方法\n\n * alert()\n   \n   显示带有一段消息和一个确认按钮的警告框。一般调试还是用**console.log()**\n\n * confirm()\n   \n   带有一段消息以及确认、取消按钮的对话框。返回boolean：window.confirm("确认删除？");\n\n * prompt()\n   \n   显示可提示用户输入的对话框：prompt("输入您的年龄",0);\n\n * open()\n   \n   打开一个新的窗口，并返回此对象：window.open(url,name,features,replace)，都是可选参数\n   \n   当弹窗被浏览器内置工具屏蔽时会返回null，被工具屏蔽会报错\n\n * close()\n   \n   关闭窗口\n\n\n# location 🔥\n\n表示其链接到的对象的位置（url）。如果直接打印location，则能获取到当前地址栏的信息\n\n\n# 属性\n\n- `href`\n    \n    设置或返回完整的 url（绝对或相对），随后浏览器会进行跳转\n    \n    ```js\n    location.href="https://www.baidu.com"\n    ```\n\n\n * search\n   \n   设置或返回从?开始的url（即查询部分）。可用于获取参数🔥\n\n\n# 方法\n\n * reload()：重新加载当前文档\n * 其他看文档\n\n\n# screen 🔥❎\n\n客户端显示屏幕的信息 document.write(screen.width+"*"+screen.height);\n\n\n# history\n\n包含用户（在浏览器窗口中）访问过的 url，不是历史记录\n\n\n# 属性\n\n * length：返回当前窗口历史列表中的 url 数量\n\n\n# 方法\n\n * back()：加载 history 列表中的前一个 url\n * forward()：加载 history 列表中的下一个 url\n * go(number | url)：加载 history 列表中的某个具体页面。go(-1);、go(1);等同于上述方法，可以传其他值\n\n\n# navigator\n\n代表浏览器信息\n\n由于许多属性都是实验性的，且许多属性获取的值不能保证正确性，所以不推荐使用。如：\n\n * useragent\n   \n   可以判断浏览器类型，不推荐',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"Layui",frontmatter:{title:"Layui",date:"2021-08-25T21:12:20.000Z",permalink:"/pages/baf83c/",categories:["JS","常用框架"],tags:[null]},regularPath:"/1200.JS/800.%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/802.Layui.html",relativePath:"1200.JS/800.常用框架/802.Layui.md",key:"v-6157df39",path:"/pages/baf83c/",headers:[{level:2,title:"iframe 父子页面通信",slug:"iframe-父子页面通信",normalizedTitle:"iframe 父子页面通信",charIndex:12}],headersStr:"iframe 父子页面通信",content:"# Layui\n\n\n# iframe 父子页面通信\n\nindex.html\n\n<script>\n      layui.use(['layer', 'form'], function () {\n        var layer = layui.layer,\n          form = layui.form,\n          $ = layui.$\n\n        const addEl = document.getElementById('add')\n        addEl.addEventListener('click', function () {\n          layer.open({\n            type: 2,\n            area: ['700px', '450px'],\n            fixed: false, //不固定\n            maxmin: true,\n            content: 'layer/add.html?id=666',\n            btn: ['确定', '取消'],\n            skin: 'demo-class',\n            success: function (layero, index) {\n              // layer 的 success 会在 onload 执行后执行，此时HTMLS都渲染完毕！JS不一定，有时JS（按顺序）执行时间太长。\n              // 所以这里传递复杂参数还是得使用 子页面DOM存储，或者在子页面调用 parent 处理 DOM或变量或方法\n              console.log('success')\n              var iframeWin = window[layero.find('iframe')[0]['name']] //得到iframe页的窗口对象，执行iframe页的方法\n              // 这里的method.transferData可能都没有执行到，会找不到！！！\n              iframeWin.method.transferData({ id: 666, name: 'conanan' })\n              layer.iframeAuto(index)\n            },\n            yes: function (index, layero) {\n              // var index2 = layer.load(2, {\n              //   id: '9sfsfs99999fs',\n              //   area: ['1500px', '100px'],\n              //   zIndex: 99999999,\n              // })\n              var iframeWin = window[layero.find('iframe')[0]['name']] //得到iframe页的窗口对象，执行iframe页的方法\n              // 需要防抖函数来保证不被重复点击\n              const returnData = iframeWin.method.saveData()\n              console.log('returnData', returnData)\n              // layer.close(index2)\n              return false\n            },\n          })\n        })\n      })\n    <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\nadd.html\n\n<script>\n      var method // 必须var，全局变量，可以让父页面调用\n      let data\n      let returnData = { name: '*_H', list: [1, 2, 3] }\n      layui.use(['layer', 'form'], function () {\n        var layer = layui.layer,\n          form = layui.form\n\n        const hrefObj = layui.url()\n        console.log('hrefObj', hrefObj)\n\n        const router = layui.router()\n        console.log('router', router)\n\n        window.onload = function () {\n          console.log('onload')\n          // console.log('此时无法获取data哦', data)\n          // layer 的 success 会在 onload 执行后执行，此时HTML渲染完毕！\n        }\n\n        method = {\n          transferData: function (obj) {\n            // 接收父页面传值\n            data = obj\n            console.log('transferData', data)\n            method.init()\n          },\n          init() {\n            // 可以执行 Ajax 等初始化查询操作\n            console.log('init', data)\n          },\n          saveData() {\n            // 保存并返回值给父页面\n            // let l = layer.load(1, {zIndex: 999999999, maxWidth: 3000, maxHeight: 2000})\n            layer.msg(\n              'saveData success...',\n              {\n                tipsMore: true,\n                icon: 1,\n              },\n              function () {\n                var index = parent.layer.getFrameIndex(window.name) //先得到当前iframe层的索引\n                parent.layer.close(index) //再执行关闭\n                // layer.close(l)\n              }\n            )\n            return returnData // 不能放在 layer.msg 的 function 回调中\n          },\n        }\n\n        console.log('666')\n      })\n    <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n",normalizedContent:"# layui\n\n\n# iframe 父子页面通信\n\nindex.html\n\n<script>\n      layui.use(['layer', 'form'], function () {\n        var layer = layui.layer,\n          form = layui.form,\n          $ = layui.$\n\n        const addel = document.getelementbyid('add')\n        addel.addeventlistener('click', function () {\n          layer.open({\n            type: 2,\n            area: ['700px', '450px'],\n            fixed: false, //不固定\n            maxmin: true,\n            content: 'layer/add.html?id=666',\n            btn: ['确定', '取消'],\n            skin: 'demo-class',\n            success: function (layero, index) {\n              // layer 的 success 会在 onload 执行后执行，此时htmls都渲染完毕！js不一定，有时js（按顺序）执行时间太长。\n              // 所以这里传递复杂参数还是得使用 子页面dom存储，或者在子页面调用 parent 处理 dom或变量或方法\n              console.log('success')\n              var iframewin = window[layero.find('iframe')[0]['name']] //得到iframe页的窗口对象，执行iframe页的方法\n              // 这里的method.transferdata可能都没有执行到，会找不到！！！\n              iframewin.method.transferdata({ id: 666, name: 'conanan' })\n              layer.iframeauto(index)\n            },\n            yes: function (index, layero) {\n              // var index2 = layer.load(2, {\n              //   id: '9sfsfs99999fs',\n              //   area: ['1500px', '100px'],\n              //   zindex: 99999999,\n              // })\n              var iframewin = window[layero.find('iframe')[0]['name']] //得到iframe页的窗口对象，执行iframe页的方法\n              // 需要防抖函数来保证不被重复点击\n              const returndata = iframewin.method.savedata()\n              console.log('returndata', returndata)\n              // layer.close(index2)\n              return false\n            },\n          })\n        })\n      })\n    <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\nadd.html\n\n<script>\n      var method // 必须var，全局变量，可以让父页面调用\n      let data\n      let returndata = { name: '*_h', list: [1, 2, 3] }\n      layui.use(['layer', 'form'], function () {\n        var layer = layui.layer,\n          form = layui.form\n\n        const hrefobj = layui.url()\n        console.log('hrefobj', hrefobj)\n\n        const router = layui.router()\n        console.log('router', router)\n\n        window.onload = function () {\n          console.log('onload')\n          // console.log('此时无法获取data哦', data)\n          // layer 的 success 会在 onload 执行后执行，此时html渲染完毕！\n        }\n\n        method = {\n          transferdata: function (obj) {\n            // 接收父页面传值\n            data = obj\n            console.log('transferdata', data)\n            method.init()\n          },\n          init() {\n            // 可以执行 ajax 等初始化查询操作\n            console.log('init', data)\n          },\n          savedata() {\n            // 保存并返回值给父页面\n            // let l = layer.load(1, {zindex: 999999999, maxwidth: 3000, maxheight: 2000})\n            layer.msg(\n              'savedata success...',\n              {\n                tipsmore: true,\n                icon: 1,\n              },\n              function () {\n                var index = parent.layer.getframeindex(window.name) //先得到当前iframe层的索引\n                parent.layer.close(index) //再执行关闭\n                // layer.close(l)\n              }\n            )\n            return returndata // 不能放在 layer.msg 的 function 回调中\n          },\n        }\n\n        console.log('666')\n      })\n    <\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"99 jQuery",frontmatter:{title:"99 jQuery",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/bbc451/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/800.%E5%B8%B8%E7%94%A8%E6%A1%86%E6%9E%B6/801.%20jQuery.html",relativePath:"1200.JS/800.常用框架/801. jQuery.md",key:"v-a747ade8",path:"/pages/bbc451/",headers:[{level:2,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:229},{level:2,title:"选择器",slug:"选择器",normalizedTitle:"选择器",charIndex:246},{level:2,title:"DOM 操作",slug:"dom-操作",normalizedTitle:"dom 操作",charIndex:2624},{level:2,title:"遍历",slug:"遍历",normalizedTitle:"遍历",charIndex:4221},{level:2,title:"事件",slug:"事件",normalizedTitle:"事件",charIndex:423},{level:2,title:"动画",slug:"动画",normalizedTitle:"动画",charIndex:2301},{level:2,title:"插件",slug:"插件",normalizedTitle:"插件",charIndex:5221},{level:2,title:"jQuery 重写案例",slug:"jquery-重写案例",normalizedTitle:"jquery 重写案例",charIndex:7594},{level:3,title:"定时弹出广告(show()/hide())",slug:"定时弹出广告-show-hide",normalizedTitle:"定时弹出广告(show()/hide())",charIndex:7610},{level:3,title:"隔行换色(.css)",slug:"隔行换色-css",normalizedTitle:"隔行换色(.css)",charIndex:7941},{level:3,title:"全选全不选(attr/prop)",slug:"全选全不选-attr-prop",normalizedTitle:"全选全不选(attr/prop)",charIndex:8110},{level:3,title:"省市联动",slug:"省市联动",normalizedTitle:"省市联动",charIndex:8431},{level:3,title:"左右列表(双击和 selected 有关)",slug:"左右列表-双击和-selected-有关",normalizedTitle:"左右列表(双击和 selected 有关)",charIndex:9252},{level:2,title:"使用 validate 完成表单校验",slug:"使用-validate-完成表单校验",normalizedTitle:"使用 validate 完成表单校验",charIndex:10049},{level:2,title:"jQuery UI 的 autocomplete",slug:"jquery-ui-的-autocomplete",normalizedTitle:"jquery ui 的 autocomplete",charIndex:11367}],headersStr:"基本语法 选择器 DOM 操作 遍历 事件 动画 插件 jQuery 重写案例 定时弹出广告(show()/hide()) 隔行换色(.css) 全选全不选(attr/prop) 省市联动 左右列表(双击和 selected 有关) 使用 validate 完成表单校验 jQuery UI 的 autocomplete",content:'# jQuery\n\n> JavaScript 框架，简化 JS 开发，本质上就是一些 JS 文件，封装了 JS 的原生代码\n> \n> 不带 min 的和带 min 的版本区别在于格式、缩进、大小、注释。一个用于开发环境，一个用于生产环境\n\n区别：\n\n * jQuery 的加载比 js 快，jQuery 在 dom 树结构绘制完毕就会加载；而 js 在整个页面加载完毕才加载\n * jQuery 没有覆盖问题，并且按顺序执行；而 js 存在覆盖问题\n\n\n# 基本语法\n\n * 语法：$(CSS选择器)或jQuery(CSS选择器)，jQuery 对象内部以**==数组==存储匹配的数据**，若只有一个，索引号为 0\n\n * 对象转换（jQuery 对象和 JS 对象无法互相操作属性和方法）\n   \n   * JS--\x3ejQuery：$(JS对象)\n   * jQuery--\x3eJS：$(选择器)[0]或$(选择器).get(0)\n\n * 绑定事件（去掉 JS 事件中 on 即可，并给事件方法传入 function 对象）\n   \n   $("#id1").click(function() {\n     //。。。\n   });\n   \n   \n   1\n   2\n   3\n   \n\n * 入口函数（DOM 树加载完毕执行）：区别在于 onload 只能定义一次，否则覆盖；而 ready 可以定义多次\n   \n   //$(document).ready(function(){   //精简如下\n   $(function() {});\n   \n   \n   1\n   2\n   \n\n\n# 选择器\n\n> 在字符串中\n\n * 基本选择器\n   \n   * #id\n   * .class\n   * element\n   * * ：选择所有元素\n\n * 组合选择器\n   \n   组合      选择\n   A,B     选择所有 A 元素和 B 元素\n   A B     ==后代选择器==（B是 A 的所有后代结点，如子节点或者孙节点），可能多个\n   A > B   ==子选择器==（B是 A 的直接子节点），可能多个\n   A + B   ==相邻兄弟选择器==（AB 有相同的父结点，B是 A 的紧跟着的兄弟节点），只能一个\n   A ~ B   ==一般兄弟选择器==（AB 有相同的父节点，B是 A之后的所有兄弟节点），可能多个\n\n * 属性选择器（值要加引号）\n   \n   属性                                        选择\n   ==[attr]==                                带有以 attr 命名的属性的元素\n   ==[attr=\'value\']==                        带有以 attr 命名的，且**值为"value"**的属性的元素。\n   ==[attr!=\'value\']==                       带有以 attr 命名的，且值不为"value"的属性的元素或没有这个属性的元素\n   [attr~=value]                             带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为"value"\n   [attr|=value]                             带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（"-"为连字符，Unicode\n                                             编码为 U+002D）开头。用来匹配语言简写代码（如 zh-CN，zh-TW 可以用 zh 作为 value）\n   ==[attr^=value]==                         表示带有以 attr 命名的，且值是以"value"开头的属性的元素\n   ==[attr$=value]==                         表示带有以 attr 命名的，且值是以"value"结尾的属性的元素\n   ==[attr=value*]==                         表示带有以 attr 命名的，且值包含有"value"的属性的元素\n   ==[attr1=\'value1\'][attr2=\'value2\']...==   复合属性选择器，需要同时满足多个条件时使用。\n\n * 基本过滤选择器\n   \n   * :first：首元素选择器，获得选择的元素中的第一个元素\n   * :last：尾元素选择器，获得选择的元素中的最后一个元素\n   * :not(selector)：非元素选择器，不包括指定内容的元素。如：1234:not(3)---\x3e124\n   * :even：偶数选择器，从 0 开始计数。操作索引号，页面显示奇数项\n   * :odd：奇数选择器，从 0 开始计数\n   * :eq(index)：等于索引选择器，等于指定索引元素\n   * :gt(index)：大于索引选择器，大于指定索引元素\n   * :lt(index)：小于索引选择器，小于指定索引元素\n   * :header：标题选择器，获得标题（h1~h6）元素，固定写法\n   * :animated：获得动画的\n   * :focus：获得焦点\n   * :first-child：第一个子元素\n   * :last-child：最后一个子元素\n   * ……\n\n * 表单属性过滤选择器\n   \n   * :enabled：可用元素选择器，获得可用元素\n   * :disabled：不可用元素选择器，获得不可用元素\n   * :checked：选中选择器（radio、checkbox）\n   * :selected：选中选择器（select）\n   * :input：匹配所有 input, textarea, select 和 button 元素\n\n * 内容过滤选择器\n   \n   * :contains：匹配包含指定文本的元素\n\n\n# DOM 操作\n\n * 内容操作\n   * html()：获取/设置元素的标签体内容 <a><font>内容</font></a> --\x3e <font>内容</font>\n   * text()：获取/设置元素的标签体纯文本内容 <a><font>内容</font></a> --\x3e 内容，设置时将 font 也删去了\n   * val()：获取/设置元素的value 属性值，常用于**input标签，select**标签值也可以使用\n * 属性操作\n   1. 通用属性操作（获取传递 1 个字符串；设置传递 2 个字符串；删除传递 1 个字符串）\n      * attr(): 获取/设置元素的属性\n      * removeAttr():删除属性\n      * prop():获取/设置元素的属性\n      * removeProp():删除属性\n        * ==attr 和 prop区别？==\n          * 如果操作的是元素的固有属性，则建议使用 prop。如 checked，selected、disabled、href、src 等之类\n          * 如果操作的是元素自定义属性，则建议使用 attr。若上述属性在未设置属性值时使用 attr，返回 undefined\n   2. 对 class 属性操作\n      * addClass():添加 class 属性值\n      * removeClass():删除 class 属性值\n      * toggleClass():切换class 属性，综合上面 2 个方法，类似开关\n        * toggleClass("one")：判断如果元素对象上存在 class="one"，则将属性值 one 删除掉。否则添加\n      * css()：传递 1 个字符串为获取值；2 个为设置值\n * CRUD 操作（除过 empty，其他方法 JS 原生都有实现，empty 可以利用innerHTML=""实现）\n   * 内部插入（父子），对已存在的元素为剪贴\n     * append(content) ：在 A 元素结尾追加 B\n     * prepend(content)：在 A 元素开头追加 B\n     * appendTo(content)：在 B 元素结尾追加 A\n     * prependTo(content)：在 B 元素开头追加 A\n   * 外部插入（兄弟），对已存在的元素为剪贴\n     * before(content)：在 A 元素之前插入 B\n     * after(content)：在 A 元素之后插入 B\n     * insertBefore(content)：在 B 元素之前插入 A\n     * insertAfter(content)：在 B 元素之后插入 A\n   * 删除\n     * empty()：清空匹配元素中所有的子节点（所有 Node），但是保留当前对象以及其属性节点\n     * remove([expr])：expr 筛选元素。删除所有匹配的元素，事件数据也会删除，不提供值为删除自己\n     * detach([expr])：expr 筛选元素。删除所有匹配的元素，事件数据会保留\n   * 替换\n     * replaceWith(html)：把匹配的元素替换为指定元素，用 B 替换 A\n     * replaceAll(html)：相反，用 A 替换 B\n     * clone([flag])：复制，克隆匹配的 DOM 元素并且选中这些克隆的副本。QQ 表情案例\n       * flag 为 true 副本具有与真身一样的事件处理能力，默认不用填写代表为 false\n\n\n# 遍历\n\n * .each(callback)：jQuery 对象使用（选择器获取后使用），遍历后的值可能为 JS 对象，注意方法调用区别\n   \n   $(arr).each(function(key, value) {});\n   \n   \n   1\n   \n   * key 为索引；value/this 是每一个元素对象（JS 对象）；\n   * 回调函数返回值为 false 相当于 break；返回值为 true 相当于 continue\n\n * $.each(object,[callback])：遍历任意对象（JS 数组等也可以）。\n   \n   $.each(arr, function(key, value) {});\n   \n   \n   1\n   \n\n * for...of：jQuery3.0 后提供的方式，同 ES6 中使用方法一致\n\n\n# 事件\n\n * 页面加载：\n   \n   * ready(fn)：有时标签绑定一个事件但是函数不执行，原因就是 DOM 没有加载完毕。可以放在/body 之前，或 onload 里\n     \n     //$(document).ready(function(){   //精简如下\n     $(function() {});\n     \n     \n     1\n     2\n     \n\n * 事件绑定：\n   \n   * jquery 标准的绑定方式：jq对象.事件方法(回调函数)；\n     \n     * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为，如触发事件。\n       \n       表单对象.submit();：让表单提交\n   \n   * on 绑定事件/off 解除绑定\n     \n     * jq对象.on("事件名称",回调函数)\n     * jq对象.off("事件名称")\n       * 如果 off 方法不传递任何参数，则将组件上的所有事件全部解绑\n   \n   * toggle 事件切换\n     \n     * jq对象.toggle(fn1,fn2...)：当单击 jq 对象对应的组件后，会执行 fn1.第二次点击会执行 fn2.....\n     \n     * 注意：1.9 版本 .toggle() 方法删除,jQuery Migrate（迁移）插件可以恢复此功能。\n       \n       <script\n         src="../js/jquery-migrate-1.0.0.js"\n         type="text/javascript"\n         charset="utf-8"\n       ><\/script>\n       \n       \n       1\n       2\n       3\n       4\n       5\n       \n\n * 鼠标事件\n   \n   * mouseover\n   * mouseout\n   * hover(overfn, outfn)\n   * toggle\n   * 同 js 方法\n\n\n# 动画\n\n * 显示/隐藏\n   * show([speed,[easing],[fn]])\n     1. speed：动画的速度。三个预定义的值("slow","normal", "fast")或表示动画时长的毫秒数值(如：1000)\n        1. easing：用来指定切换效果，默认是"swing"，可用参数"linear" * swing：动画执行时效果是 先慢，中间快，最后又慢\n           * linear：动画执行时速度是匀速的\n     2. fn：在动画完成时执行的函数，每个元素执行一次。\n   * hide([speed,[easing],[fn]])\n   * toggle([speed,[easing],[fn]])\n * 滑动显示/隐藏\n   * slideDown([speed,[easing],[fn]])\n   * slideUp([speed,[easing],[fn]])\n   * slideToggle([speed,[easing],[fn]])\n * 淡入淡出\n   * fadeIn([speed,[easing],[fn]])\n   * fadeOut([speed,[easing],[fn]])\n   * fadeToggle([speed,[easing],[fn]])\n   * fadeTo([[s],o,[e],[fn]])：调整元素不透明度\n\n\n# 插件\n\n * 增强 JQuery 的功能\n\n * 实现方式\n   \n   1. $.fn.extend(object) ：增强通过 jQuery 获取的对象的功能，如获取$("#id")对象，并增强其功能\n      \n      //1.定义jqeury的对象插件\n      $.fn.extend({\n        //定义了一个check()方法。所有的jq对象都可以调用该方法\n        check: function() {\n          //让复选框选中\n          this.prop("checked", true); //this:调用该方法的jq对象\n        },\n        uncheck: function() {\n          //让复选框不选中\n          this.prop("checked", false);\n        },\n      });\n      \n      $(function() {\n        $("#btn-check").click(function() {\n          //获取复选框对象\n          $("input[type=\'checkbox\']").check();\n        });\n      \n        $("#btn-uncheck").click(function() {\n          //获取复选框对象\n          $("input[type=\'checkbox\']").uncheck();\n        });\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      \n   \n   2. $.extend(object)：增强 jQuery 对象自身的功能，$或 jQuery\n      \n      $.extend({\n        max: function(a, b) {\n          //返回两数中的较大值\n          return a >= b ? a : b;\n        },\n        min: function(a, b) {\n          //返回两数中的较小值\n          return a <= b ? a : b;\n        },\n      });\n      //调用全局方法\n      var max = $.max(4, 3); //4\n      var min = $.min(1, 2); //1\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      \n\n\n# jQuery 重写案例\n\n\n# 定时弹出广告(show()/hide())\n\n$(function() {\n  showTime = setTimeout("showAd()", 1000);\n});\nvar showAd = function() {\n  $("#adImg").show(500);\n  clearTimeout(showTime);\n  hiddenTime = setTimeout("hiddenAd()", 5000);\n};\nvar hiddenAd = function() {\n  $("#adImg").hide(1000);\n  clearTimeout(hiddenTime);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 隔行换色(.css)\n\n$(function() {\n  $("tbody>tr:even").css("background-color", "yello"); //偶数行设置\n  $("tbody>tr:odd").css("background-color", "red"); //奇数行设置\n});\n\n\n1\n2\n3\n4\n\n\n\n# 全选全不选(attr/prop)\n\n$(function() {\n  //全选/不选使用prop属性\n  $("#ckAll").click(function() {\n    $("tbody input").prop("checked", this.checked);\n  });\n  //反选只会转为DOM对象后再操作\n  $("#reCk").click(function() {\n    $("tbody input").each(function() {\n      this.checked = !this.checked;\n    });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 省市联动\n\n$(function () {\n    var arr = new Array();\n    arr[0] = [\'西安\', \'商洛\', \'延安\', \'安康\'];\n    arr[1] = [\'石家庄\', \'廊坊\', \'秦皇岛\', \'雄安\'];\n    arr[2] = [\'深圳\', \'珠海\', \'广州\', \'不知道\'];\n\n    $("#sheng").change(function () {\n        $("#shi option").remove();\n        // $("#shi").empty();\n\n        var value = parseInt(this.value);\n        $.each(arr,function (k,v) {\n            if(k===value){\n                $(v).each(function (k,v) {\n                    var text = document.createTextNode(v);\n                    var option = document.createElement("option");\n                    option.appendChild(text);\n                    $("#shi").append(option);\n                    // $(option).appendTo($("#shi"));\n                })；\n            }\n        });\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 左右列表(双击和 selected 有关)\n\n$(function() {\n  //按键\n  $("#toRight").click(function() {\n    // $("#right").append($("#left option:selected"));\n    $("#left option:selected").appendTo($("#right"));\n  });\n  $("#toLeft").click(function() {\n    // $("#left").append($("#right option:selected"));\n    $("#right option:selected").appendTo($("#left"));\n  });\n  $("#allToRight").click(function() {\n    $("#left option").appendTo($("#right"));\n  });\n  $("#allToLeft").click(function() {\n    $("#right option").appendTo($("#left"));\n  });\n\n  //双击\n  $("#left").dblclick(function() {\n    $("#left option:selected").appendTo($("#right"));\n  });\n  $("#right").dblclick(function() {\n    $("#right option:selected").appendTo($("#left"));\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 使用 validate 完成表单校验\n\n * 依赖 jQuery 库，所以先导入 jQuery 再导入 validate，最后导入国际化信息库(提示为中文)\n\n$(function() {\n  $("#form1").validate({\n    rules: {\n      username: {\n        required: true,\n        minlength: 6,\n      },\n      password: {\n        required: true,\n        maxlength: 16,\n        digits: true,\n      },\n      rePassword: {\n        required: true,\n        equalTo: "[name=\'password\']",\n      },\n      email: {\n        email: true,\n      },\n    },\n    messages: {\n      username: {\n        required: "用户名不能为空",\n        minlength: "用户名不能少于6位",\n      },\n      password: {\n        required: "密码不能为空",\n        maxlength: "密码不能多于16位",\n        digits: "密码只能是数字",\n      },\n      rePassword: {\n        required: "确认密码不能为空",\n        equalTo: "两次输入的密码不一致",\n      },\n      email: {\n        email: "邮箱格式不正确",\n      },\n    },\n    errorElement: "label", //用来创建错误提示信息标签,validate插件默认的就是label\n    success: function(label) {\n      //验证成功后的执行的回调函数\n      //label指向上面那个错误提示信息标签label\n      label\n        .text(" ") //清空错误提示消息\n        .addClass("success"); //加上自定义的success类\n    },\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\x3c!--单选，多选标签得在其后面加label标签，否则提示信息位置不正确--\x3e\n<label for="sex" class="error" style="display: none;"></label>\n\n\n1\n2\n\n\n\n# jQuery UI 的 autocomplete\n\n<input id="user" type="text" name="username"\n       class="layui-input"\n       placeholder="用&nbsp;户&nbsp;名"\n       onKeyDown="if(event.keyCode==\'13\'){password.focus();}"\n       >\n\n\n1\n2\n3\n4\n5\n\n\n$(function(){\n    $.ajax({\n        type: \'GET\',\n        url: \'/showLoginUser\',\n        success: function (res) {\n            loginUser = res;\n            $.each(res,function (key,value) {\n                loginUsername.push(value.USERNAME);\n            });\n        }\n    });\n})\n\nvar loginUser = [];\nvar loginUsername = [];\n\n/* 显示登录过的用户 */\n$("#user").autocomplete({\n    minLength: 0, //\n    // loginUsername 这个参数必须是存放字符串的数组，如[\'a\',\'b\']\n    source: loginUsername,\n    // select，字面意思。\n    select: function (event, ui) {\n        var keyword = ui.item.value; // 选择的值\n        $.each(loginUser, (key, value) => { \n            if (keyword === value.USERNAME) {\n                $("#password").val(value.PASSWD_BAK);\n            }\n        });\n    }\n}).click(function () {\n    // $(this)代表$("#user")，其中autocomplete有search属性，\n    $(this).autocomplete("search");\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n.ui-autocomplete {\n    max-height: 210px;\n    overflow-y: auto;\n    /* 防止水平滚动条 */\n    overflow-x: hidden;\n}\n.ui-menu-item{\n    font-size: 18px;\n    padding-bottom: 3px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',normalizedContent:'# jquery\n\n> javascript 框架，简化 js 开发，本质上就是一些 js 文件，封装了 js 的原生代码\n> \n> 不带 min 的和带 min 的版本区别在于格式、缩进、大小、注释。一个用于开发环境，一个用于生产环境\n\n区别：\n\n * jquery 的加载比 js 快，jquery 在 dom 树结构绘制完毕就会加载；而 js 在整个页面加载完毕才加载\n * jquery 没有覆盖问题，并且按顺序执行；而 js 存在覆盖问题\n\n\n# 基本语法\n\n * 语法：$(css选择器)或jquery(css选择器)，jquery 对象内部以**==数组==存储匹配的数据**，若只有一个，索引号为 0\n\n * 对象转换（jquery 对象和 js 对象无法互相操作属性和方法）\n   \n   * js--\x3ejquery：$(js对象)\n   * jquery--\x3ejs：$(选择器)[0]或$(选择器).get(0)\n\n * 绑定事件（去掉 js 事件中 on 即可，并给事件方法传入 function 对象）\n   \n   $("#id1").click(function() {\n     //。。。\n   });\n   \n   \n   1\n   2\n   3\n   \n\n * 入口函数（dom 树加载完毕执行）：区别在于 onload 只能定义一次，否则覆盖；而 ready 可以定义多次\n   \n   //$(document).ready(function(){   //精简如下\n   $(function() {});\n   \n   \n   1\n   2\n   \n\n\n# 选择器\n\n> 在字符串中\n\n * 基本选择器\n   \n   * #id\n   * .class\n   * element\n   * * ：选择所有元素\n\n * 组合选择器\n   \n   组合      选择\n   a,b     选择所有 a 元素和 b 元素\n   a b     ==后代选择器==（b是 a 的所有后代结点，如子节点或者孙节点），可能多个\n   a > b   ==子选择器==（b是 a 的直接子节点），可能多个\n   a + b   ==相邻兄弟选择器==（ab 有相同的父结点，b是 a 的紧跟着的兄弟节点），只能一个\n   a ~ b   ==一般兄弟选择器==（ab 有相同的父节点，b是 a之后的所有兄弟节点），可能多个\n\n * 属性选择器（值要加引号）\n   \n   属性                                        选择\n   ==[attr]==                                带有以 attr 命名的属性的元素\n   ==[attr=\'value\']==                        带有以 attr 命名的，且**值为"value"**的属性的元素。\n   ==[attr!=\'value\']==                       带有以 attr 命名的，且值不为"value"的属性的元素或没有这个属性的元素\n   [attr~=value]                             带有以 attr 命名的属性的元素，并且该属性是一个以空格作为分隔的值列表，其中至少一个值为"value"\n   [attr|=value]                             带有以 attr 命名的属性的元素，属性值为“value”或是以“value-”为前缀（"-"为连字符，unicode\n                                             编码为 u+002d）开头。用来匹配语言简写代码（如 zh-cn，zh-tw 可以用 zh 作为 value）\n   ==[attr^=value]==                         表示带有以 attr 命名的，且值是以"value"开头的属性的元素\n   ==[attr$=value]==                         表示带有以 attr 命名的，且值是以"value"结尾的属性的元素\n   ==[attr=value*]==                         表示带有以 attr 命名的，且值包含有"value"的属性的元素\n   ==[attr1=\'value1\'][attr2=\'value2\']...==   复合属性选择器，需要同时满足多个条件时使用。\n\n * 基本过滤选择器\n   \n   * :first：首元素选择器，获得选择的元素中的第一个元素\n   * :last：尾元素选择器，获得选择的元素中的最后一个元素\n   * :not(selector)：非元素选择器，不包括指定内容的元素。如：1234:not(3)---\x3e124\n   * :even：偶数选择器，从 0 开始计数。操作索引号，页面显示奇数项\n   * :odd：奇数选择器，从 0 开始计数\n   * :eq(index)：等于索引选择器，等于指定索引元素\n   * :gt(index)：大于索引选择器，大于指定索引元素\n   * :lt(index)：小于索引选择器，小于指定索引元素\n   * :header：标题选择器，获得标题（h1~h6）元素，固定写法\n   * :animated：获得动画的\n   * :focus：获得焦点\n   * :first-child：第一个子元素\n   * :last-child：最后一个子元素\n   * ……\n\n * 表单属性过滤选择器\n   \n   * :enabled：可用元素选择器，获得可用元素\n   * :disabled：不可用元素选择器，获得不可用元素\n   * :checked：选中选择器（radio、checkbox）\n   * :selected：选中选择器（select）\n   * :input：匹配所有 input, textarea, select 和 button 元素\n\n * 内容过滤选择器\n   \n   * :contains：匹配包含指定文本的元素\n\n\n# dom 操作\n\n * 内容操作\n   * html()：获取/设置元素的标签体内容 <a><font>内容</font></a> --\x3e <font>内容</font>\n   * text()：获取/设置元素的标签体纯文本内容 <a><font>内容</font></a> --\x3e 内容，设置时将 font 也删去了\n   * val()：获取/设置元素的value 属性值，常用于**input标签，select**标签值也可以使用\n * 属性操作\n   1. 通用属性操作（获取传递 1 个字符串；设置传递 2 个字符串；删除传递 1 个字符串）\n      * attr(): 获取/设置元素的属性\n      * removeattr():删除属性\n      * prop():获取/设置元素的属性\n      * removeprop():删除属性\n        * ==attr 和 prop区别？==\n          * 如果操作的是元素的固有属性，则建议使用 prop。如 checked，selected、disabled、href、src 等之类\n          * 如果操作的是元素自定义属性，则建议使用 attr。若上述属性在未设置属性值时使用 attr，返回 undefined\n   2. 对 class 属性操作\n      * addclass():添加 class 属性值\n      * removeclass():删除 class 属性值\n      * toggleclass():切换class 属性，综合上面 2 个方法，类似开关\n        * toggleclass("one")：判断如果元素对象上存在 class="one"，则将属性值 one 删除掉。否则添加\n      * css()：传递 1 个字符串为获取值；2 个为设置值\n * crud 操作（除过 empty，其他方法 js 原生都有实现，empty 可以利用innerhtml=""实现）\n   * 内部插入（父子），对已存在的元素为剪贴\n     * append(content) ：在 a 元素结尾追加 b\n     * prepend(content)：在 a 元素开头追加 b\n     * appendto(content)：在 b 元素结尾追加 a\n     * prependto(content)：在 b 元素开头追加 a\n   * 外部插入（兄弟），对已存在的元素为剪贴\n     * before(content)：在 a 元素之前插入 b\n     * after(content)：在 a 元素之后插入 b\n     * insertbefore(content)：在 b 元素之前插入 a\n     * insertafter(content)：在 b 元素之后插入 a\n   * 删除\n     * empty()：清空匹配元素中所有的子节点（所有 node），但是保留当前对象以及其属性节点\n     * remove([expr])：expr 筛选元素。删除所有匹配的元素，事件数据也会删除，不提供值为删除自己\n     * detach([expr])：expr 筛选元素。删除所有匹配的元素，事件数据会保留\n   * 替换\n     * replacewith(html)：把匹配的元素替换为指定元素，用 b 替换 a\n     * replaceall(html)：相反，用 a 替换 b\n     * clone([flag])：复制，克隆匹配的 dom 元素并且选中这些克隆的副本。qq 表情案例\n       * flag 为 true 副本具有与真身一样的事件处理能力，默认不用填写代表为 false\n\n\n# 遍历\n\n * .each(callback)：jquery 对象使用（选择器获取后使用），遍历后的值可能为 js 对象，注意方法调用区别\n   \n   $(arr).each(function(key, value) {});\n   \n   \n   1\n   \n   * key 为索引；value/this 是每一个元素对象（js 对象）；\n   * 回调函数返回值为 false 相当于 break；返回值为 true 相当于 continue\n\n * $.each(object,[callback])：遍历任意对象（js 数组等也可以）。\n   \n   $.each(arr, function(key, value) {});\n   \n   \n   1\n   \n\n * for...of：jquery3.0 后提供的方式，同 es6 中使用方法一致\n\n\n# 事件\n\n * 页面加载：\n   \n   * ready(fn)：有时标签绑定一个事件但是函数不执行，原因就是 dom 没有加载完毕。可以放在/body 之前，或 onload 里\n     \n     //$(document).ready(function(){   //精简如下\n     $(function() {});\n     \n     \n     1\n     2\n     \n\n * 事件绑定：\n   \n   * jquery 标准的绑定方式：jq对象.事件方法(回调函数)；\n     \n     * 注：如果调用事件方法，不传递回调函数，则会触发浏览器默认行为，如触发事件。\n       \n       表单对象.submit();：让表单提交\n   \n   * on 绑定事件/off 解除绑定\n     \n     * jq对象.on("事件名称",回调函数)\n     * jq对象.off("事件名称")\n       * 如果 off 方法不传递任何参数，则将组件上的所有事件全部解绑\n   \n   * toggle 事件切换\n     \n     * jq对象.toggle(fn1,fn2...)：当单击 jq 对象对应的组件后，会执行 fn1.第二次点击会执行 fn2.....\n     \n     * 注意：1.9 版本 .toggle() 方法删除,jquery migrate（迁移）插件可以恢复此功能。\n       \n       <script\n         src="../js/jquery-migrate-1.0.0.js"\n         type="text/javascript"\n         charset="utf-8"\n       ><\/script>\n       \n       \n       1\n       2\n       3\n       4\n       5\n       \n\n * 鼠标事件\n   \n   * mouseover\n   * mouseout\n   * hover(overfn, outfn)\n   * toggle\n   * 同 js 方法\n\n\n# 动画\n\n * 显示/隐藏\n   * show([speed,[easing],[fn]])\n     1. speed：动画的速度。三个预定义的值("slow","normal", "fast")或表示动画时长的毫秒数值(如：1000)\n        1. easing：用来指定切换效果，默认是"swing"，可用参数"linear" * swing：动画执行时效果是 先慢，中间快，最后又慢\n           * linear：动画执行时速度是匀速的\n     2. fn：在动画完成时执行的函数，每个元素执行一次。\n   * hide([speed,[easing],[fn]])\n   * toggle([speed,[easing],[fn]])\n * 滑动显示/隐藏\n   * slidedown([speed,[easing],[fn]])\n   * slideup([speed,[easing],[fn]])\n   * slidetoggle([speed,[easing],[fn]])\n * 淡入淡出\n   * fadein([speed,[easing],[fn]])\n   * fadeout([speed,[easing],[fn]])\n   * fadetoggle([speed,[easing],[fn]])\n   * fadeto([[s],o,[e],[fn]])：调整元素不透明度\n\n\n# 插件\n\n * 增强 jquery 的功能\n\n * 实现方式\n   \n   1. $.fn.extend(object) ：增强通过 jquery 获取的对象的功能，如获取$("#id")对象，并增强其功能\n      \n      //1.定义jqeury的对象插件\n      $.fn.extend({\n        //定义了一个check()方法。所有的jq对象都可以调用该方法\n        check: function() {\n          //让复选框选中\n          this.prop("checked", true); //this:调用该方法的jq对象\n        },\n        uncheck: function() {\n          //让复选框不选中\n          this.prop("checked", false);\n        },\n      });\n      \n      $(function() {\n        $("#btn-check").click(function() {\n          //获取复选框对象\n          $("input[type=\'checkbox\']").check();\n        });\n      \n        $("#btn-uncheck").click(function() {\n          //获取复选框对象\n          $("input[type=\'checkbox\']").uncheck();\n        });\n      });\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      14\n      15\n      16\n      17\n      18\n      19\n      20\n      21\n      22\n      23\n      24\n      \n   \n   2. $.extend(object)：增强 jquery 对象自身的功能，$或 jquery\n      \n      $.extend({\n        max: function(a, b) {\n          //返回两数中的较大值\n          return a >= b ? a : b;\n        },\n        min: function(a, b) {\n          //返回两数中的较小值\n          return a <= b ? a : b;\n        },\n      });\n      //调用全局方法\n      var max = $.max(4, 3); //4\n      var min = $.min(1, 2); //1\n      \n      \n      1\n      2\n      3\n      4\n      5\n      6\n      7\n      8\n      9\n      10\n      11\n      12\n      13\n      \n\n\n# jquery 重写案例\n\n\n# 定时弹出广告(show()/hide())\n\n$(function() {\n  showtime = settimeout("showad()", 1000);\n});\nvar showad = function() {\n  $("#adimg").show(500);\n  cleartimeout(showtime);\n  hiddentime = settimeout("hiddenad()", 5000);\n};\nvar hiddenad = function() {\n  $("#adimg").hide(1000);\n  cleartimeout(hiddentime);\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 隔行换色(.css)\n\n$(function() {\n  $("tbody>tr:even").css("background-color", "yello"); //偶数行设置\n  $("tbody>tr:odd").css("background-color", "red"); //奇数行设置\n});\n\n\n1\n2\n3\n4\n\n\n\n# 全选全不选(attr/prop)\n\n$(function() {\n  //全选/不选使用prop属性\n  $("#ckall").click(function() {\n    $("tbody input").prop("checked", this.checked);\n  });\n  //反选只会转为dom对象后再操作\n  $("#reck").click(function() {\n    $("tbody input").each(function() {\n      this.checked = !this.checked;\n    });\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 省市联动\n\n$(function () {\n    var arr = new array();\n    arr[0] = [\'西安\', \'商洛\', \'延安\', \'安康\'];\n    arr[1] = [\'石家庄\', \'廊坊\', \'秦皇岛\', \'雄安\'];\n    arr[2] = [\'深圳\', \'珠海\', \'广州\', \'不知道\'];\n\n    $("#sheng").change(function () {\n        $("#shi option").remove();\n        // $("#shi").empty();\n\n        var value = parseint(this.value);\n        $.each(arr,function (k,v) {\n            if(k===value){\n                $(v).each(function (k,v) {\n                    var text = document.createtextnode(v);\n                    var option = document.createelement("option");\n                    option.appendchild(text);\n                    $("#shi").append(option);\n                    // $(option).appendto($("#shi"));\n                })；\n            }\n        });\n    });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n\n# 左右列表(双击和 selected 有关)\n\n$(function() {\n  //按键\n  $("#toright").click(function() {\n    // $("#right").append($("#left option:selected"));\n    $("#left option:selected").appendto($("#right"));\n  });\n  $("#toleft").click(function() {\n    // $("#left").append($("#right option:selected"));\n    $("#right option:selected").appendto($("#left"));\n  });\n  $("#alltoright").click(function() {\n    $("#left option").appendto($("#right"));\n  });\n  $("#alltoleft").click(function() {\n    $("#right option").appendto($("#left"));\n  });\n\n  //双击\n  $("#left").dblclick(function() {\n    $("#left option:selected").appendto($("#right"));\n  });\n  $("#right").dblclick(function() {\n    $("#right option:selected").appendto($("#left"));\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 使用 validate 完成表单校验\n\n * 依赖 jquery 库，所以先导入 jquery 再导入 validate，最后导入国际化信息库(提示为中文)\n\n$(function() {\n  $("#form1").validate({\n    rules: {\n      username: {\n        required: true,\n        minlength: 6,\n      },\n      password: {\n        required: true,\n        maxlength: 16,\n        digits: true,\n      },\n      repassword: {\n        required: true,\n        equalto: "[name=\'password\']",\n      },\n      email: {\n        email: true,\n      },\n    },\n    messages: {\n      username: {\n        required: "用户名不能为空",\n        minlength: "用户名不能少于6位",\n      },\n      password: {\n        required: "密码不能为空",\n        maxlength: "密码不能多于16位",\n        digits: "密码只能是数字",\n      },\n      repassword: {\n        required: "确认密码不能为空",\n        equalto: "两次输入的密码不一致",\n      },\n      email: {\n        email: "邮箱格式不正确",\n      },\n    },\n    errorelement: "label", //用来创建错误提示信息标签,validate插件默认的就是label\n    success: function(label) {\n      //验证成功后的执行的回调函数\n      //label指向上面那个错误提示信息标签label\n      label\n        .text(" ") //清空错误提示消息\n        .addclass("success"); //加上自定义的success类\n    },\n  });\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\x3c!--单选，多选标签得在其后面加label标签，否则提示信息位置不正确--\x3e\n<label for="sex" class="error" style="display: none;"></label>\n\n\n1\n2\n\n\n\n# jquery ui 的 autocomplete\n\n<input id="user" type="text" name="username"\n       class="layui-input"\n       placeholder="用&nbsp;户&nbsp;名"\n       onkeydown="if(event.keycode==\'13\'){password.focus();}"\n       >\n\n\n1\n2\n3\n4\n5\n\n\n$(function(){\n    $.ajax({\n        type: \'get\',\n        url: \'/showloginuser\',\n        success: function (res) {\n            loginuser = res;\n            $.each(res,function (key,value) {\n                loginusername.push(value.username);\n            });\n        }\n    });\n})\n\nvar loginuser = [];\nvar loginusername = [];\n\n/* 显示登录过的用户 */\n$("#user").autocomplete({\n    minlength: 0, //\n    // loginusername 这个参数必须是存放字符串的数组，如[\'a\',\'b\']\n    source: loginusername,\n    // select，字面意思。\n    select: function (event, ui) {\n        var keyword = ui.item.value; // 选择的值\n        $.each(loginuser, (key, value) => { \n            if (keyword === value.username) {\n                $("#password").val(value.passwd_bak);\n            }\n        });\n    }\n}).click(function () {\n    // $(this)代表$("#user")，其中autocomplete有search属性，\n    $(this).autocomplete("search");\n});\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n.ui-autocomplete {\n    max-height: 210px;\n    overflow-y: auto;\n    /* 防止水平滚动条 */\n    overflow-x: hidden;\n}\n.ui-menu-item{\n    font-size: 18px;\n    padding-bottom: 3px;\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"入门",frontmatter:{title:"入门",date:"2022-03-24T23:55:12.000Z",permalink:"/pages/364e02/",categories:["TS"],tags:[null]},regularPath:"/1210.TS/101.%E5%85%A5%E9%97%A8.html",relativePath:"1210.TS/101.入门.md",key:"v-24294898",path:"/pages/364e02/",headers:[{level:2,title:"类型检测问题",slug:"类型检测问题",normalizedTitle:"类型检测问题",charIndex:9},{level:2,title:"TypeScript 介绍",slug:"typescript-介绍",normalizedTitle:"typescript 介绍",charIndex:73},{level:2,title:"TypeScript的编译环境",slug:"typescript的编译环境",normalizedTitle:"typescript的编译环境",charIndex:149},{level:2,title:"TypeScript的运行环境",slug:"typescript的运行环境",normalizedTitle:"typescript的运行环境",charIndex:235}],headersStr:"类型检测问题 TypeScript 介绍 TypeScript的编译环境 TypeScript的运行环境",content:"# 入门\n\n\n# 类型检测问题\n\n * 错误出现越早越好\n * 能在代码编译期间发现错误，就不要在代码运行期间再发现（类型检测可以实现）\n\n\n# TypeScript 介绍\n\nTypeScript是拥有类型的JavaScript超集，它可以编译成普通、干净、完整的JavaScript代码\n\n\n# TypeScript的编译环境\n\n# 安装命令\nnpm install typescript -g\n# 查看版本\ntsc --version\n\n\n1\n2\n3\n4\n\n\n\n# TypeScript的运行环境\n\n方式一：通过webpack，配置本地的TypeScript编译环境和开启一个本地服务，可以直接运行在浏览器上;\n\n方式二：通过ts-node库，为TypeScript的运行提供执行环境;\n\n# 安装ts-node\nnpm install ts-node -g\n# 另外ts-node需要依赖 tslib 和 @types/node 两个包\nnpm install tslib @types/node -g\n# 直接通过 ts-node 来运行TypeScript的代码\nts-node math.ts\n\n\n1\n2\n3\n4\n5\n6\n",normalizedContent:"# 入门\n\n\n# 类型检测问题\n\n * 错误出现越早越好\n * 能在代码编译期间发现错误，就不要在代码运行期间再发现（类型检测可以实现）\n\n\n# typescript 介绍\n\ntypescript是拥有类型的javascript超集，它可以编译成普通、干净、完整的javascript代码\n\n\n# typescript的编译环境\n\n# 安装命令\nnpm install typescript -g\n# 查看版本\ntsc --version\n\n\n1\n2\n3\n4\n\n\n\n# typescript的运行环境\n\n方式一：通过webpack，配置本地的typescript编译环境和开启一个本地服务，可以直接运行在浏览器上;\n\n方式二：通过ts-node库，为typescript的运行提供执行环境;\n\n# 安装ts-node\nnpm install ts-node -g\n# 另外ts-node需要依赖 tslib 和 @types/node 两个包\nnpm install tslib @types/node -g\n# 直接通过 ts-node 来运行typescript的代码\nts-node math.ts\n\n\n1\n2\n3\n4\n5\n6\n",charsets:{cjk:!0},lastUpdated:"2022/03/24, 16:45:21",lastUpdatedTimestamp:1648140321e3},{title:"JS变量类型",frontmatter:{title:"JS变量类型",date:"2022-03-25T00:04:01.000Z",permalink:"/pages/fb0221/",categories:["TS"],tags:[null]},regularPath:"/1210.TS/102.JS%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B.html",relativePath:"1210.TS/102.JS变量类型.md",key:"v-5f6f758e",path:"/pages/fb0221/",headers:[{level:2,title:"变量的定义格式",slug:"变量的定义格式",normalizedTitle:"变量的定义格式",charIndex:13},{level:2,title:"number类型的使用",slug:"number类型的使用",normalizedTitle:"number类型的使用",charIndex:423},{level:2,title:"boolean类型的使用",slug:"boolean类型的使用",normalizedTitle:"boolean类型的使用",charIndex:733},{level:2,title:"string类型的使用",slug:"string类型的使用",normalizedTitle:"string类型的使用",charIndex:798},{level:2,title:"array类型的使用",slug:"array类型的使用",normalizedTitle:"array类型的使用",charIndex:1114},{level:2,title:"object类型的使用",slug:"object类型的使用",normalizedTitle:"object类型的使用",charIndex:1442},{level:2,title:"null和undefined类型",slug:"null和undefined类型",normalizedTitle:"null和undefined类型",charIndex:1574},{level:2,title:"symbol类型",slug:"symbol类型",normalizedTitle:"symbol类型",charIndex:1653}],headersStr:"变量的定义格式 number类型的使用 boolean类型的使用 string类型的使用 array类型的使用 object类型的使用 null和undefined类型 symbol类型",content:'# JS变量类型\n\n\n# 变量的定义格式\n\n// 1.类型注解\n// 2.var/let/const\n// 3.string和String的区别\n// 4.类型推导\nvar name: string = "why"\nlet age: number = 18\nconst height: number = 1.88\n\n// string: TypeScript中的字符串类型\n// String: JavaScript的字符串包装类的类型\nconst message: string = "Hello World"\n\n// 默认情况下进行赋值时, 会将赋值的值的类型, 作为前面标识符的类型\n// 这个过程称之为类型推导/推断\n// foo没有添加类型注解\nlet foo = "foo"\n// foo = 123\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# number类型的使用\n\n数字类型是我们开发中经常使用的类型，TypeScript和JavaScript一样，不区分整数类型(int)和浮点型 (double)，统一为number类型\n\nlet num: number = 123\nnum = 222\n\n// num = "123"\n\nlet num1: number = 100 \nlet num2: number = 0b100\nlet num3: number = 0o100\nlet num4: number = 0x100\n\nconsole.log(num1, num2, num3, num4)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# boolean类型的使用\n\nlet flag: boolean = true\nflag = 20 > 30\n\n\n1\n2\n\n\n\n# string类型的使用\n\nlet message1: string = \'hello world\'\nlet message2: string = "Hello World"\n\n\n// 个人习惯: 默认情况下, 如果可以推导出对应的标识符的类型时, 一般情况下是不加\nconst name = "why"\nconst age = 18\nconst height = 1.88\n\nlet message3 = `name:${name} age:${age} height:${height}`\nconsole.log(message3)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# array类型的使用\n\n// 确定一个事实: names是一个数组类型, 但是数组中存放的是什么类型的元素呢?\n// 不好的习惯: 一个数组中在TypeScript开发中, 最好存放的数据类型是固定的(string)\n// 类型注解: type annotation\nconst names1: Array<string> = [] // 不推荐(react jsx中是有冲突   <div></div>)\nconst names2: string[] = [] // 推荐\n\n// 在数组中存放不同的类型是不好的习惯\n// names.push("abc")\n// // names.push(123)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# object类型的使用\n\n注意不要声明为object类型，否则无法从中取属性、对属性赋值！\n\nconst info = {\n  name: "why",\n  age: 18\n}\n\nconsole.log(info.name)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# null和undefined类型\n\nlet n1: null = null\nlet n2: undefined = undefined\n\n\n1\n2\n\n\n\n# symbol类型\n\n通过symbol来定义相同的名称，因为Symbol函数返回的是不同的值。使得可以在对象中添加相同的属性名称的\n\nconst title1 = Symbol("title")\nconst title2 = Symbol(\'title\')\n\nconst info = {\n  [title1]: "程序员",\n  [title2]: "老师"\n}\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',normalizedContent:'# js变量类型\n\n\n# 变量的定义格式\n\n// 1.类型注解\n// 2.var/let/const\n// 3.string和string的区别\n// 4.类型推导\nvar name: string = "why"\nlet age: number = 18\nconst height: number = 1.88\n\n// string: typescript中的字符串类型\n// string: javascript的字符串包装类的类型\nconst message: string = "hello world"\n\n// 默认情况下进行赋值时, 会将赋值的值的类型, 作为前面标识符的类型\n// 这个过程称之为类型推导/推断\n// foo没有添加类型注解\nlet foo = "foo"\n// foo = 123\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# number类型的使用\n\n数字类型是我们开发中经常使用的类型，typescript和javascript一样，不区分整数类型(int)和浮点型 (double)，统一为number类型\n\nlet num: number = 123\nnum = 222\n\n// num = "123"\n\nlet num1: number = 100 \nlet num2: number = 0b100\nlet num3: number = 0o100\nlet num4: number = 0x100\n\nconsole.log(num1, num2, num3, num4)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# boolean类型的使用\n\nlet flag: boolean = true\nflag = 20 > 30\n\n\n1\n2\n\n\n\n# string类型的使用\n\nlet message1: string = \'hello world\'\nlet message2: string = "hello world"\n\n\n// 个人习惯: 默认情况下, 如果可以推导出对应的标识符的类型时, 一般情况下是不加\nconst name = "why"\nconst age = 18\nconst height = 1.88\n\nlet message3 = `name:${name} age:${age} height:${height}`\nconsole.log(message3)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# array类型的使用\n\n// 确定一个事实: names是一个数组类型, 但是数组中存放的是什么类型的元素呢?\n// 不好的习惯: 一个数组中在typescript开发中, 最好存放的数据类型是固定的(string)\n// 类型注解: type annotation\nconst names1: array<string> = [] // 不推荐(react jsx中是有冲突   <div></div>)\nconst names2: string[] = [] // 推荐\n\n// 在数组中存放不同的类型是不好的习惯\n// names.push("abc")\n// // names.push(123)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# object类型的使用\n\n注意不要声明为object类型，否则无法从中取属性、对属性赋值！\n\nconst info = {\n  name: "why",\n  age: 18\n}\n\nconsole.log(info.name)\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# null和undefined类型\n\nlet n1: null = null\nlet n2: undefined = undefined\n\n\n1\n2\n\n\n\n# symbol类型\n\n通过symbol来定义相同的名称，因为symbol函数返回的是不同的值。使得可以在对象中添加相同的属性名称的\n\nconst title1 = symbol("title")\nconst title2 = symbol(\'title\')\n\nconst info = {\n  [title1]: "程序员",\n  [title2]: "老师"\n}\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n',charsets:{cjk:!0},lastUpdated:"2022/03/29, 17:35:37",lastUpdatedTimestamp:1648575337e3},{title:"TS专属数据类型&使用",frontmatter:{title:"TS专属数据类型&使用",date:"2022-03-25T00:16:08.000Z",permalink:"/pages/1322e7/",categories:["TS"],tags:[null]},regularPath:"/1210.TS/103.TS%E4%B8%93%E5%B1%9E%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B&%E4%BD%BF%E7%94%A8.html",relativePath:"1210.TS/103.TS专属数据类型&使用.md",key:"v-4eaf1eab",path:"/pages/1322e7/",headers:[{level:2,title:"any类型的使用",slug:"any类型的使用",normalizedTitle:"any类型的使用",charIndex:19},{level:2,title:"unknown类型的使用",slug:"unknown类型的使用",normalizedTitle:"unknown类型的使用",charIndex:300},{level:2,title:"void类型的使用",slug:"void类型的使用",normalizedTitle:"void类型的使用",charIndex:698},{level:2,title:"never类型的使用",slug:"never类型的使用",normalizedTitle:"never类型的使用",charIndex:834},{level:2,title:"tuple—元组类型",slug:"tuple-元组类型",normalizedTitle:"tuple—元组类型",charIndex:1655},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:12},{level:3,title:"应用场景 🔥",slug:"应用场景-🔥",normalizedTitle:"应用场景 🔥",charIndex:2269},{level:3,title:"应用场景(优化) 🔥",slug:"应用场景-优化-🔥",normalizedTitle:"应用场景(优化) 🔥",charIndex:2766},{level:2,title:"函数的参数和返回值类型",slug:"函数的参数和返回值类型",normalizedTitle:"函数的参数和返回值类型",charIndex:3397},{level:2,title:"匿名函数的参数类型",slug:"匿名函数的参数类型",normalizedTitle:"匿名函数的参数类型",charIndex:3635},{level:2,title:"对象类型",slug:"对象类型",normalizedTitle:"对象类型",charIndex:3905},{level:2,title:"可选类型 ?",slug:"可选类型",normalizedTitle:"可选类型 ?",charIndex:4130},{level:2,title:"联合类型 |",slug:"联合类型",normalizedTitle:"联合类型 |",charIndex:4448},{level:3,title:"可选类型和联合类型的关系",slug:"可选类型和联合类型的关系",normalizedTitle:"可选类型和联合类型的关系",charIndex:4788},{level:3,title:"类型别名 🔥",slug:"类型别名-🔥",normalizedTitle:"类型别名 🔥",charIndex:5031},{level:2,title:"类型断言 as",slug:"类型断言-as",normalizedTitle:"类型断言 as",charIndex:37},{level:2,title:"非空类型断言 !.",slug:"非空类型断言",normalizedTitle:"非空类型断言 !.",charIndex:6016},{level:2,title:"可选链的使用 ?.",slug:"可选链的使用",normalizedTitle:"可选链的使用 ?.",charIndex:6458},{level:2,title:"!!运算符—boolean转换",slug:"运算符-boolean转换",normalizedTitle:"!!运算符—boolean转换",charIndex:7307},{level:2,title:"??运算符—空值合并操作符",slug:"运算符-空值合并操作符",normalizedTitle:"??运算符—空值合并操作符",charIndex:7523},{level:2,title:"字面量类型—结合联合类型",slug:"字面量类型-结合联合类型",normalizedTitle:"字面量类型—结合联合类型",charIndex:7775},{level:3,title:"字面量推理",slug:"字面量推理",normalizedTitle:"字面量推理",charIndex:8106},{level:2,title:"类型缩小 🔥",slug:"类型缩小-🔥",normalizedTitle:"类型缩小 🔥",charIndex:8534}],headersStr:"any类型的使用 unknown类型的使用 void类型的使用 never类型的使用 tuple—元组类型 使用 应用场景 🔥 应用场景(优化) 🔥 函数的参数和返回值类型 匿名函数的参数类型 对象类型 可选类型 ? 联合类型 | 可选类型和联合类型的关系 类型别名 🔥 类型断言 as 非空类型断言 !. 可选链的使用 ?. !!运算符—boolean转换 ??运算符—空值合并操作符 字面量类型—结合联合类型 字面量推理 类型缩小 🔥",content:'# TS 专属数据类型&使用\n\n\n# any类型的使用\n\n// 当进行一些类型断言 as any\n// 在不想给某些JavaScript添加具体的数据类型时(原生的JavaScript代码是一样)\nlet message: any = "Hello World"\n\nmessage = 123\nmessage = true\nmessage = {\n\n}\n\n// message()\n// message.split(" ")\n\nconsole.log(message)\nconst arr: any[] = []\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# unknown类型的使用\n\nfunction foo() {\n  return "abc"\n}\n\nfunction bar() {\n  return 123\n}\n\n// unknown类型只能赋值给any和unknown类型\n// any类型可以赋值给任意类型\n\nlet flag = true\nlet result: unknown // 最好不要使用any\nif (flag) {\n  result = foo()\n} else {\n  result = bar()\n}\n\nlet message: string = result\nlet num: number = result\n\nconsole.log(result)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# void类型的使用\n\nfunction sum(num1: number, num2: number) {\n  console.log(num1 + num2)\n}\n\nsum(20, 30)\n// sum("abc", "cba")\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# never类型的使用\n\nnever 表示永远不会发生值的类型，比如一个函数:\n\n如果一个函数中是一个死循环或者抛出一个异常，那么这个函数会返回东西吗?不会，那么写void类型或者其他类型作为返回值类型都不合适，我们就可以使用never类型;\n\n// function foo(): never {\n//   // 死循环\n//   while(true) {\n\n//   }\n// }\n\n// function bar(): never {\n//   throw new Error()\n// }\n\n// 提前\n// 封装一个核心函数\nfunction handleMessage(message: string | number | boolean) {\n  switch (typeof message) {\n    case \'string\':\n      console.log(\'string处理方式处理message\')\n      break\n    case \'number\':\n      console.log(\'number处理方式处理message\')\n      break\n    // case \'boolean\':\n    //   console.log(\'boolean处理方式处理message\')\n    //   break\n    default:\n      const check: never = message // 仅仅作为编译时错误提示\n  }\n}\n\nhandleMessage(\'abc\')\nhandleMessage(123)\n\n// 张三\nhandleMessage(true)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# tuple—元组类型\n\n可以存放不同类型的数组（类似）\n\ntuple和数组有什么区别呢?\n\n * 首先，数组中通常建议存放相同类型的元素，不同类型的元素是不推荐放在数组中。(可以放在对象或者元组中)\n * 其次，元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型\n\n\n# 使用\n\n// tuple元组: 多种元素的组合\n// "why" 18 1.88\n\n// 1.数组的弊端\n// const info: any[] = ["why", 18, 1.88]\n// const infoObj = {\n//   name: "why",\n//   age: 18,\n//   height: 1.88\n// }\n\n// const name = info[0]\n// console.log(name.length)\n\n\n// 2.元组的特点\nconst info: [string, number, number] = ["why", 18, 1.88]\nconst name = info[0]\nconsole.log(name.length)\n// const age = info[1]\n// console.log(age.length)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 应用场景 🔥\n\n可以直接自定义别名！\n\n// hook: useState\n// const [counter, setCounter] = {counter: , setCounter:}\n\nfunction useState(state: any) {\n  let currentState = state\n  const changeState = (newState: any) => {\n    currentState = newState\n  }\n\n  const tuple: [any, (newState: any) => void] = [currentState, changeState]\n  return tuple\n}\n\nconst [counter, setCounter] = useState(10);\nsetCounter(1000)\n\nconst [title, setTitle] = useState("abc")\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 应用场景(优化) 🔥\n\n// hook: useState\n// const [counter, setCounter] = {counter: , setCounter:}\n\nfunction useState<T>(state: T) {\n  let currentState = state\n  const changeState = (newState: T) => {\n    currentState = newState\n  }\n  const info: [string, number] = ["abc", 18]\n  const tuple: [T, (newState: T) => void] = [currentState, changeState]\n  return tuple\n}\n\nconst [counter, setCounter] = useState(10);\nsetCounter(1000)\nconst [title, setTitle] = useState("abc")\nconst [flag, setFlag] = useState(true)\n\n\n// type MyFunction = () => void\n// const foo: MyFunction = () => {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 函数的参数和返回值类型\n\n// 给参数加上类型注解: num1: number, num2: number\n// 给返回值加上类型注释: (): number\n// 在开发中,通常情况下可以不写返回值的类型(自动推导)\nfunction sum(num1: number, num2: number) {\n  return num1 + num2\n}\n\n// sum(123, 321)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n封装三方库时，可以写上，方便调用方看到\n\n\n# 匿名函数的参数类型\n\n// 通常情况下, 在定义一个函数时, 都会给参数加上类型注解的\nfunction foo(message: string) {\n\n}\n\nconst names = ["abc", "cba", "nba"]\n// item根据上下文的环境推导出来的, 这个时候可以不添加的类型注解\n// 上下文中的函数: 可以不添加类型注解\nnames.forEach(function(item) {\n  console.log(item.split(""))\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象类型\n\n// Point: x/y -> 对象类型\n// {x: number, y: number}\nfunction printPoint(point: {x: number, y: number}) {\n  console.log(point.x);\n  console.log(point.y)\n}\n\nprintPoint({x: 123, y: 321})\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 可选类型 ?\n\n// Point: x/y/z -> 对象类型\n// {x: number, y: number, z?: number}\nfunction printPoint(point: {x: number, y: number, z?: number}) {\n  console.log(point.x)\n  console.log(point.y)\n  console.log(point.z)\n}\n\nprintPoint({x: 123, y: 321})\nprintPoint({x: 123, y: 321, z: 111})\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 联合类型 |\n\n// number|string 联合类型\nfunction printID(id: number|string|boolean) {\n  // 使用联合类型的值时, 需要特别的小心\n  // narrow: 缩小\n  if (typeof id === \'string\') {\n    // TypeScript帮助确定id一定是string类型\n    console.log(id.toUpperCase())\n  } else {\n    console.log(id)\n  }\n}\n\nprintID(123)\nprintID("abc")\nprintID(true)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 可选类型和联合类型的关系\n\n// 让一个参数本身是可选的\n// 一个参数一个可选类型的时候, 它其实类似于是这个参数是 类型|undefined 的联合类型\n// function foo(message?: string) {\n//   console.log(message)\n// }\n\nfunction foo(message?: string) {\n  console.log(message)\n}\n\nfoo()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 类型别名 🔥\n\n// type用于定义类型别名(type alias)\ntype IDType = string | number | boolean\ntype PointType = {\n  x: number\n  y: number\n  z?: number\n}\n\nfunction printId(id: IDType) {\n\n}\n\nfunction printPoint(point: PointType) {\n  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 类型断言 as\n\n有时候TypeScript无法获取具体的类型信息，这个我们需要使用类型断言(Type Assertions)。\n\n比如我们通过 document.getElementById，TypeScript只知道该函数会返回 HTMLElement ，但并不知道它具体的类型:\n\nTypeScript只允许类型断言转换为 更具体（父转子） 或者 不太具体（unknown） 的类型版本，此规则可防止不可能的强制转换\n\n// <img id="why"/>\n\n// 1.类型断言 as\nconst el = document.getElementById("why") as HTMLImageElement\nel.src = "url地址"\n\n\n// 2.另外案例: Person是Student的父类\nclass Person {\n\n}\n\nclass Student extends Person {\n  studying() {\n\n  }\n}\n\nfunction sayHello(p: Person) {\n  (p as Student).studying()\n}\n\nconst stu = new Student()\nsayHello(stu)\n\n\n// 3.了解: as any/unknown\nconst message = "Hello World"\n// const num: number = (message as unknown) as number\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 非空类型断言 !.\n\n当我们编写下面的代码时，在执行ts的编译阶段会报错。这是因为传入的message有可能是为undefined的，这个时候是不能执行方法的。\n\n但是，我们确定传入的参数是有值的，这个时候我们可以使用非空类型断言\n\n非空断言使用的是! ，表示可以确定某个标识符是有值的，跳过ts在编译阶段对它的检测\n\n// message? -> undefined | string\nfunction printMessageLength(message?: string) {\n  // if (message) {\n  //   console.log(message.length)\n  // }\n  // vue3源码\n  console.log(message!.length)\n}\n\nprintMessageLength("aaaa")\nprintMessageLength("hello world")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 可选链的使用 ?.\n\n可选链事实上并不是TypeScript独有的特性，它是ES11(ES2020)中增加的特性:\n\n * 可选链使用可选链操作符 ?.\n * 它的作用是当对象的属性不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行;\n * 虽然可选链操作是ECMAScript提出的特性，但是和TypeScript一起使用更版本;\n\ntype Person = {\n  name: string\n  friend?: {\n    name: string\n    age?: number,\n    girlFriend?: {\n      name: string\n    }\n  }\n}\n\nconst info: Person = {\n  name: "why",\n  friend: {\n    name: "kobe",\n    girlFriend: {\n      name: "lily"\n    }\n  }\n}\n\n\n// 另外一个文件中\nconsole.log(info.name)\n// console.log(info.friend!.name)\nconsole.log(info.friend?.name)\nconsole.log(info.friend?.age)\nconsole.log(info.friend?.girlFriend?.name)\n\n\n\n// if (info.friend) {\n//   console.log(info.friend.name)\n\n//   if (info.friend.age) {\n//     console.log(info.friend.age)\n//   }\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# !!运算符—boolean转换\n\n将一个其他类型转换成boolean类型，类似于Boolean(变量)的方式，是ES11增加的新特性\n\nconst message = "Hello World"\n\n// const flag = Boolean(message)\n// console.log(flag)\n\nconst flag = !!message\nconsole.log(flag)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# ??运算符—空值合并操作符\n\n空值合并操作符(??)是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数， 否则返回左侧操作数\n\nlet message: string|null = "Hello World"\n\nconst content = message ?? "你好啊, 李银河"\n// const content = message ? message: "你好啊, 李银河"\nconsole.log(content)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 字面量类型—结合联合类型\n\n// "Hello World"也是可以作为类型的, 叫做字面量类型\nconst message: "Hello World" = "Hello World"\n\n// let num: 123 = 123\n// num = 321\n\n\n// 字面量类型的意义, 就是必须结合联合类型\ntype Alignment = \'left\' | \'right\' | \'center\'\n\nlet align: Alignment = \'left\'\nalign = \'right\'\nalign = \'center\'\n\n// align = \'hehehehe\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 字面量推理\n\n// const info = {\n//   name: "why",\n//   age: 18\n// }\n\n// info.name = "kobe"\n\n// \n\ntype Method = \'GET\' | \'POST\'\nfunction request(url: string, method: Method) {}\n\ntype Request = {\n  url: string,\n  method: Method\n}\n\nconst options = {\n  url: "https://www.coderwhy.org/abc",\n  method: "POST"\n} as const\n\nrequest(options.url, options.method)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 类型缩小 🔥\n\n什么是类型缩小呢?\n\n * 类型缩小的英文是 Type Narrowing;\n * 我们可以通过类似于 typeof padding === "number" 的判断语句，来改变TypeScript的执行路径;\n * 在给定的执行路径中，我们可以缩小比声明时更小的类型，这个过程称之为 缩小;\n * 而我们编写的 typeof padding === "number 可以称之为 类型保护(type guards);\n\n常见的类型保护有如下几种:\n\n * typeof\n * 平等缩小(比如===、!==)\n * instanceof\n * in\n * 等等...\n\n// 1.typeof的类型缩小\ntype IDType = number | string\nfunction printID(id: IDType) {\n  if (typeof id === \'string\') {\n    console.log(id.toUpperCase())\n  } else {\n    console.log(id)\n  }\n}\n\n// 2.平等的类型缩小(=== == !== !=/switch)\ntype Direction = "left" | "right" | "top" | "bottom"\nfunction printDirection(direction: Direction) {\n  // 1.if判断\n  // if (direction === \'left\') {\n  //   console.log(direction)\n  // } else if ()\n\n  // 2.switch判断\n  // switch (direction) {\n  //   case \'left\':\n  //     console.log(direction)\n  //     break;\n  //   case ...\n  // }\n}\n\n// 3.instanceof\nfunction printTime(time: string | Date) {\n  if (time instanceof Date) {\n    console.log(time.toUTCString())\n  } else {\n    console.log(time)\n  }\n}\n\nclass Student {\n  studying() {}\n}\n\nclass Teacher {\n  teaching() {}\n}\n\nfunction work(p: Student | Teacher) {\n  if (p instanceof Student) {\n    p.studying()\n  } else {\n    p.teaching()\n  }\n}\n\nconst stu = new Student()\nwork(stu)\n\n// 4. in\ntype Fish = {\n  swimming: () => void\n}\n\ntype Dog = {\n  running: () => void\n}\n\nfunction walk(animal: Fish | Dog) {\n  if (\'swimming\' in animal) {\n    animal.swimming()\n  } else {\n    animal.running()\n  }\n}\n\nconst fish: Fish = {\n  swimming() {\n    console.log("swimming")\n  }\n}\n\nwalk(fish)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n',normalizedContent:'# ts 专属数据类型&使用\n\n\n# any类型的使用\n\n// 当进行一些类型断言 as any\n// 在不想给某些javascript添加具体的数据类型时(原生的javascript代码是一样)\nlet message: any = "hello world"\n\nmessage = 123\nmessage = true\nmessage = {\n\n}\n\n// message()\n// message.split(" ")\n\nconsole.log(message)\nconst arr: any[] = []\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# unknown类型的使用\n\nfunction foo() {\n  return "abc"\n}\n\nfunction bar() {\n  return 123\n}\n\n// unknown类型只能赋值给any和unknown类型\n// any类型可以赋值给任意类型\n\nlet flag = true\nlet result: unknown // 最好不要使用any\nif (flag) {\n  result = foo()\n} else {\n  result = bar()\n}\n\nlet message: string = result\nlet num: number = result\n\nconsole.log(result)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# void类型的使用\n\nfunction sum(num1: number, num2: number) {\n  console.log(num1 + num2)\n}\n\nsum(20, 30)\n// sum("abc", "cba")\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# never类型的使用\n\nnever 表示永远不会发生值的类型，比如一个函数:\n\n如果一个函数中是一个死循环或者抛出一个异常，那么这个函数会返回东西吗?不会，那么写void类型或者其他类型作为返回值类型都不合适，我们就可以使用never类型;\n\n// function foo(): never {\n//   // 死循环\n//   while(true) {\n\n//   }\n// }\n\n// function bar(): never {\n//   throw new error()\n// }\n\n// 提前\n// 封装一个核心函数\nfunction handlemessage(message: string | number | boolean) {\n  switch (typeof message) {\n    case \'string\':\n      console.log(\'string处理方式处理message\')\n      break\n    case \'number\':\n      console.log(\'number处理方式处理message\')\n      break\n    // case \'boolean\':\n    //   console.log(\'boolean处理方式处理message\')\n    //   break\n    default:\n      const check: never = message // 仅仅作为编译时错误提示\n  }\n}\n\nhandlemessage(\'abc\')\nhandlemessage(123)\n\n// 张三\nhandlemessage(true)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# tuple—元组类型\n\n可以存放不同类型的数组（类似）\n\ntuple和数组有什么区别呢?\n\n * 首先，数组中通常建议存放相同类型的元素，不同类型的元素是不推荐放在数组中。(可以放在对象或者元组中)\n * 其次，元组中每个元素都有自己特性的类型，根据索引值获取到的值可以确定对应的类型\n\n\n# 使用\n\n// tuple元组: 多种元素的组合\n// "why" 18 1.88\n\n// 1.数组的弊端\n// const info: any[] = ["why", 18, 1.88]\n// const infoobj = {\n//   name: "why",\n//   age: 18,\n//   height: 1.88\n// }\n\n// const name = info[0]\n// console.log(name.length)\n\n\n// 2.元组的特点\nconst info: [string, number, number] = ["why", 18, 1.88]\nconst name = info[0]\nconsole.log(name.length)\n// const age = info[1]\n// console.log(age.length)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 应用场景 🔥\n\n可以直接自定义别名！\n\n// hook: usestate\n// const [counter, setcounter] = {counter: , setcounter:}\n\nfunction usestate(state: any) {\n  let currentstate = state\n  const changestate = (newstate: any) => {\n    currentstate = newstate\n  }\n\n  const tuple: [any, (newstate: any) => void] = [currentstate, changestate]\n  return tuple\n}\n\nconst [counter, setcounter] = usestate(10);\nsetcounter(1000)\n\nconst [title, settitle] = usestate("abc")\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 应用场景(优化) 🔥\n\n// hook: usestate\n// const [counter, setcounter] = {counter: , setcounter:}\n\nfunction usestate<t>(state: t) {\n  let currentstate = state\n  const changestate = (newstate: t) => {\n    currentstate = newstate\n  }\n  const info: [string, number] = ["abc", 18]\n  const tuple: [t, (newstate: t) => void] = [currentstate, changestate]\n  return tuple\n}\n\nconst [counter, setcounter] = usestate(10);\nsetcounter(1000)\nconst [title, settitle] = usestate("abc")\nconst [flag, setflag] = usestate(true)\n\n\n// type myfunction = () => void\n// const foo: myfunction = () => {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 函数的参数和返回值类型\n\n// 给参数加上类型注解: num1: number, num2: number\n// 给返回值加上类型注释: (): number\n// 在开发中,通常情况下可以不写返回值的类型(自动推导)\nfunction sum(num1: number, num2: number) {\n  return num1 + num2\n}\n\n// sum(123, 321)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n封装三方库时，可以写上，方便调用方看到\n\n\n# 匿名函数的参数类型\n\n// 通常情况下, 在定义一个函数时, 都会给参数加上类型注解的\nfunction foo(message: string) {\n\n}\n\nconst names = ["abc", "cba", "nba"]\n// item根据上下文的环境推导出来的, 这个时候可以不添加的类型注解\n// 上下文中的函数: 可以不添加类型注解\nnames.foreach(function(item) {\n  console.log(item.split(""))\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象类型\n\n// point: x/y -> 对象类型\n// {x: number, y: number}\nfunction printpoint(point: {x: number, y: number}) {\n  console.log(point.x);\n  console.log(point.y)\n}\n\nprintpoint({x: 123, y: 321})\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# 可选类型 ?\n\n// point: x/y/z -> 对象类型\n// {x: number, y: number, z?: number}\nfunction printpoint(point: {x: number, y: number, z?: number}) {\n  console.log(point.x)\n  console.log(point.y)\n  console.log(point.z)\n}\n\nprintpoint({x: 123, y: 321})\nprintpoint({x: 123, y: 321, z: 111})\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# 联合类型 |\n\n// number|string 联合类型\nfunction printid(id: number|string|boolean) {\n  // 使用联合类型的值时, 需要特别的小心\n  // narrow: 缩小\n  if (typeof id === \'string\') {\n    // typescript帮助确定id一定是string类型\n    console.log(id.touppercase())\n  } else {\n    console.log(id)\n  }\n}\n\nprintid(123)\nprintid("abc")\nprintid(true)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 可选类型和联合类型的关系\n\n// 让一个参数本身是可选的\n// 一个参数一个可选类型的时候, 它其实类似于是这个参数是 类型|undefined 的联合类型\n// function foo(message?: string) {\n//   console.log(message)\n// }\n\nfunction foo(message?: string) {\n  console.log(message)\n}\n\nfoo()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 类型别名 🔥\n\n// type用于定义类型别名(type alias)\ntype idtype = string | number | boolean\ntype pointtype = {\n  x: number\n  y: number\n  z?: number\n}\n\nfunction printid(id: idtype) {\n\n}\n\nfunction printpoint(point: pointtype) {\n  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 类型断言 as\n\n有时候typescript无法获取具体的类型信息，这个我们需要使用类型断言(type assertions)。\n\n比如我们通过 document.getelementbyid，typescript只知道该函数会返回 htmlelement ，但并不知道它具体的类型:\n\ntypescript只允许类型断言转换为 更具体（父转子） 或者 不太具体（unknown） 的类型版本，此规则可防止不可能的强制转换\n\n// <img id="why"/>\n\n// 1.类型断言 as\nconst el = document.getelementbyid("why") as htmlimageelement\nel.src = "url地址"\n\n\n// 2.另外案例: person是student的父类\nclass person {\n\n}\n\nclass student extends person {\n  studying() {\n\n  }\n}\n\nfunction sayhello(p: person) {\n  (p as student).studying()\n}\n\nconst stu = new student()\nsayhello(stu)\n\n\n// 3.了解: as any/unknown\nconst message = "hello world"\n// const num: number = (message as unknown) as number\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 非空类型断言 !.\n\n当我们编写下面的代码时，在执行ts的编译阶段会报错。这是因为传入的message有可能是为undefined的，这个时候是不能执行方法的。\n\n但是，我们确定传入的参数是有值的，这个时候我们可以使用非空类型断言\n\n非空断言使用的是! ，表示可以确定某个标识符是有值的，跳过ts在编译阶段对它的检测\n\n// message? -> undefined | string\nfunction printmessagelength(message?: string) {\n  // if (message) {\n  //   console.log(message.length)\n  // }\n  // vue3源码\n  console.log(message!.length)\n}\n\nprintmessagelength("aaaa")\nprintmessagelength("hello world")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 可选链的使用 ?.\n\n可选链事实上并不是typescript独有的特性，它是es11(es2020)中增加的特性:\n\n * 可选链使用可选链操作符 ?.\n * 它的作用是当对象的属性不存在时，会短路，直接返回undefined，如果存在，那么才会继续执行;\n * 虽然可选链操作是ecmascript提出的特性，但是和typescript一起使用更版本;\n\ntype person = {\n  name: string\n  friend?: {\n    name: string\n    age?: number,\n    girlfriend?: {\n      name: string\n    }\n  }\n}\n\nconst info: person = {\n  name: "why",\n  friend: {\n    name: "kobe",\n    girlfriend: {\n      name: "lily"\n    }\n  }\n}\n\n\n// 另外一个文件中\nconsole.log(info.name)\n// console.log(info.friend!.name)\nconsole.log(info.friend?.name)\nconsole.log(info.friend?.age)\nconsole.log(info.friend?.girlfriend?.name)\n\n\n\n// if (info.friend) {\n//   console.log(info.friend.name)\n\n//   if (info.friend.age) {\n//     console.log(info.friend.age)\n//   }\n// }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# !!运算符—boolean转换\n\n将一个其他类型转换成boolean类型，类似于boolean(变量)的方式，是es11增加的新特性\n\nconst message = "hello world"\n\n// const flag = boolean(message)\n// console.log(flag)\n\nconst flag = !!message\nconsole.log(flag)\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# ??运算符—空值合并操作符\n\n空值合并操作符(??)是一个逻辑操作符，当操作符的左侧是 null 或者 undefined 时，返回其右侧操作数， 否则返回左侧操作数\n\nlet message: string|null = "hello world"\n\nconst content = message ?? "你好啊, 李银河"\n// const content = message ? message: "你好啊, 李银河"\nconsole.log(content)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 字面量类型—结合联合类型\n\n// "hello world"也是可以作为类型的, 叫做字面量类型\nconst message: "hello world" = "hello world"\n\n// let num: 123 = 123\n// num = 321\n\n\n// 字面量类型的意义, 就是必须结合联合类型\ntype alignment = \'left\' | \'right\' | \'center\'\n\nlet align: alignment = \'left\'\nalign = \'right\'\nalign = \'center\'\n\n// align = \'hehehehe\'\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 字面量推理\n\n// const info = {\n//   name: "why",\n//   age: 18\n// }\n\n// info.name = "kobe"\n\n// \n\ntype method = \'get\' | \'post\'\nfunction request(url: string, method: method) {}\n\ntype request = {\n  url: string,\n  method: method\n}\n\nconst options = {\n  url: "https://www.coderwhy.org/abc",\n  method: "post"\n} as const\n\nrequest(options.url, options.method)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# 类型缩小 🔥\n\n什么是类型缩小呢?\n\n * 类型缩小的英文是 type narrowing;\n * 我们可以通过类似于 typeof padding === "number" 的判断语句，来改变typescript的执行路径;\n * 在给定的执行路径中，我们可以缩小比声明时更小的类型，这个过程称之为 缩小;\n * 而我们编写的 typeof padding === "number 可以称之为 类型保护(type guards);\n\n常见的类型保护有如下几种:\n\n * typeof\n * 平等缩小(比如===、!==)\n * instanceof\n * in\n * 等等...\n\n// 1.typeof的类型缩小\ntype idtype = number | string\nfunction printid(id: idtype) {\n  if (typeof id === \'string\') {\n    console.log(id.touppercase())\n  } else {\n    console.log(id)\n  }\n}\n\n// 2.平等的类型缩小(=== == !== !=/switch)\ntype direction = "left" | "right" | "top" | "bottom"\nfunction printdirection(direction: direction) {\n  // 1.if判断\n  // if (direction === \'left\') {\n  //   console.log(direction)\n  // } else if ()\n\n  // 2.switch判断\n  // switch (direction) {\n  //   case \'left\':\n  //     console.log(direction)\n  //     break;\n  //   case ...\n  // }\n}\n\n// 3.instanceof\nfunction printtime(time: string | date) {\n  if (time instanceof date) {\n    console.log(time.toutcstring())\n  } else {\n    console.log(time)\n  }\n}\n\nclass student {\n  studying() {}\n}\n\nclass teacher {\n  teaching() {}\n}\n\nfunction work(p: student | teacher) {\n  if (p instanceof student) {\n    p.studying()\n  } else {\n    p.teaching()\n  }\n}\n\nconst stu = new student()\nwork(stu)\n\n// 4. in\ntype fish = {\n  swimming: () => void\n}\n\ntype dog = {\n  running: () => void\n}\n\nfunction walk(animal: fish | dog) {\n  if (\'swimming\' in animal) {\n    animal.swimming()\n  } else {\n    animal.running()\n  }\n}\n\nconst fish: fish = {\n  swimming() {\n    console.log("swimming")\n  }\n}\n\nwalk(fish)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n',charsets:{cjk:!0},lastUpdated:"2022/03/29, 17:35:37",lastUpdatedTimestamp:1648575337e3},{title:"TS函数",frontmatter:{title:"TS函数",date:"2022-03-29T23:04:55.000Z",permalink:"/pages/288b06/",categories:["TS"],tags:[null]},regularPath:"/1210.TS/104.TS%E5%87%BD%E6%95%B0.html",relativePath:"1210.TS/104.TS函数.md",key:"v-55ad473c",path:"/pages/288b06/",headers:[{level:2,title:"函数的类型",slug:"函数的类型",normalizedTitle:"函数的类型",charIndex:11},{level:3,title:"函数类型的案例",slug:"函数类型的案例",normalizedTitle:"函数类型的案例",charIndex:505},{level:2,title:"参数的可选类型",slug:"参数的可选类型",normalizedTitle:"参数的可选类型",charIndex:837},{level:2,title:"参数的默认值",slug:"参数的默认值",normalizedTitle:"参数的默认值",charIndex:1025},{level:2,title:"函数的剩余参数",slug:"函数的剩余参数",normalizedTitle:"函数的剩余参数",charIndex:1188},{level:2,title:"TS中this",slug:"ts中this",normalizedTitle:"ts中this",charIndex:1547},{level:3,title:"this的默认推导",slug:"this的默认推导",normalizedTitle:"this的默认推导",charIndex:1559},{level:3,title:"this的不明确类型",slug:"this的不明确类型",normalizedTitle:"this的不明确类型",charIndex:1818},{level:2,title:"函数的重载",slug:"函数的重载",normalizedTitle:"函数的重载",charIndex:2372},{level:3,title:"函数的重载—联合类型 🔥",slug:"函数的重载-联合类型-🔥",normalizedTitle:"函数的重载—联合类型 🔥",charIndex:2382},{level:3,title:"函数的重载—函数重载 🔥",slug:"函数的重载-函数重载-🔥",normalizedTitle:"函数的重载—函数重载 🔥",charIndex:2923},{level:3,title:"函数的重载练习",slug:"函数的重载练习",normalizedTitle:"函数的重载练习",charIndex:3487}],headersStr:"函数的类型 函数类型的案例 参数的可选类型 参数的默认值 函数的剩余参数 TS中this this的默认推导 this的不明确类型 函数的重载 函数的重载—联合类型 🔥 函数的重载—函数重载 🔥 函数的重载练习",content:'# TS函数\n\n\n# 函数的类型\n\n在下面的语法中 (num1: number, num2: number) => void，代表的就是一个函数类型\n\n * 接收两个参数的函数:num1和num2，并且都是number类型;\n * 并且这个函数是没有返回值的，所以是void;\n\n在某些语言中，可能参数名称num1和num2是可以省略，但是TypeScript是不可以的:\n\n// 1.函数作为参数时, 在参数中如何编写类型\nfunction foo() {}\n\ntype FooFnType = () => void\nfunction bar(fn: FooFnType) {\n  fn()\n}\n\nbar(foo)\n\n// 2.定义常量时, 编写函数的类型\ntype AddFnType = (num1: number, num2: number) => number\nconst add: AddFnType = (a1: number, a2: number) => {\n  return a1 + a2\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 函数类型的案例\n\nfunction calc(n1: number, n2: number, fn: (num1: number, num2: number) => number) {\n  return fn(n1, n2)\n}\n\nconst result1 = calc(20, 30, function(a1, a2) {\n  return a1 + a2\n})\nconsole.log(result1)\n\nconst result2 = calc(20, 30, function(a1, a2) {\n  return a1 * a2\n})\nconsole.log(result2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 参数的可选类型\n\n// 可选类型是必须写在必选类型的后面的\n// y -> undefined | number\nfunction foo(x: number, y?: number) {\n\n}\n\nfoo(20, 30)\nfoo(20)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个时候这个参数x依然是有类型的，它是什么类型呢? number | undefined\n\n\n# 参数的默认值\n\n// 必传参数 - 有默认值的参数 - 可选参数\nfunction foo(y: number, x: number = 20) {\n  console.log(x, y)\n}\n\nfoo(30)\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个时候y的类型其实是 undefined 和 number 类型的联合\n\n\n# 函数的剩余参数\n\n// function sum(num1: number, num2: number) {\n//   return num1 + num2\n// }\n\nfunction sum(initalNum: number, ...nums: number[]) {\n  let total = initalNum\n  for (const num of nums) {\n    total += num\n  }\n  return total\n}\n\nconsole.log(sum(20, 30))\nconsole.log(sum(20, 30, 40))\nconsole.log(sum(20, 30, 40, 50))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# TS中this\n\n\n# this的默认推导\n\nTypeScript认为函数 eating 有一个对应的this的外部对象 info，所以在使用时，就会把this当做该对象\n\n// this是可以被推导出来 info对象(TypeScript推导出来)\nconst info = {\n  name: "why",\n  eating() {\n    console.log(this.name + " eating")\n  }\n}\n\ninfo.eating()\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# this的不明确类型\n\n这段代码运行会报错的:\n\n * 这里我们再次强调一下，TS进行类型检测的目的是让我们的代码更加的安全;\n * 所以这里对于 eating 的调用来说，我们虽然将其放到了info中，通过info去调用，this依然是指向info对象的;\n * 但是对于TS编译器来说，这个代码是非常不安全的，因为我们也有可能直接调用函数，或者通过别的对象来调用函数;\n\ntype ThisType = { name: string };\n\nfunction eating(this: ThisType, message: string) {\n  console.log(this.name + " eating", message);\n}\n\nconst info = {\n  name: "why",\n  eating: eating,\n};\n\n// 隐式绑定\ninfo.eating("哈哈哈");\n\n// 显示绑定\neating.call({name: "kobe"}, "呵呵呵")\neating.apply({name: "james"}, ["嘿嘿嘿"])\n\nexport {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 函数的重载\n\n\n# 函数的重载—联合类型 🔥\n\n在TypeScript中，如果我们编写了一个add函数，希望可以对字符串和数字类型进行相加，应该如何编写呢\n\n在TypeScript中，我们可以去编写不同的重载签名(overload signatures)来表示函数可以以不同的方式进行调用；一般是编写两个或者以上的重载签名，再去编写一个通用的函数以及实现\n\n/**\n * 通过联合类型有两个缺点:\n *  1.进行很多的逻辑判断(类型缩小)\n *  2.返回值的类型依然是不能确定\n */\nfunction add(a1: number | string, a2: number | string) {\n  if (typeof a1 === "number" && typeof a2 === "number") {\n    return a1 + a2\n  } else if (typeof a1 === "string" && typeof a2 === "string") {\n    return a1 + a2\n  }\n\n  // return a1 + a2;\n}\n\nadd(10, 20)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 函数的重载—函数重载 🔥\n\n// 函数的重载: 函数的名称相同, 但是参数不同的几个函数, 就是函数的重载\nfunction add(num1: number, num2: number): number; // 没函数体\nfunction add(num1: string, num2: string): string;\n\nfunction add(num1: any, num2: any): any {\n  if (typeof num1 === \'string\' && typeof num2 === \'string\') {\n    return num1.length + num2.length\n  }\n  return num1 + num2\n}\n\nconst result = add(20, 30)\nconst result2 = add("abc", "cba")\nconsole.log(result)\nconsole.log(result2)\n\n// 在函数的重载中, 实现函数是不能直接被调用的\n// add({name: "why"}, {age: 18})\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 函数的重载练习\n\n一般使用联合类型实现，除非比较复杂，如返回值类型也不同！\n\n// 实现方式一: 联合类型\nfunction getLength(args: string | any[]) {\n  return args.length\n}\n\nconsole.log(getLength("abc"))\nconsole.log(getLength([123, 321, 123]))\n\n// 实现方式二: 函数的重载\n// function getLength(args: string): number;\n// function getLength(args: any[]): number;\n\n// function getLength(args: any): number {\n//   return args.length\n// }\n\n// console.log(getLength("abc"))\n// console.log(getLength([123, 321, 123]))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',normalizedContent:'# ts函数\n\n\n# 函数的类型\n\n在下面的语法中 (num1: number, num2: number) => void，代表的就是一个函数类型\n\n * 接收两个参数的函数:num1和num2，并且都是number类型;\n * 并且这个函数是没有返回值的，所以是void;\n\n在某些语言中，可能参数名称num1和num2是可以省略，但是typescript是不可以的:\n\n// 1.函数作为参数时, 在参数中如何编写类型\nfunction foo() {}\n\ntype foofntype = () => void\nfunction bar(fn: foofntype) {\n  fn()\n}\n\nbar(foo)\n\n// 2.定义常量时, 编写函数的类型\ntype addfntype = (num1: number, num2: number) => number\nconst add: addfntype = (a1: number, a2: number) => {\n  return a1 + a2\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 函数类型的案例\n\nfunction calc(n1: number, n2: number, fn: (num1: number, num2: number) => number) {\n  return fn(n1, n2)\n}\n\nconst result1 = calc(20, 30, function(a1, a2) {\n  return a1 + a2\n})\nconsole.log(result1)\n\nconst result2 = calc(20, 30, function(a1, a2) {\n  return a1 * a2\n})\nconsole.log(result2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 参数的可选类型\n\n// 可选类型是必须写在必选类型的后面的\n// y -> undefined | number\nfunction foo(x: number, y?: number) {\n\n}\n\nfoo(20, 30)\nfoo(20)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n这个时候这个参数x依然是有类型的，它是什么类型呢? number | undefined\n\n\n# 参数的默认值\n\n// 必传参数 - 有默认值的参数 - 可选参数\nfunction foo(y: number, x: number = 20) {\n  console.log(x, y)\n}\n\nfoo(30)\n\n\n1\n2\n3\n4\n5\n6\n\n\n这个时候y的类型其实是 undefined 和 number 类型的联合\n\n\n# 函数的剩余参数\n\n// function sum(num1: number, num2: number) {\n//   return num1 + num2\n// }\n\nfunction sum(initalnum: number, ...nums: number[]) {\n  let total = initalnum\n  for (const num of nums) {\n    total += num\n  }\n  return total\n}\n\nconsole.log(sum(20, 30))\nconsole.log(sum(20, 30, 40))\nconsole.log(sum(20, 30, 40, 50))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# ts中this\n\n\n# this的默认推导\n\ntypescript认为函数 eating 有一个对应的this的外部对象 info，所以在使用时，就会把this当做该对象\n\n// this是可以被推导出来 info对象(typescript推导出来)\nconst info = {\n  name: "why",\n  eating() {\n    console.log(this.name + " eating")\n  }\n}\n\ninfo.eating()\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# this的不明确类型\n\n这段代码运行会报错的:\n\n * 这里我们再次强调一下，ts进行类型检测的目的是让我们的代码更加的安全;\n * 所以这里对于 eating 的调用来说，我们虽然将其放到了info中，通过info去调用，this依然是指向info对象的;\n * 但是对于ts编译器来说，这个代码是非常不安全的，因为我们也有可能直接调用函数，或者通过别的对象来调用函数;\n\ntype thistype = { name: string };\n\nfunction eating(this: thistype, message: string) {\n  console.log(this.name + " eating", message);\n}\n\nconst info = {\n  name: "why",\n  eating: eating,\n};\n\n// 隐式绑定\ninfo.eating("哈哈哈");\n\n// 显示绑定\neating.call({name: "kobe"}, "呵呵呵")\neating.apply({name: "james"}, ["嘿嘿嘿"])\n\nexport {};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 函数的重载\n\n\n# 函数的重载—联合类型 🔥\n\n在typescript中，如果我们编写了一个add函数，希望可以对字符串和数字类型进行相加，应该如何编写呢\n\n在typescript中，我们可以去编写不同的重载签名(overload signatures)来表示函数可以以不同的方式进行调用；一般是编写两个或者以上的重载签名，再去编写一个通用的函数以及实现\n\n/**\n * 通过联合类型有两个缺点:\n *  1.进行很多的逻辑判断(类型缩小)\n *  2.返回值的类型依然是不能确定\n */\nfunction add(a1: number | string, a2: number | string) {\n  if (typeof a1 === "number" && typeof a2 === "number") {\n    return a1 + a2\n  } else if (typeof a1 === "string" && typeof a2 === "string") {\n    return a1 + a2\n  }\n\n  // return a1 + a2;\n}\n\nadd(10, 20)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 函数的重载—函数重载 🔥\n\n// 函数的重载: 函数的名称相同, 但是参数不同的几个函数, 就是函数的重载\nfunction add(num1: number, num2: number): number; // 没函数体\nfunction add(num1: string, num2: string): string;\n\nfunction add(num1: any, num2: any): any {\n  if (typeof num1 === \'string\' && typeof num2 === \'string\') {\n    return num1.length + num2.length\n  }\n  return num1 + num2\n}\n\nconst result = add(20, 30)\nconst result2 = add("abc", "cba")\nconsole.log(result)\nconsole.log(result2)\n\n// 在函数的重载中, 实现函数是不能直接被调用的\n// add({name: "why"}, {age: 18})\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 函数的重载练习\n\n一般使用联合类型实现，除非比较复杂，如返回值类型也不同！\n\n// 实现方式一: 联合类型\nfunction getlength(args: string | any[]) {\n  return args.length\n}\n\nconsole.log(getlength("abc"))\nconsole.log(getlength([123, 321, 123]))\n\n// 实现方式二: 函数的重载\n// function getlength(args: string): number;\n// function getlength(args: any[]): number;\n\n// function getlength(args: any): number {\n//   return args.length\n// }\n\n// console.log(getlength("abc"))\n// console.log(getlength([123, 321, 123]))\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n',charsets:{cjk:!0},lastUpdated:"2022/03/29, 17:35:37",lastUpdatedTimestamp:1648575337e3},{title:"TS类",frontmatter:{title:"TS类",date:"2022-03-29T23:36:34.000Z",permalink:"/pages/d281f9/",categories:["TS"],tags:[null]},regularPath:"/1210.TS/105.TS%E7%B1%BB.html",relativePath:"1210.TS/105.TS类.md",key:"v-51db4340",path:"/pages/d281f9/",headers:[{level:2,title:"类的定义",slug:"类的定义",normalizedTitle:"类的定义",charIndex:10},{level:2,title:"类的继承",slug:"类的继承",normalizedTitle:"类的继承",charIndex:359},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:368},{level:3,title:"super、override",slug:"super、override",normalizedTitle:"super、override",charIndex:883},{level:2,title:"类的多态",slug:"类的多态",normalizedTitle:"类的多态",charIndex:1622},{level:2,title:"成员的修饰符",slug:"成员的修饰符",normalizedTitle:"成员的修饰符",charIndex:2178},{level:3,title:"public",slug:"public",normalizedTitle:"public",charIndex:2215},{level:3,title:"private",slug:"private",normalizedTitle:"private",charIndex:2222},{level:3,title:"protected",slug:"protected",normalizedTitle:"protected",charIndex:2230},{level:2,title:"属性的只读-readonly",slug:"属性的只读-readonly",normalizedTitle:"属性的只读-readonly",charIndex:2951},{level:2,title:"getters-setter",slug:"getters-setter",normalizedTitle:"getters-setter",charIndex:3492},{level:2,title:"类的静态成员",slug:"类的静态成员",normalizedTitle:"类的静态成员",charIndex:3871},{level:2,title:"抽象类abstract",slug:"抽象类abstract",normalizedTitle:"抽象类abstract",charIndex:4198},{level:2,title:"类的类型",slug:"类的类型",normalizedTitle:"类的类型",charIndex:5084}],headersStr:"类的定义 类的继承 介绍 super、override 类的多态 成员的修饰符 public private protected 属性的只读-readonly getters-setter 类的静态成员 抽象类abstract 类的类型",content:'# TS类\n\n\n# 类的定义\n\nclass Person {\n  name: string\n  age: number\n\n  constructor(name: string, age: number) {\n    this.name = name\n    this.age = age\n  }\n\n  eating() {\n    console.log(this.name + \' eating\')\n  }\n}\n\nconst p = new Person(\'why\', 18)\nconsole.log(p.name)\nconsole.log(p.age)\np.eating()\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 类的继承\n\n\n# 介绍\n\nclass Person {\n  name: string = ""\n  age: number = 0\n\n  eating() {\n    console.log("eating")\n  }\n}\n\nclass Student extends Person {\n  sno: number = 0\n\n  studying() {\n    console.log("studying")\n  }\n}\n\nclass Teacher extends Person {\n  title: string = ""\n\n  teaching() {\n    console.log("teaching")\n  }\n}\n\nconst stu = new Student()\nstu.name = "coderwhy"\nstu.age = 10\nconsole.log(stu.name)\nconsole.log(stu.age)\nstu.eating()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# super、override\n\nclass Person {\n  name: string\n  age: number\n\n  constructor(name: string, age: number) {\n    this.name = name\n    this.age = age\n  }\n\n  eating() {\n    console.log("eating 100行")\n  }\n}\n\nclass Student extends Person {\n  sno: number\n\n  constructor(name: string, age: number, sno: number) {\n    // super调用父类的构造器\n    super(name, age)\n    this.sno = sno\n  }\n\n  eating() {\n    console.log("student eating")\n    super.eating()\n  }\n\n  studying() {\n    console.log("studying")\n  }\n}\n\nconst stu = new Student("why", 18, 111)\nconsole.log(stu.name)\nconsole.log(stu.age)\nconsole.log(stu.sno)\n\nstu.eating()\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 类的多态\n\nclass Animal {\n  action() {\n    console.log("animal action")\n  }\n}\n\nclass Dog extends Animal {\n  action() {\n    console.log("dog running!!!")\n  }\n}\n\nclass Fish extends Animal {\n  action() {\n    console.log("fish swimming")\n  }\n}\n\nclass Person extends Animal {\n\n}\n\n// animal: dog/fish\n// 多态的目的是为了写出更加具备通用性的代码\nfunction makeActions(animals: Animal[]) {\n  animals.forEach(animal => {\n    animal.action()\n  })\n}\n\nmakeActions([new Dog(), new Fish(), new Person()])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 成员的修饰符\n\n在TypeScript中，类的属性和方法支持三种修饰符: public、private、protected\n\n * public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是public的;\n * private 修饰的是仅在同一类中可见、私有的属性或方法;\n * protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法;\n\n\n# public\n\n\n# private\n\nclass Person {\n  private name: string = ""\n\n  // 封装了两个方法, 通过方法来访问name\n  getName() {\n    return this.name\n  }\n\n  setName(newName) {\n    this.name = newName\n  }\n}\n\nconst p = new Person()\nconsole.log(p.getName())\np.setName("why")\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# protected\n\n// protected: 在类内部和子类中可以访问\n\nclass Person {\n  protected name: string = "123"\n}\n\nclass Student extends Person {\n  getName() {\n    return this.name\n  }\n}\n\nconst stu = new Student()\nconsole.log(stu.getName())\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 属性的只读-readonly\n\nclass Person {\n  // 1.只读属性是可以在构造器中赋值, 赋值之后就不可以修改\n  // 2.属性本身不能进行修改, 但是如果它是对象类型, 对象中的属性是可以修改\n  readonly name: string\n  age?: number\n  readonly friend?: Person\n  constructor(name: string, friend?: Person) {\n    this.name = name\n    this.friend = friend\n  }\n}\n\nconst p = new Person("why", new Person("kobe"))\nconsole.log(p.name)\nconsole.log(p.friend)\n\n// 不可以直接修改friend\n// p.friend = new Person("james")\nif (p.friend) {\n  p.friend.age = 30\n} \n\n// p.name = "123"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# getters-setter\n\nclass Person {\n  private _name: string\n  constructor(name: string) {\n    this._name = name\n  }\n\n  // 访问器setter/getter\n  // setter\n  set name(newName) {\n    this._name = newName\n  }\n  // getter\n  get name() {\n    return this._name\n  }\n}\n\nconst p = new Person("why")\np.name = "coderwhy"\nconsole.log(p.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 类的静态成员\n\n// class Person {\n//   name: string = ""\n//   age: number = 12\n// }\n\n// const p = new Person()\n// p.name = "123"\n\nclass Student {\n  static time: string = "20:00"\n\n  static attendClass() {\n    console.log("去学习~")\n  }\n}\n\nconsole.log(Student.time)\nStudent.attendClass()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 抽象类abstract\n\n\nfunction makeArea(shape: Shape) {\n  return shape.getArea()\n}\n\n\nabstract class Shape {\n  abstract getArea(): number\n}\n\n\nclass Rectangle extends Shape {\n  private width: number\n  private height: number\n\n  constructor(width: number, height: number) {\n    super()\n    this.width = width\n    this.height = height\n  }\n\n  getArea() {\n    return this.width * this.height\n  }\n}\n\nclass Circle extends Shape {\n  private r: number\n\n  constructor(r: number) {\n    super()\n    this.r = r\n  }\n\n  getArea() {\n    return this.r * this.r * 3.14\n  }\n}\n\nconst rectangle = new Rectangle(20, 30)\nconst circle = new Circle(10)\n\nconsole.log(makeArea(rectangle))\nconsole.log(makeArea(circle))\n// makeArea(new Shape())\n\n// makeArea(123)\n// makeArea("123")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 类的类型\n\nclass Person {\n  name: string = "123"\n  eating() {\n\n  }\n}\n\nconst p = new Person()\n\nconst p1: Person = {\n  name: "why",\n  eating() {\n\n  }\n}\n\nfunction printPerson(p: Person) {\n  console.log(p.name)\n}\n\nprintPerson(new Person())\nprintPerson({name: "kobe", eating: function() {}})\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',normalizedContent:'# ts类\n\n\n# 类的定义\n\nclass person {\n  name: string\n  age: number\n\n  constructor(name: string, age: number) {\n    this.name = name\n    this.age = age\n  }\n\n  eating() {\n    console.log(this.name + \' eating\')\n  }\n}\n\nconst p = new person(\'why\', 18)\nconsole.log(p.name)\nconsole.log(p.age)\np.eating()\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 类的继承\n\n\n# 介绍\n\nclass person {\n  name: string = ""\n  age: number = 0\n\n  eating() {\n    console.log("eating")\n  }\n}\n\nclass student extends person {\n  sno: number = 0\n\n  studying() {\n    console.log("studying")\n  }\n}\n\nclass teacher extends person {\n  title: string = ""\n\n  teaching() {\n    console.log("teaching")\n  }\n}\n\nconst stu = new student()\nstu.name = "coderwhy"\nstu.age = 10\nconsole.log(stu.name)\nconsole.log(stu.age)\nstu.eating()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# super、override\n\nclass person {\n  name: string\n  age: number\n\n  constructor(name: string, age: number) {\n    this.name = name\n    this.age = age\n  }\n\n  eating() {\n    console.log("eating 100行")\n  }\n}\n\nclass student extends person {\n  sno: number\n\n  constructor(name: string, age: number, sno: number) {\n    // super调用父类的构造器\n    super(name, age)\n    this.sno = sno\n  }\n\n  eating() {\n    console.log("student eating")\n    super.eating()\n  }\n\n  studying() {\n    console.log("studying")\n  }\n}\n\nconst stu = new student("why", 18, 111)\nconsole.log(stu.name)\nconsole.log(stu.age)\nconsole.log(stu.sno)\n\nstu.eating()\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 类的多态\n\nclass animal {\n  action() {\n    console.log("animal action")\n  }\n}\n\nclass dog extends animal {\n  action() {\n    console.log("dog running!!!")\n  }\n}\n\nclass fish extends animal {\n  action() {\n    console.log("fish swimming")\n  }\n}\n\nclass person extends animal {\n\n}\n\n// animal: dog/fish\n// 多态的目的是为了写出更加具备通用性的代码\nfunction makeactions(animals: animal[]) {\n  animals.foreach(animal => {\n    animal.action()\n  })\n}\n\nmakeactions([new dog(), new fish(), new person()])\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 成员的修饰符\n\n在typescript中，类的属性和方法支持三种修饰符: public、private、protected\n\n * public 修饰的是在任何地方可见、公有的属性或方法，默认编写的属性就是public的;\n * private 修饰的是仅在同一类中可见、私有的属性或方法;\n * protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法;\n\n\n# public\n\n\n# private\n\nclass person {\n  private name: string = ""\n\n  // 封装了两个方法, 通过方法来访问name\n  getname() {\n    return this.name\n  }\n\n  setname(newname) {\n    this.name = newname\n  }\n}\n\nconst p = new person()\nconsole.log(p.getname())\np.setname("why")\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# protected\n\n// protected: 在类内部和子类中可以访问\n\nclass person {\n  protected name: string = "123"\n}\n\nclass student extends person {\n  getname() {\n    return this.name\n  }\n}\n\nconst stu = new student()\nconsole.log(stu.getname())\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 属性的只读-readonly\n\nclass person {\n  // 1.只读属性是可以在构造器中赋值, 赋值之后就不可以修改\n  // 2.属性本身不能进行修改, 但是如果它是对象类型, 对象中的属性是可以修改\n  readonly name: string\n  age?: number\n  readonly friend?: person\n  constructor(name: string, friend?: person) {\n    this.name = name\n    this.friend = friend\n  }\n}\n\nconst p = new person("why", new person("kobe"))\nconsole.log(p.name)\nconsole.log(p.friend)\n\n// 不可以直接修改friend\n// p.friend = new person("james")\nif (p.friend) {\n  p.friend.age = 30\n} \n\n// p.name = "123"\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# getters-setter\n\nclass person {\n  private _name: string\n  constructor(name: string) {\n    this._name = name\n  }\n\n  // 访问器setter/getter\n  // setter\n  set name(newname) {\n    this._name = newname\n  }\n  // getter\n  get name() {\n    return this._name\n  }\n}\n\nconst p = new person("why")\np.name = "coderwhy"\nconsole.log(p.name)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 类的静态成员\n\n// class person {\n//   name: string = ""\n//   age: number = 12\n// }\n\n// const p = new person()\n// p.name = "123"\n\nclass student {\n  static time: string = "20:00"\n\n  static attendclass() {\n    console.log("去学习~")\n  }\n}\n\nconsole.log(student.time)\nstudent.attendclass()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 抽象类abstract\n\n\nfunction makearea(shape: shape) {\n  return shape.getarea()\n}\n\n\nabstract class shape {\n  abstract getarea(): number\n}\n\n\nclass rectangle extends shape {\n  private width: number\n  private height: number\n\n  constructor(width: number, height: number) {\n    super()\n    this.width = width\n    this.height = height\n  }\n\n  getarea() {\n    return this.width * this.height\n  }\n}\n\nclass circle extends shape {\n  private r: number\n\n  constructor(r: number) {\n    super()\n    this.r = r\n  }\n\n  getarea() {\n    return this.r * this.r * 3.14\n  }\n}\n\nconst rectangle = new rectangle(20, 30)\nconst circle = new circle(10)\n\nconsole.log(makearea(rectangle))\nconsole.log(makearea(circle))\n// makearea(new shape())\n\n// makearea(123)\n// makearea("123")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 类的类型\n\nclass person {\n  name: string = "123"\n  eating() {\n\n  }\n}\n\nconst p = new person()\n\nconst p1: person = {\n  name: "why",\n  eating() {\n\n  }\n}\n\nfunction printperson(p: person) {\n  console.log(p.name)\n}\n\nprintperson(new person())\nprintperson({name: "kobe", eating: function() {}})\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',charsets:{cjk:!0},lastUpdated:"2022/03/29, 17:35:37",lastUpdatedTimestamp:1648575337e3},{title:"TS接口 🔥",frontmatter:{title:"TS接口 🔥",date:"2022-03-30T00:30:04.000Z",permalink:"/pages/e73701/",categories:["TS"],tags:[null]},regularPath:"/1210.TS/106.TS%E6%8E%A5%E5%8F%A3.html",relativePath:"1210.TS/106.TS接口.md",key:"v-f29668a2",path:"/pages/e73701/",headers:[{level:2,title:"声明对象类型",slug:"声明对象类型",normalizedTitle:"声明对象类型",charIndex:30},{level:2,title:"索引类型",slug:"索引类型",normalizedTitle:"索引类型",charIndex:516},{level:2,title:"函数类型—不清晰推荐使用type",slug:"函数类型-不清晰推荐使用type",normalizedTitle:"函数类型—不清晰推荐使用type",charIndex:930},{level:2,title:"接口的继承",slug:"接口的继承",normalizedTitle:"接口的继承",charIndex:1281},{level:2,title:"交叉类型—接口组合",slug:"交叉类型-接口组合",normalizedTitle:"交叉类型—接口组合",charIndex:1550},{level:2,title:"接口的实现",slug:"接口的实现",normalizedTitle:"接口的实现",charIndex:2078},{level:2,title:"interface和type的区别 🔥",slug:"interface和type的区别-🔥",normalizedTitle:"interface和type的区别 🔥",charIndex:2815},{level:2,title:"字面量赋值",slug:"字面量赋值",normalizedTitle:"字面量赋值",charIndex:3579},{level:2,title:"枚举类型",slug:"枚举类型",normalizedTitle:"枚举类型",charIndex:4306},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:940},{level:3,title:"枚举类型的值",slug:"枚举类型的值",normalizedTitle:"枚举类型的值",charIndex:5069}],headersStr:"声明对象类型 索引类型 函数类型—不清晰推荐使用type 接口的继承 交叉类型—接口组合 接口的实现 interface和type的区别 🔥 字面量赋值 枚举类型 使用 枚举类型的值",content:'# TS接口 🔥\n\n相比类，接口用的地方非常多！\n\n\n# 声明对象类型\n\n// 通过类型(type)别名来声明对象类型\n// type InfoType = {name: string, age: number}\n\n// 另外一种方式声明对象类型: 接口interface\n// 在其中可以定义可选类型\n// 也可以定义只读属性\ninterface IInfoType {\n  readonly name: string\n  age: number\n  friend?: {\n    name: string\n  }\n}\n\nconst info: IInfoType = {\n  name: "why",\n  age: 18,\n  friend: {\n    name: "kobe"\n  }\n}\n\nconsole.log(info.friend?.name)\nconsole.log(info.name)\n// info.name = "123"\ninfo.age = 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 索引类型\n\n// 通过interface来定义索引类型\ninterface IndexLanguage {\n  [index: number]: string\n}\n\nconst frontLanguage: IndexLanguage = {\n  0: "HTML",\n  1: "CSS",\n  2: "JavaScript",\n  3: "Vue"\n}\n\n\ninterface ILanguageYear {\n  [name: string]: number\n}\n\nconst languageYear: ILanguageYear = {\n  "C": 1972,\n  "Java": 1995,\n  "JavaScript": 1996,\n  "TypeScript": 2014\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 函数类型—不清晰推荐使用type\n\n// type CalcFn = (n1: number, n2: number) => number\n// 可调用的接口\ninterface CalcFn {\n  (n1: number, n2: number): number\n}\n\nfunction calc(num1: number, num2: number, calcFn: CalcFn) {\n  return calcFn(num1, num2)\n}\n\nconst add: CalcFn = (num1, num2) => {\n  return num1 + num2\n}\n\ncalc(20, 30, add)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 接口的继承\n\ninterface ISwim {\n  swimming: () => void\n}\n\ninterface IFly {\n  flying: () => void\n}\n\n\ninterface IAction extends ISwim, IFly {\n\n}\n\nconst action: IAction = {\n  swimming() {\n\n  },\n  flying() {\n    \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 交叉类型—接口组合\n\n// 一种组合类型的方式: 联合类型\ntype WhyType = number | string\ntype Direction = "left" | "right" | "center"\n\n\n// 另一种组件类型的方式: 交叉类型\ntype WType = number & string\n\ninterface ISwim {\n  swimming: () => void\n}\n\ninterface IFly {\n  flying: () => void\n}\n\ntype MyType1 = ISwim | IFly\ntype MyType2 = ISwim & IFly\n\nconst obj1: MyType1 = {\n  flying() {\n\n  }\n}\n\nconst obj2: MyType2 = {\n  swimming() {\n\n  },\n  flying() {\n    \n  }\n}\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 接口的实现\n\ninterface ISwim {\n  swimming: () => void\n}\n\ninterface IEat {\n  eating: () => void\n}\n\n// 类实现接口\nclass Animal {\n  \n}\n\n// 继承: 只能实现单继承\n// 实现: 实现接口, 类可以实现多个接口\nclass Fish extends Animal implements ISwim, IEat {\n  swimming() {\n    console.log("Fish Swmming")\n  }\n\n  eating() {\n    console.log("Fish Eating")\n  }\n}\n\n\nclass Person implements ISwim {\n  swimming() {\n    console.log("Person Swimming")\n  }\n}\n\n\n// 编写一些公共的API: 面向接口编程\nfunction swimAction(swimable: ISwim) {\n  swimable.swimming()\n}\n\n// 1.所有实现了接口的类对应的对象, 都是可以传入\nswimAction(new Fish())\nswimAction(new Person())\n\n\nswimAction({swimming: function() {}})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# interface和type的区别 🔥\n\n我们会发现interface和type都可以用来定义对象类型，那么在开发中定义对象类型时，到底选择哪一个呢?\n\n * 如果是定义非对象类型，通常推荐使用type，比如Direction、Alignment、一些Function;\n\n * 如果是定义对象类型，那么他们是有区别的:\n   \n   * interface 可以重复的对某个接口来定义属性和方法（多个同名接口合并）;\n   * 而type定义的是别名，别名是不能重复的;\n\n// interface IFoo {\n//   name: string\n// }\n\n// interface IFoo {\n//   age: number\n// }\n\n// const foo: IFoo = {\n//   name: "why",\n//   age: 18\n// }\n\n// document.getElementById("app") as HTMLDivElement\n// window.addEventListener\n\n// interface Window {\n//   age: number\n// }\n// window.age = 19\n// console.log(window.age)\n\n\n// type IBar = {\n//   name: string\n//   age: number\n// }\n\n// type IBar = {\n// }\n\ninterface IPerson {\n  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 字面量赋值\n\n这是因为TypeScript在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。\n\n但是之后如果我们是将一个变量标识符赋值给其他的变量时，会进行freshness擦除操作\n\ninterface IPerson {\n  name: string\n  age: number\n  height: number\n}\n\n// const info = {\n//   name: "why",\n//   age: 18,\n//   height: 1.88,\n//   address: "广州市"\n// }\n\n// // freshness擦除\n// const p: IPerson = info\n\n// console.log(info)\n// console.log(p)\n\n\nfunction printInfo(person: IPerson) {\n  console.log(person)\n}\n\n// 代码会报错\n// printInfo({\n//   name: "why",\n//   age: 18,\n//   height: 1.88,\n//   address: "广州市"\n// })\n\nconst info = {\n  name: "why",\n  age: 18,\n  height: 1.88,\n  address: "广州市"\n}\n\nprintInfo(info)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 枚举类型\n\n\n# 使用\n\n// type Direction = "left" | "Right" | "Top" | "Bottom"\n\nenum Direction {\n  LEFT,\n  RIGHT,\n  TOP,\n  BOTTOM\n}\n\n\nfunction turnDirection(direction: Direction) {\n  switch (direction) {\n    case Direction.LEFT:\n      console.log("改变角色的方向向左")\n      break;\n    case Direction.RIGHT:\n      console.log("改变角色的方向向右")\n      break;\n    case Direction.TOP:\n      console.log("改变角色的方向向上")\n      break;\n    case Direction.BOTTOM:\n      console.log("改变角色的方向向下")\n      break;\n    default:\n      const foo: never = direction;\n      break;\n  }\n}\n\nturnDirection(Direction.LEFT)\nturnDirection(Direction.RIGHT)\nturnDirection(Direction.TOP)\nturnDirection(Direction.BOTTOM)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 枚举类型的值\n\n// type Direction = "left" | "Right" | "Top" | "Bottom"\n\nenum Direction {\n  LEFT = "LEFT",\n  RIGHT = "RIGHT",\n  TOP = "TOP",\n  BOTTOM = "BOTTOM"\n}\n\nlet name: string = "abc"\nlet d: Direction = Direction.BOTTOM\n\nfunction turnDirection(direction: Direction) {\n  console.log(direction)\n  switch (direction) {\n    case Direction.LEFT:\n      console.log("改变角色的方向向左")\n      break;\n    case Direction.RIGHT:\n      console.log("改变角色的方向向右")\n      break;\n    case Direction.TOP:\n      console.log("改变角色的方向向上")\n      break;\n    case Direction.BOTTOM:\n      console.log("改变角色的方向向下")\n      break;\n    default:\n      const foo: never = direction;\n      break;\n  }\n}\n\nturnDirection(Direction.LEFT)\nturnDirection(Direction.RIGHT)\nturnDirection(Direction.TOP)\nturnDirection(Direction.BOTTOM)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n',normalizedContent:'# ts接口 🔥\n\n相比类，接口用的地方非常多！\n\n\n# 声明对象类型\n\n// 通过类型(type)别名来声明对象类型\n// type infotype = {name: string, age: number}\n\n// 另外一种方式声明对象类型: 接口interface\n// 在其中可以定义可选类型\n// 也可以定义只读属性\ninterface iinfotype {\n  readonly name: string\n  age: number\n  friend?: {\n    name: string\n  }\n}\n\nconst info: iinfotype = {\n  name: "why",\n  age: 18,\n  friend: {\n    name: "kobe"\n  }\n}\n\nconsole.log(info.friend?.name)\nconsole.log(info.name)\n// info.name = "123"\ninfo.age = 20\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# 索引类型\n\n// 通过interface来定义索引类型\ninterface indexlanguage {\n  [index: number]: string\n}\n\nconst frontlanguage: indexlanguage = {\n  0: "html",\n  1: "css",\n  2: "javascript",\n  3: "vue"\n}\n\n\ninterface ilanguageyear {\n  [name: string]: number\n}\n\nconst languageyear: ilanguageyear = {\n  "c": 1972,\n  "java": 1995,\n  "javascript": 1996,\n  "typescript": 2014\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 函数类型—不清晰推荐使用type\n\n// type calcfn = (n1: number, n2: number) => number\n// 可调用的接口\ninterface calcfn {\n  (n1: number, n2: number): number\n}\n\nfunction calc(num1: number, num2: number, calcfn: calcfn) {\n  return calcfn(num1, num2)\n}\n\nconst add: calcfn = (num1, num2) => {\n  return num1 + num2\n}\n\ncalc(20, 30, add)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# 接口的继承\n\ninterface iswim {\n  swimming: () => void\n}\n\ninterface ifly {\n  flying: () => void\n}\n\n\ninterface iaction extends iswim, ifly {\n\n}\n\nconst action: iaction = {\n  swimming() {\n\n  },\n  flying() {\n    \n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 交叉类型—接口组合\n\n// 一种组合类型的方式: 联合类型\ntype whytype = number | string\ntype direction = "left" | "right" | "center"\n\n\n// 另一种组件类型的方式: 交叉类型\ntype wtype = number & string\n\ninterface iswim {\n  swimming: () => void\n}\n\ninterface ifly {\n  flying: () => void\n}\n\ntype mytype1 = iswim | ifly\ntype mytype2 = iswim & ifly\n\nconst obj1: mytype1 = {\n  flying() {\n\n  }\n}\n\nconst obj2: mytype2 = {\n  swimming() {\n\n  },\n  flying() {\n    \n  }\n}\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 接口的实现\n\ninterface iswim {\n  swimming: () => void\n}\n\ninterface ieat {\n  eating: () => void\n}\n\n// 类实现接口\nclass animal {\n  \n}\n\n// 继承: 只能实现单继承\n// 实现: 实现接口, 类可以实现多个接口\nclass fish extends animal implements iswim, ieat {\n  swimming() {\n    console.log("fish swmming")\n  }\n\n  eating() {\n    console.log("fish eating")\n  }\n}\n\n\nclass person implements iswim {\n  swimming() {\n    console.log("person swimming")\n  }\n}\n\n\n// 编写一些公共的api: 面向接口编程\nfunction swimaction(swimable: iswim) {\n  swimable.swimming()\n}\n\n// 1.所有实现了接口的类对应的对象, 都是可以传入\nswimaction(new fish())\nswimaction(new person())\n\n\nswimaction({swimming: function() {}})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# interface和type的区别 🔥\n\n我们会发现interface和type都可以用来定义对象类型，那么在开发中定义对象类型时，到底选择哪一个呢?\n\n * 如果是定义非对象类型，通常推荐使用type，比如direction、alignment、一些function;\n\n * 如果是定义对象类型，那么他们是有区别的:\n   \n   * interface 可以重复的对某个接口来定义属性和方法（多个同名接口合并）;\n   * 而type定义的是别名，别名是不能重复的;\n\n// interface ifoo {\n//   name: string\n// }\n\n// interface ifoo {\n//   age: number\n// }\n\n// const foo: ifoo = {\n//   name: "why",\n//   age: 18\n// }\n\n// document.getelementbyid("app") as htmldivelement\n// window.addeventlistener\n\n// interface window {\n//   age: number\n// }\n// window.age = 19\n// console.log(window.age)\n\n\n// type ibar = {\n//   name: string\n//   age: number\n// }\n\n// type ibar = {\n// }\n\ninterface iperson {\n  \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 字面量赋值\n\n这是因为typescript在字面量直接赋值的过程中，为了进行类型推导会进行严格的类型限制。\n\n但是之后如果我们是将一个变量标识符赋值给其他的变量时，会进行freshness擦除操作\n\ninterface iperson {\n  name: string\n  age: number\n  height: number\n}\n\n// const info = {\n//   name: "why",\n//   age: 18,\n//   height: 1.88,\n//   address: "广州市"\n// }\n\n// // freshness擦除\n// const p: iperson = info\n\n// console.log(info)\n// console.log(p)\n\n\nfunction printinfo(person: iperson) {\n  console.log(person)\n}\n\n// 代码会报错\n// printinfo({\n//   name: "why",\n//   age: 18,\n//   height: 1.88,\n//   address: "广州市"\n// })\n\nconst info = {\n  name: "why",\n  age: 18,\n  height: 1.88,\n  address: "广州市"\n}\n\nprintinfo(info)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 枚举类型\n\n\n# 使用\n\n// type direction = "left" | "right" | "top" | "bottom"\n\nenum direction {\n  left,\n  right,\n  top,\n  bottom\n}\n\n\nfunction turndirection(direction: direction) {\n  switch (direction) {\n    case direction.left:\n      console.log("改变角色的方向向左")\n      break;\n    case direction.right:\n      console.log("改变角色的方向向右")\n      break;\n    case direction.top:\n      console.log("改变角色的方向向上")\n      break;\n    case direction.bottom:\n      console.log("改变角色的方向向下")\n      break;\n    default:\n      const foo: never = direction;\n      break;\n  }\n}\n\nturndirection(direction.left)\nturndirection(direction.right)\nturndirection(direction.top)\nturndirection(direction.bottom)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 枚举类型的值\n\n// type direction = "left" | "right" | "top" | "bottom"\n\nenum direction {\n  left = "left",\n  right = "right",\n  top = "top",\n  bottom = "bottom"\n}\n\nlet name: string = "abc"\nlet d: direction = direction.bottom\n\nfunction turndirection(direction: direction) {\n  console.log(direction)\n  switch (direction) {\n    case direction.left:\n      console.log("改变角色的方向向左")\n      break;\n    case direction.right:\n      console.log("改变角色的方向向右")\n      break;\n    case direction.top:\n      console.log("改变角色的方向向上")\n      break;\n    case direction.bottom:\n      console.log("改变角色的方向向下")\n      break;\n    default:\n      const foo: never = direction;\n      break;\n  }\n}\n\nturndirection(direction.left)\nturndirection(direction.right)\nturndirection(direction.top)\nturndirection(direction.bottom)\n\nexport {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n',charsets:{cjk:!0},lastUpdated:"2022/03/29, 17:35:37",lastUpdatedTimestamp:1648575337e3},{title:"TS泛型 🔥",frontmatter:{title:"TS泛型 🔥",date:"2022-03-30T00:55:50.000Z",permalink:"/pages/e0eec1/",categories:["TS"],tags:[null]},regularPath:"/1210.TS/107.TS%E6%B3%9B%E5%9E%8B.html",relativePath:"1210.TS/107.TS泛型.md",key:"v-3fbd6196",path:"/pages/e0eec1/",headers:[{level:2,title:"认识泛型",slug:"认识泛型",normalizedTitle:"认识泛型",charIndex:14},{level:2,title:"泛型接受类型参数",slug:"泛型接受类型参数",normalizedTitle:"泛型接受类型参数",charIndex:326},{level:2,title:"泛型接口的使用",slug:"泛型接口的使用",normalizedTitle:"泛型接口的使用",charIndex:469},{level:2,title:"泛型类的使用",slug:"泛型类的使用",normalizedTitle:"泛型类的使用",charIndex:621},{level:2,title:"类型的类型约束",slug:"类型的类型约束",normalizedTitle:"类型的类型约束",charIndex:1103},{level:2,title:"非空判断运算符",slug:"非空判断运算符",normalizedTitle:"非空判断运算符",charIndex:1322}],headersStr:"认识泛型 泛型接受类型参数 泛型接口的使用 泛型类的使用 类型的类型约束 非空判断运算符",content:'# TS泛型 🔥\n\n\n# 认识泛型\n\n类型的参数化\n\n// 类型的参数化\n\n// 在定义这个函数时, 我不决定这些参数的类型\n// 而是让调用者以参数的形式告知,我这里的函数参数应该是什么类型\nfunction sum<Type>(num: Type): Type {\n  return num\n}\n\n// 1.调用方式一: 明确的传入类型\nsum<number>(20)\nsum<{name: string}>({name: "why"})\nsum<any[]>(["abc"])\n\n// 2.调用方式二: 类型推到\nsum(50)\nsum("abc")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 泛型接受类型参数\n\nfunction foo<T, E, O>(arg1: T, arg2: E, arg3?: O, ...args: T[]) {\n\n}\n\nfoo<number, string, boolean>(10, "abc", true)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 泛型接口的使用\n\ninterface IPerson<T1 = string, T2 = number> {\n  name: T1\n  age: T2\n}\n\nconst p: IPerson = {\n  name: "why",\n  age: 18\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 泛型类的使用\n\nclass Point<T> {\n  x: T\n  y: T\n  z: T\n\n  constructor(x: T, y: T, z: T) {\n    this.x = x\n    this.y = y\n    this.z = y\n  }\n}\n\nconst p1 = new Point("1.33.2", "2.22.3", "4.22.1")\nconst p2 = new Point<string>("1.33.2", "2.22.3", "4.22.1")\nconst p3: Point<string> = new Point("1.33.2", "2.22.3", "4.22.1")\n\nconst names1: string[] = ["abc", "cba", "nba"]\nconst names2: Array<string> = ["abc", "cba", "nba"] // 不推荐(react jsx <>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 类型的类型约束\n\ninterface ILength {\n  length: number\n}\n\nfunction getLength<T extends ILength>(arg: T) {\n  return arg.length\n}\n\ngetLength("abc")\ngetLength(["abc", "cba"])\ngetLength({length: 100})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 非空判断运算符\n\nconst flag = "" ?? true\nconsole.log(flag)\n\n\n1\n2\n',normalizedContent:'# ts泛型 🔥\n\n\n# 认识泛型\n\n类型的参数化\n\n// 类型的参数化\n\n// 在定义这个函数时, 我不决定这些参数的类型\n// 而是让调用者以参数的形式告知,我这里的函数参数应该是什么类型\nfunction sum<type>(num: type): type {\n  return num\n}\n\n// 1.调用方式一: 明确的传入类型\nsum<number>(20)\nsum<{name: string}>({name: "why"})\nsum<any[]>(["abc"])\n\n// 2.调用方式二: 类型推到\nsum(50)\nsum("abc")\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 泛型接受类型参数\n\nfunction foo<t, e, o>(arg1: t, arg2: e, arg3?: o, ...args: t[]) {\n\n}\n\nfoo<number, string, boolean>(10, "abc", true)\n\n\n1\n2\n3\n4\n5\n\n\n\n# 泛型接口的使用\n\ninterface iperson<t1 = string, t2 = number> {\n  name: t1\n  age: t2\n}\n\nconst p: iperson = {\n  name: "why",\n  age: 18\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 泛型类的使用\n\nclass point<t> {\n  x: t\n  y: t\n  z: t\n\n  constructor(x: t, y: t, z: t) {\n    this.x = x\n    this.y = y\n    this.z = y\n  }\n}\n\nconst p1 = new point("1.33.2", "2.22.3", "4.22.1")\nconst p2 = new point<string>("1.33.2", "2.22.3", "4.22.1")\nconst p3: point<string> = new point("1.33.2", "2.22.3", "4.22.1")\n\nconst names1: string[] = ["abc", "cba", "nba"]\nconst names2: array<string> = ["abc", "cba", "nba"] // 不推荐(react jsx <>)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 类型的类型约束\n\ninterface ilength {\n  length: number\n}\n\nfunction getlength<t extends ilength>(arg: t) {\n  return arg.length\n}\n\ngetlength("abc")\ngetlength(["abc", "cba"])\ngetlength({length: 100})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 非空判断运算符\n\nconst flag = "" ?? true\nconsole.log(flag)\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/03/29, 17:35:37",lastUpdatedTimestamp:1648575337e3},{title:"TS补充",frontmatter:{title:"TS补充",date:"2022-03-30T01:08:18.000Z",permalink:"/pages/306c32/",categories:["TS"],tags:[null]},regularPath:"/1210.TS/108.TS%E8%A1%A5%E5%85%85.html",relativePath:"1210.TS/108.TS补充.md",key:"v-14bf56d8",path:"/pages/306c32/",headers:[{level:2,title:"模块化&命名空间",slug:"模块化-命名空间",normalizedTitle:"模块化&amp;命名空间",charIndex:null},{level:3,title:"模块",slug:"模块",normalizedTitle:"模块",charIndex:11},{level:3,title:"命名空间namespace",slug:"命名空间namespace",normalizedTitle:"命名空间namespace",charIndex:136},{level:2,title:"类型的查找、声明 🔥",slug:"类型的查找、声明-🔥",normalizedTitle:"类型的查找、声明 🔥",charIndex:518},{level:3,title:"内置类型声明",slug:"内置类型声明",normalizedTitle:"内置类型声明",charIndex:976},{level:3,title:"外部定义类型声明和自定义声明",slug:"外部定义类型声明和自定义声明",normalizedTitle:"外部定义类型声明和自定义声明",charIndex:1220},{level:3,title:"声明模块、命名空间、变量、函数、类、文件",slug:"声明模块、命名空间、变量、函数、类、文件",normalizedTitle:"声明模块、命名空间、变量、函数、类、文件",charIndex:1657},{level:2,title:"tsconfig.json文件",slug:"tsconfig-json文件",normalizedTitle:"tsconfig.json文件",charIndex:2389}],headersStr:"模块化&命名空间 模块 命名空间namespace 类型的查找、声明 🔥 内置类型声明 外部定义类型声明和自定义声明 声明模块、命名空间、变量、函数、类、文件 tsconfig.json文件",content:"# TS补充\n\n\n# 模块化&命名空间\n\nTypeScript支持两种方式来控制我们的作用域:\n\n * 模块化:每个文件可以是一个独立的模块，支持ES Module，也支持CommonJS;\n * 命名空间:通过namespace来声明一个命名空间\n\n\n# 模块\n\n\n# 命名空间namespace\n\n命名空间在TypeScript早期时，称之为内部模块，主要目的是将一个模块内部再进行作用域的划分，防止一些命名冲突的问题。\n\nexport namespace time {\n  export function format(time: string) {\n    return \"2222-02-22\"\n  }\n\n  export function foo() {\n\n  }\n\n  export let name: string = \"abc\"\n}\n\nexport namespace price {\n  export function format(price: number) {\n    return \"99.99\"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 类型的查找、声明 🔥\n\n就是为了不报错！\n\n之前我们所有的typescript中的类型，几乎都是我们自己编写的，但是我们也有用到一些其他的类型\n\nconst imageEl = document.getElementById(\"image\") as HTMLImageElement;\n\n\n1\n\n\n大家是否会奇怪，我们的HTMLImageElement类型来自哪里呢?甚至是document为什么可以有getElementById的方法呢?其实这里就涉及到typescript对类型的管理和查找规则了\n\n先给大家介绍另外的一种typescript文件:.d.ts文件\n\n * 我们之前编写的typescript文件都是 .ts 文件，这些文件最终会输出 .js 文件，也是我们通常编写代码的地方;\n\n * 还有另外一种文件 .d.ts 文件，它是用来做类型的声明(declare)。 它仅仅用来做类型检测，告知typescript我们有哪些类型;\n\n那么typescript会在哪里查找我们的类型声明呢?\n\n * 内置类型声明;\n * 外部定义类型声明;\n * 自己定义类型声明;\n\n\n# 内置类型声明\n\n内置类型声明是typescript自带的、帮助我们内置了JavaScript运行时的一些标准化API的声明文件\n\n包括比如Math、Date等内置类型，也包括DOM API，比如Window、Document等;\n\n内置类型声明通常在我们安装typescript的环境中会带有的，https://github.com/microsoft/TypeScript/tree/main/lib\n\n\n# 外部定义类型声明和自定义声明\n\n外部类型声明通常是我们使用一些库(比如第三方库)时，需要的一些类型声明。这些库通常有两种类型声明方式;\n\n * 在自己库中进行类型声明(编写.d.ts文件)，比如axios\n * 通过社区的一个公有库DefinitelyTyped存放类型声明文件\n   * 该库的GitHub地址:https://github.com/DefinitelyTyped/DefinitelyTyped/\n   * 该库查找声明安装方式的地址:https://www.typescriptlang.org/dt/search?search=\n   * 比如我们安装react的类型声明: npm i @types/react --save-dev\n\n什么情况下需要自己来定义声明文件呢？\n\n * 我们使用的第三方库是一个纯的JavaScript库，没有对应的声明文件;比如lodash\n * 我们给自己的代码中声明一些类型，方便在其他地方直接进行使用;\n\n\n# 声明模块、命名空间、变量、函数、类、文件\n\ncoderwhy.d.ts\n\n// 声明模块\ndeclare module 'lodash' {\n  export function join(arr: any[]): void\n}\n\n// 声明变量/函数/类\ndeclare let whyName: string\ndeclare let whyAge: number\ndeclare let whyHeight: number\n\ndeclare function whyFoo(): void\n\ndeclare class Person {\n  name: string\n  age: number\n  constructor(name: string, age: number)\n}\n\n// 声明文件\ndeclare module '*.jpg'\ndeclare module '*.jpeg'\ndeclare module '*.png'\ndeclare module '*.svg'\ndeclare module '*.gif'\n\n// 声明命名空间\ndeclare namespace $ {\n  export function ajax(settings: any): any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 在开发vue的过程中，默认是不识别我们的.vue文件的，那么我们就需要对其进行文件的声明;\n * 在开发中我们使用了 jpg 这类图片文件，默认typescript也是不支持的，也需要对其进行声明\n\n\n# tsconfig.json文件\n\n用于配置TypeScript编译时的配置选项：https://www.typescriptlang.org/tsconfig",normalizedContent:"# ts补充\n\n\n# 模块化&命名空间\n\ntypescript支持两种方式来控制我们的作用域:\n\n * 模块化:每个文件可以是一个独立的模块，支持es module，也支持commonjs;\n * 命名空间:通过namespace来声明一个命名空间\n\n\n# 模块\n\n\n# 命名空间namespace\n\n命名空间在typescript早期时，称之为内部模块，主要目的是将一个模块内部再进行作用域的划分，防止一些命名冲突的问题。\n\nexport namespace time {\n  export function format(time: string) {\n    return \"2222-02-22\"\n  }\n\n  export function foo() {\n\n  }\n\n  export let name: string = \"abc\"\n}\n\nexport namespace price {\n  export function format(price: number) {\n    return \"99.99\"\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n\n# 类型的查找、声明 🔥\n\n就是为了不报错！\n\n之前我们所有的typescript中的类型，几乎都是我们自己编写的，但是我们也有用到一些其他的类型\n\nconst imageel = document.getelementbyid(\"image\") as htmlimageelement;\n\n\n1\n\n\n大家是否会奇怪，我们的htmlimageelement类型来自哪里呢?甚至是document为什么可以有getelementbyid的方法呢?其实这里就涉及到typescript对类型的管理和查找规则了\n\n先给大家介绍另外的一种typescript文件:.d.ts文件\n\n * 我们之前编写的typescript文件都是 .ts 文件，这些文件最终会输出 .js 文件，也是我们通常编写代码的地方;\n\n * 还有另外一种文件 .d.ts 文件，它是用来做类型的声明(declare)。 它仅仅用来做类型检测，告知typescript我们有哪些类型;\n\n那么typescript会在哪里查找我们的类型声明呢?\n\n * 内置类型声明;\n * 外部定义类型声明;\n * 自己定义类型声明;\n\n\n# 内置类型声明\n\n内置类型声明是typescript自带的、帮助我们内置了javascript运行时的一些标准化api的声明文件\n\n包括比如math、date等内置类型，也包括dom api，比如window、document等;\n\n内置类型声明通常在我们安装typescript的环境中会带有的，https://github.com/microsoft/typescript/tree/main/lib\n\n\n# 外部定义类型声明和自定义声明\n\n外部类型声明通常是我们使用一些库(比如第三方库)时，需要的一些类型声明。这些库通常有两种类型声明方式;\n\n * 在自己库中进行类型声明(编写.d.ts文件)，比如axios\n * 通过社区的一个公有库definitelytyped存放类型声明文件\n   * 该库的github地址:https://github.com/definitelytyped/definitelytyped/\n   * 该库查找声明安装方式的地址:https://www.typescriptlang.org/dt/search?search=\n   * 比如我们安装react的类型声明: npm i @types/react --save-dev\n\n什么情况下需要自己来定义声明文件呢？\n\n * 我们使用的第三方库是一个纯的javascript库，没有对应的声明文件;比如lodash\n * 我们给自己的代码中声明一些类型，方便在其他地方直接进行使用;\n\n\n# 声明模块、命名空间、变量、函数、类、文件\n\ncoderwhy.d.ts\n\n// 声明模块\ndeclare module 'lodash' {\n  export function join(arr: any[]): void\n}\n\n// 声明变量/函数/类\ndeclare let whyname: string\ndeclare let whyage: number\ndeclare let whyheight: number\n\ndeclare function whyfoo(): void\n\ndeclare class person {\n  name: string\n  age: number\n  constructor(name: string, age: number)\n}\n\n// 声明文件\ndeclare module '*.jpg'\ndeclare module '*.jpeg'\ndeclare module '*.png'\ndeclare module '*.svg'\ndeclare module '*.gif'\n\n// 声明命名空间\ndeclare namespace $ {\n  export function ajax(settings: any): any\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n * 在开发vue的过程中，默认是不识别我们的.vue文件的，那么我们就需要对其进行文件的声明;\n * 在开发中我们使用了 jpg 这类图片文件，默认typescript也是不支持的，也需要对其进行声明\n\n\n# tsconfig.json文件\n\n用于配置typescript编译时的配置选项：https://www.typescriptlang.org/tsconfig",charsets:{cjk:!0},lastUpdated:"2022/03/29, 17:35:37",lastUpdatedTimestamp:1648575337e3},{title:"NodeJS-1 入门",frontmatter:{title:"NodeJS-1 入门",date:"2020-12-27T00:16:27.000Z",permalink:"/pages/b62d08/",categories:["Node","Node"],tags:[null]},regularPath:"/1300.Node/100.Node/101.%E5%85%A5%E9%97%A8.html",relativePath:"1300.Node/100.Node/101.入门.md",key:"v-7849f14a",path:"/pages/b62d08/",headers:[{level:2,title:"使用 NVM 安装 Node",slug:"使用-nvm-安装-node",normalizedTitle:"使用 nvm 安装 node",charIndex:372},{level:3,title:"使用 Oh My Zsh 安装 NVM",slug:"使用-oh-my-zsh-安装-nvm",normalizedTitle:"使用 oh my zsh 安装 nvm",charIndex:473},{level:3,title:"使用 install script 安装 NVM",slug:"使用-install-script-安装-nvm",normalizedTitle:"使用 install script 安装 nvm",charIndex:682},{level:3,title:"使用 NVM 安装 Node",slug:"使用-nvm-安装-node-2",normalizedTitle:"使用 nvm 安装 node",charIndex:372},{level:2,title:"NPM",slug:"npm",normalizedTitle:"npm",charIndex:1413},{level:3,title:"NRM",slug:"nrm",normalizedTitle:"nrm",charIndex:1563},{level:3,title:"CNPM",slug:"cnpm",normalizedTitle:"cnpm",charIndex:1660},{level:3,title:"初始化工程",slug:"初始化工程",normalizedTitle:"初始化工程",charIndex:2044},{level:3,title:"本地安装",slug:"本地安装",normalizedTitle:"本地安装",charIndex:2292},{level:3,title:"全局安装",slug:"全局安装",normalizedTitle:"全局安装",charIndex:2999},{level:3,title:"批量下载",slug:"批量下载",normalizedTitle:"批量下载",charIndex:3405},{level:3,title:"运行工程",slug:"运行工程",normalizedTitle:"运行工程",charIndex:3560},{level:3,title:"编译工程",slug:"编译工程",normalizedTitle:"编译工程",charIndex:3641},{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:4012},{level:3,title:"控制台输出",slug:"控制台输出",normalizedTitle:"控制台输出",charIndex:4021},{level:3,title:"使用函数",slug:"使用函数",normalizedTitle:"使用函数",charIndex:4165},{level:3,title:"模块化编程",slug:"模块化编程",normalizedTitle:"模块化编程",charIndex:4329},{level:3,title:"创建 web 服务器",slug:"创建-web-服务器",normalizedTitle:"创建 web 服务器",charIndex:4566},{level:3,title:"理解服务端渲染",slug:"理解服务端渲染",normalizedTitle:"理解服务端渲染",charIndex:5133},{level:3,title:"接收参数",slug:"接收参数",normalizedTitle:"接收参数",charIndex:5848}],headersStr:"使用 NVM 安装 Node 使用 Oh My Zsh 安装 NVM 使用 install script 安装 NVM 使用 NVM 安装 Node NPM NRM CNPM 初始化工程 本地安装 全局安装 批量下载 运行工程 编译工程 快速入门 控制台输出 使用函数 模块化编程 创建 web 服务器 理解服务端渲染 接收参数",content:'# 入门\n\nNode.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。 Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。在特定领域性能出色，比如用 Node.js 实现消息推送、状态监控等的业务功能非常合适。\n\n传统意义上的 JavaScript 运行在浏览器上，Chrome 使用的 JavaScript 引擎是 V8，Node.js 是一个运行在服务端的框架，它的底层就使用了 V8 引擎，这样就可以使用 javascript 去编写一些服务端的程序，这样也就实现了用 javaScript 去开发服务端的功能，这样做的好处就是前端和后端都采用 javascript，即开发一份 js 程序即可以运行在前端也可以运行的服务端，这样比一个应用使用多种语言在开发效率上要高。\n\n\n# 使用 NVM 安装 Node\n\n在Node.js 官网下载所属平台的安装包或二进制文件，安装后在命令行输入node -v查看版本\n\n有时需要切换版本，推荐使用nvm安装 Node，Github\n\n\n# 使用 Oh My Zsh 安装 NVM\n\ngit clone https://github.com/lukechilds/zsh-nvm ~/.oh-my-zsh/custom/plugins/zsh-nvm\n\n\n1\n\n\nThen load as a plugin in your .zshrc\n\nplugins+=(zsh-nvm)\n\n\n1\n\n\n刷新.zshrc\n\nsource ~/.zshrc\n\n\n1\n\n\n\n# 使用 install script 安装 NVM\n\nTo install or update nvm, you should run the install script. To do that, you may either download and run the script manually, or use the following cURL or Wget command:\n\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash\nwget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash\n\n\n1\n2\n\n\n\n# 使用 NVM 安装 Node\n\nTo download, compile, and install the latest release of node, do this:\n\nnvm install node # "node" is an alias for the latest version\n\n\n1\n\n\n列出可以安装的版本🔥\n\n# 主要的版本\nnvm ls\n# 远程所有的可用版本\nnvm ls-remote\n\n\n1\n2\n3\n4\n\n\n安装LTS版本 🔥\n\nnvm install --lts\n\n\n1\n\n\n安装特定版本 🔥\n\nnvm install 8.17.0 # or 10.10.0, 8.9.1, etc\n\n\n1\n\n\n切换版本\n\nnvm use v12.18.0\n\n\n1\n\n\n其他使用方法后续再添加\n\n\n# NPM\n\nNPM 全称 Node Package Manager，他是 Node 包管理和分发工具。其实我们可以把 NPM 理解为前端的 Maven。我们通过 NPM 可以很方便地下载 js 库，管理前端工程。 Node.js 已经集成了 npm 工具，npm -v可查看当前 npm 版本\n\n\n# NRM\n\n用于切换镜像\n\n# 安装 nrm\nnpm install -g nrm\n# 查看可用镜像\nnrm ls\n# 切换镜像\nnrm use <xxx>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# CNPM\n\n有时我们使用 npm 下载资源会很慢，所以我们可以安装一个 cnmp(淘宝镜像)来加快下载速度。输入如下命令：\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n安装后使用.\\cnpm -v查看 cnpm 版本（在npm_modules目录下执行）\n\n安装 nrm.\\cnpm install -g nrm（在npm_modules目录下执行）\n\n.\\nrm ls查看镜像后，使用nrm use XXX切换镜像（在npm_modules目录下执行）\n\n配置环境变量后即可在任意目录下执行\n\n * 配置NODE_HOME = C:\\Program Files\\nodejs\n * Path 中配置%NODE_HOME%;%NODE_HOME%\\npm_modules;\n\n\n# 初始化工程\n\ninit命令是工程初始化命令。建立一个空文件夹，在命令提示符进入该文件夹执行命令初始化npm init\n\n按照提示输入相关信息，如果是用默认值则直接回车即可。\n\n * name: 项目名称\n * version: 项目版本号\n * description: 项目描述\n * keywords: {Array}关键词，便于用户搜索到我们的项目\n\n最后会生成package.json文件，这个是包的配置文件，相当于 maven 的pom.xml我们之后也可以根据需要进行修改。\n\n\n# 本地安装\n\ninstall 命令用于安装某个模块，如果我们想安装express模块（node 的 web 框架），输出命令如下npm install express\n\n出现黄色的是警告信息，可以忽略，请放心，你已经成功执行了该命令。\n\n在该目录下已经出现了一个node_modules文件夹 和package-lock.json\n\nnode_modules文件夹用于存放下载的 js 库（相当于 maven 的本地仓库）\n\npackage-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。\n\n我们再打开 package.json 文件，发现刚才下载的 express 已经添加到依赖列表中了.\n\n关于版本号定义：\n\n * 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n * 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装 1.3.x，也就是说安装时不改变大版本号和次要版本号。\n * 插入号（caret）+指定版本：比如^1.2.2，表示安装1.x.x的最新版本（不低于 1.2.2），但是不安装 2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为 0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\n * latest：安装最新版本。\n\n\n# 全局安装\n\n刚才我们使用的是本地安装，会将 js 库安装在当前目录，而使用全局安装会将库安装到你的全局目录下。\n\n如果你不知道你的全局目录在哪里，执行命令npm config ls或npm root -g\n\n我的全局目录在C:/用户/[用户名]/AppData/Roming/npm/node_meodules。为了方便对依赖包管理，我们将管理包的路径设置在单独的地方，本教程将安装目录设置在 node.js 的目录下，创建npm_modules和npm_cache，执行下边的命令：\n\nnpm config set prefix "C:\\Develop\\nodejs\\npm_modules"\nnpm config set cache "C:\\Develop\\nodejs\\npm_cache"\n\n\n1\n2\n\n\n比如我们全局安装 jquery, 输入以下命令npm install jquery -g\n\n\n# 批量下载\n\n我们从网上下载某些代码，发现只有package.json，没有node_modules文件夹，这时我们需要通过命令重新下载这些 js 库\n\n进入目录（package.json 所在的目录）输入命令npm install，此时，npm 会自动下载package.json中依赖的 js 库.\n\n\n# 运行工程\n\n如果我们想运行某个工程，则使用 run 命令\n\n如果package.json中定义的脚本如下\n\n * dev是开发阶段测试运行\n * build是构建编译工程\n * lint 是运行 js 代码检测\n\n我们现在来试一下运行 dev，命令行输入npm run dev\n\n\n# 编译工程\n\n我们接下来，测试一个代码的编译，编译后我们就可以将工程部署到 nginx 中啦~\n\n编译后的代码会放在dist文件夹中，首先我们先删除 dist 文件夹中的文件，进入命令提示符输入命令npm run build\n\n生成后我们会发现只有一个静态页面，和一个static文件夹\n\n这种工程我们称之为单页 Web 应用（single page web application，SPA），就是只有一张 Web 页面的应用，是加载单个 HTML 页面并在用户与应用程序交互时动态更新该页面的 Web 应用程序。\n\n这里其实是调用了 webpack 来实现打包的，关于 webpack 我们后续的章节进行介绍\n\n\n# 快速入门\n\n\n# 控制台输出\n\n我们现在做个最简单的小例子，演示如何在控制台输出，创建文本文件 demo1.js,代码内容\n\nvar a = 1;\nvar b = 2;\nconsole.log(a + b);\n\n\n1\n2\n3\n\n\n我们在命令提示符下输入命令\n\nnode demo1.js\n\n\n1\n\n\n\n# 使用函数\n\n创建文本文件 demo2.js\n\nvar c = add(100, 200);\nconsole.log(c);\nfunction add(a, b) {\n  return a + b;\n}\n\n\n1\n2\n3\n4\n5\n\n\n命令提示符输入命令。运行后看到输出结果为 300\n\nnode demo2.js\n\n\n1\n\n\n\n# 模块化编程\n\n创建文本文件 demo3_1.js\n\nexports.add = function(a, b) {\n  return a + b;\n};\n\n\n1\n2\n3\n\n\n创建文本文件 demo3_2.js\n\nvar demo = require("./demo3_1"); //ES5的语法\nconsole.log(demo.add(400, 600));\n\n\n1\n2\n\n\n我们在命令提示符下输入命令。结果为 1000\n\nnode demo3_2.js\n\n\n1\n\n\n\n# 创建 web 服务器\n\n创建文本文件 demo4.js\n\nvar http = require("http");\nhttp\n  .createServer(function(request, response) {\n    // 发送 HTTP 头部\n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, { "Content-Type": "text/plain" });\n    // 发送响应数据 "Hello World"\n    response.end("Hello World\\n");\n  })\n  .listen(8888);\n// 终端打印如下信息\nconsole.log("Server running at http://127.0.0.1:8888/");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nhttp为 node 内置的 web 模块\n\n我们在命令提示符下输入命令\n\nnode demo4.js\n\n\n1\n\n\n服务启动后，我们打开浏览器，输入网址http://localhost:8888/\n\n即可看到网页输出结果 Hello World。Ctrl+c 终止运行。\n\n\n# 理解服务端渲染\n\n我们创建 demo5.js  ，将上边的例子写成循环的形式\n\nvar http = require("http");\nhttp\n  .createServer(function(request, response) {\n    // 发送 HTTP 头部\n    // HTTP 状态值: 200 : OK\n    // 内容类型: text/plain\n    response.writeHead(200, { "Content-Type": "text/plain" });\n    // 发送响应数据 "Hello World"\n    for (var i = 0; i < 10; i++) {\n      response.write("Hello World\\n"); //write和end区别\n    }\n    response.end("");\n  })\n  .listen(8888);\n// 终端打印如下信息\nconsole.log("Server running at http://127.0.0.1:8888/");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们在命令提示符下输入命令启动服务\n\nnode demo5.js\n\n\n1\n\n\n浏览器地址栏输入http://127.0.0.1:8888即可看到查询结果。\n\n我们右键“查看源代码”发现，并没有我们写的 for 循环语句，而是直接的 10 条 Hello World ，这就说明这个循环是在服务端完成的，而非浏览器（客户端）来完成。这与我们原来的 JSP 很是相似。\n\n\n# 接收参数\n\n创建 demo6.js\n\nvar http = require("http");\nvar url = require("url");\nhttp\n  .createServer(function(request, response) {\n    response.writeHead(200, { "Content-Type": "text/plain" });\n    // 解析 url 参数\n    var params = url.parse(request.url, true).query;\n    response.write("name:" + params.name);\n    response.write("\\n");\n    response.end();\n  })\n  .listen(8888);\nconsole.log("Server running at http://127.0.0.1:8888/");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们在命令提示符下输入命令\n\nnode demo6.js\n\n\n1\n\n\n在浏览器测试结果',normalizedContent:'# 入门\n\nnode.js 是一个基于 chrome v8 引擎的 javascript 运行环境。 node.js 使用了一个事件驱动、非阻塞式 i/o 的模型，使其轻量又高效。在特定领域性能出色，比如用 node.js 实现消息推送、状态监控等的业务功能非常合适。\n\n传统意义上的 javascript 运行在浏览器上，chrome 使用的 javascript 引擎是 v8，node.js 是一个运行在服务端的框架，它的底层就使用了 v8 引擎，这样就可以使用 javascript 去编写一些服务端的程序，这样也就实现了用 javascript 去开发服务端的功能，这样做的好处就是前端和后端都采用 javascript，即开发一份 js 程序即可以运行在前端也可以运行的服务端，这样比一个应用使用多种语言在开发效率上要高。\n\n\n# 使用 nvm 安装 node\n\n在node.js 官网下载所属平台的安装包或二进制文件，安装后在命令行输入node -v查看版本\n\n有时需要切换版本，推荐使用nvm安装 node，github\n\n\n# 使用 oh my zsh 安装 nvm\n\ngit clone https://github.com/lukechilds/zsh-nvm ~/.oh-my-zsh/custom/plugins/zsh-nvm\n\n\n1\n\n\nthen load as a plugin in your .zshrc\n\nplugins+=(zsh-nvm)\n\n\n1\n\n\n刷新.zshrc\n\nsource ~/.zshrc\n\n\n1\n\n\n\n# 使用 install script 安装 nvm\n\nto install or update nvm, you should run the install script. to do that, you may either download and run the script manually, or use the following curl or wget command:\n\ncurl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash\nwget -qo- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash\n\n\n1\n2\n\n\n\n# 使用 nvm 安装 node\n\nto download, compile, and install the latest release of node, do this:\n\nnvm install node # "node" is an alias for the latest version\n\n\n1\n\n\n列出可以安装的版本🔥\n\n# 主要的版本\nnvm ls\n# 远程所有的可用版本\nnvm ls-remote\n\n\n1\n2\n3\n4\n\n\n安装lts版本 🔥\n\nnvm install --lts\n\n\n1\n\n\n安装特定版本 🔥\n\nnvm install 8.17.0 # or 10.10.0, 8.9.1, etc\n\n\n1\n\n\n切换版本\n\nnvm use v12.18.0\n\n\n1\n\n\n其他使用方法后续再添加\n\n\n# npm\n\nnpm 全称 node package manager，他是 node 包管理和分发工具。其实我们可以把 npm 理解为前端的 maven。我们通过 npm 可以很方便地下载 js 库，管理前端工程。 node.js 已经集成了 npm 工具，npm -v可查看当前 npm 版本\n\n\n# nrm\n\n用于切换镜像\n\n# 安装 nrm\nnpm install -g nrm\n# 查看可用镜像\nnrm ls\n# 切换镜像\nnrm use <xxx>\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# cnpm\n\n有时我们使用 npm 下载资源会很慢，所以我们可以安装一个 cnmp(淘宝镜像)来加快下载速度。输入如下命令：\n\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\n\n安装后使用.\\cnpm -v查看 cnpm 版本（在npm_modules目录下执行）\n\n安装 nrm.\\cnpm install -g nrm（在npm_modules目录下执行）\n\n.\\nrm ls查看镜像后，使用nrm use xxx切换镜像（在npm_modules目录下执行）\n\n配置环境变量后即可在任意目录下执行\n\n * 配置node_home = c:\\program files\\nodejs\n * path 中配置%node_home%;%node_home%\\npm_modules;\n\n\n# 初始化工程\n\ninit命令是工程初始化命令。建立一个空文件夹，在命令提示符进入该文件夹执行命令初始化npm init\n\n按照提示输入相关信息，如果是用默认值则直接回车即可。\n\n * name: 项目名称\n * version: 项目版本号\n * description: 项目描述\n * keywords: {array}关键词，便于用户搜索到我们的项目\n\n最后会生成package.json文件，这个是包的配置文件，相当于 maven 的pom.xml我们之后也可以根据需要进行修改。\n\n\n# 本地安装\n\ninstall 命令用于安装某个模块，如果我们想安装express模块（node 的 web 框架），输出命令如下npm install express\n\n出现黄色的是警告信息，可以忽略，请放心，你已经成功执行了该命令。\n\n在该目录下已经出现了一个node_modules文件夹 和package-lock.json\n\nnode_modules文件夹用于存放下载的 js 库（相当于 maven 的本地仓库）\n\npackage-lock.json是当 node_modules 或 package.json 发生变化时自动生成的文件。这个文件主要功能是确定当前安装的包的依赖，以便后续重新安装的时候生成相同的依赖，而忽略项目开发过程中有些依赖已经发生的更新。\n\n我们再打开 package.json 文件，发现刚才下载的 express 已经添加到依赖列表中了.\n\n关于版本号定义：\n\n * 指定版本：比如1.2.2，遵循“大版本.次要版本.小版本”的格式规定，安装时只安装指定版本。\n * 波浪号（tilde）+指定版本：比如~1.2.2，表示安装1.2.x的最新版本（不低于1.2.2），但是不安装 1.3.x，也就是说安装时不改变大版本号和次要版本号。\n * 插入号（caret）+指定版本：比如^1.2.2，表示安装1.x.x的最新版本（不低于 1.2.2），但是不安装 2.x.x，也就是说安装时不改变大版本号。需要注意的是，如果大版本号为 0，则插入号的行为与波浪号相同，这是因为此时处于开发阶段，即使是次要版本号变动，也可能带来程序的不兼容。\n * latest：安装最新版本。\n\n\n# 全局安装\n\n刚才我们使用的是本地安装，会将 js 库安装在当前目录，而使用全局安装会将库安装到你的全局目录下。\n\n如果你不知道你的全局目录在哪里，执行命令npm config ls或npm root -g\n\n我的全局目录在c:/用户/[用户名]/appdata/roming/npm/node_meodules。为了方便对依赖包管理，我们将管理包的路径设置在单独的地方，本教程将安装目录设置在 node.js 的目录下，创建npm_modules和npm_cache，执行下边的命令：\n\nnpm config set prefix "c:\\develop\\nodejs\\npm_modules"\nnpm config set cache "c:\\develop\\nodejs\\npm_cache"\n\n\n1\n2\n\n\n比如我们全局安装 jquery, 输入以下命令npm install jquery -g\n\n\n# 批量下载\n\n我们从网上下载某些代码，发现只有package.json，没有node_modules文件夹，这时我们需要通过命令重新下载这些 js 库\n\n进入目录（package.json 所在的目录）输入命令npm install，此时，npm 会自动下载package.json中依赖的 js 库.\n\n\n# 运行工程\n\n如果我们想运行某个工程，则使用 run 命令\n\n如果package.json中定义的脚本如下\n\n * dev是开发阶段测试运行\n * build是构建编译工程\n * lint 是运行 js 代码检测\n\n我们现在来试一下运行 dev，命令行输入npm run dev\n\n\n# 编译工程\n\n我们接下来，测试一个代码的编译，编译后我们就可以将工程部署到 nginx 中啦~\n\n编译后的代码会放在dist文件夹中，首先我们先删除 dist 文件夹中的文件，进入命令提示符输入命令npm run build\n\n生成后我们会发现只有一个静态页面，和一个static文件夹\n\n这种工程我们称之为单页 web 应用（single page web application，spa），就是只有一张 web 页面的应用，是加载单个 html 页面并在用户与应用程序交互时动态更新该页面的 web 应用程序。\n\n这里其实是调用了 webpack 来实现打包的，关于 webpack 我们后续的章节进行介绍\n\n\n# 快速入门\n\n\n# 控制台输出\n\n我们现在做个最简单的小例子，演示如何在控制台输出，创建文本文件 demo1.js,代码内容\n\nvar a = 1;\nvar b = 2;\nconsole.log(a + b);\n\n\n1\n2\n3\n\n\n我们在命令提示符下输入命令\n\nnode demo1.js\n\n\n1\n\n\n\n# 使用函数\n\n创建文本文件 demo2.js\n\nvar c = add(100, 200);\nconsole.log(c);\nfunction add(a, b) {\n  return a + b;\n}\n\n\n1\n2\n3\n4\n5\n\n\n命令提示符输入命令。运行后看到输出结果为 300\n\nnode demo2.js\n\n\n1\n\n\n\n# 模块化编程\n\n创建文本文件 demo3_1.js\n\nexports.add = function(a, b) {\n  return a + b;\n};\n\n\n1\n2\n3\n\n\n创建文本文件 demo3_2.js\n\nvar demo = require("./demo3_1"); //es5的语法\nconsole.log(demo.add(400, 600));\n\n\n1\n2\n\n\n我们在命令提示符下输入命令。结果为 1000\n\nnode demo3_2.js\n\n\n1\n\n\n\n# 创建 web 服务器\n\n创建文本文件 demo4.js\n\nvar http = require("http");\nhttp\n  .createserver(function(request, response) {\n    // 发送 http 头部\n    // http 状态值: 200 : ok\n    // 内容类型: text/plain\n    response.writehead(200, { "content-type": "text/plain" });\n    // 发送响应数据 "hello world"\n    response.end("hello world\\n");\n  })\n  .listen(8888);\n// 终端打印如下信息\nconsole.log("server running at http://127.0.0.1:8888/");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\nhttp为 node 内置的 web 模块\n\n我们在命令提示符下输入命令\n\nnode demo4.js\n\n\n1\n\n\n服务启动后，我们打开浏览器，输入网址http://localhost:8888/\n\n即可看到网页输出结果 hello world。ctrl+c 终止运行。\n\n\n# 理解服务端渲染\n\n我们创建 demo5.js  ，将上边的例子写成循环的形式\n\nvar http = require("http");\nhttp\n  .createserver(function(request, response) {\n    // 发送 http 头部\n    // http 状态值: 200 : ok\n    // 内容类型: text/plain\n    response.writehead(200, { "content-type": "text/plain" });\n    // 发送响应数据 "hello world"\n    for (var i = 0; i < 10; i++) {\n      response.write("hello world\\n"); //write和end区别\n    }\n    response.end("");\n  })\n  .listen(8888);\n// 终端打印如下信息\nconsole.log("server running at http://127.0.0.1:8888/");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n我们在命令提示符下输入命令启动服务\n\nnode demo5.js\n\n\n1\n\n\n浏览器地址栏输入http://127.0.0.1:8888即可看到查询结果。\n\n我们右键“查看源代码”发现，并没有我们写的 for 循环语句，而是直接的 10 条 hello world ，这就说明这个循环是在服务端完成的，而非浏览器（客户端）来完成。这与我们原来的 jsp 很是相似。\n\n\n# 接收参数\n\n创建 demo6.js\n\nvar http = require("http");\nvar url = require("url");\nhttp\n  .createserver(function(request, response) {\n    response.writehead(200, { "content-type": "text/plain" });\n    // 解析 url 参数\n    var params = url.parse(request.url, true).query;\n    response.write("name:" + params.name);\n    response.write("\\n");\n    response.end();\n  })\n  .listen(8888);\nconsole.log("server running at http://127.0.0.1:8888/");\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n我们在命令提示符下输入命令\n\nnode demo6.js\n\n\n1\n\n\n在浏览器测试结果',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"入门",frontmatter:{title:"入门",date:"2022-01-16T16:41:40.000Z",permalink:"/pages/6f1f8f/",categories:["Node","Webpack5"],tags:[null]},regularPath:"/1301.Webpack/100.Webpack5/101.%E5%85%A5%E9%97%A8.html",relativePath:"1301.Webpack/100.Webpack5/101.入门.md",key:"v-0c43a93e",path:"/pages/6f1f8f/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:9},{level:2,title:"打包的东西",slug:"打包的东西",normalizedTitle:"打包的东西",charIndex:382},{level:2,title:"Node 和 NPM 版本",slug:"node-和-npm-版本",normalizedTitle:"node 和 npm 版本",charIndex:606},{level:2,title:"webpack & webpack-cli",slug:"webpack-webpack-cli",normalizedTitle:"webpack &amp; webpack-cli",charIndex:null},{level:2,title:"全局 webpack 打包",slug:"全局-webpack-打包",normalizedTitle:"全局 webpack 打包",charIndex:970},{level:2,title:"局部 webpack 打包 🔥",slug:"局部-webpack-打包-🔥",normalizedTitle:"局部 webpack 打包 🔥",charIndex:2384},{level:2,title:"入口、出口文件配置 🔥",slug:"入口、出口文件配置-🔥",normalizedTitle:"入口、出口文件配置 🔥",charIndex:2676},{level:2,title:"Webpack的依赖图",slug:"webpack的依赖图",normalizedTitle:"webpack的依赖图",charIndex:3356},{level:2,title:"打包 css",slug:"打包-css",normalizedTitle:"打包 css",charIndex:3544},{level:2,title:"打包 less、scss、stylus",slug:"打包-less、scss、stylus",normalizedTitle:"打包 less、scss、stylus",charIndex:4046},{level:2,title:"PostCSS",slug:"postcss",normalizedTitle:"postcss",charIndex:4523},{level:3,title:"安装 postcss、postcss-cli",slug:"安装-postcss、postcss-cli",normalizedTitle:"安装 postcss、postcss-cli",charIndex:4703},{level:3,title:"插件autoprefixer（可不用该插件）",slug:"插件autoprefixer-可不用该插件",normalizedTitle:"插件autoprefixer（可不用该插件）",charIndex:4870},{level:3,title:"postcss-loader",slug:"postcss-loader",normalizedTitle:"postcss-loader",charIndex:4652},{level:3,title:"postcss-preset-env",slug:"postcss-preset-env",normalizedTitle:"postcss-preset-env",charIndex:5623},{level:3,title:"postcss 完整配置",slug:"postcss-完整配置",normalizedTitle:"postcss 完整配置",charIndex:6158},{level:2,title:"打包资源",slug:"打包资源",normalizedTitle:"打包资源",charIndex:6993},{level:3,title:"file-loader",slug:"file-loader",normalizedTitle:"file-loader",charIndex:7108},{level:4,title:"完整配置",slug:"完整配置",normalizedTitle:"完整配置",charIndex:6166},{level:3,title:"url-loader",slug:"url-loader",normalizedTitle:"url-loader",charIndex:7864},{level:3,title:"字体文件",slug:"字体文件",normalizedTitle:"字体文件",charIndex:8839},{level:3,title:"asset module type 🔥",slug:"asset-module-type-🔥",normalizedTitle:"asset module type 🔥",charIndex:9094},{level:4,title:"完整配置",slug:"完整配置-2",normalizedTitle:"完整配置",charIndex:6166},{level:2,title:"Plugin",slug:"plugin",normalizedTitle:"plugin",charIndex:10170},{level:3,title:"CleanWebpackPlugin",slug:"cleanwebpackplugin",normalizedTitle:"cleanwebpackplugin",charIndex:10515},{level:3,title:"HtmlWebpackPlugin",slug:"htmlwebpackplugin",normalizedTitle:"htmlwebpackplugin",charIndex:10825},{level:3,title:"DefinePlugin",slug:"defineplugin",normalizedTitle:"defineplugin",charIndex:11280},{level:3,title:"CopyWebpackPlugin",slug:"copywebpackplugin",normalizedTitle:"copywebpackplugin",charIndex:11649},{level:2,title:"Mode配置",slug:"mode配置",normalizedTitle:"mode配置",charIndex:12437},{level:2,title:"Babel",slug:"babel",normalizedTitle:"babel",charIndex:12753},{level:3,title:"介绍",slug:"介绍-2",normalizedTitle:"介绍",charIndex:9},{level:3,title:"Babel命令行使用",slug:"babel命令行使用",normalizedTitle:"babel命令行使用",charIndex:12942},{level:3,title:"插件的使用",slug:"插件的使用",normalizedTitle:"插件的使用",charIndex:13250},{level:3,title:"Babel的预设preset",slug:"babel的预设preset",normalizedTitle:"babel的预设preset",charIndex:13755},{level:3,title:"Babel的底层原理",slug:"babel的底层原理",normalizedTitle:"babel的底层原理",charIndex:13952},{level:3,title:"Babel编译器执行原理",slug:"babel编译器执行原理",normalizedTitle:"babel编译器执行原理",charIndex:14292},{level:3,title:"babel-loader 🔥",slug:"babel-loader-🔥",normalizedTitle:"babel-loader 🔥",charIndex:14362},{level:3,title:"babel-preset 🔥",slug:"babel-preset-🔥",normalizedTitle:"babel-preset 🔥",charIndex:15005},{level:3,title:"Babel的配置文件",slug:"babel的配置文件",normalizedTitle:"babel的配置文件",charIndex:15687},{level:2,title:"Vue 打包 🔥",slug:"vue-打包-🔥",normalizedTitle:"vue 打包 🔥",charIndex:16195},{level:3,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:207},{level:3,title:"Vue打包后不同版本解析",slug:"vue打包后不同版本解析",normalizedTitle:"vue打包后不同版本解析",charIndex:16612},{level:3,title:"运行时+编译器 vs 仅运行时",slug:"运行时-编译器-vs-仅运行时",normalizedTitle:"运行时+编译器 vs 仅运行时",charIndex:17103},{level:3,title:"VSCode对SFC文件的支持",slug:"vscode对sfc文件的支持",normalizedTitle:"vscode对sfc文件的支持",charIndex:17552},{level:3,title:"App.vue 打包 🔥",slug:"app-vue-打包-🔥",normalizedTitle:"app.vue 打包 🔥",charIndex:17733},{level:2,title:"devServer 🔥",slug:"devserver-🔥",normalizedTitle:"devserver 🔥",charIndex:18059},{level:3,title:"需求",slug:"需求",normalizedTitle:"需求",charIndex:18076},{level:3,title:"webpack watch",slug:"webpack-watch",normalizedTitle:"webpack watch",charIndex:18255},{level:3,title:"webpack-dev-server 🔥",slug:"webpack-dev-server-🔥",normalizedTitle:"webpack-dev-server 🔥",charIndex:18697},{level:4,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:689},{level:4,title:"contentBase 配置 🔥",slug:"contentbase-配置-🔥",normalizedTitle:"contentbase 配置 🔥",charIndex:19065},{level:4,title:"host配置 🔥",slug:"host配置-🔥",normalizedTitle:"host配置 🔥",charIndex:19396},{level:4,title:"port、open、compress 配置 🔥",slug:"port、open、compress-配置-🔥",normalizedTitle:"port、open、compress 配置 🔥",charIndex:19788},{level:4,title:"proxy 配置 🔥",slug:"proxy-配置-🔥",normalizedTitle:"proxy 配置 🔥",charIndex:19993},{level:4,title:"historyApiFallback 配置",slug:"historyapifallback-配置",normalizedTitle:"historyapifallback 配置",charIndex:20838},{level:3,title:"HMR 模块热替换 🔥",slug:"hmr-模块热替换-🔥",normalizedTitle:"hmr 模块热替换 🔥",charIndex:21151},{level:4,title:"介绍",slug:"介绍-3",normalizedTitle:"介绍",charIndex:9},{level:4,title:"hot 配置 🔥",slug:"hot-配置-🔥",normalizedTitle:"hot 配置 🔥",charIndex:21481},{level:4,title:"框架的HMR 🔥",slug:"框架的hmr-🔥",normalizedTitle:"框架的hmr 🔥",charIndex:21886},{level:4,title:"HMR 原理 🔥",slug:"hmr-原理-🔥",normalizedTitle:"hmr 原理 🔥",charIndex:22193},{level:2,title:"resolve 模块解析配置",slug:"resolve-模块解析配置",normalizedTitle:"resolve 模块解析配置",charIndex:22573},{level:3,title:"介绍",slug:"介绍-4",normalizedTitle:"介绍",charIndex:9},{level:3,title:"路径",slug:"路径",normalizedTitle:"路径",charIndex:3031},{level:3,title:"文件？文件夹？",slug:"文件-文件夹",normalizedTitle:"文件？文件夹？",charIndex:23113},{level:3,title:"extensions和alias配置",slug:"extensions和alias配置",normalizedTitle:"extensions和alias配置",charIndex:23377},{level:3,title:"配置 🔥",slug:"配置-🔥",normalizedTitle:"配置 🔥",charIndex:2683},{level:2,title:"分离开发生产环境 🔥",slug:"分离开发生产环境-🔥",normalizedTitle:"分离开发生产环境 🔥",charIndex:23880}],headersStr:"介绍 打包的东西 Node 和 NPM 版本 webpack & webpack-cli 全局 webpack 打包 局部 webpack 打包 🔥 入口、出口文件配置 🔥 Webpack的依赖图 打包 css 打包 less、scss、stylus PostCSS 安装 postcss、postcss-cli 插件autoprefixer（可不用该插件） postcss-loader postcss-preset-env postcss 完整配置 打包资源 file-loader 完整配置 url-loader 字体文件 asset module type 🔥 完整配置 Plugin CleanWebpackPlugin HtmlWebpackPlugin DefinePlugin CopyWebpackPlugin Mode配置 Babel 介绍 Babel命令行使用 插件的使用 Babel的预设preset Babel的底层原理 Babel编译器执行原理 babel-loader 🔥 babel-preset 🔥 Babel的配置文件 Vue 打包 🔥 问题 Vue打包后不同版本解析 运行时+编译器 vs 仅运行时 VSCode对SFC文件的支持 App.vue 打包 🔥 devServer 🔥 需求 webpack watch webpack-dev-server 🔥 安装 contentBase 配置 🔥 host配置 🔥 port、open、compress 配置 🔥 proxy 配置 🔥 historyApiFallback 配置 HMR 模块热替换 🔥 介绍 hot 配置 🔥 框架的HMR 🔥 HMR 原理 🔥 resolve 模块解析配置 介绍 路径 文件？文件夹？ extensions和alias配置 配置 🔥 分离开发生产环境 🔥",content:'# 入门\n\n\n# 介绍\n\n本质上，webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。\n\n * 现代的modern：我们前端说过，正是因为现代前端开发面临各种各样的问题，才催生了webpack的出现和发展\n * 静态的static：这样表述的原因是我们最终可以将代码打包成最终的静态资源(部署到静态服务器)\n * 模块化module：webpack默认支持各种模块化开发，ES Module、CommonJS、AMD等\n * 打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具\n\n\n# 打包的东西\n\nJavaScript的打包:\n\n * ES6转换成ES5的语法;\n * TypeScript的处理，将其转换成JavaScript;\n\nCss的处理:\n\n * CSS文件模块的加载、提取;\n * Less、Sass等预处理器的处理;\n\n资源文件img、font:\n\n * 图片img文件的加载;\n * 字体font文件的加载;\n\nHTML资源的处理\n\n * 打包HTML资源文件;\n\n处理vue项目的SFC文件.vue文件;\n\n\n# Node 和 NPM 版本\n\n目前使用的版本\n\nv14.18.3\n6.14.15\n\n\n1\n2\n\n\n\n# webpack & webpack-cli\n\nwebpack的安装目前分为两个：webpack、webpack-cli\n\n·那么它们是什么关系呢?\n\n * 执行webpack命令，会执行node_modules下的.bin目录下的webpack;\n * webpack在执行时是依赖webpack-cli的，如果没有安装就会报错;\n * 而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程;\n * 所以在安装webpack时，我们需要同时安装webpack-cli(第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自己的vue-service-cli的东西)\n\n\n\n\n# 全局 webpack 打包\n\n安装\n\nnpm install webpack webpack-cli –g # 全局安装 \n\n\n1\n\n\n创建如下文件\n\n\n\n/index.html\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    \x3c!-- 源js文件无法运行 --\x3e\n    <script src="./src/index.js" type="module"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n/src/index.js\n\nimport { sum } from "./js/math";\nconst { priceFormat } = require("./js/format");\n\nconsole.log(sum(20, 30));\nconsole.log(priceFormat());\n\n\n1\n2\n3\n4\n5\n\n\n/src/js/format.js\n\nconst priceFormat = function() {\n  return "¥99.88";\n}\n\n// CommonJS的导出\nmodule.exports = {\n  priceFormat\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n/src/js/math.js\n\n// ES Module\nexport function sum(num1, num2) {\n  return num1 + num2;\n}\n\n\n1\n2\n3\n4\n\n\n在项目/目录下执行webpack，会生成/dist/main.js，将html替换为\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    \x3c!-- 源js文件无法运行 --\x3e\n    \x3c!-- <script src="./src/index.js" type="module"><\/script> --\x3e\n    \x3c!-- 打包后的js文件可以访问 --\x3e\n    <script src="./dist/main.js"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n就会运行成功！\n\n\n# 局部 webpack 打包 🔥\n\nnpm init\nnpm install webpack webpack-cli -D\nnpx webpack\n\n\n1\n2\n3\n\n\nnpx意思是在npm安装的node_modules中的.bin目录下查找命令\n\n在package.json中创建scripts脚本，执行脚本打包即可\n\n  "scripts": {\n    "build": "webpack"\n  },\n\n\n1\n2\n3\n\n\n此时只写webpack，它会自动先在node_modules中的.bin目录下查找命令。执行如下命令即可打包\n\nnpm run build\n\n\n1\n\n\n\n# 入口、出口文件配置 🔥\n\n当我们运行webpack时，webpack会查找当前目录下的 src/index.js作为入口，不存在则报错\n\n可以通过配置来指定入口和出口：\n\n npx webpack --entry ./src/main.js --output-path ./build\n\n\n1\n\n\n但是不推荐该方式，可以在项目根目录创建wepack.config.js文件\n\nconst path = require(\'path\')\n\n// Webpack在Node环境运行，Node使用的CommonJS，要改为ES6需要配置，比较麻烦\nmodule.exports = {\n  // 入口文件名\n  entry: \'./src/main.js\',\n  output: {\n    // path必须是绝对路径！！！，__dirname代表当前文件（webpack.config.js）所在绝对路径\n    path: path.resolve(__dirname, \'./build\'),\n    filename: \'bundle.js\',\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在package.json中修改scripts脚本即可使用\n\n"build": "webpack"\n\n\n1\n\n\n若是创建的文件名不是默认的，而是如conana.config.js，则需要修改scripts脚本。不推荐！！！\n\n"build": "webpack --config conana.config.js"\n\n\n1\n\n\n\n# Webpack的依赖图\n\n\n\n * 事实上webpack在处理应用程序时，它会根据命令或者配置文件找到入口文件\n * 从入口开始，会生成一个依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块(比如.js文件、css文件、图片、字 体等)\n * 然后遍历图结构，打包一个个模块(根据文件的不同使用不同的loader来解析)\n * 注意，没有依赖到的不会打包！！！\n\n\n# 打包 css\n\ncss-loader 是将 css 解析、装载；style-loader 是将解析、装载的 css 添加到 style 标签中。\n\nnpm install css-loader style-loader -D\n\n\n1\n\n\n配置webpack.config.js\n\nmodule.exports = {\\\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // loader: \'css-loader\',\n        // use: [\'css-loader\'],\n        // 完整写法(倒序执行！！！)\n        use: [\n          { loader: \'style-loader\', options: {} },\n          { loader: \'css-loader\', options: {} },\n        ],\n      },\n    ],\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 打包 less、scss、stylus\n\n这里以 less 为例。less会将less文件转换为css文件，安装后会有个lessc可执行文件；less-loader会批量将less文件转为css文件\n\nnpm install less less-loader -D\n\n\n1\n\n\n配置webpack.config.js\n\ngmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        use: [\n          { loader: \'style-loader\', options: {} },\n          { loader: \'css-loader\', options: {} },\n          { loader: \'less-loader\', options: {} },\n        ],\n      },\n    ],\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# PostCSS\n\nCSS的转换和适配，比如自动添加浏览器前缀、css样式的重置。实现这些功能，我们需要借助于PostCSS对应的插件\n\n如何使用PostCSS呢?主要就是两个步骤:\n\n * 第一步:查找PostCSS在构建工具中的扩展，比如webpack中的postcss-loader;\n * 第二步:选择可以添加你需要的PostCSS相关的插件;\n\n\n# 安装 postcss、postcss-cli\n\nnpm install postcss postcss-cli -D\n\n\n1\n\n\npostcss-cli可以直接在终端使用PostCSS\n\n我们编写一个需要添加前缀的csshttps://autoprefixer.github.io/，在该网站中查询一些添加css属性的样式;\n\n\n# 插件autoprefixer（可不用该插件）\n\n添加前缀，所以要安装autoprefixer\n\n npm install autoprefixer -D\n\n\n1\n\n\n直接使用使用postcss工具，并且制定使用autoprefixer\n\n npx postcss --use autoprefixer -o end.css ./src/css/style.css\n\n\n1\n\n\n\n# postcss-loader\n\n真实开发中我们必然不会直接使用命令行工具来对css进行处理，而是可以借助于构建工具。在webpack中使用postcss就是使用postcss-loader来处理的\n\n npm install postcss-loader -D\n\n\n1\n\n\n修改加载css的loader。注意:因为postcss需要有对应的插件才会起效果，所以我们需要配置它的plugin\n\n{\n    loader: \'postcss-loader\',\n        options: {\n            postcssOptions: {\n                plugins: [\n                    require(\'autoprefixer\')\n                ]\n            },\n        },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n当然，我们也可以将这些配置信息放到一个单独的文件中进行管理，在根目录下创建postcss.config.js\n\nmodule.exports = {\n  plugins: [\n      require(\'autoprefixer\')\n  ],\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# postcss-preset-env\n\n事实上，在配置postcss-loader时，我们配置插件并不需要使用autoprefixer，我们可以使用另外一个插件:postcss-preset-env\n\n * postcss-preset-env也是一个postcss的插件;\n * 它可以帮助我们将一些现代的CSS特性，转成大多数浏览器认识的CSS，并且会根据目标浏览器或者运行时环境 添加所需的polyfill\n * 也包括会自动帮助我们添加autoprefixer(所以相当于已经内置了autoprefixer)\n\n npm install postcss-preset-env -D\n\n\n1\n\n\n之后，我们直接修改掉之前的autoprefixer即可\n\nmodule.exports = {\n  plugins: [\n      require(\'postcss-preset-env\')\n  ],\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意:我们在使用某些postcss插件时，也可以直接传入字符串\n\nmodule.exports = {\n  plugins: [\n      \'postcss-preset-env\'\n  ],\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# postcss 完整配置\n\nwebpack.config.js\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          { loader: \'style-loader\', options: {} },\n          { loader: \'css-loader\', options: {} },\n          {\n            loader: \'postcss-loader\',\n            options: {},\n          },\n        ],\n      },\n      {\n        test: /\\.less$/,\n        use: [\n          { loader: \'style-loader\', options: {} },\n          { loader: \'css-loader\', options: {} },\n          {\n            loader: \'postcss-loader\',\n            options: {},\n          },\n          { loader: \'less-loader\', options: {} },\n        ],\n      },\n    ],\n  },\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\npostcss.config.js\n\nmodule.exports = {\n  plugins: [require(\'postcss-preset-env\')],\n}\n\n\n1\n2\n3\n\n\n\n# 打包资源\n\n为了演示我们项目中可以加载图片，我们需要在项目中使用图片，比较常见的使用图片的方式是两种\n\n * img元素，设置src属性;\n * 其他元素(比如div)，设置background-image的css属性;\n\n\n# file-loader\n\n要处理jpg、png等格式的图片，我们也需要有对应的loader:file-loader\n\nfile-loader的作用就是帮助我们处理import/require()方式引入的一个文件资源，并且会将它放到我们输出的文件夹中;\n\n当然我们待会儿可以学习如何修改它的名字和所在文件夹\n\nnpm install file-loader -D\n\n\n1\n\n\n有时候我们处理后的文件名称按照一定的规则进行显示，比如保留原来的文件名、扩展名，同时为了防止重复，包含一个hash值等;\n\n这个时候我们可以使用PlaceHolders来完成，webpack给我们提供了大量的PlaceHolders来显示不同的内容: https://webpack.js.org/loaders/file-loader/#placeholders。我们可以在文档中查阅自己需要的placeholder;\n\n我们这里介绍几个最常用的placeholder:\n\n * [ext]: 处理文件的扩展名;\n * [name]:处理文件的名称;\n * [hash]:文件的内容，使用MD4的散列函数处理，生成的一个128位的hash值(32个十六进制);\n * [contentHash]:在file-loader中和[hash]结果是一致的(在webpack的一些其他地方不一样，后面会讲到);\n * [hash:<length>]:截图hash的长度，默认32个字符太长了;\n * [path]:文件相对于webpack配置文件的路径;\n\n# 完整配置\n\n{\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        use: {\n          // file-loader 和 url-loader 根据需要选择一个\n          loader: \'file-loader\',\n          // loader: \'url-loader\',\n          options: {\n            // outputPath: "img",\n            name: \'img/[name]_[hash:6].[ext]\',\n          },\n        },\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# url-loader\n\nurl-loader和file-loader的工作方式是相似的，但是可以将较小的文件，转成base64的URI\n\n npm install url-loader -D\n\n\n1\n\n\ndist文件夹中，我们会看不到图片文件:\n\n * 这是因为我的两张图片的大小分别是38kb和295kb;\n * 默认情况下url-loader会将所有的图片文件转成base64编码\n\n但是开发中我们往往是小的图片需要转换，但是大的图片直接使用图片即可\n\n * 这是因为小的图片转换base64之后可以和页面一起被请求，减少不必要的请求过程\n * 而大的图片也进行转换，反而会影响页面的请求速度;\n\nurl-loader有一个options属性limit，可以用于设置转换的限制;\n\n{\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        use: {\n          // file-loader 和 url-loader 根据需要选择一个\n          // loader: \'file-loader\',\n          loader: \'url-loader\',\n          options: {\n            // outputPath: "img",\n            name: \'img/[name]_[hash:6].[ext]\',\n            limit: 100 * 1024,\n          },\n        },\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 字体文件\n\n{\n        test: /\\.(eot|ttf|woff2?)$/,\n        use: {\n          loader: "file-loader",\n          options: {\n            // outputPath: "font",\n            name: "font/[name]_[hash:6].[ext]"\n          }\n        }\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# asset module type 🔥\n\n我们当前使用的webpack版本是webpack5:\n\n * 在webpack5之前，加载这些资源我们需要使用一些loader，比如raw-loader 、url-loader、file-loader;\n * 在webpack5开始，我们可以直接使用资源模块类型(asset module type)，来替代上面的这些loader;\n\n资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader:\n\n * asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现;\n * asset/inline 导出一个资源的 data URI。之前通过使用 url-loader 实现;\n * asset/source 导出资源的源代码。之前通过使用 raw-loader 实现;\n * asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体 积限制实现;\n\n# 完整配置\n\n// webpack5的asset module type替换file-loader 和 url-loader等\n      {\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        type: \'asset\',\n        generator: {\n          filename: \'img/[name]_[hash:6][ext]\',\n        },\n        parser: {\n          dataUrlCondition: {\n            maxSize: 100 * 1024,\n          },\n        },\n      },\n          {\n        test: /\\.(eot|ttf|woff2?)$/,\n        type: \'asset/resource\',\n        generator: {\n          filename: \'font/[name]_[hash:6][ext]\',\n        },\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n效果和上述url-loader、file-loader一样！！！\n\n\n# Plugin\n\nWebpack的另一个核心是Plugin，官方有这样一段对Plugin的描述:\n\nWhile loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.\n\n上面表达的含义翻译过来就是:\n\n * Loader是用于特定的模块类型进行转换;\n * Plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等;\n\n\n\n\n# CleanWebpackPlugin\n\n前面我们演示的过程中，每次修改了一些配置，重新打包时，都需要手动删除dist文件夹。我们可以借助于一个插件来帮助我们完成，这个插件就是CleanWebpackPlugin\n\n npm install clean-webpack-plugin -D\n\n\n1\n\n\n配置\n\nconst { CleanWebpackPlugin } = require("clean-webpack-plugin");\n\nmodule.exports = {\n  plugins: [\n    new CleanWebpackPlugin(),\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# HtmlWebpackPlugin\n\n另外还有一个不太规范的地方:\n\n * 我们的HTML文件是编写在根目录下的，而最终打包的dist文件夹中是没有index.html文件的。\n * 在进行项目部署的时，必然也是需要有对应的入口文件index.html;\n * 所以我们也需要对index.html进行打包处理;\n\n npm install html-webpack-plugin -D\n\n\n1\n\n\n配置（可以在public中使用自定义模板）\n\nconst HtmlWebpackPlugin = require("html-webpack-plugin");\n\n\nmodule.exports = {\n  plugins: [\n      new HtmlWebpackPlugin({\n      \ttemplate: "./public/index.html",\n      \ttitle: "哈哈哈哈"\n      }),\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# DefinePlugin\n\n这是因为在编译template模块时，有一个BASE_URL<link rel="icon" href="<%= BASE_URL %>favicon.ico">但是我们并没有设置过这个常量值，所以会出现没有定义的错误，可以使用DefinePlugin插件;\n\nDefinePlugin允许在编译时创建配置的全局常量，是一个webpack内置的插件(不需要单独安装)\n\nconst { DefinePlugin } = require("webpack");\n\nmodule.exports = {\n  plugins: [\n      new DefinePlugin({\n      \tBASE_URL: "\'./\'"\n      }),\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# CopyWebpackPlugin\n\n在vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist文件夹中。 这个复制的功能，我们可以使用CopyWebpackPlugin来完成;\n\n npm install copy-webpack-plugin -D\n\n\n1\n\n\n配置CopyWebpackPlugin：\n\n * 复制的规则在patterns中设置;\n * **from:**设置从哪一个源中开始复制;\n * **to:**复制到的位置，可以省略，会默认复制到打包的目录下;\n * **globOptions:**设置一些额外的选项，其中可以编写需要忽略的文件:\n   * .DS_Store:mac目录下回自动生成的一个文件;\n   * index.html:也不需要复制，因为我们已经通过HtmlWebpackPlugin完成了index.html的生成;\n\nconst CopyWebpackPlugin = require(\'copy-webpack-plugin\');\n\nmodule.exports = {\n  plugins: [\n      new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: "public",\n          to: "./",\n          globOptions: {\n            ignore: [\n              "**/index.html"\n            ]\n          }\n        }\n      ]\n    })\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# Mode配置\n\nMode配置选项，可以告知webpack使用响应模式的内置优化:\n\n * 默认值是production(什么都不设置的情况下);\n * 可选值有:\'none\' | \'development\' | \'production\'\n\n\n\n  // 设置模式\n  // development 开发阶段, 会设置development\n  // production 准备打包上线的时候, 设置production\n  mode: "development",\n  // 设置source-map, 建立js映射文件, 方便调试代码和错误\n  devtool: "source-map",\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# Babel\n\n\n# 介绍\n\n开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的。所以，学习Babel对于我们理解代码从编写到线上的转变过程至关重要\n\nBabel是一个工具链，主要用于旧浏览器或者环境中将ECMAScript 2015+代码转换为向后兼容版本的 JavaScript。如语法转换、源代码转换等\n\n\n# Babel命令行使用\n\nbabel本身可以作为一个独立的工具(和postcss一样)，不和webpack等构建工具配置来单独使用\n\n如果我们希望在命令行尝试使用babel，需要安装如下库\n\n * @babel/core:babel的核心代码，必须安装;\n * @babel/cli:可以让我们在命令行使用babel;\n\n npm install @babel/cli @babel/core -D\n\n\n1\n\n\n使用babel来处理我们的源代码:\n\n * src:是源文件的目录;\n * --out-dir:指定要输出的文件夹dist;\n\n npx babel src --out-dir dist\n\n\n1\n\n\n\n# 插件的使用\n\n比如我们需要转换箭头函数，那么我们就可以使用箭头函数转换相关的插件\n\n npm install @babel/plugin-transform-arrow-functions -D\n npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions\n\n\n1\n2\n\n\n查看转换后的结果:我们会发现 const 并没有转成 var\n\n * 这是因为 plugin-transform-arrow-functions，并没有提供这样的功能;\n * 我们需要使用 plugin-transform-block-scoping 来完成这样的功能;\n\nnpm install @babel/plugin-transform-block-scoping -D\nnpx babel src --out-dir dist --plugins=@babel/plugin-transform-block-scoping ,@babel/plugin-transform-arrow-functions\n\n\n1\n2\n\n\n\n# Babel的预设preset\n\n但是如果要转换的内容过多，一个个设置是比较麻烦的，我们可以使用预设(preset)\n\n安装@babel/preset-env预设\n\n npm install @babel/preset-env -D\n\n\n1\n\n\n执行如下命令\n\n npx babel src --out-dir dist --presets=@babel/preset-env\n\n\n1\n\n\n\n# Babel的底层原理\n\nbabel是如何做到将我们的**一段代码(ES6、TypeScript、React)转成另外一段代码(ES5)**的呢?\n\n * 从一种源代码(原生语言)转换成另一种源代码(目标语言)，这是什么的工作呢?\n * 就是编译器，事实上我们可以将babel看成就是一个编译器。\n * Babel编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码;\n\nBabel也拥有编译器的工作流程:\n\n * 解析阶段(Parsing)\n * 转换阶段(Transformation)\n * 生成阶段(Code Generation)\n\nhttps://github.com/jamiebuilds/the-super-tiny-compiler\n\n\n# Babel编译器执行原理\n\nBabel的执行阶段\n\n\n\n当然，这只是一个简化版的编译器工具流程，在每个阶段又会有自己具体的工作\n\n\n\n\n# babel-loader 🔥\n\n在实际开发中，我们通常会在构建工具中通过配置babel来对其进行使用的，比如在webpack中。那么我们就需要去安装相关的依赖，如果之前已经安装了@babel/core，那么这里不需要再次安装\n\n npm install babel-loader @babel/core -D\n\n\n1\n\n\n我们可以设置一个规则，在加载js文件时，使用我们的babel\n\n{\n    test: /\\.js$/,\n    loader: "babel-loader"\n}\n\n\n1\n2\n3\n4\n\n\n我们必须指定使用的插件才会生效\n\n{\n    test: /\\.js$/,\n        use: {\n            loader: "babel-loader",\n                options: {\n                    plugins: [\n                       "@babel/plugin-transform-arrow-functions",\n                       "@babel/plugin-transform-block-scoping",\n                    ]\n                    \n                }\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# babel-preset 🔥\n\n如果我们一个个去安装使用插件，那么需要手动来管理大量的babel插件，我们可以直接给webpack提供一个 preset，webpack会根据我们的预设来加载对应的插件列表，并且将其传递给babel。\n\n比如常见的预设有三个:\n\n * env\n\n * react\n\n * TypeScript\n\n安装preset-env\n\n npm install @babel/preset-env\n\n\n1\n\n\n配置\n\n{\n    test: /\\.js$/,\n        use: {\n            loader: "babel-loader",\n                options: {\n                    // plugins: [\n                    //   "@babel/plugin-transform-arrow-functions",\n                    //   "@babel/plugin-transform-block-scoping",\n                    // ]\n                    presets: [\n                        "@babel/preset-env"\n                    ]\n                }\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# Babel的配置文件\n\n像之前一样，我们可以将babel的配置信息放到一个独立的文件中，babel给我们提供了两种配置文件的编写:\n\n * babel.config.json(或者.js，.cjs，.mjs)文件;\n * .babelrc.json(或者.babelrc，.js，.cjs，.mjs)文件;\n\n它们两个有什么区别呢?目前很多的项目都采用了多包管理的方式(babel本身、element-plus、umi等);\n\n * .babelrc.json:早期使用较多的配置方式，但是对于配置Monorepos项目是比较麻烦的;\n * babel.config.json(babel7):可以直接作用于Monorepos项目的子包，更加推荐;\n\nbabel.config.js\n\nmodule.exports = {\n  presets: [\n    "@babel/preset-env"\n  ]\n}\n\n\n1\n2\n3\n4\n5\n\n\nwebpack.config.js可以精简为\n\n{\n    test: /\\.js$/,\n    loader: "babel-loader"\n}\n\n\n1\n2\n3\n4\n\n\n\n# Vue 打包 🔥\n\n\n# 问题\n\n安装vue\n\nnpm install vue\n\n\n1\n\n\n修改element.js\n\nimport { createApp } from \'vue\';\n\ncreateApp({\n    template: \'#my-app\',\n    data(){\n        return {\n            title: \'标题\',\n            content: \'内容\',\n        }\n    }\n}).mount(\'#app\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n由于vue是js文件，所以打包是正常的。但是界面没有效果，且报如下警告：\n\n\n\n修改为如下的即可\n\nimport { createApp } from \'vue/dist/vue.esm-bundler\';\n\n\n1\n\n\n但是使用SFC时无需改为vue.esm-bundler\n\n\n# Vue打包后不同版本解析\n\n * vue(.runtime).global(.prod).js:\n   \n   * p通过浏览器中的 <script src="..."> 直接使用;\n   * 我们之前通过CDN引入和下载的Vue版本就是这个版本;\n   * 会暴露一个全局的Vue来使用;\n\n * vue(.runtime).esm-browser(.prod).js:\n   \n   * 用于通过原生 ES 模块导入使用 (在浏览器中通过 <script type="module"> 来使用)。\n\n * vue(.runtime).esm-bundler.js:\n\n * 用于 webpack，rollup 和 parcel 等构建工具;\n\n * 构建工具中默认是vue.runtime.esm-bundler.js;\n\n * 如果我们需要解析模板template，那么需要手动指定vue.esm-bundler.js;\n\n * **vue.cjs(.prod).js:\n   \n   * 服务器端渲染使用;\n   * 通过require()在Node.js中使用;\n\n\n# 运行时+编译器 vs 仅运行时\n\n在Vue的开发过程中我们有三种方式来编写DOM元素:\n\n * 方式一:template模板的方式(之前经常使用的方式);\n * 方式二:render函数的方式，使用h函数来编写渲染的内容;\n * 方式三:通过.vue文件中的template来编写模板;\n\n它们的模板分别是如何处理的呢?\n\n * 方式二中的h函数可以直接返回一个虚拟节点，也就是Vnode节点;\n * 方式一和方式三的template都需要有特定的代码来对其进行解析:\n   * 方式三.vue文件中的template可以通过在vue-loader对其进行编译和处理;\n   * 方式一中的template我们必须要通过源码中一部分代码来进行编译;\n\n所以，Vue在让我们选择版本的时候分为 运行时+编译器 vs **仅运行时\n\n * 运行时+编译器包含了对template模板的编译代码，更加完整，但是也更大一些;\n * 仅运行时没有包含对template版本的编译代码，相对更小一些;\n\n\n# VSCode对SFC文件的支持\n\n真实开发中多数情况下我们都是使用SFC(single-file components)，即单文件组件方式\n\nVSCode对SFC的支持:\n\n * 插件一:Vetur，从Vue2开发就一直在使用的VSCode支持Vue的插件;\n * 插件二:Volar，官方推荐的插件(后续会基于Volar开发官方的VSCode插件);\n\n\n# App.vue 打包 🔥\n\nnpm install vue-loader -D\nnpm install @vue/compiler-sfc -D\n\n\n1\n2\n\n\nwebpack.config.js\n\n{\n    test: /\\.vue$/,\n    loader: "vue-loader"\n}\n\n\n1\n2\n3\n4\n\n\n还配置对应的Vue插件\n\nconst { VueLoaderPlugin } = require(\'vue-loader/dist/index\');\n\nmodule.exports = {\n  plugins: [\n    new VueLoaderPlugin(),\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# devServer 🔥\n\n\n# 需求\n\n目前我们开发的代码，为了运行需要有两个操作\n\n * npm run build编译相关代码\n * 通过live server或者直接通过浏览器，打开index.html代码，查看效果\n\n这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成编译和展示。为了完成自动编译，webpack提供了几种可选的方式：\n\n * webpack watch mode\n * webpack-dev-server（常用）\n * webpack-dev-middleware\n\n\n# webpack watch\n\nwebpack给我们提供了watch模式。在该模式下，webpack依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译，我们不需要手动去运行 npm run build指令了\n\n开启watch两种方式\n\n * 在导出的配置中，添加 watch: true。修改webpack.config.js\n   \n   // mode: \'xxx\',\n   watch: true,\n   \n   \n   1\n   2\n   \n\n * 在启动webpack的命令中，添加 --watch的标识。修改package.json\n   \n   "script": {\n      "watch": "webpack --watch" \n   }\n   \n   \n   1\n   2\n   3\n   \n\n\n# webpack-dev-server 🔥\n\n上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的。当然通过在VSCode中使用live-server来完成这样的功能。在不使用live-server的情况下，可以具备live reloading(实时重新加载)的功能\n\n# 安装\n\n * 安装webpack-dev-server\n   \n    npm install webpack-dev-server -D\n   \n   \n   1\n   \n\n * 修改package.json\n   \n   "script": {\n      "serve": "webpack serve" \n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   执行npm run serve即可完成\n\n# contentBase 配置 🔥\n\n修改webpack.config.js配置文件，告知 devServer，从什么位置查找文件\n\ndevServer: {\n    contentBase: "./public",\n}\n\n\n1\n2\n3\n\n\n这里的文件指的是额外的，如favicon.ico 或者其他 x.mp4 之类的资源，一般放在 /public中\n\n * 打包阶段：使用的是copyWepackPlugin插件，每次打包将/public中文件复制到/build中\n * 开发阶段，复制文件比较耗费性能，并且 webpack-dev-server 使用的是内存方式，不适合复制这些静态资源。所以在找不到资源时，就会去配置的contentBase中查找\n\n# host配置 🔥\n\ndevServer: {\n    host: "0.0.0.0",\n}\n\n\n1\n2\n3\n\n\nhost设置主机地址:\n\n * 默认值是localhost;\n * 如果希望其他地方也可以访问，可以设置为0.0.0.0;\n\nlocalhost 和 0.0.0.0 的区别\n\n * localhost:本质上是一个域名，通常情况下会被解析成127.0.0.1;\n * 127.0.0.1:回环地址(Loop Back Address)，表达的意思其实是我们主机自己发出去的包，直接被自己接收;\n   * 正常的数据库包经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ;\n   * 而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的; ü 比如我们监听 127.0.0.1时，在同一个网段下的主机中，通过ip地址是不能访问的\n\n# port、open、compress 配置 🔥\n\n * port设置监听的端口，默认情况下是8080\n\n * open是否打开浏览器\n   \n   默认值是false，设置为true会打开浏览器; 也可以设置为类似于 Google Chrome等值\n\n * compress是否为静态文件开启gzip compression\n   \n   默认值是false，可以设置为true。一般对js进行压缩！\n\n# proxy 配置 🔥\n\n首先要明确，跨域是浏览器的安全策略！服务器之间访问没有跨域问题。proxy就是根据这个原理来解决开发阶段跨域问题！\n\n如，8000访问8888的api\n\ndevServer: {\n\tproxy: {\n      "/api": {\n        target: "http://localhost:8888",\n        pathRewrite: {\n          "^/api": ""\n        },\n        secure: false,\n        changeOrigin: true\n      }\n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nproxy是我们开发（生产中不 用这个！）中非常常用的一个配置选项，它的目的设置代理来解决跨域访问的问题:\n\n * 比如我们的一个api请求是 http://localhost:8888，但是本地启动服务器的域名是 http://localhost:8000，这 个时候发送网络请求就会出现跨域的问题;\n\n * 那么我们可以将请求先发送到一个代理服务器，代理服务器和API服务器没有跨域的问题，就可以解决我们的跨域问题了;\n\n进行如下的设置\n\n * **target:**表示的是代理到的目标地址，比如 /api-hy/moment会被代理到 http://localhost:8888/api-hy/moment;\n * **pathRewrite:**默认情况下，我们的 /api-hy 也会被写入到URL中，如果希望删除，可以使用pathRewrite;\n * **secure:**默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false; 开发阶段可以置为false\n * **changeOrigin:**它表示是否更新代理后请求的headers中host地址（将target配置写入header）。\n\n# historyApiFallback 配置\n\n和路由有关！\n\nhistoryApiFallback是开发中一个非常常见的属性，它主要的作用是解决SPA页面在路由跳转之后，进行页面刷新时，返回404的错误。\n\nboolean值：\n\n * 默认是false\n * 如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容\n\nobject类型的值，可以配置rewrites属性(了解)：\n\n * 可以配置from来匹配路径，决定要跳转到哪一个页面\n\n事实上devServer中实现historyApiFallback功能是通过connect-history-api-fallback库的\n\n\n# HMR 模块热替换 🔥\n\n# 介绍\n\nHMR的全称是Hot Module Replacement，翻译为模块热替换。指在 应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面。\n\nHMR通过如下几种方式，来提高开发的速度：\n\n * 不重新加载整个页面，这样可以保留某些应用程序的状态不丢失。如计数器\n * 只更新需要变化的内容，节省开发的时间\n * 修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的devtools中直接修改样式\n\n默认情况下，webpack-dev-server已经支持HMR，我们只需要开启即可。在不开启HMR的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是live reloading\n\n# hot 配置 🔥\n\n修改webpack.config.js配置文件\n\ntarget: \'web\', // 这个不配置有时会出问题！\ndevServer: {\n    hot: true,\n}\n\n\n1\n2\n3\n4\n\n\n浏览器可以看到如下效果\n\n\n\n但是你会发现，当我们修改了某一个模块的代码时，依然是刷新的整个页面。这是因为我们需要去指定哪些模块发生更新时，进行HMR。导入文件的方式还需要添加HMR方式！！！如main.js中：\n\nimport \'./js/element\'; // 旧方式，不能删\n\n// HMR 方式\nif(module.hot) {\n \tmodule.hot.accept(\'./js/element.js\', () => {\n        console.log(\'element HMR\');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面方式太麻烦了！！！\n\n# 框架的HMR 🔥\n\n在开发其他项目时，我们是否需要经常手动去写入 module.hot.accpet相关的API呢?比如开发Vue、React项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作呢? 事实上社区已经针对这些有很成熟的解决方案了;\n\n * 比如vue开发中，我们使用vue-loader，此loader支持vue组件的HMR，提供开箱即用的体验;\n\n * 比如react开发中，有React Hot Loader，实时调整react组件(目前React官方已经弃用了，改成使用react-refresh);\n\n注意：有时TS文件的HMR也需要手动配置！使用vben项目时遇到该问题！\n\n# HMR 原理 🔥\n\nwebpack-dev-server会创建两个服务:提供静态资源的服务(express)和Socket服务(net.Socket);\n\n * express server负责直接提供静态资源的服务(打包后的资源直接被浏览器请求和解析);\n * HMR Socket Server，是一个socket的长连接\n   * 长连接有一个最好的好处是建立连接后双方可以通信(服务器可以直接发送文件到客户端);\n   * 当服务器监听到对应的模块发生变化时，会生成两个文件.json(manifest文件)和.js文件(update chunk);\n   * 通过长连接，可以直接将这两个文件主动发送给客户端(浏览器);\n   * 浏览器拿到两个新的文件后，通过HMR runtime机制，加载这两个文件，并且针对修改的模块进行更新;\n\n\n\n\n# resolve 模块解析配置\n\n\n# 介绍\n\nresolve用于设置模块如何被解析:\n\n * 在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库;\n * resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码;\n * webpack 使用 enhanced-resolve 来解析文件路径;\n\n\n# 路径\n\nwebpack能解析三种文件路径\n\n * 绝对路径：由于已经获得文件的绝对路径，因此不需要再做进一步解析\n * 相对路径：\n   * 在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录\n   * 在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径\n * 模块路径（如 import { createApp } from \'vue\';：\n   * 在 resolve.modules中指定的所有目录检索模块。默认值是 [\'node_modules\']，所以默认会从node_modules中查找文件\n   * 我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解alias的配置\n\n\n# 文件？文件夹？\n\n * 如果是一个文件\n   \n   * 如果文件具有扩展名，则直接打包文件\n   * 否则，将使用 resolve.extensions选项作为文件扩展名解析（依次匹配扩展查询文件）\n\n * 如果是一个文件夹\n   \n   会在文件夹中根据 resolve.mainFiles配置选项中指定的文件顺序查找\n   \n   * resolve.mainFiles的默认值是 [\'index\']\n   * 再根据 resolve.extensions来解析扩展名\n   \n   所以一般查找到index文件\n\n\n# extensions和alias配置\n\nextensions是解析到文件时自动添加扩展名:\n\n * 默认值是 [\'.wasm\', \'.mjs\', \'.js\', \'.json\'];\n * 所以如果我们代码中想要添加加载 .vue 或者 jsx 或者 ts 等文件时，我们必须自己写上扩展名;\n\n另一个非常好用的功能是配置别名alias:\n\n * 特别是当我们项目的目录结构比较深的时候，或者一个文件的路径可能需要 ../../../这种路径片段;\n * 我们可以给某些常见的路径起一个别名;\n\n\n# 配置 🔥\n\n修改webpack.config.js配置文件\n\nresolve: {\n    extensions: [".js", ".json", ".mjs", ".vue", ".ts", ".jsx", ".tsx"],\n    alias: {\n      "@": path.resolve(__dirname, "./src"),\n      "js": path.resolve(__dirname, "./src/js")\n    }\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 分离开发生产环境 🔥\n\n目前我们所有的webpack配置信息都是放到一个配置文件中的:webpack.config.js\n\n * 当配置越来越多时，这个文件会变得越来越不容易维护;\n\n * 并且某些配置是在开发环境需要使用的，某些配置是在生成环境需要使用的，当然某些配置是在开发和生成环 境都会使用的;\n\n * 所以，我们最好对配置进行划分，方便我们维护和管理;\n\n那么，在启动时如何可以区分不同的配置呢?\n\n * 方案一：编写两个不同的配置文件，开发和生成时，分别加载不同的配置文件即可;\n\n * 方式二：使用相同的一个入口配置文件，通过设置参数来区分它们;\n   \n   修改package.json\n   \n   {\n       "scripts": {\n           "build": "webpack --config ./config/webpack.prod.config.js",\n           "serve": "webpack serve --config ./config/webpack.dev.config.js"\n       },   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   安装merge\n   \n   npm install webpack-merge -D\n   \n   \n   1\n   \n\n配置文件\n\n/config/webpack.comm.config.js\n\nconst path = require("path");\nconst HtmlWebpackPlugin = require("html-webpack-plugin");\nconst { DefinePlugin } = require("webpack");\nconst { VueLoaderPlugin } = require(\'vue-loader/dist/index\');\n\nmodule.exports = {\n  target: "web",\n  entry: "./src/main.js",\n  output: {\n    path: path.resolve(__dirname, "../build"),\n    filename: "js/bundle.js",\n  },\n  resolve: {\n    extensions: [".js", ".json", ".mjs", ".vue", ".ts", ".jsx", ".tsx"],\n    alias: {\n      "@": path.resolve(__dirname, "../src"),\n      "js": path.resolve(__dirname, "../src/js")\n    }\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ["style-loader", "css-loader", "postcss-loader"],\n      },\n      {\n        test: /\\.less$/,\n        use: ["style-loader", "css-loader", "less-loader"],\n      },\n      // },\n      {\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        type: "asset",\n        generator: {\n          filename: "img/[name]_[hash:6][ext]",\n        },\n        parser: {\n          dataUrlCondition: {\n            maxSize: 10 * 1024,\n          },\n        },\n      },\n      {\n        test: /\\.(eot|ttf|woff2?)$/,\n        type: "asset/resource",\n        generator: {\n          filename: "font/[name]_[hash:6][ext]",\n        },\n      },\n      {\n        test: /\\.js$/,\n        loader: "babel-loader"\n      },\n      {\n        test: /\\.vue$/,\n        loader: "vue-loader"\n      }\n    ],\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: "./public/index.html",\n      title: "哈哈哈哈"\n    }),\n    new DefinePlugin({\n      BASE_URL: "\'./\'",\n      __VUE_OPTIONS_API__: true,\n      __VUE_PROD_DEVTOOLS__: false\n    }),\n    new VueLoaderPlugin()\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n/config/webpack.dev.config.js\n\nconst { merge } = require(\'webpack-merge\');\n\nconst commonConfig = require(\'./webpack.comm.config\');\n\nmodule.exports = merge(commonConfig, {\n  mode: "development",\n  devtool: "source-map",\n  devServer: {\n    contentBase: "./public",\n    hot: true,\n    // host: "0.0.0.0",\n    port: 7777,\n    open: true,\n    // compress: true,\n    proxy: {\n      "/api": {\n        target: "http://localhost:8888",\n        pathRewrite: {\n          "^/api": ""\n        },\n        secure: false,\n        changeOrigin: true\n      }\n    }\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n/config/webpack.prod.config.js\n\nconst { CleanWebpackPlugin } = require("clean-webpack-plugin");\nconst CopyWebpackPlugin = require(\'copy-webpack-plugin\');\nconst {merge} = require(\'webpack-merge\');\n\nconst commonConfig = require(\'./webpack.comm.config\');\n\nmodule.exports = merge(commonConfig, {\n  mode: "production",\n  plugins: [\n    new CleanWebpackPlugin(),\n    new CopyWebpackPlugin({\n      patterns: [\n        {\n          from: "./public",\n          globOptions: {\n            ignore: [\n              "**/index.html"\n            ]\n          }\n        }\n      ]\n    }),\n  ]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',normalizedContent:'# 入门\n\n\n# 介绍\n\n本质上，webpack 是一个用于现代 javascript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。\n\n * 现代的modern：我们前端说过，正是因为现代前端开发面临各种各样的问题，才催生了webpack的出现和发展\n * 静态的static：这样表述的原因是我们最终可以将代码打包成最终的静态资源(部署到静态服务器)\n * 模块化module：webpack默认支持各种模块化开发，es module、commonjs、amd等\n * 打包bundler：webpack可以将帮助我们进行打包，所以它是一个打包工具\n\n\n# 打包的东西\n\njavascript的打包:\n\n * es6转换成es5的语法;\n * typescript的处理，将其转换成javascript;\n\ncss的处理:\n\n * css文件模块的加载、提取;\n * less、sass等预处理器的处理;\n\n资源文件img、font:\n\n * 图片img文件的加载;\n * 字体font文件的加载;\n\nhtml资源的处理\n\n * 打包html资源文件;\n\n处理vue项目的sfc文件.vue文件;\n\n\n# node 和 npm 版本\n\n目前使用的版本\n\nv14.18.3\n6.14.15\n\n\n1\n2\n\n\n\n# webpack & webpack-cli\n\nwebpack的安装目前分为两个：webpack、webpack-cli\n\n·那么它们是什么关系呢?\n\n * 执行webpack命令，会执行node_modules下的.bin目录下的webpack;\n * webpack在执行时是依赖webpack-cli的，如果没有安装就会报错;\n * 而webpack-cli中代码执行时，才是真正利用webpack进行编译和打包的过程;\n * 所以在安装webpack时，我们需要同时安装webpack-cli(第三方的脚手架事实上是没有使用webpack-cli的，而是类似于自己的vue-service-cli的东西)\n\n\n\n\n# 全局 webpack 打包\n\n安装\n\nnpm install webpack webpack-cli –g # 全局安装 \n\n\n1\n\n\n创建如下文件\n\n\n\n/index.html\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    \x3c!-- 源js文件无法运行 --\x3e\n    <script src="./src/index.js" type="module"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n/src/index.js\n\nimport { sum } from "./js/math";\nconst { priceformat } = require("./js/format");\n\nconsole.log(sum(20, 30));\nconsole.log(priceformat());\n\n\n1\n2\n3\n4\n5\n\n\n/src/js/format.js\n\nconst priceformat = function() {\n  return "¥99.88";\n}\n\n// commonjs的导出\nmodule.exports = {\n  priceformat\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n/src/js/math.js\n\n// es module\nexport function sum(num1, num2) {\n  return num1 + num2;\n}\n\n\n1\n2\n3\n4\n\n\n在项目/目录下执行webpack，会生成/dist/main.js，将html替换为\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    \x3c!-- 源js文件无法运行 --\x3e\n    \x3c!-- <script src="./src/index.js" type="module"><\/script> --\x3e\n    \x3c!-- 打包后的js文件可以访问 --\x3e\n    <script src="./dist/main.js"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n就会运行成功！\n\n\n# 局部 webpack 打包 🔥\n\nnpm init\nnpm install webpack webpack-cli -d\nnpx webpack\n\n\n1\n2\n3\n\n\nnpx意思是在npm安装的node_modules中的.bin目录下查找命令\n\n在package.json中创建scripts脚本，执行脚本打包即可\n\n  "scripts": {\n    "build": "webpack"\n  },\n\n\n1\n2\n3\n\n\n此时只写webpack，它会自动先在node_modules中的.bin目录下查找命令。执行如下命令即可打包\n\nnpm run build\n\n\n1\n\n\n\n# 入口、出口文件配置 🔥\n\n当我们运行webpack时，webpack会查找当前目录下的 src/index.js作为入口，不存在则报错\n\n可以通过配置来指定入口和出口：\n\n npx webpack --entry ./src/main.js --output-path ./build\n\n\n1\n\n\n但是不推荐该方式，可以在项目根目录创建wepack.config.js文件\n\nconst path = require(\'path\')\n\n// webpack在node环境运行，node使用的commonjs，要改为es6需要配置，比较麻烦\nmodule.exports = {\n  // 入口文件名\n  entry: \'./src/main.js\',\n  output: {\n    // path必须是绝对路径！！！，__dirname代表当前文件（webpack.config.js）所在绝对路径\n    path: path.resolve(__dirname, \'./build\'),\n    filename: \'bundle.js\',\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n在package.json中修改scripts脚本即可使用\n\n"build": "webpack"\n\n\n1\n\n\n若是创建的文件名不是默认的，而是如conana.config.js，则需要修改scripts脚本。不推荐！！！\n\n"build": "webpack --config conana.config.js"\n\n\n1\n\n\n\n# webpack的依赖图\n\n\n\n * 事实上webpack在处理应用程序时，它会根据命令或者配置文件找到入口文件\n * 从入口开始，会生成一个依赖关系图，这个依赖关系图会包含应用程序中所需的所有模块(比如.js文件、css文件、图片、字 体等)\n * 然后遍历图结构，打包一个个模块(根据文件的不同使用不同的loader来解析)\n * 注意，没有依赖到的不会打包！！！\n\n\n# 打包 css\n\ncss-loader 是将 css 解析、装载；style-loader 是将解析、装载的 css 添加到 style 标签中。\n\nnpm install css-loader style-loader -d\n\n\n1\n\n\n配置webpack.config.js\n\nmodule.exports = {\\\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        // loader: \'css-loader\',\n        // use: [\'css-loader\'],\n        // 完整写法(倒序执行！！！)\n        use: [\n          { loader: \'style-loader\', options: {} },\n          { loader: \'css-loader\', options: {} },\n        ],\n      },\n    ],\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 打包 less、scss、stylus\n\n这里以 less 为例。less会将less文件转换为css文件，安装后会有个lessc可执行文件；less-loader会批量将less文件转为css文件\n\nnpm install less less-loader -d\n\n\n1\n\n\n配置webpack.config.js\n\ngmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.less$/,\n        use: [\n          { loader: \'style-loader\', options: {} },\n          { loader: \'css-loader\', options: {} },\n          { loader: \'less-loader\', options: {} },\n        ],\n      },\n    ],\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# postcss\n\ncss的转换和适配，比如自动添加浏览器前缀、css样式的重置。实现这些功能，我们需要借助于postcss对应的插件\n\n如何使用postcss呢?主要就是两个步骤:\n\n * 第一步:查找postcss在构建工具中的扩展，比如webpack中的postcss-loader;\n * 第二步:选择可以添加你需要的postcss相关的插件;\n\n\n# 安装 postcss、postcss-cli\n\nnpm install postcss postcss-cli -d\n\n\n1\n\n\npostcss-cli可以直接在终端使用postcss\n\n我们编写一个需要添加前缀的csshttps://autoprefixer.github.io/，在该网站中查询一些添加css属性的样式;\n\n\n# 插件autoprefixer（可不用该插件）\n\n添加前缀，所以要安装autoprefixer\n\n npm install autoprefixer -d\n\n\n1\n\n\n直接使用使用postcss工具，并且制定使用autoprefixer\n\n npx postcss --use autoprefixer -o end.css ./src/css/style.css\n\n\n1\n\n\n\n# postcss-loader\n\n真实开发中我们必然不会直接使用命令行工具来对css进行处理，而是可以借助于构建工具。在webpack中使用postcss就是使用postcss-loader来处理的\n\n npm install postcss-loader -d\n\n\n1\n\n\n修改加载css的loader。注意:因为postcss需要有对应的插件才会起效果，所以我们需要配置它的plugin\n\n{\n    loader: \'postcss-loader\',\n        options: {\n            postcssoptions: {\n                plugins: [\n                    require(\'autoprefixer\')\n                ]\n            },\n        },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n当然，我们也可以将这些配置信息放到一个单独的文件中进行管理，在根目录下创建postcss.config.js\n\nmodule.exports = {\n  plugins: [\n      require(\'autoprefixer\')\n  ],\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# postcss-preset-env\n\n事实上，在配置postcss-loader时，我们配置插件并不需要使用autoprefixer，我们可以使用另外一个插件:postcss-preset-env\n\n * postcss-preset-env也是一个postcss的插件;\n * 它可以帮助我们将一些现代的css特性，转成大多数浏览器认识的css，并且会根据目标浏览器或者运行时环境 添加所需的polyfill\n * 也包括会自动帮助我们添加autoprefixer(所以相当于已经内置了autoprefixer)\n\n npm install postcss-preset-env -d\n\n\n1\n\n\n之后，我们直接修改掉之前的autoprefixer即可\n\nmodule.exports = {\n  plugins: [\n      require(\'postcss-preset-env\')\n  ],\n}\n\n\n1\n2\n3\n4\n5\n\n\n注意:我们在使用某些postcss插件时，也可以直接传入字符串\n\nmodule.exports = {\n  plugins: [\n      \'postcss-preset-env\'\n  ],\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# postcss 完整配置\n\nwebpack.config.js\n\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: [\n          { loader: \'style-loader\', options: {} },\n          { loader: \'css-loader\', options: {} },\n          {\n            loader: \'postcss-loader\',\n            options: {},\n          },\n        ],\n      },\n      {\n        test: /\\.less$/,\n        use: [\n          { loader: \'style-loader\', options: {} },\n          { loader: \'css-loader\', options: {} },\n          {\n            loader: \'postcss-loader\',\n            options: {},\n          },\n          { loader: \'less-loader\', options: {} },\n        ],\n      },\n    ],\n  },\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\npostcss.config.js\n\nmodule.exports = {\n  plugins: [require(\'postcss-preset-env\')],\n}\n\n\n1\n2\n3\n\n\n\n# 打包资源\n\n为了演示我们项目中可以加载图片，我们需要在项目中使用图片，比较常见的使用图片的方式是两种\n\n * img元素，设置src属性;\n * 其他元素(比如div)，设置background-image的css属性;\n\n\n# file-loader\n\n要处理jpg、png等格式的图片，我们也需要有对应的loader:file-loader\n\nfile-loader的作用就是帮助我们处理import/require()方式引入的一个文件资源，并且会将它放到我们输出的文件夹中;\n\n当然我们待会儿可以学习如何修改它的名字和所在文件夹\n\nnpm install file-loader -d\n\n\n1\n\n\n有时候我们处理后的文件名称按照一定的规则进行显示，比如保留原来的文件名、扩展名，同时为了防止重复，包含一个hash值等;\n\n这个时候我们可以使用placeholders来完成，webpack给我们提供了大量的placeholders来显示不同的内容: https://webpack.js.org/loaders/file-loader/#placeholders。我们可以在文档中查阅自己需要的placeholder;\n\n我们这里介绍几个最常用的placeholder:\n\n * [ext]: 处理文件的扩展名;\n * [name]:处理文件的名称;\n * [hash]:文件的内容，使用md4的散列函数处理，生成的一个128位的hash值(32个十六进制);\n * [contenthash]:在file-loader中和[hash]结果是一致的(在webpack的一些其他地方不一样，后面会讲到);\n * [hash:<length>]:截图hash的长度，默认32个字符太长了;\n * [path]:文件相对于webpack配置文件的路径;\n\n# 完整配置\n\n{\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        use: {\n          // file-loader 和 url-loader 根据需要选择一个\n          loader: \'file-loader\',\n          // loader: \'url-loader\',\n          options: {\n            // outputpath: "img",\n            name: \'img/[name]_[hash:6].[ext]\',\n          },\n        },\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# url-loader\n\nurl-loader和file-loader的工作方式是相似的，但是可以将较小的文件，转成base64的uri\n\n npm install url-loader -d\n\n\n1\n\n\ndist文件夹中，我们会看不到图片文件:\n\n * 这是因为我的两张图片的大小分别是38kb和295kb;\n * 默认情况下url-loader会将所有的图片文件转成base64编码\n\n但是开发中我们往往是小的图片需要转换，但是大的图片直接使用图片即可\n\n * 这是因为小的图片转换base64之后可以和页面一起被请求，减少不必要的请求过程\n * 而大的图片也进行转换，反而会影响页面的请求速度;\n\nurl-loader有一个options属性limit，可以用于设置转换的限制;\n\n{\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        use: {\n          // file-loader 和 url-loader 根据需要选择一个\n          // loader: \'file-loader\',\n          loader: \'url-loader\',\n          options: {\n            // outputpath: "img",\n            name: \'img/[name]_[hash:6].[ext]\',\n            limit: 100 * 1024,\n          },\n        },\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 字体文件\n\n{\n        test: /\\.(eot|ttf|woff2?)$/,\n        use: {\n          loader: "file-loader",\n          options: {\n            // outputpath: "font",\n            name: "font/[name]_[hash:6].[ext]"\n          }\n        }\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# asset module type 🔥\n\n我们当前使用的webpack版本是webpack5:\n\n * 在webpack5之前，加载这些资源我们需要使用一些loader，比如raw-loader 、url-loader、file-loader;\n * 在webpack5开始，我们可以直接使用资源模块类型(asset module type)，来替代上面的这些loader;\n\n资源模块类型(asset module type)，通过添加 4 种新的模块类型，来替换所有这些 loader:\n\n * asset/resource 发送一个单独的文件并导出 url。之前通过使用 file-loader 实现;\n * asset/inline 导出一个资源的 data uri。之前通过使用 url-loader 实现;\n * asset/source 导出资源的源代码。之前通过使用 raw-loader 实现;\n * asset 在导出一个 data uri 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体 积限制实现;\n\n# 完整配置\n\n// webpack5的asset module type替换file-loader 和 url-loader等\n      {\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        type: \'asset\',\n        generator: {\n          filename: \'img/[name]_[hash:6][ext]\',\n        },\n        parser: {\n          dataurlcondition: {\n            maxsize: 100 * 1024,\n          },\n        },\n      },\n          {\n        test: /\\.(eot|ttf|woff2?)$/,\n        type: \'asset/resource\',\n        generator: {\n          filename: \'font/[name]_[hash:6][ext]\',\n        },\n      },\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n效果和上述url-loader、file-loader一样！！！\n\n\n# plugin\n\nwebpack的另一个核心是plugin，官方有这样一段对plugin的描述:\n\nwhile loaders are used to transform certain types of modules, plugins can be leveraged to perform a wider range of tasks like bundle optimization, asset management and injection of environment variables.\n\n上面表达的含义翻译过来就是:\n\n * loader是用于特定的模块类型进行转换;\n * plugin可以用于执行更加广泛的任务，比如打包优化、资源管理、环境变量注入等;\n\n\n\n\n# cleanwebpackplugin\n\n前面我们演示的过程中，每次修改了一些配置，重新打包时，都需要手动删除dist文件夹。我们可以借助于一个插件来帮助我们完成，这个插件就是cleanwebpackplugin\n\n npm install clean-webpack-plugin -d\n\n\n1\n\n\n配置\n\nconst { cleanwebpackplugin } = require("clean-webpack-plugin");\n\nmodule.exports = {\n  plugins: [\n    new cleanwebpackplugin(),\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# htmlwebpackplugin\n\n另外还有一个不太规范的地方:\n\n * 我们的html文件是编写在根目录下的，而最终打包的dist文件夹中是没有index.html文件的。\n * 在进行项目部署的时，必然也是需要有对应的入口文件index.html;\n * 所以我们也需要对index.html进行打包处理;\n\n npm install html-webpack-plugin -d\n\n\n1\n\n\n配置（可以在public中使用自定义模板）\n\nconst htmlwebpackplugin = require("html-webpack-plugin");\n\n\nmodule.exports = {\n  plugins: [\n      new htmlwebpackplugin({\n      \ttemplate: "./public/index.html",\n      \ttitle: "哈哈哈哈"\n      }),\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# defineplugin\n\n这是因为在编译template模块时，有一个base_url<link rel="icon" href="<%= base_url %>favicon.ico">但是我们并没有设置过这个常量值，所以会出现没有定义的错误，可以使用defineplugin插件;\n\ndefineplugin允许在编译时创建配置的全局常量，是一个webpack内置的插件(不需要单独安装)\n\nconst { defineplugin } = require("webpack");\n\nmodule.exports = {\n  plugins: [\n      new defineplugin({\n      \tbase_url: "\'./\'"\n      }),\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# copywebpackplugin\n\n在vue的打包过程中，如果我们将一些文件放到public的目录下，那么这个目录会被复制到dist文件夹中。 这个复制的功能，我们可以使用copywebpackplugin来完成;\n\n npm install copy-webpack-plugin -d\n\n\n1\n\n\n配置copywebpackplugin：\n\n * 复制的规则在patterns中设置;\n * **from:**设置从哪一个源中开始复制;\n * **to:**复制到的位置，可以省略，会默认复制到打包的目录下;\n * **globoptions:**设置一些额外的选项，其中可以编写需要忽略的文件:\n   * .ds_store:mac目录下回自动生成的一个文件;\n   * index.html:也不需要复制，因为我们已经通过htmlwebpackplugin完成了index.html的生成;\n\nconst copywebpackplugin = require(\'copy-webpack-plugin\');\n\nmodule.exports = {\n  plugins: [\n      new copywebpackplugin({\n      patterns: [\n        {\n          from: "public",\n          to: "./",\n          globoptions: {\n            ignore: [\n              "**/index.html"\n            ]\n          }\n        }\n      ]\n    })\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# mode配置\n\nmode配置选项，可以告知webpack使用响应模式的内置优化:\n\n * 默认值是production(什么都不设置的情况下);\n * 可选值有:\'none\' | \'development\' | \'production\'\n\n\n\n  // 设置模式\n  // development 开发阶段, 会设置development\n  // production 准备打包上线的时候, 设置production\n  mode: "development",\n  // 设置source-map, 建立js映射文件, 方便调试代码和错误\n  devtool: "source-map",\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# babel\n\n\n# 介绍\n\n开发中，我们想要使用es6+的语法，想要使用typescript，开发react项目，它们都是离不开babel的。所以，学习babel对于我们理解代码从编写到线上的转变过程至关重要\n\nbabel是一个工具链，主要用于旧浏览器或者环境中将ecmascript 2015+代码转换为向后兼容版本的 javascript。如语法转换、源代码转换等\n\n\n# babel命令行使用\n\nbabel本身可以作为一个独立的工具(和postcss一样)，不和webpack等构建工具配置来单独使用\n\n如果我们希望在命令行尝试使用babel，需要安装如下库\n\n * @babel/core:babel的核心代码，必须安装;\n * @babel/cli:可以让我们在命令行使用babel;\n\n npm install @babel/cli @babel/core -d\n\n\n1\n\n\n使用babel来处理我们的源代码:\n\n * src:是源文件的目录;\n * --out-dir:指定要输出的文件夹dist;\n\n npx babel src --out-dir dist\n\n\n1\n\n\n\n# 插件的使用\n\n比如我们需要转换箭头函数，那么我们就可以使用箭头函数转换相关的插件\n\n npm install @babel/plugin-transform-arrow-functions -d\n npx babel src --out-dir dist --plugins=@babel/plugin-transform-arrow-functions\n\n\n1\n2\n\n\n查看转换后的结果:我们会发现 const 并没有转成 var\n\n * 这是因为 plugin-transform-arrow-functions，并没有提供这样的功能;\n * 我们需要使用 plugin-transform-block-scoping 来完成这样的功能;\n\nnpm install @babel/plugin-transform-block-scoping -d\nnpx babel src --out-dir dist --plugins=@babel/plugin-transform-block-scoping ,@babel/plugin-transform-arrow-functions\n\n\n1\n2\n\n\n\n# babel的预设preset\n\n但是如果要转换的内容过多，一个个设置是比较麻烦的，我们可以使用预设(preset)\n\n安装@babel/preset-env预设\n\n npm install @babel/preset-env -d\n\n\n1\n\n\n执行如下命令\n\n npx babel src --out-dir dist --presets=@babel/preset-env\n\n\n1\n\n\n\n# babel的底层原理\n\nbabel是如何做到将我们的**一段代码(es6、typescript、react)转成另外一段代码(es5)**的呢?\n\n * 从一种源代码(原生语言)转换成另一种源代码(目标语言)，这是什么的工作呢?\n * 就是编译器，事实上我们可以将babel看成就是一个编译器。\n * babel编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码;\n\nbabel也拥有编译器的工作流程:\n\n * 解析阶段(parsing)\n * 转换阶段(transformation)\n * 生成阶段(code generation)\n\nhttps://github.com/jamiebuilds/the-super-tiny-compiler\n\n\n# babel编译器执行原理\n\nbabel的执行阶段\n\n\n\n当然，这只是一个简化版的编译器工具流程，在每个阶段又会有自己具体的工作\n\n\n\n\n# babel-loader 🔥\n\n在实际开发中，我们通常会在构建工具中通过配置babel来对其进行使用的，比如在webpack中。那么我们就需要去安装相关的依赖，如果之前已经安装了@babel/core，那么这里不需要再次安装\n\n npm install babel-loader @babel/core -d\n\n\n1\n\n\n我们可以设置一个规则，在加载js文件时，使用我们的babel\n\n{\n    test: /\\.js$/,\n    loader: "babel-loader"\n}\n\n\n1\n2\n3\n4\n\n\n我们必须指定使用的插件才会生效\n\n{\n    test: /\\.js$/,\n        use: {\n            loader: "babel-loader",\n                options: {\n                    plugins: [\n                       "@babel/plugin-transform-arrow-functions",\n                       "@babel/plugin-transform-block-scoping",\n                    ]\n                    \n                }\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# babel-preset 🔥\n\n如果我们一个个去安装使用插件，那么需要手动来管理大量的babel插件，我们可以直接给webpack提供一个 preset，webpack会根据我们的预设来加载对应的插件列表，并且将其传递给babel。\n\n比如常见的预设有三个:\n\n * env\n\n * react\n\n * typescript\n\n安装preset-env\n\n npm install @babel/preset-env\n\n\n1\n\n\n配置\n\n{\n    test: /\\.js$/,\n        use: {\n            loader: "babel-loader",\n                options: {\n                    // plugins: [\n                    //   "@babel/plugin-transform-arrow-functions",\n                    //   "@babel/plugin-transform-block-scoping",\n                    // ]\n                    presets: [\n                        "@babel/preset-env"\n                    ]\n                }\n        }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# babel的配置文件\n\n像之前一样，我们可以将babel的配置信息放到一个独立的文件中，babel给我们提供了两种配置文件的编写:\n\n * babel.config.json(或者.js，.cjs，.mjs)文件;\n * .babelrc.json(或者.babelrc，.js，.cjs，.mjs)文件;\n\n它们两个有什么区别呢?目前很多的项目都采用了多包管理的方式(babel本身、element-plus、umi等);\n\n * .babelrc.json:早期使用较多的配置方式，但是对于配置monorepos项目是比较麻烦的;\n * babel.config.json(babel7):可以直接作用于monorepos项目的子包，更加推荐;\n\nbabel.config.js\n\nmodule.exports = {\n  presets: [\n    "@babel/preset-env"\n  ]\n}\n\n\n1\n2\n3\n4\n5\n\n\nwebpack.config.js可以精简为\n\n{\n    test: /\\.js$/,\n    loader: "babel-loader"\n}\n\n\n1\n2\n3\n4\n\n\n\n# vue 打包 🔥\n\n\n# 问题\n\n安装vue\n\nnpm install vue\n\n\n1\n\n\n修改element.js\n\nimport { createapp } from \'vue\';\n\ncreateapp({\n    template: \'#my-app\',\n    data(){\n        return {\n            title: \'标题\',\n            content: \'内容\',\n        }\n    }\n}).mount(\'#app\');\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n由于vue是js文件，所以打包是正常的。但是界面没有效果，且报如下警告：\n\n\n\n修改为如下的即可\n\nimport { createapp } from \'vue/dist/vue.esm-bundler\';\n\n\n1\n\n\n但是使用sfc时无需改为vue.esm-bundler\n\n\n# vue打包后不同版本解析\n\n * vue(.runtime).global(.prod).js:\n   \n   * p通过浏览器中的 <script src="..."> 直接使用;\n   * 我们之前通过cdn引入和下载的vue版本就是这个版本;\n   * 会暴露一个全局的vue来使用;\n\n * vue(.runtime).esm-browser(.prod).js:\n   \n   * 用于通过原生 es 模块导入使用 (在浏览器中通过 <script type="module"> 来使用)。\n\n * vue(.runtime).esm-bundler.js:\n\n * 用于 webpack，rollup 和 parcel 等构建工具;\n\n * 构建工具中默认是vue.runtime.esm-bundler.js;\n\n * 如果我们需要解析模板template，那么需要手动指定vue.esm-bundler.js;\n\n * **vue.cjs(.prod).js:\n   \n   * 服务器端渲染使用;\n   * 通过require()在node.js中使用;\n\n\n# 运行时+编译器 vs 仅运行时\n\n在vue的开发过程中我们有三种方式来编写dom元素:\n\n * 方式一:template模板的方式(之前经常使用的方式);\n * 方式二:render函数的方式，使用h函数来编写渲染的内容;\n * 方式三:通过.vue文件中的template来编写模板;\n\n它们的模板分别是如何处理的呢?\n\n * 方式二中的h函数可以直接返回一个虚拟节点，也就是vnode节点;\n * 方式一和方式三的template都需要有特定的代码来对其进行解析:\n   * 方式三.vue文件中的template可以通过在vue-loader对其进行编译和处理;\n   * 方式一中的template我们必须要通过源码中一部分代码来进行编译;\n\n所以，vue在让我们选择版本的时候分为 运行时+编译器 vs **仅运行时\n\n * 运行时+编译器包含了对template模板的编译代码，更加完整，但是也更大一些;\n * 仅运行时没有包含对template版本的编译代码，相对更小一些;\n\n\n# vscode对sfc文件的支持\n\n真实开发中多数情况下我们都是使用sfc(single-file components)，即单文件组件方式\n\nvscode对sfc的支持:\n\n * 插件一:vetur，从vue2开发就一直在使用的vscode支持vue的插件;\n * 插件二:volar，官方推荐的插件(后续会基于volar开发官方的vscode插件);\n\n\n# app.vue 打包 🔥\n\nnpm install vue-loader -d\nnpm install @vue/compiler-sfc -d\n\n\n1\n2\n\n\nwebpack.config.js\n\n{\n    test: /\\.vue$/,\n    loader: "vue-loader"\n}\n\n\n1\n2\n3\n4\n\n\n还配置对应的vue插件\n\nconst { vueloaderplugin } = require(\'vue-loader/dist/index\');\n\nmodule.exports = {\n  plugins: [\n    new vueloaderplugin(),\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# devserver 🔥\n\n\n# 需求\n\n目前我们开发的代码，为了运行需要有两个操作\n\n * npm run build编译相关代码\n * 通过live server或者直接通过浏览器，打开index.html代码，查看效果\n\n这个过程经常操作会影响我们的开发效率，我们希望可以做到，当文件发生变化时，可以自动的完成编译和展示。为了完成自动编译，webpack提供了几种可选的方式：\n\n * webpack watch mode\n * webpack-dev-server（常用）\n * webpack-dev-middleware\n\n\n# webpack watch\n\nwebpack给我们提供了watch模式。在该模式下，webpack依赖图中的所有文件，只要有一个发生了更新，那么代码将被重新编译，我们不需要手动去运行 npm run build指令了\n\n开启watch两种方式\n\n * 在导出的配置中，添加 watch: true。修改webpack.config.js\n   \n   // mode: \'xxx\',\n   watch: true,\n   \n   \n   1\n   2\n   \n\n * 在启动webpack的命令中，添加 --watch的标识。修改package.json\n   \n   "script": {\n      "watch": "webpack --watch" \n   }\n   \n   \n   1\n   2\n   3\n   \n\n\n# webpack-dev-server 🔥\n\n上面的方式可以监听到文件的变化，但是事实上它本身是没有自动刷新浏览器的功能的。当然通过在vscode中使用live-server来完成这样的功能。在不使用live-server的情况下，可以具备live reloading(实时重新加载)的功能\n\n# 安装\n\n * 安装webpack-dev-server\n   \n    npm install webpack-dev-server -d\n   \n   \n   1\n   \n\n * 修改package.json\n   \n   "script": {\n      "serve": "webpack serve" \n   }\n   \n   \n   1\n   2\n   3\n   \n   \n   执行npm run serve即可完成\n\n# contentbase 配置 🔥\n\n修改webpack.config.js配置文件，告知 devserver，从什么位置查找文件\n\ndevserver: {\n    contentbase: "./public",\n}\n\n\n1\n2\n3\n\n\n这里的文件指的是额外的，如favicon.ico 或者其他 x.mp4 之类的资源，一般放在 /public中\n\n * 打包阶段：使用的是copywepackplugin插件，每次打包将/public中文件复制到/build中\n * 开发阶段，复制文件比较耗费性能，并且 webpack-dev-server 使用的是内存方式，不适合复制这些静态资源。所以在找不到资源时，就会去配置的contentbase中查找\n\n# host配置 🔥\n\ndevserver: {\n    host: "0.0.0.0",\n}\n\n\n1\n2\n3\n\n\nhost设置主机地址:\n\n * 默认值是localhost;\n * 如果希望其他地方也可以访问，可以设置为0.0.0.0;\n\nlocalhost 和 0.0.0.0 的区别\n\n * localhost:本质上是一个域名，通常情况下会被解析成127.0.0.1;\n * 127.0.0.1:回环地址(loop back address)，表达的意思其实是我们主机自己发出去的包，直接被自己接收;\n   * 正常的数据库包经常 应用层 - 传输层 - 网络层 - 数据链路层 - 物理层 ;\n   * 而回环地址，是在网络层直接就被获取到了，是不会经常数据链路层和物理层的; u 比如我们监听 127.0.0.1时，在同一个网段下的主机中，通过ip地址是不能访问的\n\n# port、open、compress 配置 🔥\n\n * port设置监听的端口，默认情况下是8080\n\n * open是否打开浏览器\n   \n   默认值是false，设置为true会打开浏览器; 也可以设置为类似于 google chrome等值\n\n * compress是否为静态文件开启gzip compression\n   \n   默认值是false，可以设置为true。一般对js进行压缩！\n\n# proxy 配置 🔥\n\n首先要明确，跨域是浏览器的安全策略！服务器之间访问没有跨域问题。proxy就是根据这个原理来解决开发阶段跨域问题！\n\n如，8000访问8888的api\n\ndevserver: {\n\tproxy: {\n      "/api": {\n        target: "http://localhost:8888",\n        pathrewrite: {\n          "^/api": ""\n        },\n        secure: false,\n        changeorigin: true\n      }\n    } \n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nproxy是我们开发（生产中不 用这个！）中非常常用的一个配置选项，它的目的设置代理来解决跨域访问的问题:\n\n * 比如我们的一个api请求是 http://localhost:8888，但是本地启动服务器的域名是 http://localhost:8000，这 个时候发送网络请求就会出现跨域的问题;\n\n * 那么我们可以将请求先发送到一个代理服务器，代理服务器和api服务器没有跨域的问题，就可以解决我们的跨域问题了;\n\n进行如下的设置\n\n * **target:**表示的是代理到的目标地址，比如 /api-hy/moment会被代理到 http://localhost:8888/api-hy/moment;\n * **pathrewrite:**默认情况下，我们的 /api-hy 也会被写入到url中，如果希望删除，可以使用pathrewrite;\n * **secure:**默认情况下不接收转发到https的服务器上，如果希望支持，可以设置为false; 开发阶段可以置为false\n * **changeorigin:**它表示是否更新代理后请求的headers中host地址（将target配置写入header）。\n\n# historyapifallback 配置\n\n和路由有关！\n\nhistoryapifallback是开发中一个非常常见的属性，它主要的作用是解决spa页面在路由跳转之后，进行页面刷新时，返回404的错误。\n\nboolean值：\n\n * 默认是false\n * 如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容\n\nobject类型的值，可以配置rewrites属性(了解)：\n\n * 可以配置from来匹配路径，决定要跳转到哪一个页面\n\n事实上devserver中实现historyapifallback功能是通过connect-history-api-fallback库的\n\n\n# hmr 模块热替换 🔥\n\n# 介绍\n\nhmr的全称是hot module replacement，翻译为模块热替换。指在 应用程序运行过程中，替换、添加、删除模块，而无需重新刷新整个页面。\n\nhmr通过如下几种方式，来提高开发的速度：\n\n * 不重新加载整个页面，这样可以保留某些应用程序的状态不丢失。如计数器\n * 只更新需要变化的内容，节省开发的时间\n * 修改了css、js源代码，会立即在浏览器更新，相当于直接在浏览器的devtools中直接修改样式\n\n默认情况下，webpack-dev-server已经支持hmr，我们只需要开启即可。在不开启hmr的情况下，当我们修改了源代码之后，整个页面会自动刷新，使用的是live reloading\n\n# hot 配置 🔥\n\n修改webpack.config.js配置文件\n\ntarget: \'web\', // 这个不配置有时会出问题！\ndevserver: {\n    hot: true,\n}\n\n\n1\n2\n3\n4\n\n\n浏览器可以看到如下效果\n\n\n\n但是你会发现，当我们修改了某一个模块的代码时，依然是刷新的整个页面。这是因为我们需要去指定哪些模块发生更新时，进行hmr。导入文件的方式还需要添加hmr方式！！！如main.js中：\n\nimport \'./js/element\'; // 旧方式，不能删\n\n// hmr 方式\nif(module.hot) {\n \tmodule.hot.accept(\'./js/element.js\', () => {\n        console.log(\'element hmr\');\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n上面方式太麻烦了！！！\n\n# 框架的hmr 🔥\n\n在开发其他项目时，我们是否需要经常手动去写入 module.hot.accpet相关的api呢?比如开发vue、react项目，我们修改了组件，希望进行热更新，这个时候应该如何去操作呢? 事实上社区已经针对这些有很成熟的解决方案了;\n\n * 比如vue开发中，我们使用vue-loader，此loader支持vue组件的hmr，提供开箱即用的体验;\n\n * 比如react开发中，有react hot loader，实时调整react组件(目前react官方已经弃用了，改成使用react-refresh);\n\n注意：有时ts文件的hmr也需要手动配置！使用vben项目时遇到该问题！\n\n# hmr 原理 🔥\n\nwebpack-dev-server会创建两个服务:提供静态资源的服务(express)和socket服务(net.socket);\n\n * express server负责直接提供静态资源的服务(打包后的资源直接被浏览器请求和解析);\n * hmr socket server，是一个socket的长连接\n   * 长连接有一个最好的好处是建立连接后双方可以通信(服务器可以直接发送文件到客户端);\n   * 当服务器监听到对应的模块发生变化时，会生成两个文件.json(manifest文件)和.js文件(update chunk);\n   * 通过长连接，可以直接将这两个文件主动发送给客户端(浏览器);\n   * 浏览器拿到两个新的文件后，通过hmr runtime机制，加载这两个文件，并且针对修改的模块进行更新;\n\n\n\n\n# resolve 模块解析配置\n\n\n# 介绍\n\nresolve用于设置模块如何被解析:\n\n * 在开发中我们会有各种各样的模块依赖，这些模块可能来自于自己编写的代码，也可能来自第三方库;\n * resolve可以帮助webpack从每个 require/import 语句中，找到需要引入到合适的模块代码;\n * webpack 使用 enhanced-resolve 来解析文件路径;\n\n\n# 路径\n\nwebpack能解析三种文件路径\n\n * 绝对路径：由于已经获得文件的绝对路径，因此不需要再做进一步解析\n * 相对路径：\n   * 在这种情况下，使用 import 或 require 的资源文件所处的目录，被认为是上下文目录\n   * 在 import/require 中给定的相对路径，会拼接此上下文路径，来生成模块的绝对路径\n * 模块路径（如 import { createapp } from \'vue\';：\n   * 在 resolve.modules中指定的所有目录检索模块。默认值是 [\'node_modules\']，所以默认会从node_modules中查找文件\n   * 我们可以通过设置别名的方式来替换初识模块路径，具体后面讲解alias的配置\n\n\n# 文件？文件夹？\n\n * 如果是一个文件\n   \n   * 如果文件具有扩展名，则直接打包文件\n   * 否则，将使用 resolve.extensions选项作为文件扩展名解析（依次匹配扩展查询文件）\n\n * 如果是一个文件夹\n   \n   会在文件夹中根据 resolve.mainfiles配置选项中指定的文件顺序查找\n   \n   * resolve.mainfiles的默认值是 [\'index\']\n   * 再根据 resolve.extensions来解析扩展名\n   \n   所以一般查找到index文件\n\n\n# extensions和alias配置\n\nextensions是解析到文件时自动添加扩展名:\n\n * 默认值是 [\'.wasm\', \'.mjs\', \'.js\', \'.json\'];\n * 所以如果我们代码中想要添加加载 .vue 或者 jsx 或者 ts 等文件时，我们必须自己写上扩展名;\n\n另一个非常好用的功能是配置别名alias:\n\n * 特别是当我们项目的目录结构比较深的时候，或者一个文件的路径可能需要 ../../../这种路径片段;\n * 我们可以给某些常见的路径起一个别名;\n\n\n# 配置 🔥\n\n修改webpack.config.js配置文件\n\nresolve: {\n    extensions: [".js", ".json", ".mjs", ".vue", ".ts", ".jsx", ".tsx"],\n    alias: {\n      "@": path.resolve(__dirname, "./src"),\n      "js": path.resolve(__dirname, "./src/js")\n    }\n  },\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 分离开发生产环境 🔥\n\n目前我们所有的webpack配置信息都是放到一个配置文件中的:webpack.config.js\n\n * 当配置越来越多时，这个文件会变得越来越不容易维护;\n\n * 并且某些配置是在开发环境需要使用的，某些配置是在生成环境需要使用的，当然某些配置是在开发和生成环 境都会使用的;\n\n * 所以，我们最好对配置进行划分，方便我们维护和管理;\n\n那么，在启动时如何可以区分不同的配置呢?\n\n * 方案一：编写两个不同的配置文件，开发和生成时，分别加载不同的配置文件即可;\n\n * 方式二：使用相同的一个入口配置文件，通过设置参数来区分它们;\n   \n   修改package.json\n   \n   {\n       "scripts": {\n           "build": "webpack --config ./config/webpack.prod.config.js",\n           "serve": "webpack serve --config ./config/webpack.dev.config.js"\n       },   \n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   \n   \n   安装merge\n   \n   npm install webpack-merge -d\n   \n   \n   1\n   \n\n配置文件\n\n/config/webpack.comm.config.js\n\nconst path = require("path");\nconst htmlwebpackplugin = require("html-webpack-plugin");\nconst { defineplugin } = require("webpack");\nconst { vueloaderplugin } = require(\'vue-loader/dist/index\');\n\nmodule.exports = {\n  target: "web",\n  entry: "./src/main.js",\n  output: {\n    path: path.resolve(__dirname, "../build"),\n    filename: "js/bundle.js",\n  },\n  resolve: {\n    extensions: [".js", ".json", ".mjs", ".vue", ".ts", ".jsx", ".tsx"],\n    alias: {\n      "@": path.resolve(__dirname, "../src"),\n      "js": path.resolve(__dirname, "../src/js")\n    }\n  },\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ["style-loader", "css-loader", "postcss-loader"],\n      },\n      {\n        test: /\\.less$/,\n        use: ["style-loader", "css-loader", "less-loader"],\n      },\n      // },\n      {\n        test: /\\.(jpe?g|png|gif|svg)$/,\n        type: "asset",\n        generator: {\n          filename: "img/[name]_[hash:6][ext]",\n        },\n        parser: {\n          dataurlcondition: {\n            maxsize: 10 * 1024,\n          },\n        },\n      },\n      {\n        test: /\\.(eot|ttf|woff2?)$/,\n        type: "asset/resource",\n        generator: {\n          filename: "font/[name]_[hash:6][ext]",\n        },\n      },\n      {\n        test: /\\.js$/,\n        loader: "babel-loader"\n      },\n      {\n        test: /\\.vue$/,\n        loader: "vue-loader"\n      }\n    ],\n  },\n  plugins: [\n    new htmlwebpackplugin({\n      template: "./public/index.html",\n      title: "哈哈哈哈"\n    }),\n    new defineplugin({\n      base_url: "\'./\'",\n      __vue_options_api__: true,\n      __vue_prod_devtools__: false\n    }),\n    new vueloaderplugin()\n  ],\n};\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n\n\n/config/webpack.dev.config.js\n\nconst { merge } = require(\'webpack-merge\');\n\nconst commonconfig = require(\'./webpack.comm.config\');\n\nmodule.exports = merge(commonconfig, {\n  mode: "development",\n  devtool: "source-map",\n  devserver: {\n    contentbase: "./public",\n    hot: true,\n    // host: "0.0.0.0",\n    port: 7777,\n    open: true,\n    // compress: true,\n    proxy: {\n      "/api": {\n        target: "http://localhost:8888",\n        pathrewrite: {\n          "^/api": ""\n        },\n        secure: false,\n        changeorigin: true\n      }\n    }\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n/config/webpack.prod.config.js\n\nconst { cleanwebpackplugin } = require("clean-webpack-plugin");\nconst copywebpackplugin = require(\'copy-webpack-plugin\');\nconst {merge} = require(\'webpack-merge\');\n\nconst commonconfig = require(\'./webpack.comm.config\');\n\nmodule.exports = merge(commonconfig, {\n  mode: "production",\n  plugins: [\n    new cleanwebpackplugin(),\n    new copywebpackplugin({\n      patterns: [\n        {\n          from: "./public",\n          globoptions: {\n            ignore: [\n              "**/index.html"\n            ]\n          }\n        }\n      ]\n    }),\n  ]\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"Webpack-1 入门",frontmatter:{title:"Webpack-1 入门",date:"2020-12-27T00:17:11.000Z",permalink:"/pages/e2b92d/",categories:["Node","Webpack"],tags:[null]},regularPath:"/1301.Webpack/200.Webpack3/101.%E5%85%A5%E9%97%A8.html",relativePath:"1301.Webpack/200.Webpack3/101.入门.md",key:"v-914be310",path:"/pages/e2b92d/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:49},{level:3,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:56},{level:3,title:"优缺点",slug:"优缺点",normalizedTitle:"优缺点",charIndex:305},{level:4,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:312},{level:4,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:306},{level:3,title:"和 grunt / gulp 对比",slug:"和-grunt-gulp-对比",normalizedTitle:"和 grunt / gulp 对比",charIndex:633},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:756},{level:3,title:"局部安装",slug:"局部安装",normalizedTitle:"局部安装",charIndex:826},{level:3,title:"全局安装",slug:"全局安装",normalizedTitle:"全局安装",charIndex:1253},{level:2,title:"基本使用—打包 JS",slug:"基本使用-打包-js",normalizedTitle:"基本使用—打包 js",charIndex:1668},{level:2,title:"配置—webpack.config.js",slug:"配置-webpack-config-js",normalizedTitle:"配置—webpack.config.js",charIndex:4202},{level:2,title:"loader 🔥",slug:"loader-🔥",normalizedTitle:"loader 🔥",charIndex:5872},{level:3,title:"打包 CSS",slug:"打包-css",normalizedTitle:"打包 css",charIndex:6159},{level:3,title:"打包 less、scss、stylus",slug:"打包-less、scss、stylus",normalizedTitle:"打包 less、scss、stylus",charIndex:7780},{level:3,title:"打包图片",slug:"打包图片",normalizedTitle:"打包图片",charIndex:10777},{level:3,title:"babel",slug:"babel",normalizedTitle:"babel",charIndex:13542},{level:2,title:"Vue—配合 webpack 使用 🔥",slug:"vue-配合-webpack-使用-🔥",normalizedTitle:"vue—配合 webpack 使用 🔥",charIndex:16271},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:616},{level:3,title:"el 和 template 区别",slug:"el-和-template-区别",normalizedTitle:"el 和 template 区别",charIndex:20679},{level:3,title:"终极使用",slug:"终极使用",normalizedTitle:"终极使用",charIndex:21845},{level:2,title:"plugin",slug:"plugin",normalizedTitle:"plugin",charIndex:23860},{level:3,title:"banner",slug:"banner",normalizedTitle:"banner",charIndex:26205},{level:3,title:"HtmlWebpackPlugin 🔥",slug:"htmlwebpackplugin-🔥",normalizedTitle:"htmlwebpackplugin 🔥",charIndex:28543},{level:3,title:"uglifyjs 压缩 🔥",slug:"uglifyjs-压缩-🔥",normalizedTitle:"uglifyjs 压缩 🔥",charIndex:32337},{level:2,title:"webpack-dev-server 🔥",slug:"webpack-dev-server-🔥",normalizedTitle:"webpack-dev-server 🔥",charIndex:36057},{level:2,title:"配置文件分离 🔥",slug:"配置文件分离-🔥",normalizedTitle:"配置文件分离 🔥",charIndex:40560},{level:2,title:"其他（旧）",slug:"其他-旧",normalizedTitle:"其他（旧）",charIndex:45467}],headersStr:"概念 简介 优缺点 优点 缺点 和 grunt / gulp 对比 安装 局部安装 全局安装 基本使用—打包 JS 配置—webpack.config.js loader 🔥 打包 CSS 打包 less、scss、stylus 打包图片 babel Vue—配合 webpack 使用 🔥 配置 el 和 template 区别 终极使用 plugin banner HtmlWebpackPlugin 🔥 uglifyjs 压缩 🔥 webpack-dev-server 🔥 配置文件分离 🔥 其他（旧）",content:"# 入门\n\n配套的代码在 Github 中。\n\n可查看中文文档，官方文档。注意两者区别。\n\n\n# 概念\n\n\n# 简介\n\n本质上，webpack 是一个用于现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。\n\n\n\n静态模块 + 打包\n\n * 在 ES6 之前，进行模块化开发时必须借助其他工具，如 CommonJS。通过模块化开发完项目后，还需处理模块间的依赖\n * 将各模块进行打包整合，处理为大部分浏览器能识别的代码、资源\n\n\n# 优缺点\n\n# 优点\n\n * 模块化开发\n   \n   程序员在开发时可以分模块创建不同的 js、 css 等小文件方便开发，最后使用 webpack 将这些小文件打包成一个文件，减少了 http 的请求次数。webpack 可以实现按需打包，为了避免出现打包文件过大可以打包成多个文件。\n\n * 编译 typescript、ES6 等高级 js 语法\n\n * CSS 预编译\n   \n   webpack 允许在开发中使用 Sass 和 Less 等原生 CSS 的扩展技术，通过 sass-loader、less-loader 将 Sass 和 Less 的语法编译成浏览器可识别的 CSS 语法。\n\n# 缺点\n\n * 配置有些繁琐，文档不丰富\n\n\n# 和 grunt / gulp 对比\n\n * grunt / gulp 核心为 Task，主要用于简单的合并、压缩。更强调前端流程的自动化、模块化不是它的核心\n * Webpack 更加强调模块化开发管理，文件合并、压缩、预处理是附带功能\n\n\n# 安装\n\nWebpack 依赖 Node，Node 会自动安装 npm。一般推荐先对项目进行npn init或npm install\n\n\n# 局部安装\n\n在 package.json 中定义 scripts 中的 webpack 命令，首先查找使用的是局部安装的 webpack，在 node_modules/bin 中。命令行中也是先查找项目中的 webpack。类比 DNS\n\ncd 目录\n# --save-dev 是开发时依赖，项目打包后不需要继续使用\nnpm install --save-dev webpack\n# 或指定版本\nnpm install --save-dev webpack@<version>\n\n# 安装后查看版本号，需要找到安装的目录，如 node_modules/webpack/bin，进入后\n./webpack.js -v\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nnpm install --save-dev webpack@3.7.0 #本地安装 Webpack 3.6.0，因为 vue cli2 依赖该版本。此处改为3.7.0是为了区分\n\n\n1\n\n\n\n# 全局安装\n\n一般不推荐，但是在使用命令学习时每个文件夹都要局部安装的话太麻烦了\n\n全局安装之后在终端执行 webpack 命令，就使用的是全局安装的 webpack 。注意：4.0 以后的版本需要安装 webpack-cl。\n\n本地安装只需去掉-g，即可在当前目录安装\n\nnpm install webpack -g\n# 4.0后的版本需要安装 webpack-cl\nnpm install webpack-cli -g\n# 可以指定版本\nnpm install webpack@<version> -g #全局安装 Webpack 3.6.0，因为 vue cli2 依赖该版本。\n\n\n# 安装后查看版本号\nwebpack -v\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nnpm install webpack@3.6.0 -g #全局安装 Webpack 3.6.0，因为 vue cli2 依赖该版本。\n\n\n1\n\n\n\n# 基本使用—打包 JS\n\n目前的项目文件结构\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n    <script src=\"./dist/bundle.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n// main.js\n\n// CommonJS\nvar { formatDate } = require('./js/utils.js')\n\nconsole.log(formatDate(new Date()))\n\n// ES6\nimport * as poem from './js/poem.js'\nconsole.log(poem.SPRING)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n// ./js/utils.js\n\nfunction formatDate(date) {\n  return `${date.getFullYear()}-${\n    date.getMonth() + 1 < 10 ? '0' + (date.getMonth() + 1) : date.getMonth() + 1\n  }-${date.getDate() < 10 ? '0' + date.getDate() : date.getDate()} ${\n    date.getHours() < 10 ? '0' + date.getHours() : date.getHours()\n  }:${date.getMinutes() < 10 ? '0' + date.getMinutes() : date.getMinutes()}:${\n    date.getSeconds() < 10 ? '0' + date.getSeconds() : date.getSeconds()\n  }`\n}\n\n// CommonJS\n// 可以省略掉 module\nmodule.exports = {\n  formatDate,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n// ./js/poem.js\n\nconst SPRING =\n  '天街小雨润如酥，草色遥看近却无。最是一年春好处，绝胜烟柳满皇都。'\nconst SUMMER =\n  '毕竟西湖六月中，风光不与四时同。接天莲叶无穷碧，映日荷花别样红。'\nconst AUTUMN =\n  '银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星。'\nconst WINTER = '日暮苍山远，天寒白屋贫。柴门闻犬吠，风雪夜归人。'\n\n// ES6\nexport { SPRING, SUMMER, AUTUMN, WINTER }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n执行打包命令\n\ncd study-webpack/1 webpack起步\n# 使用全局 webpack 打包\nwebpack ./src/main.js ./dist/bundle.js\n\n##########\nHash: f664968929cb925ac098\nVersion: webpack 3.6.0\nTime: 35ms\n    Asset     Size  Chunks             Chunk Names\nbundle.js  4.16 kB       0  [emitted]  main\n   [0] /Users/conanan/Documents/VSCode/study-webpack/1 webpack起步/src/main.js 144 bytes {0} [built]\n   [1] /Users/conanan/Documents/VSCode/study-webpack/1 webpack起步/src/utils.js 504 bytes {0} [built]\n   [2] /Users/conanan/Documents/VSCode/study-webpack/1 webpack起步/src/poem.js 486 bytes {0} [built]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ncd study-webpack/1 webpack起步\n#使用本地 webpack 打包\n./node_modules/.bin/webpack ./src/main.js ./dist/bundle.js\n\n##########\nHash: bf83695e4e6f3e90f28b\nVersion: webpack 3.7.0\nTime: 35ms\n    Asset    Size  Chunks             Chunk Names\nbundle.js  4.2 kB       0  [emitted]  main\n   [0] ./src/main.js 163 bytes {0} [built]\n   [1] ./src/utils.js 516 bytes {0} [built]\n   [2] ./src/poem.js 493 bytes {0} [built]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n虽然仅仅打包了 main.js，但是 webpack 会将 main.js 所依赖的所有 js 文件都打包，且无论是 ES6 的模块化还是 CommonJS 的模块化都可以正确打包\n\n\n# 配置—webpack.config.js\n\n做到的结果是仅需执行webpack命令或npm run build命令即可做出上述复杂命令的操作\n\n首先生成package.json，在执行npm init时指定 name（最好全英文）、入口文件main.js（不指定也没有报错？）\n\n在 src 和 dist 同级目录下创建webpack.config.js\n\n// 这个会从 node 中查找，需要 npm init 来生成 package.json。这里好像不能使用 ES6 的模块化语法\nconst path = require('path')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n执行命令\n\ncd study-webpack/2 webpack配置\n# 默认先查找局部安装的 webpack\nwebpack\n\n##########\nHash: bf83695e4e6f3e90f28b\nVersion: webpack 3.7.0\nTime: 37ms\n    Asset    Size  Chunks             Chunk Names\nbundle.js  4.2 kB       0  [emitted]  main\n   [0] ./src/main.js 163 bytes {0} [built]\n   [1] ./src/utils.js 516 bytes {0} [built]\n   [2] ./src/poem.js 493 bytes {0} [built]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如何配置执行npm run build即可完成上述操作呢？需要修改package.json\n\n{\n  \"name\": \"meetwebpack\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n执行命令\n\ncd study-webpack/2 webpack配置\nnpm run build\n\n##########\n> meetwebpack@1.0.0 build /Users/conanan/Documents/VSCode/study-webpack/2 webpack配置\n> webpack\n\nHash: bf83695e4e6f3e90f28b\nVersion: webpack 3.7.0\nTime: 35ms\n    Asset    Size  Chunks             Chunk Names\nbundle.js  4.2 kB       0  [emitted]  main\n   [0] ./src/main.js 163 bytes {0} [built]\n   [1] ./src/utils.js 516 bytes {0} [built]\n   [2] ./src/poem.js 493 bytes {0} [built]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# loader 🔥\n\nwebpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。\n\nLoader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过  require  来加载任何类型的模块或文件，比如 CoffeeScript、 JSX、 LESS 或图片。首先我们需要安装相关 Loader 插件，具体操作文档中写得非常详细。\n\n\n# 打包 CSS\n\ncss-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识 css。\n\n目前的项目文件结构\n\n 1. 安装 css-loader 和 style-loader\n    \n    npm install --save-dev css-loader style-loader\n    \n    \n    1\n    \n\n 2. 修改 webpack.config.js，添加 module 模块\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n      },\n      module: {\n        rules: [\n          {\n            test: /\\.css$/i,\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // style-loader 将模块导出作为style添加到DOM中\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n        ],\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n\n 3. 创建 css 文件\n    \n    /* css/normal.css */\n    \n    body {\n      background-color: skyblue;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 4. 修改入口 main.js ，引入上面的 css 文件（若没有 loader，直接引入打包则报错）\n    \n    // CommonJS\n    var { formatDate } = require('./js/utils.js')\n    \n    console.log(formatDate(new Date()))\n    \n    // ES6\n    import * as poem from './js/poem.js'\n    console.log(poem.SPRING)\n    \n    // CommonJS 语法，不能使用 ES6，那是针对 JS 的\n    require('./css/normal.css')\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 5. 重新打包webpack或npn run build\n\n 6. 访问 index.html 看看背景\n\n\n# 打包 less、scss、stylus\n\n这里以 less 为例，创建文件并放入 css 目录中，引入等操作和 css 文件一样\n\n 1. 安装 less-loader（由于 webpack 的版本较低，是 3.6.0 或 3.7.0，目前已经出了 5.0 了，这里 less-loader 版本也需要降低）\n    \n    npm install --save-dev less-loader less\n    \n    \n    1\n    \n    \n    卸载高版本 less-loader，重新安装指定版本的（我也是服了，没找到哪写了版本高）\n    \n    npm uninstall less-loader\n    npm install less-loader@4.1.0 --save-dev\n    \n    \n    1\n    2\n    \n\n 2. 修改 webpack.config.js，添加 module 模块\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到DOM中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from JS strings\n              },\n              {\n                loader: 'css-loader', // translates CSS into CommonJS\n              },\n              {\n                loader: 'less-loader', // compiles Less to CSS\n              },\n            ],\n          },\n        ],\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    \n\n 3. 创建 less 文件，并在入口文件 main.js 中引入\n    \n    // css/special.less\n    \n    @fontSize: 50px;\n    @fontColor: orange;\n    \n    body {\n      font-size: @fontSize;\n      color: @fontColor;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    // main.js\n    \n    // CommonJS\n    var { formatDate } = require('./js/utils.js')\n    \n    console.log(formatDate(new Date()))\n    \n    // ES6\n    import * as poem from './js/poem.js'\n    console.log(poem.SPRING)\n    \n    // CommonJS 语法，不能使用 ES6，那是针对 JS 的\n    require('./css/normal.css')\n    require('./css/special.less')\n    document.writeln('World')\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 4. HTML 文件\n    \n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <p>Hello</p>\n        \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n        <script src=\"./dist/bundle.js\"><\/script>\n      </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 5. 重新打包webpack或npn run build\n\n 6. 访问 index.html 看看字体及颜色\n\n\n# 打包图片\n\n 1. 安装 url-loader，file-loader（当图片大小大于 limit 时使用）\n    \n    npm install --save-dev url-loader\n    npm install --save-dev file-loader\n    \n    \n    1\n    2\n    \n\n 2. 修改 webpack.config.js，添加 module 模块\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicPath配置\n        publicPath: 'dist/',\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到DOM中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from JS strings\n              },\n              {\n                loader: 'css-loader', // translates CSS into CommonJS\n              },\n              {\n                loader: 'less-loader', // compiles Less to CSS\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n        ],\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    \n\n 3. 修改 css 中背景\n    \n    body {\n      /* background-color: skyblue; */\n      background-image: url('../img/conan.jpeg');\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 重新打包webpack或npn run build\n\n 5. 访问 index.html 看看背景图片\n    \n    当图片大小小于 limit 时，会被编译为 base64 字符串，可以直接显示出来\n    \n    当大于 limit 时，会使用 file-loader 进行加载，且重命名（32 位哈希值）并打包到 dist 目录中，由于路径不对无法显示（显示的是以 index.html 的目录为目录的路径，需要改为以 dist/ 为目录的路径）。\n    \n    实际中，这种 32 位哈希值的文件名并不方便，且没有放入统一的目录中。实际可能会将其放入img/[name][hash:8].[ext]，在 loader 中配置即可\n    \n    但是实际中，会把所有文件都打包到 dist 中，此时应该删掉 publicPath 配置！\n\n\n# babel\n\nwebpack 打包的 JS 文件，没有将 ES6 转为 ES5，有部分浏览器不支持，所以此时可以使用 babel\n\n 1. 安装 babel-loader 和 babel（注意此处还是根据 webpack 3.6.* 选择的版本）\n    \n    npm install babel-loader@7 babel-core babel-preset-es2015 --save-dev\n    \n    \n    1\n    \n    \n    我就服了，文档里的配置还让安装 webpack？还失败了，还有些看不懂的配置。算了 😄\n\n 2. 修改 webpack.config.js，添加 module 模块\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicPath配置\n        publicPath: 'dist/',\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到DOM中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from JS strings\n              },\n              {\n                loader: 'css-loader', // translates CSS into CommonJS\n              },\n              {\n                loader: 'less-loader', // compiles Less to CSS\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n        ],\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    \n\n 3. 重新打包webpack或npn run build。查看 buldle.js 文件\n\n\n# Vue—配合 webpack 使用 🔥\n\n\n# 配置\n\n 1. npm 安装 vue\n    \n    npm install vue --save\n    \n    \n    1\n    \n    \n    --save可以简写为-S，vue 是要在发布时也使用的，所以无需添加-dev\n\n 2. 使用 vue 开发，在 main.js 中\n    \n    // CommonJS\n    var { formatDate } = require('./js/utils.js')\n    \n    console.log(formatDate(new Date()))\n    \n    // ES6\n    import * as poem from './js/poem.js'\n    console.log(poem.SPRING)\n    \n    // CommonJS 语法，不能使用 ES6，那是针对 JS 的\n    require('./css/normal.css')\n    require('./css/special.less')\n    document.writeln('World')\n    \n    import Vue from 'vue'\n    \n    const vm = new Vue({\n      el: '#app',\n      data: {\n        message: 'Hello',\n      },\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n    \n    修改 index.html\n    \n    <!DOCTYPE html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"UTF-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>Document</title>\n      </head>\n      <body>\n        <div id=\"app\">\n          {{message}}\n        </div>\n        \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n        <script src=\"./dist/bundle.js\"><\/script>\n      </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 3. 重新打包webpack或npn run build。访问后发现报错\n    \n    bundle.js:1344 [Vue warn]: You are using the runtime-only build of Vue where the template compiler is not available. Either pre-compile the templates into render functions, or use the compiler-included build.\n    \n    \n    1\n    \n    \n    这是由于 vue 在构建时有两个版本\n    \n    * runtime-only：代码中，不可以有任何 template，如 id=\"app\" 那个 div\n    * runtime-compiler：代码中，可以有 template，compiler 会对其进行编译\n    \n    官网文档解释，修改 webpack.config.js\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicPath配置\n        publicPath: 'dist/',\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到DOM中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from JS strings\n              },\n              {\n                loader: 'css-loader', // translates CSS into CommonJS\n              },\n              {\n                loader: 'less-loader', // compiles Less to CSS\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n        ],\n      },\n      resolve: {\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    \n\n 4. 重新打包webpack或npn run build。访问\n\n\n# el 和 template 区别\n\n实际使用时，不会修改 index.html 的代码，仅仅留个 id=\"app\" 的 div，只需要在使用 vue 时指定 template 即可，vue 内部会自动将 template 中的代码替换 id=\"app\" 的 div（该 div 将不见）\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n    <script src=\"./dist/bundle.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n// main.js\n\n// CommonJS\nvar { formatDate } = require('./js/utils.js')\n\nconsole.log(formatDate(new Date()))\n\n// ES6\nimport * as poem from './js/poem.js'\nconsole.log(poem.SPRING)\n\n// CommonJS 语法，不能使用 ES6，那是针对 JS 的\nrequire('./css/normal.css')\nrequire('./css/special.less')\ndocument.writeln('World')\n\nimport Vue from 'vue'\n\nconst vm = new Vue({\n  el: '#app',\n  template: `\n    <div>\n        <h2>{{message}}</h2>\n        <button @click=\"btnClick\">按钮</button>\n    </div>\n    `,\n  data: {\n    message: 'Hello',\n  },\n  methods: {\n    btnClick() {\n      alert(1)\n    },\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 终极使用\n\n这个视频讲解的非常详细，一步一步\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n    <script src=\"./dist/bundle.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n// CommonJS\nvar { formatDate } = require('./js/utils.js')\n\nconsole.log(formatDate(new Date()))\n\n// ES6\nimport * as poem from './js/poem.js'\nconsole.log(poem.SPRING)\n\n// CommonJS 语法，不能使用 ES6，那是针对 JS 的\nrequire('./css/normal.css')\nrequire('./css/special.less')\n// document.writeln(\"World\");\n\nimport Vue from 'vue'\n// 导入组件 js 文件，可省略后缀\n// import App from \"./vue/app\";\n// 导入组件 vue 文件，不可省略后缀。在 vue 文件中可以省略（但需webpack配置）\nimport App from './vue/App.vue'\n\nconst vm = new Vue({\n  el: '#app',\n  template: '<App/>',\n  components: {\n    App,\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\x3c!-- vue/App.vue--\x3e\n<template>\n  <div>\n    <h2>{{ message }}</h2>\n    <button @click=\"btnClick\">按钮</button>\n    <cpn />\n  </div>\n</template>\n\n<script>\n// 可省略后缀（需在 webpakc 中配置）\nimport Cpn from './Cpn'\n\nexport default {\n  name: 'App',\n  components: {\n    Cpn,\n  },\n  data() {\n    return { message: 'Hello' }\n  },\n  methods: {\n    btnClick() {\n      alert(1)\n    },\n  },\n}\n<\/script>\n\n<style></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\x3c!-- vue/Cpn.vue--\x3e\n<template>\n  <div>\n    <h2>{{ message }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Cpn',\n  data() {\n    return {\n      message: 'Cpn 组件！！！！！',\n    }\n  },\n}\n<\/script>\n\n<style></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n若修改后重新打包失败，可以安装 Vue Loader。其中 vue-template-compiler 用于直接解析 template 模版（提高性能）\n\nnpm install -D vue-loader vue-template-compiler\n\n\n1\n\n\nwebpack.config.js\n\n// 这个会从 node 中查找，需要 npm init 来生成 package.json\nconst path = require('path')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n    // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicPath配置\n    publicPath: 'dist/',\n  },\n  module: {\n    rules: [\n      {\n        // 匹配.css文件\n        test: /\\.css$/i,\n\n        // style-loader 将模块导出作为style添加到DOM中\n        // css-loader解析css文件后，使用import加载，并返回css代码\n        // 使用多个loader时，从右到左加载。顺序不能乱！\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.less$/,\n        use: [\n          {\n            loader: 'style-loader', // creates style nodes from JS strings\n          },\n          {\n            loader: 'css-loader', // translates CSS into CommonJS\n          },\n          {\n            loader: 'less-loader', // compiles Less to CSS\n          },\n        ],\n      },\n      {\n        test: /\\.(png|jpg|gif|jpeg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 当图片大小小于 limit 时，会被编译为base64字符串\n              // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n              limit: 10000,\n              // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n              name: 'img/[name][hash:8].[ext]',\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.js$/,\n        // 排除\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['es2015'],\n          },\n        },\n      },\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n      },\n    ],\n  },\n  resolve: {\n    // 在 .vue 文件中导入如下文件时可以省略后缀\n    extensions: ['.js', '.vue', '.css'],\n    alias: {\n      // 指定发布的版本\n      vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n    },\n  },\n  plugins: [\n    // 请确保引入这个插件！\n    new VueLoaderPlugin(),\n  ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n重新打包webpack或npn run build。访问\n\n\n# plugin\n\nplugin 与 loader 区别：\n\n * loader：用于转换某些类型的模块，是转换器\n * plugin：是对 webpack 本身的扩展，是扩展器\n\n使用步骤：\n\n 1. npm 安装（某些 webpack 内置的无需安装）\n 2. 在 webpack.config.js 中的 plugins 配置\n\n\n# banner\n\nwebpack 自带，只需配置好\n\n// 这个会从 node 中查找，需要 npm init 来生成 package.json\nconst path = require('path')\nconst VueLoaderPlugin = require('vue-loader/lib/plugin')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n    // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicPath配置\n    publicPath: 'dist/',\n  },\n  module: {\n    rules: [\n      {\n        // 匹配.css文件\n        test: /\\.css$/i,\n\n        // style-loader 将模块导出作为style添加到DOM中\n        // css-loader解析css文件后，使用import加载，并返回css代码\n        // 使用多个loader时，从右到左加载。顺序不能乱！\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.less$/,\n        use: [\n          {\n            loader: 'style-loader', // creates style nodes from JS strings\n          },\n          {\n            loader: 'css-loader', // translates CSS into CommonJS\n          },\n          {\n            loader: 'less-loader', // compiles Less to CSS\n          },\n        ],\n      },\n      {\n        test: /\\.(png|jpg|gif|jpeg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 当图片大小小于 limit 时，会被编译为base64字符串\n              // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n              limit: 10000,\n              // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n              name: 'img/[name][hash:8].[ext]',\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.js$/,\n        // 排除\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['es2015'],\n          },\n        },\n      },\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n      },\n    ],\n  },\n  resolve: {\n    // 在 .vue 文件中导入如下文件时可以省略后缀\n    extensions: ['.js', '.vue', '.css'],\n    alias: {\n      // 指定发布的版本\n      vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n    },\n  },\n  plugins: [\n    // 请确保引入这个插件！\n    new VueLoaderPlugin(),\n  ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n重新打包webpack或npn run build。查看 bundle.js 文件\n\n\n# HtmlWebpackPlugin 🔥\n\n目前我们的 index.html 文件在根目录下，且打包后也是在原位置，而实际真实发布项目时，发布的是 dist 目录中的内容，但是其中并没有 index.html，只能复制过去。所以我们需要可以将 index.html 打包到 dist 目录的插件。\n\nHtmlWebpackPlugin 插件可以做：\n\n * 自动生成一个 index.html（可指定模板）\n * 将打包的 js 文件，自动通过 script 标签插入到 index.html 的 body 中\n\n使用步骤：\n\n 1. 安装（只开发时依赖）由于 webpack 版本为 3.6.*，所以此处需要安装指定版本的\n    \n    npm install html-webpack-plugin@3.2.0 --save-dev\n    \n    \n    1\n    \n\n 2. 修改 webpack.config.js 中 plugins 内容\n    \n    注意删掉publicPath\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    const VueLoaderPlugin = require('vue-loader/lib/plugin')\n    const webpack = require('webpack')\n    const htmlWebpackPlugin = require('html-webpack-plugin')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicPath配置\n        // publicPath: \"dist/\",\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到DOM中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from JS strings\n              },\n              {\n                loader: 'css-loader', // translates CSS into CommonJS\n              },\n              {\n                loader: 'less-loader', // compiles Less to CSS\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n          {\n            test: /\\.vue$/,\n            loader: 'vue-loader',\n          },\n        ],\n      },\n      resolve: {\n        // 在 .vue 文件中导入如下文件时可以省略后缀\n        extensions: ['.js', '.vue', '.css'],\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n      plugins: [\n        // 请确保引入这个插件！\n        new VueLoaderPlugin(),\n        // banner插件\n        new webpack.BannerPlugin('最终版权归conanan所有'),\n        // htmlWebpackPlugin 插件\n        new htmlWebpackPlugin({\n          template: 'index.html',\n        }),\n      ],\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    \n\n 3. 重新打包webpack或npn run build。查看 index.html 文件\n\n\n# uglifyjs 压缩 🔥\n\n 1. 安装（由于 webpack 版本及 CLI2，遂选择该版本）\n    \n    还是报错，我看 node_modules 中好像自带了，只需配置即可食用\n    \n    npm install uglifyjs-webpack-plugin@1.1.1 --save-dev\n    \n    \n    1\n    \n\n 2. 修改 webpack.config.js 中 plugins 内容\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    const VueLoaderPlugin = require('vue-loader/lib/plugin')\n    const webpack = require('webpack')\n    const htmlWebpackPlugin = require('html-webpack-plugin')\n    const uglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicPath配置\n        // publicPath: \"dist/\",\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到DOM中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from JS strings\n              },\n              {\n                loader: 'css-loader', // translates CSS into CommonJS\n              },\n              {\n                loader: 'less-loader', // compiles Less to CSS\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n          {\n            test: /\\.vue$/,\n            loader: 'vue-loader',\n          },\n        ],\n      },\n      resolve: {\n        // 在 .vue 文件中导入如下文件时可以省略后缀\n        extensions: ['.js', '.vue', '.css'],\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n      plugins: [\n        // 请确保引入这个插件！\n        new VueLoaderPlugin(),\n        // banner插件\n        new webpack.BannerPlugin('最终版权归conanan所有'),\n        // htmlWebpackPlugin 插件\n        new htmlWebpackPlugin({\n          template: 'index.html',\n        }),\n        // uglifyjsWebpackPlugin 插件\n        new uglifyjsWebpackPlugin(),\n      ],\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    94\n    \n\n 3. 重新打包webpack或npn run build。查看 bundle.js 文件\n\n\n# webpack-dev-server 🔥\n\nwebpack 提供了一个可选的本地开发服务器，基于 node 搭建，内部使用 express 框架，可以实现浏览器自动“刷新”显示我们修改后的结果。不过它是一个单独的模块，需要先安装。\n\n 1. 安装（版本号还是由于 webpack 3.6.*）\n    \n    npm install webpack-dev-server@2.9.1 --save-dev\n    \n    \n    1\n    \n\n 2. 修改 webpack.config.js 中 devServer 内容\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    const VueLoaderPlugin = require('vue-loader/lib/plugin')\n    const webpack = require('webpack')\n    const htmlWebpackPlugin = require('html-webpack-plugin')\n    const uglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicPath配置\n        // publicPath: \"dist/\",\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到DOM中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from JS strings\n              },\n              {\n                loader: 'css-loader', // translates CSS into CommonJS\n              },\n              {\n                loader: 'less-loader', // compiles Less to CSS\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n          {\n            test: /\\.vue$/,\n            loader: 'vue-loader',\n          },\n        ],\n      },\n      resolve: {\n        // 在 .vue 文件中导入如下文件时可以省略后缀\n        extensions: ['.js', '.vue', '.css'],\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n      plugins: [\n        // 请确保引入这个插件！\n        new VueLoaderPlugin(),\n        // banner插件\n        new webpack.BannerPlugin('最终版权归conanan所有'),\n        // htmlWebpackPlugin 插件\n        new htmlWebpackPlugin({\n          template: 'index.html',\n        }),\n        // uglifyjsWebpackPlugin 插件\n        new uglifyjsWebpackPlugin(),\n      ],\n      devServer: {\n        // 为那个目录提供本地服务，默认是项目根目录\n        contentBase: './dist',\n        // 页面实时刷新\n        inline: true,\n        // 端口\n        port: 9999,\n        // 在SPA中，依赖H5的history模式\n        // historyApiFallback,\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    94\n    95\n    96\n    97\n    98\n    99\n    100\n    101\n    102\n    103\n    104\n    \n\n 3. 执行webpack-dev-server发现没有该命令，原因是安装到本地，可以在 package.json 中配置 scripts，即可实现默认查找本地 node_modules 中命令。--open可以在服务启动后自动打开浏览器\n    \n    {\n      \"scripts\": {\n        \"dev\": \"webpack-dev-server --open\"\n      }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    但是发现无法启动，报错\n    \n    ERROR in bundle.js from UglifyJs\n    Unexpected token: name (urlParts) [bundle.js:4153,4]\n    \n    \n    1\n    2\n    \n    \n    参考这个博客，虽然可以启动了，但是修改文件后还是报错。算了（所以目前代码 5 webpack-plugins 可能有问题，接下来就解决了）\n\n\n# 配置文件分离 🔥\n\n这里就有问题了，webpack.config.js 中的配置，有些是开发模式需要的，有些才是发布模式需要的，如何分离？并且开发模式时使用 uglifyjs 插件会无法调试，如何解决？此时需要 webpack 的配置文件分离。\n\n 1. 安装依赖\n    \n    npm install webpack-merge --save-dev\n    \n    \n    1\n    \n\n 2. build/base.config.js。注意 output 目录的改变\n    \n    // 基础依赖\n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    const VueLoaderPlugin = require('vue-loader/lib/plugin')\n    const webpack = require('webpack')\n    const htmlWebpackPlugin = require('html-webpack-plugin')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        // 配置文件分离后需要修改 path\n        path: path.resolve(__dirname, '../dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicPath配置\n        // publicPath: \"dist/\",\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到DOM中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from JS strings\n              },\n              {\n                loader: 'css-loader', // translates CSS into CommonJS\n              },\n              {\n                loader: 'less-loader', // compiles Less to CSS\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n          {\n            test: /\\.vue$/,\n            loader: 'vue-loader',\n          },\n        ],\n      },\n      resolve: {\n        // 在 .vue 文件中导入如下文件时可以省略后缀\n        extensions: ['.js', '.vue', '.css'],\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n      plugins: [\n        // 请确保引入这个插件！\n        new VueLoaderPlugin(),\n        // banner插件\n        new webpack.BannerPlugin('最终版权归conanan所有'),\n        // htmlWebpackPlugin 插件\n        new htmlWebpackPlugin({\n          template: 'index.html',\n        }),\n      ],\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    \n\n 3. build/dev.config.js\n    \n    // 开发时配置\n    const baseConfig = require('./base.config')\n    const webpackMerge = require('webpack-merge')\n    \n    module.exports = webpackMerge(baseConfig, {\n      devServer: {\n        // 为那个目录提供本地服务，默认是项目根目录\n        contentBase: './dist',\n        // 页面实时刷新\n        inline: true,\n        // 端口\n        port: 9999,\n        // 在SPA中，依赖H5的history模式\n        // historyApiFallback,\n      },\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 4. build/prod.config.js\n    \n    // 生产时依赖\n    const uglifyjsWebpackPlugin = require('uglifyjs-webpack-plugin')\n    const baseConfig = require('./base.config')\n    const webpackMerge = require('webpack-merge')\n    \n    module.exports = webpackMerge(baseConfig, {\n      plugins: [\n        // uglifyjsWebpackPlugin 插件\n        new uglifyjsWebpackPlugin(),\n      ],\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 5. 删掉之前的 webpack.config.js，此时命令就不能使用了，需要修改配置 package.json\n    \n    {\n      \"scripts\": {\n        \"dev\": \"webpack-dev-server --open --config ./build/dev.config.js\",\n        \"build\": \"webpack --config ./build/prod.config.js\"\n      }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    执行上述命令，发现一切都好了！😄\n\n\n# 其他（旧）\n\nwebpack-dev-server 开发服务器，它的功能可以实现热加载并且自动刷新浏览器。\n\n 1. 创建一个新的程序目录，这里我们创建webpacktest目录，将 webpack 入门程序的代码拷贝进来，并在目录下创建src目录、dist目录。将main.js，module01.js和vue.min.js拷贝到 src 目录。html 文件拷贝到当前目录下。\n\n 2. 使用 webpack-dev-server 需要安装 webpack、 webpack-dev-server和 html-webpack-plugin三个包在当前程序目录\n    \n    cnpm install webpack@3.6.0 webpack-dev-server@2.9.1 html-webpack-plugin@2.30.1 --save-dev\n    \n    安装完成后程序目录出现**package.json文件**，此文件中记录了程序的依赖信息（上面三个）\n    \n    还有**node_modules文件夹**，有 993 个文件或文件夹！！！存放本程序所依赖的包！\n\n 3. 配置 webpack-dev-server，在package.json中配置 script（运行命令），最终内容如下\n    \n    {\n      \"scripts\": {\n        \"dev\": \"webpack-dev-server --inline --hot --open --port 5008\"\n      },\n      \"devDependencies\": {\n        \"html-webpack-plugin\": \"^2.30.1\",\n        \"webpack\": \"^3.6.0\",\n        \"webpack-dev-server\": \"^2.9.1\"\n      }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    scripts：可执行的命令\n    \n    --inline：自动刷新；--hot：热加载；--open：自动在默认浏览器打开；--port：指定端口；\n    \n    --host：可以指定服务器的 ip，不指定则为 127.0.0.1，如果对外发布则填写公网 ip 地址\n    \n    devDependencies：开发人员在开发过程中所需要的依赖\n\n 4. 配置webpack.config.js，是 webpack 的配置文件，在此文件中可以配置应用的入口文件、输出配置、插件等，其中要实现热加载自动刷新功能需要配置 html-webpack-plugin 插件。html-webpack-plugin 的作用是根据 html 模板在内存生成 html 文件，它的工作原理是根据模板文件在内存中生成一个 index.html 文件。\n    \n    1. 配置模板文件。将原来的vue.html作为模板文件，为了和内存中的index.html文件名区别，注意将vue.html中的所有script标签去掉\n    \n    2. 在webpack.config.js（与package.json同目录）中配置html-webpack-plugin插件\n       \n       //引用html-webpack-plugin插件，作用是根据html模板在内存生成html文件，它的工作原理是根据模板文件在内存中生成一个index.html文件。\n       var htmlwp = require('html-webpack-plugin')\n       module.exports = {\n         entry: './src/main.js', //指定打包的入口文件\n         output: {\n           path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径\n           filename: 'build.js', //输出文件\n         },\n         devtool: 'eval-source-map', //Debug调试\n         plugins: [\n           new htmlwp({\n             title: '首页', //生成的页面标题<head><title>首页</title></head>\n             filename: 'index.html', //webpack-dev-server在内存中生成的文件名称，自动将build注入到这个页面底部，才能实现自动刷新功能\n             template: 'vue.html', //根据vue.html这个模板来生成(这个文件请程序员自己生成)\n           }),\n         ],\n       }\n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       11\n       12\n       13\n       14\n       15\n       16\n       17\n       \n\n 5. 运行\n    \n    * 在webpacktest目录，执行**npm run dev**。\n    \n    * 或使用 webstorm，右键package.json文件，选择“Show npm Scripts”，双击 dev 即可\n      \n      【注意】dev 就是在package.json中配置的webpack-dev-server......命令。\n      \n      启动成功自动打开浏览器。修改 src 中的任意文件内容，自动加载并刷新浏览器。\n\n 6. Debug 调试\n    \n    使用了 webpack 之后就不能采用传统 js 的调试方法在 chrome 中打断点（因为打包了！内容发生变化）\n    \n    webpack 提供 devtool 进行调试，它是基于 sourcemap 的方式，在调试时会生成一个 map 文件，其内容记录生成文件和源文件的内容映射，即生成文件中的哪个位置对应源文件中的哪个位置，有了 sourcemap 就可以在调试时看到源代码。\n    \n    * 在 webpack.config.js 中配置：devtool: 'eval‐source‐map',具体查看上面的代码\n    * 在 js 中跟踪代码的位置上添加debugger，开启浏览器开发者工具……",normalizedContent:"# 入门\n\n配套的代码在 github 中。\n\n可查看中文文档，官方文档。注意两者区别。\n\n\n# 概念\n\n\n# 简介\n\n本质上，webpack 是一个用于现代 javascript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 bundle。\n\n\n\n静态模块 + 打包\n\n * 在 es6 之前，进行模块化开发时必须借助其他工具，如 commonjs。通过模块化开发完项目后，还需处理模块间的依赖\n * 将各模块进行打包整合，处理为大部分浏览器能识别的代码、资源\n\n\n# 优缺点\n\n# 优点\n\n * 模块化开发\n   \n   程序员在开发时可以分模块创建不同的 js、 css 等小文件方便开发，最后使用 webpack 将这些小文件打包成一个文件，减少了 http 的请求次数。webpack 可以实现按需打包，为了避免出现打包文件过大可以打包成多个文件。\n\n * 编译 typescript、es6 等高级 js 语法\n\n * css 预编译\n   \n   webpack 允许在开发中使用 sass 和 less 等原生 css 的扩展技术，通过 sass-loader、less-loader 将 sass 和 less 的语法编译成浏览器可识别的 css 语法。\n\n# 缺点\n\n * 配置有些繁琐，文档不丰富\n\n\n# 和 grunt / gulp 对比\n\n * grunt / gulp 核心为 task，主要用于简单的合并、压缩。更强调前端流程的自动化、模块化不是它的核心\n * webpack 更加强调模块化开发管理，文件合并、压缩、预处理是附带功能\n\n\n# 安装\n\nwebpack 依赖 node，node 会自动安装 npm。一般推荐先对项目进行npn init或npm install\n\n\n# 局部安装\n\n在 package.json 中定义 scripts 中的 webpack 命令，首先查找使用的是局部安装的 webpack，在 node_modules/bin 中。命令行中也是先查找项目中的 webpack。类比 dns\n\ncd 目录\n# --save-dev 是开发时依赖，项目打包后不需要继续使用\nnpm install --save-dev webpack\n# 或指定版本\nnpm install --save-dev webpack@<version>\n\n# 安装后查看版本号，需要找到安装的目录，如 node_modules/webpack/bin，进入后\n./webpack.js -v\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\nnpm install --save-dev webpack@3.7.0 #本地安装 webpack 3.6.0，因为 vue cli2 依赖该版本。此处改为3.7.0是为了区分\n\n\n1\n\n\n\n# 全局安装\n\n一般不推荐，但是在使用命令学习时每个文件夹都要局部安装的话太麻烦了\n\n全局安装之后在终端执行 webpack 命令，就使用的是全局安装的 webpack 。注意：4.0 以后的版本需要安装 webpack-cl。\n\n本地安装只需去掉-g，即可在当前目录安装\n\nnpm install webpack -g\n# 4.0后的版本需要安装 webpack-cl\nnpm install webpack-cli -g\n# 可以指定版本\nnpm install webpack@<version> -g #全局安装 webpack 3.6.0，因为 vue cli2 依赖该版本。\n\n\n# 安装后查看版本号\nwebpack -v\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nnpm install webpack@3.6.0 -g #全局安装 webpack 3.6.0，因为 vue cli2 依赖该版本。\n\n\n1\n\n\n\n# 基本使用—打包 js\n\n目前的项目文件结构\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>document</title>\n  </head>\n  <body>\n    \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n    <script src=\"./dist/bundle.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n// main.js\n\n// commonjs\nvar { formatdate } = require('./js/utils.js')\n\nconsole.log(formatdate(new date()))\n\n// es6\nimport * as poem from './js/poem.js'\nconsole.log(poem.spring)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n// ./js/utils.js\n\nfunction formatdate(date) {\n  return `${date.getfullyear()}-${\n    date.getmonth() + 1 < 10 ? '0' + (date.getmonth() + 1) : date.getmonth() + 1\n  }-${date.getdate() < 10 ? '0' + date.getdate() : date.getdate()} ${\n    date.gethours() < 10 ? '0' + date.gethours() : date.gethours()\n  }:${date.getminutes() < 10 ? '0' + date.getminutes() : date.getminutes()}:${\n    date.getseconds() < 10 ? '0' + date.getseconds() : date.getseconds()\n  }`\n}\n\n// commonjs\n// 可以省略掉 module\nmodule.exports = {\n  formatdate,\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\n// ./js/poem.js\n\nconst spring =\n  '天街小雨润如酥，草色遥看近却无。最是一年春好处，绝胜烟柳满皇都。'\nconst summer =\n  '毕竟西湖六月中，风光不与四时同。接天莲叶无穷碧，映日荷花别样红。'\nconst autumn =\n  '银烛秋光冷画屏，轻罗小扇扑流萤。天阶夜色凉如水，坐看牵牛织女星。'\nconst winter = '日暮苍山远，天寒白屋贫。柴门闻犬吠，风雪夜归人。'\n\n// es6\nexport { spring, summer, autumn, winter }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n执行打包命令\n\ncd study-webpack/1 webpack起步\n# 使用全局 webpack 打包\nwebpack ./src/main.js ./dist/bundle.js\n\n##########\nhash: f664968929cb925ac098\nversion: webpack 3.6.0\ntime: 35ms\n    asset     size  chunks             chunk names\nbundle.js  4.16 kb       0  [emitted]  main\n   [0] /users/conanan/documents/vscode/study-webpack/1 webpack起步/src/main.js 144 bytes {0} [built]\n   [1] /users/conanan/documents/vscode/study-webpack/1 webpack起步/src/utils.js 504 bytes {0} [built]\n   [2] /users/conanan/documents/vscode/study-webpack/1 webpack起步/src/poem.js 486 bytes {0} [built]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\ncd study-webpack/1 webpack起步\n#使用本地 webpack 打包\n./node_modules/.bin/webpack ./src/main.js ./dist/bundle.js\n\n##########\nhash: bf83695e4e6f3e90f28b\nversion: webpack 3.7.0\ntime: 35ms\n    asset    size  chunks             chunk names\nbundle.js  4.2 kb       0  [emitted]  main\n   [0] ./src/main.js 163 bytes {0} [built]\n   [1] ./src/utils.js 516 bytes {0} [built]\n   [2] ./src/poem.js 493 bytes {0} [built]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n虽然仅仅打包了 main.js，但是 webpack 会将 main.js 所依赖的所有 js 文件都打包，且无论是 es6 的模块化还是 commonjs 的模块化都可以正确打包\n\n\n# 配置—webpack.config.js\n\n做到的结果是仅需执行webpack命令或npm run build命令即可做出上述复杂命令的操作\n\n首先生成package.json，在执行npm init时指定 name（最好全英文）、入口文件main.js（不指定也没有报错？）\n\n在 src 和 dist 同级目录下创建webpack.config.js\n\n// 这个会从 node 中查找，需要 npm init 来生成 package.json。这里好像不能使用 es6 的模块化语法\nconst path = require('path')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n执行命令\n\ncd study-webpack/2 webpack配置\n# 默认先查找局部安装的 webpack\nwebpack\n\n##########\nhash: bf83695e4e6f3e90f28b\nversion: webpack 3.7.0\ntime: 37ms\n    asset    size  chunks             chunk names\nbundle.js  4.2 kb       0  [emitted]  main\n   [0] ./src/main.js 163 bytes {0} [built]\n   [1] ./src/utils.js 516 bytes {0} [built]\n   [2] ./src/poem.js 493 bytes {0} [built]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n如何配置执行npm run build即可完成上述操作呢？需要修改package.json\n\n{\n  \"name\": \"meetwebpack\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"main.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"error: no test specified\\\" && exit 1\",\n    \"build\": \"webpack\"\n  },\n  \"author\": \"\",\n  \"license\": \"isc\"\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n执行命令\n\ncd study-webpack/2 webpack配置\nnpm run build\n\n##########\n> meetwebpack@1.0.0 build /users/conanan/documents/vscode/study-webpack/2 webpack配置\n> webpack\n\nhash: bf83695e4e6f3e90f28b\nversion: webpack 3.7.0\ntime: 35ms\n    asset    size  chunks             chunk names\nbundle.js  4.2 kb       0  [emitted]  main\n   [0] ./src/main.js 163 bytes {0} [built]\n   [1] ./src/utils.js 516 bytes {0} [built]\n   [2] ./src/poem.js 493 bytes {0} [built]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n\n# loader 🔥\n\nwebpack 只能理解 javascript 和 json 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。\n\nloader 可以理解为是模块和资源的转换器，它本身是一个函数，接受源文件作为参数，返回转换的结果。这样，我们就可以通过  require  来加载任何类型的模块或文件，比如 coffeescript、 jsx、 less 或图片。首先我们需要安装相关 loader 插件，具体操作文档中写得非常详细。\n\n\n# 打包 css\n\ncss-loader 是将 css 装载到 javascript；style-loader 是让 javascript 认识 css。\n\n目前的项目文件结构\n\n 1. 安装 css-loader 和 style-loader\n    \n    npm install --save-dev css-loader style-loader\n    \n    \n    1\n    \n\n 2. 修改 webpack.config.js，添加 module 模块\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n      },\n      module: {\n        rules: [\n          {\n            test: /\\.css$/i,\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // style-loader 将模块导出作为style添加到dom中\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n        ],\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n\n 3. 创建 css 文件\n    \n    /* css/normal.css */\n    \n    body {\n      background-color: skyblue;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n\n 4. 修改入口 main.js ，引入上面的 css 文件（若没有 loader，直接引入打包则报错）\n    \n    // commonjs\n    var { formatdate } = require('./js/utils.js')\n    \n    console.log(formatdate(new date()))\n    \n    // es6\n    import * as poem from './js/poem.js'\n    console.log(poem.spring)\n    \n    // commonjs 语法，不能使用 es6，那是针对 js 的\n    require('./css/normal.css')\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 5. 重新打包webpack或npn run build\n\n 6. 访问 index.html 看看背景\n\n\n# 打包 less、scss、stylus\n\n这里以 less 为例，创建文件并放入 css 目录中，引入等操作和 css 文件一样\n\n 1. 安装 less-loader（由于 webpack 的版本较低，是 3.6.0 或 3.7.0，目前已经出了 5.0 了，这里 less-loader 版本也需要降低）\n    \n    npm install --save-dev less-loader less\n    \n    \n    1\n    \n    \n    卸载高版本 less-loader，重新安装指定版本的（我也是服了，没找到哪写了版本高）\n    \n    npm uninstall less-loader\n    npm install less-loader@4.1.0 --save-dev\n    \n    \n    1\n    2\n    \n\n 2. 修改 webpack.config.js，添加 module 模块\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到dom中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from js strings\n              },\n              {\n                loader: 'css-loader', // translates css into commonjs\n              },\n              {\n                loader: 'less-loader', // compiles less to css\n              },\n            ],\n          },\n        ],\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    \n\n 3. 创建 less 文件，并在入口文件 main.js 中引入\n    \n    // css/special.less\n    \n    @fontsize: 50px;\n    @fontcolor: orange;\n    \n    body {\n      font-size: @fontsize;\n      color: @fontcolor;\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    \n    \n    // main.js\n    \n    // commonjs\n    var { formatdate } = require('./js/utils.js')\n    \n    console.log(formatdate(new date()))\n    \n    // es6\n    import * as poem from './js/poem.js'\n    console.log(poem.spring)\n    \n    // commonjs 语法，不能使用 es6，那是针对 js 的\n    require('./css/normal.css')\n    require('./css/special.less')\n    document.writeln('world')\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 4. html 文件\n    \n    <!doctype html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>document</title>\n      </head>\n      <body>\n        <p>hello</p>\n        \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n        <script src=\"./dist/bundle.js\"><\/script>\n      </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    \n\n 5. 重新打包webpack或npn run build\n\n 6. 访问 index.html 看看字体及颜色\n\n\n# 打包图片\n\n 1. 安装 url-loader，file-loader（当图片大小大于 limit 时使用）\n    \n    npm install --save-dev url-loader\n    npm install --save-dev file-loader\n    \n    \n    1\n    2\n    \n\n 2. 修改 webpack.config.js，添加 module 模块\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicpath配置\n        publicpath: 'dist/',\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到dom中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from js strings\n              },\n              {\n                loader: 'css-loader', // translates css into commonjs\n              },\n              {\n                loader: 'less-loader', // compiles less to css\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n        ],\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    \n\n 3. 修改 css 中背景\n    \n    body {\n      /* background-color: skyblue; */\n      background-image: url('../img/conan.jpeg');\n    }\n    \n    \n    1\n    2\n    3\n    4\n    \n\n 4. 重新打包webpack或npn run build\n\n 5. 访问 index.html 看看背景图片\n    \n    当图片大小小于 limit 时，会被编译为 base64 字符串，可以直接显示出来\n    \n    当大于 limit 时，会使用 file-loader 进行加载，且重命名（32 位哈希值）并打包到 dist 目录中，由于路径不对无法显示（显示的是以 index.html 的目录为目录的路径，需要改为以 dist/ 为目录的路径）。\n    \n    实际中，这种 32 位哈希值的文件名并不方便，且没有放入统一的目录中。实际可能会将其放入img/[name][hash:8].[ext]，在 loader 中配置即可\n    \n    但是实际中，会把所有文件都打包到 dist 中，此时应该删掉 publicpath 配置！\n\n\n# babel\n\nwebpack 打包的 js 文件，没有将 es6 转为 es5，有部分浏览器不支持，所以此时可以使用 babel\n\n 1. 安装 babel-loader 和 babel（注意此处还是根据 webpack 3.6.* 选择的版本）\n    \n    npm install babel-loader@7 babel-core babel-preset-es2015 --save-dev\n    \n    \n    1\n    \n    \n    我就服了，文档里的配置还让安装 webpack？还失败了，还有些看不懂的配置。算了 😄\n\n 2. 修改 webpack.config.js，添加 module 模块\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicpath配置\n        publicpath: 'dist/',\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到dom中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from js strings\n              },\n              {\n                loader: 'css-loader', // translates css into commonjs\n              },\n              {\n                loader: 'less-loader', // compiles less to css\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n        ],\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    \n\n 3. 重新打包webpack或npn run build。查看 buldle.js 文件\n\n\n# vue—配合 webpack 使用 🔥\n\n\n# 配置\n\n 1. npm 安装 vue\n    \n    npm install vue --save\n    \n    \n    1\n    \n    \n    --save可以简写为-s，vue 是要在发布时也使用的，所以无需添加-dev\n\n 2. 使用 vue 开发，在 main.js 中\n    \n    // commonjs\n    var { formatdate } = require('./js/utils.js')\n    \n    console.log(formatdate(new date()))\n    \n    // es6\n    import * as poem from './js/poem.js'\n    console.log(poem.spring)\n    \n    // commonjs 语法，不能使用 es6，那是针对 js 的\n    require('./css/normal.css')\n    require('./css/special.less')\n    document.writeln('world')\n    \n    import vue from 'vue'\n    \n    const vm = new vue({\n      el: '#app',\n      data: {\n        message: 'hello',\n      },\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    \n    \n    修改 index.html\n    \n    <!doctype html>\n    <html lang=\"en\">\n      <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n        <title>document</title>\n      </head>\n      <body>\n        <div id=\"app\">\n          {{message}}\n        </div>\n        \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n        <script src=\"./dist/bundle.js\"><\/script>\n      </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    \n\n 3. 重新打包webpack或npn run build。访问后发现报错\n    \n    bundle.js:1344 [vue warn]: you are using the runtime-only build of vue where the template compiler is not available. either pre-compile the templates into render functions, or use the compiler-included build.\n    \n    \n    1\n    \n    \n    这是由于 vue 在构建时有两个版本\n    \n    * runtime-only：代码中，不可以有任何 template，如 id=\"app\" 那个 div\n    * runtime-compiler：代码中，可以有 template，compiler 会对其进行编译\n    \n    官网文档解释，修改 webpack.config.js\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicpath配置\n        publicpath: 'dist/',\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到dom中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from js strings\n              },\n              {\n                loader: 'css-loader', // translates css into commonjs\n              },\n              {\n                loader: 'less-loader', // compiles less to css\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n        ],\n      },\n      resolve: {\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    \n\n 4. 重新打包webpack或npn run build。访问\n\n\n# el 和 template 区别\n\n实际使用时，不会修改 index.html 的代码，仅仅留个 id=\"app\" 的 div，只需要在使用 vue 时指定 template 即可，vue 内部会自动将 template 中的代码替换 id=\"app\" 的 div（该 div 将不见）\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>document</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n    <script src=\"./dist/bundle.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n// main.js\n\n// commonjs\nvar { formatdate } = require('./js/utils.js')\n\nconsole.log(formatdate(new date()))\n\n// es6\nimport * as poem from './js/poem.js'\nconsole.log(poem.spring)\n\n// commonjs 语法，不能使用 es6，那是针对 js 的\nrequire('./css/normal.css')\nrequire('./css/special.less')\ndocument.writeln('world')\n\nimport vue from 'vue'\n\nconst vm = new vue({\n  el: '#app',\n  template: `\n    <div>\n        <h2>{{message}}</h2>\n        <button @click=\"btnclick\">按钮</button>\n    </div>\n    `,\n  data: {\n    message: 'hello',\n  },\n  methods: {\n    btnclick() {\n      alert(1)\n    },\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 终极使用\n\n这个视频讲解的非常详细，一步一步\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>document</title>\n  </head>\n  <body>\n    <div id=\"app\"></div>\n    \x3c!-- 引用的是打包后的文件。无需写type --\x3e\n    <script src=\"./dist/bundle.js\"><\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n// commonjs\nvar { formatdate } = require('./js/utils.js')\n\nconsole.log(formatdate(new date()))\n\n// es6\nimport * as poem from './js/poem.js'\nconsole.log(poem.spring)\n\n// commonjs 语法，不能使用 es6，那是针对 js 的\nrequire('./css/normal.css')\nrequire('./css/special.less')\n// document.writeln(\"world\");\n\nimport vue from 'vue'\n// 导入组件 js 文件，可省略后缀\n// import app from \"./vue/app\";\n// 导入组件 vue 文件，不可省略后缀。在 vue 文件中可以省略（但需webpack配置）\nimport app from './vue/app.vue'\n\nconst vm = new vue({\n  el: '#app',\n  template: '<app/>',\n  components: {\n    app,\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\x3c!-- vue/app.vue--\x3e\n<template>\n  <div>\n    <h2>{{ message }}</h2>\n    <button @click=\"btnclick\">按钮</button>\n    <cpn />\n  </div>\n</template>\n\n<script>\n// 可省略后缀（需在 webpakc 中配置）\nimport cpn from './cpn'\n\nexport default {\n  name: 'app',\n  components: {\n    cpn,\n  },\n  data() {\n    return { message: 'hello' }\n  },\n  methods: {\n    btnclick() {\n      alert(1)\n    },\n  },\n}\n<\/script>\n\n<style></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\x3c!-- vue/cpn.vue--\x3e\n<template>\n  <div>\n    <h2>{{ message }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'cpn',\n  data() {\n    return {\n      message: 'cpn 组件！！！！！',\n    }\n  },\n}\n<\/script>\n\n<style></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n若修改后重新打包失败，可以安装 vue loader。其中 vue-template-compiler 用于直接解析 template 模版（提高性能）\n\nnpm install -d vue-loader vue-template-compiler\n\n\n1\n\n\nwebpack.config.js\n\n// 这个会从 node 中查找，需要 npm init 来生成 package.json\nconst path = require('path')\nconst vueloaderplugin = require('vue-loader/lib/plugin')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n    // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicpath配置\n    publicpath: 'dist/',\n  },\n  module: {\n    rules: [\n      {\n        // 匹配.css文件\n        test: /\\.css$/i,\n\n        // style-loader 将模块导出作为style添加到dom中\n        // css-loader解析css文件后，使用import加载，并返回css代码\n        // 使用多个loader时，从右到左加载。顺序不能乱！\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.less$/,\n        use: [\n          {\n            loader: 'style-loader', // creates style nodes from js strings\n          },\n          {\n            loader: 'css-loader', // translates css into commonjs\n          },\n          {\n            loader: 'less-loader', // compiles less to css\n          },\n        ],\n      },\n      {\n        test: /\\.(png|jpg|gif|jpeg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 当图片大小小于 limit 时，会被编译为base64字符串\n              // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n              limit: 10000,\n              // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n              name: 'img/[name][hash:8].[ext]',\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.js$/,\n        // 排除\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['es2015'],\n          },\n        },\n      },\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n      },\n    ],\n  },\n  resolve: {\n    // 在 .vue 文件中导入如下文件时可以省略后缀\n    extensions: ['.js', '.vue', '.css'],\n    alias: {\n      // 指定发布的版本\n      vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n    },\n  },\n  plugins: [\n    // 请确保引入这个插件！\n    new vueloaderplugin(),\n  ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n重新打包webpack或npn run build。访问\n\n\n# plugin\n\nplugin 与 loader 区别：\n\n * loader：用于转换某些类型的模块，是转换器\n * plugin：是对 webpack 本身的扩展，是扩展器\n\n使用步骤：\n\n 1. npm 安装（某些 webpack 内置的无需安装）\n 2. 在 webpack.config.js 中的 plugins 配置\n\n\n# banner\n\nwebpack 自带，只需配置好\n\n// 这个会从 node 中查找，需要 npm init 来生成 package.json\nconst path = require('path')\nconst vueloaderplugin = require('vue-loader/lib/plugin')\n\nmodule.exports = {\n  entry: './src/main.js',\n  output: {\n    // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n    path: path.resolve(__dirname, 'dist'),\n    filename: 'bundle.js',\n    // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicpath配置\n    publicpath: 'dist/',\n  },\n  module: {\n    rules: [\n      {\n        // 匹配.css文件\n        test: /\\.css$/i,\n\n        // style-loader 将模块导出作为style添加到dom中\n        // css-loader解析css文件后，使用import加载，并返回css代码\n        // 使用多个loader时，从右到左加载。顺序不能乱！\n        use: ['style-loader', 'css-loader'],\n      },\n      {\n        test: /\\.less$/,\n        use: [\n          {\n            loader: 'style-loader', // creates style nodes from js strings\n          },\n          {\n            loader: 'css-loader', // translates css into commonjs\n          },\n          {\n            loader: 'less-loader', // compiles less to css\n          },\n        ],\n      },\n      {\n        test: /\\.(png|jpg|gif|jpeg)$/,\n        use: [\n          {\n            loader: 'url-loader',\n            options: {\n              // 当图片大小小于 limit 时，会被编译为base64字符串\n              // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n              limit: 10000,\n              // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n              name: 'img/[name][hash:8].[ext]',\n            },\n          },\n        ],\n      },\n      {\n        test: /\\.js$/,\n        // 排除\n        exclude: /(node_modules|bower_components)/,\n        use: {\n          loader: 'babel-loader',\n          options: {\n            presets: ['es2015'],\n          },\n        },\n      },\n      {\n        test: /\\.vue$/,\n        loader: 'vue-loader',\n      },\n    ],\n  },\n  resolve: {\n    // 在 .vue 文件中导入如下文件时可以省略后缀\n    extensions: ['.js', '.vue', '.css'],\n    alias: {\n      // 指定发布的版本\n      vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n    },\n  },\n  plugins: [\n    // 请确保引入这个插件！\n    new vueloaderplugin(),\n  ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n\n\n重新打包webpack或npn run build。查看 bundle.js 文件\n\n\n# htmlwebpackplugin 🔥\n\n目前我们的 index.html 文件在根目录下，且打包后也是在原位置，而实际真实发布项目时，发布的是 dist 目录中的内容，但是其中并没有 index.html，只能复制过去。所以我们需要可以将 index.html 打包到 dist 目录的插件。\n\nhtmlwebpackplugin 插件可以做：\n\n * 自动生成一个 index.html（可指定模板）\n * 将打包的 js 文件，自动通过 script 标签插入到 index.html 的 body 中\n\n使用步骤：\n\n 1. 安装（只开发时依赖）由于 webpack 版本为 3.6.*，所以此处需要安装指定版本的\n    \n    npm install html-webpack-plugin@3.2.0 --save-dev\n    \n    \n    1\n    \n\n 2. 修改 webpack.config.js 中 plugins 内容\n    \n    注意删掉publicpath\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    const vueloaderplugin = require('vue-loader/lib/plugin')\n    const webpack = require('webpack')\n    const htmlwebpackplugin = require('html-webpack-plugin')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicpath配置\n        // publicpath: \"dist/\",\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到dom中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from js strings\n              },\n              {\n                loader: 'css-loader', // translates css into commonjs\n              },\n              {\n                loader: 'less-loader', // compiles less to css\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n          {\n            test: /\\.vue$/,\n            loader: 'vue-loader',\n          },\n        ],\n      },\n      resolve: {\n        // 在 .vue 文件中导入如下文件时可以省略后缀\n        extensions: ['.js', '.vue', '.css'],\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n      plugins: [\n        // 请确保引入这个插件！\n        new vueloaderplugin(),\n        // banner插件\n        new webpack.bannerplugin('最终版权归conanan所有'),\n        // htmlwebpackplugin 插件\n        new htmlwebpackplugin({\n          template: 'index.html',\n        }),\n      ],\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    \n\n 3. 重新打包webpack或npn run build。查看 index.html 文件\n\n\n# uglifyjs 压缩 🔥\n\n 1. 安装（由于 webpack 版本及 cli2，遂选择该版本）\n    \n    还是报错，我看 node_modules 中好像自带了，只需配置即可食用\n    \n    npm install uglifyjs-webpack-plugin@1.1.1 --save-dev\n    \n    \n    1\n    \n\n 2. 修改 webpack.config.js 中 plugins 内容\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    const vueloaderplugin = require('vue-loader/lib/plugin')\n    const webpack = require('webpack')\n    const htmlwebpackplugin = require('html-webpack-plugin')\n    const uglifyjswebpackplugin = require('uglifyjs-webpack-plugin')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicpath配置\n        // publicpath: \"dist/\",\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到dom中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from js strings\n              },\n              {\n                loader: 'css-loader', // translates css into commonjs\n              },\n              {\n                loader: 'less-loader', // compiles less to css\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n          {\n            test: /\\.vue$/,\n            loader: 'vue-loader',\n          },\n        ],\n      },\n      resolve: {\n        // 在 .vue 文件中导入如下文件时可以省略后缀\n        extensions: ['.js', '.vue', '.css'],\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n      plugins: [\n        // 请确保引入这个插件！\n        new vueloaderplugin(),\n        // banner插件\n        new webpack.bannerplugin('最终版权归conanan所有'),\n        // htmlwebpackplugin 插件\n        new htmlwebpackplugin({\n          template: 'index.html',\n        }),\n        // uglifyjswebpackplugin 插件\n        new uglifyjswebpackplugin(),\n      ],\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    94\n    \n\n 3. 重新打包webpack或npn run build。查看 bundle.js 文件\n\n\n# webpack-dev-server 🔥\n\nwebpack 提供了一个可选的本地开发服务器，基于 node 搭建，内部使用 express 框架，可以实现浏览器自动“刷新”显示我们修改后的结果。不过它是一个单独的模块，需要先安装。\n\n 1. 安装（版本号还是由于 webpack 3.6.*）\n    \n    npm install webpack-dev-server@2.9.1 --save-dev\n    \n    \n    1\n    \n\n 2. 修改 webpack.config.js 中 devserver 内容\n    \n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    const vueloaderplugin = require('vue-loader/lib/plugin')\n    const webpack = require('webpack')\n    const htmlwebpackplugin = require('html-webpack-plugin')\n    const uglifyjswebpackplugin = require('uglifyjs-webpack-plugin')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        path: path.resolve(__dirname, 'dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicpath配置\n        // publicpath: \"dist/\",\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到dom中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from js strings\n              },\n              {\n                loader: 'css-loader', // translates css into commonjs\n              },\n              {\n                loader: 'less-loader', // compiles less to css\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n          {\n            test: /\\.vue$/,\n            loader: 'vue-loader',\n          },\n        ],\n      },\n      resolve: {\n        // 在 .vue 文件中导入如下文件时可以省略后缀\n        extensions: ['.js', '.vue', '.css'],\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n      plugins: [\n        // 请确保引入这个插件！\n        new vueloaderplugin(),\n        // banner插件\n        new webpack.bannerplugin('最终版权归conanan所有'),\n        // htmlwebpackplugin 插件\n        new htmlwebpackplugin({\n          template: 'index.html',\n        }),\n        // uglifyjswebpackplugin 插件\n        new uglifyjswebpackplugin(),\n      ],\n      devserver: {\n        // 为那个目录提供本地服务，默认是项目根目录\n        contentbase: './dist',\n        // 页面实时刷新\n        inline: true,\n        // 端口\n        port: 9999,\n        // 在spa中，依赖h5的history模式\n        // historyapifallback,\n      },\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    94\n    95\n    96\n    97\n    98\n    99\n    100\n    101\n    102\n    103\n    104\n    \n\n 3. 执行webpack-dev-server发现没有该命令，原因是安装到本地，可以在 package.json 中配置 scripts，即可实现默认查找本地 node_modules 中命令。--open可以在服务启动后自动打开浏览器\n    \n    {\n      \"scripts\": {\n        \"dev\": \"webpack-dev-server --open\"\n      }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    \n    \n    但是发现无法启动，报错\n    \n    error in bundle.js from uglifyjs\n    unexpected token: name (urlparts) [bundle.js:4153,4]\n    \n    \n    1\n    2\n    \n    \n    参考这个博客，虽然可以启动了，但是修改文件后还是报错。算了（所以目前代码 5 webpack-plugins 可能有问题，接下来就解决了）\n\n\n# 配置文件分离 🔥\n\n这里就有问题了，webpack.config.js 中的配置，有些是开发模式需要的，有些才是发布模式需要的，如何分离？并且开发模式时使用 uglifyjs 插件会无法调试，如何解决？此时需要 webpack 的配置文件分离。\n\n 1. 安装依赖\n    \n    npm install webpack-merge --save-dev\n    \n    \n    1\n    \n\n 2. build/base.config.js。注意 output 目录的改变\n    \n    // 基础依赖\n    // 这个会从 node 中查找，需要 npm init 来生成 package.json\n    const path = require('path')\n    const vueloaderplugin = require('vue-loader/lib/plugin')\n    const webpack = require('webpack')\n    const htmlwebpackplugin = require('html-webpack-plugin')\n    \n    module.exports = {\n      entry: './src/main.js',\n      output: {\n        // path 需要写绝对路径，但又不能直接指定，可以动态获取（采用 node 语法）\n        // 配置文件分离后需要修改 path\n        path: path.resolve(__dirname, '../dist'),\n        filename: 'bundle.js',\n        // 输出涉及url时，会自动在前面添加该字符串。实际中，会把所有文件都打包到 dist 中，此时应该删掉publicpath配置\n        // publicpath: \"dist/\",\n      },\n      module: {\n        rules: [\n          {\n            // 匹配.css文件\n            test: /\\.css$/i,\n    \n            // style-loader 将模块导出作为style添加到dom中\n            // css-loader解析css文件后，使用import加载，并返回css代码\n            // 使用多个loader时，从右到左加载。顺序不能乱！\n            use: ['style-loader', 'css-loader'],\n          },\n          {\n            test: /\\.less$/,\n            use: [\n              {\n                loader: 'style-loader', // creates style nodes from js strings\n              },\n              {\n                loader: 'css-loader', // translates css into commonjs\n              },\n              {\n                loader: 'less-loader', // compiles less to css\n              },\n            ],\n          },\n          {\n            test: /\\.(png|jpg|gif|jpeg)$/,\n            use: [\n              {\n                loader: 'url-loader',\n                options: {\n                  // 当图片大小小于 limit 时，会被编译为base64字符串\n                  // 当大于 limit 时，会使用 file-loader 进行加载，仅需要安装！\n                  limit: 10000,\n                  // img/目录下，[name]为原名，[hash:8]为8位哈希值，.[ext]为后缀\n                  name: 'img/[name][hash:8].[ext]',\n                },\n              },\n            ],\n          },\n          {\n            test: /\\.js$/,\n            // 排除\n            exclude: /(node_modules|bower_components)/,\n            use: {\n              loader: 'babel-loader',\n              options: {\n                presets: ['es2015'],\n              },\n            },\n          },\n          {\n            test: /\\.vue$/,\n            loader: 'vue-loader',\n          },\n        ],\n      },\n      resolve: {\n        // 在 .vue 文件中导入如下文件时可以省略后缀\n        extensions: ['.js', '.vue', '.css'],\n        alias: {\n          // 指定发布的版本\n          vue$: 'vue/dist/vue.esm.js', // 用 webpack 1 时需用 'vue/dist/vue.common.js'\n        },\n      },\n      plugins: [\n        // 请确保引入这个插件！\n        new vueloaderplugin(),\n        // banner插件\n        new webpack.bannerplugin('最终版权归conanan所有'),\n        // htmlwebpackplugin 插件\n        new htmlwebpackplugin({\n          template: 'index.html',\n        }),\n      ],\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    42\n    43\n    44\n    45\n    46\n    47\n    48\n    49\n    50\n    51\n    52\n    53\n    54\n    55\n    56\n    57\n    58\n    59\n    60\n    61\n    62\n    63\n    64\n    65\n    66\n    67\n    68\n    69\n    70\n    71\n    72\n    73\n    74\n    75\n    76\n    77\n    78\n    79\n    80\n    81\n    82\n    83\n    84\n    85\n    86\n    87\n    88\n    89\n    90\n    91\n    92\n    93\n    \n\n 3. build/dev.config.js\n    \n    // 开发时配置\n    const baseconfig = require('./base.config')\n    const webpackmerge = require('webpack-merge')\n    \n    module.exports = webpackmerge(baseconfig, {\n      devserver: {\n        // 为那个目录提供本地服务，默认是项目根目录\n        contentbase: './dist',\n        // 页面实时刷新\n        inline: true,\n        // 端口\n        port: 9999,\n        // 在spa中，依赖h5的history模式\n        // historyapifallback,\n      },\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    \n\n 4. build/prod.config.js\n    \n    // 生产时依赖\n    const uglifyjswebpackplugin = require('uglifyjs-webpack-plugin')\n    const baseconfig = require('./base.config')\n    const webpackmerge = require('webpack-merge')\n    \n    module.exports = webpackmerge(baseconfig, {\n      plugins: [\n        // uglifyjswebpackplugin 插件\n        new uglifyjswebpackplugin(),\n      ],\n    })\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    \n\n 5. 删掉之前的 webpack.config.js，此时命令就不能使用了，需要修改配置 package.json\n    \n    {\n      \"scripts\": {\n        \"dev\": \"webpack-dev-server --open --config ./build/dev.config.js\",\n        \"build\": \"webpack --config ./build/prod.config.js\"\n      }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    \n    \n    执行上述命令，发现一切都好了！😄\n\n\n# 其他（旧）\n\nwebpack-dev-server 开发服务器，它的功能可以实现热加载并且自动刷新浏览器。\n\n 1. 创建一个新的程序目录，这里我们创建webpacktest目录，将 webpack 入门程序的代码拷贝进来，并在目录下创建src目录、dist目录。将main.js，module01.js和vue.min.js拷贝到 src 目录。html 文件拷贝到当前目录下。\n\n 2. 使用 webpack-dev-server 需要安装 webpack、 webpack-dev-server和 html-webpack-plugin三个包在当前程序目录\n    \n    cnpm install webpack@3.6.0 webpack-dev-server@2.9.1 html-webpack-plugin@2.30.1 --save-dev\n    \n    安装完成后程序目录出现**package.json文件**，此文件中记录了程序的依赖信息（上面三个）\n    \n    还有**node_modules文件夹**，有 993 个文件或文件夹！！！存放本程序所依赖的包！\n\n 3. 配置 webpack-dev-server，在package.json中配置 script（运行命令），最终内容如下\n    \n    {\n      \"scripts\": {\n        \"dev\": \"webpack-dev-server --inline --hot --open --port 5008\"\n      },\n      \"devdependencies\": {\n        \"html-webpack-plugin\": \"^2.30.1\",\n        \"webpack\": \"^3.6.0\",\n        \"webpack-dev-server\": \"^2.9.1\"\n      }\n    }\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    \n    \n    scripts：可执行的命令\n    \n    --inline：自动刷新；--hot：热加载；--open：自动在默认浏览器打开；--port：指定端口；\n    \n    --host：可以指定服务器的 ip，不指定则为 127.0.0.1，如果对外发布则填写公网 ip 地址\n    \n    devdependencies：开发人员在开发过程中所需要的依赖\n\n 4. 配置webpack.config.js，是 webpack 的配置文件，在此文件中可以配置应用的入口文件、输出配置、插件等，其中要实现热加载自动刷新功能需要配置 html-webpack-plugin 插件。html-webpack-plugin 的作用是根据 html 模板在内存生成 html 文件，它的工作原理是根据模板文件在内存中生成一个 index.html 文件。\n    \n    1. 配置模板文件。将原来的vue.html作为模板文件，为了和内存中的index.html文件名区别，注意将vue.html中的所有script标签去掉\n    \n    2. 在webpack.config.js（与package.json同目录）中配置html-webpack-plugin插件\n       \n       //引用html-webpack-plugin插件，作用是根据html模板在内存生成html文件，它的工作原理是根据模板文件在内存中生成一个index.html文件。\n       var htmlwp = require('html-webpack-plugin')\n       module.exports = {\n         entry: './src/main.js', //指定打包的入口文件\n         output: {\n           path: __dirname + '/dist', // 注意：__dirname表示webpack.config.js所在目录的绝对路径\n           filename: 'build.js', //输出文件\n         },\n         devtool: 'eval-source-map', //debug调试\n         plugins: [\n           new htmlwp({\n             title: '首页', //生成的页面标题<head><title>首页</title></head>\n             filename: 'index.html', //webpack-dev-server在内存中生成的文件名称，自动将build注入到这个页面底部，才能实现自动刷新功能\n             template: 'vue.html', //根据vue.html这个模板来生成(这个文件请程序员自己生成)\n           }),\n         ],\n       }\n       \n       \n       1\n       2\n       3\n       4\n       5\n       6\n       7\n       8\n       9\n       10\n       11\n       12\n       13\n       14\n       15\n       16\n       17\n       \n\n 5. 运行\n    \n    * 在webpacktest目录，执行**npm run dev**。\n    \n    * 或使用 webstorm，右键package.json文件，选择“show npm scripts”，双击 dev 即可\n      \n      【注意】dev 就是在package.json中配置的webpack-dev-server......命令。\n      \n      启动成功自动打开浏览器。修改 src 中的任意文件内容，自动加载并刷新浏览器。\n\n 6. debug 调试\n    \n    使用了 webpack 之后就不能采用传统 js 的调试方法在 chrome 中打断点（因为打包了！内容发生变化）\n    \n    webpack 提供 devtool 进行调试，它是基于 sourcemap 的方式，在调试时会生成一个 map 文件，其内容记录生成文件和源文件的内容映射，即生成文件中的哪个位置对应源文件中的哪个位置，有了 sourcemap 就可以在调试时看到源代码。\n    \n    * 在 webpack.config.js 中配置：devtool: 'eval‐source‐map',具体查看上面的代码\n    * 在 js 中跟踪代码的位置上添加debugger，开启浏览器开发者工具……",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"入门",frontmatter:{title:"入门",date:"2020-12-27T00:30:47.000Z",permalink:"/pages/b41819/",categories:["Vue","基础"],tags:[null]},regularPath:"/1402.Vue2.x/100.%E5%9F%BA%E7%A1%80/101.%E5%85%A5%E9%97%A8.html",relativePath:"1402.Vue2.x/100.基础/101.入门.md",key:"v-4b33a0fc",path:"/pages/b41819/",headers:[{level:2,title:"Vue.js 是什么",slug:"vue-js-是什么",normalizedTitle:"vue.js 是什么",charIndex:30},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:281},{level:3,title:"script 引入",slug:"script-引入",normalizedTitle:"script 引入",charIndex:297},{level:3,title:"CDN",slug:"cdn",normalizedTitle:"cdn",charIndex:442},{level:3,title:"NPM",slug:"npm",normalizedTitle:"npm",charIndex:455},{level:3,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:81},{level:2,title:"Hello World",slug:"hello-world",normalizedTitle:"hello world",charIndex:602},{level:2,title:"options",slug:"options",normalizedTitle:"options",charIndex:1527},{level:3,title:"el—DOM 🔥",slug:"el-dom-🔥",normalizedTitle:"el—dom 🔥",charIndex:1583},{level:3,title:"data—数据 🔥",slug:"data-数据-🔥",normalizedTitle:"data—数据 🔥",charIndex:1912},{level:3,title:"props—数据",slug:"props-数据",normalizedTitle:"props—数据",charIndex:3196},{level:3,title:"methods—数据",slug:"methods-数据",normalizedTitle:"methods—数据",charIndex:4401},{level:2,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:5107},{level:3,title:"回调函数是什么？",slug:"回调函数是什么",normalizedTitle:"回调函数是什么？",charIndex:5288},{level:3,title:"中文版",slug:"中文版",normalizedTitle:"中文版",charIndex:5301},{level:3,title:"英文版",slug:"英文版",normalizedTitle:"英文版",charIndex:5309},{level:2,title:"MVVM",slug:"mvvm",normalizedTitle:"mvvm",charIndex:5319},{level:3,title:"简介",slug:"简介-2",normalizedTitle:"简介",charIndex:2},{level:3,title:"组成",slug:"组成",normalizedTitle:"组成",charIndex:3482},{level:3,title:"Vue 实现 MVVM",slug:"vue-实现-mvvm",normalizedTitle:"vue 实现 mvvm",charIndex:6068},{level:2,title:"响应式原理",slug:"响应式原理",normalizedTitle:"响应式原理",charIndex:7224},{level:2,title:"源码",slug:"源码",normalizedTitle:"源码",charIndex:7241}],headersStr:"Vue.js 是什么 安装 script 引入 CDN NPM 其他 Hello World options el—DOM 🔥 data—数据 🔥 props—数据 methods—数据 生命周期 回调函数是什么？ 中文版 英文版 MVVM 简介 组成 Vue 实现 MVVM 响应式原理 源码",content:"# 简介\n\n代码\n\n配套的代码在 Github 中\n\n\n# Vue.js 是什么\n\nVue 是一套用于构建用户界面的渐进式框架（可以只用 Vue，根据后续需要使用其他如 Router、Vuex 等）。\n\n与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n特点如下：\n\n * 解耦视图和数据\n * 可复用的组件\n * 前端路由\n * 状态管理\n * 虚拟 DOM\n\n\n# 安装\n\n官方的安装文档\n\n\n# script 引入\n\n直接下载并用 <script>标签引入，Vue 会被注册为一个全局变量。\n\n提示\n\n在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!\n\n * 开发版本：包含完整的警告和调试模式\n * 生产版本：删除了警告，33.30KB min+gzip\n\n\n# CDN\n\n看文档\n\n\n# NPM\n\n在用 Vue 构建大型应用时推荐使用 NPM 安装[1]。NPM 能很好地和诸如 webpack 或 Browserify 模块打包器配合使用。同时 Vue 也提供配套工具来开发单文件组件。\n\n # 最新稳定版\n$ npm install vue\n\n\n1\n2\n\n\n\n# 其他\n\n\n# Hello World\n\n<html>\n  <div id=\"app\">\n    <h1>当前计数{{ count }}</h1>\n    \x3c!-- <button @click='count++'>-</button>也可这样写，‘’中当作方法中写即可，但不推荐 --\x3e\n    <button @click=\"decrement\">-</button>\n    <button @click=\"increment\">+</button>\n  </div>\n</html>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"><\/script>\n<script>\n  new Vue({\n    el: '#app',\n    data: {\n      count: 0,\n    },\n    methods: {\n      // 方法不推荐使用“箭头函数”，因为不能传递 this 对象\n      // 可以使用 ES5 对象字面量写法，也可以使用 ES6 对象字面量增强写法\n      // ES5\n      increment: function(e) {\n        this.count++\n        // 默认方法会传递对象e，包含 MouseEvent 对象，其中有 target 属性包含了触发该事件的元素\n        // 但是若上述 HTML 中改为 @click='sub()' 则不包含该对象\n        console.log(e)\n      },\n      // ES6\n      decrement() {\n        this.count--\n      },\n    },\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nSee the Pen PoGeRvZ by apple54whn (@conanan) on CodePen.\n\n\n# options\n\n在new Vue(options)中的 options 对象可以传递什么选项呢？文档\n\n\n# el—DOM 🔥\n\n * 类型：string | Element\n\n * 限制：只在用 new 创建实例时生效。\n\n * 详细：\n   \n   提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标。可以是 CSS 选择器，也可以是一个 HTMLElement 实例。在实例挂载之后，元素可以用 vm.$el 访问。如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。\n   \n   注意\n   \n   提供的元素只能作为挂载点。不同于 Vue 1.x，所有的挂载元素会被 Vue 生成的 DOM 替换。因此不推荐挂载 root 实例到 <html> 或者 <body> 上。\n\n\n# data—数据 🔥\n\n * 类型：Object | Function\n\n * 限制：组件的定义只接受 function。因为组件是用来复用的，不同页面每次 new Vue()后需要返回不同的 data。\n\n * 详细：\n   \n   Vue 实例的数据对象。Vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 API 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。\n   \n   一旦观察过，你就无法在根数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。\n   \n   实例创建之后，可以通过 vm.$data 访问原始数据对象。Vue 实例也代理了 data 对象上所有的属性，因此访问 vm.a 等价于访问 vm.$data.a。\n   \n   以 _ 或 $ 开头的属性 不会 被 Vue 实例代理，因为它们可能和 Vue 内置的属性、API 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。\n   \n   当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。类似于data是个静态全局变量。\n   \n   如果需要，可以通过将 vm.$data 传入 JSON.parse(JSON.stringify(...)) 得到深拷贝的原始数据对象。\n\n * 示例：\n   \n   var data = { a: 1 }\n   \n   // 直接创建一个实例\n   var vm = new Vue({\n     data: data,\n   })\n   vm.a // => 1\n   vm.$data === data // => true\n   \n   // Vue.extend() 中 data 必须是函数\n   var Component = Vue.extend({\n     data: function() {\n       return { a: 1 }\n     },\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   注意，如果你为 data 属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。\n   \n   data: (vm) => ({ a: vm.myProp })\n   \n   \n   1\n   \n\n\n# props—数据\n\n * 类型：Array | Object\n\n * 详细：\n   \n   props 可以是数组或对象，用于接收来自父组件（当前页面使用一个组件，则这个页面称为父组件）的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。\n   \n   你可以基于对象的语法使用以下选项：\n   \n   * type: 可以是下列原生构造函数中的一种：String、 Number、 Boolean、 Array、 Object、 Date、 Function、Symbol、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。Prop 类型的更多信息在此。\n   * default: any 为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。\n   * required: Boolean 定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。\n   * validator: Function 自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在这里查阅更多 prop 验证的相关信息。\n\n * 示例：\n   \n   // 简单语法\n   Vue.component('props-demo-simple', {\n     props: ['size', 'myMessage'],\n   })\n   \n   // 对象语法，提供验证\n   Vue.component('props-demo-advanced', {\n     props: {\n       // 检测类型\n       height: Number,\n       // 检测类型 + 其他验证\n       age: {\n         type: Number,\n         default: 0,\n         required: true,\n         validator: function(value) {\n           return value >= 0\n         },\n       },\n     },\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n * 参考：Props\n\n\n# methods—数据\n\n * 类型：{ [key: string]: Function }\n\n * 详细：\n   \n   methods 将被混入到 Vue 实例中。可以直接通过 VM 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 Vue 实例。\n   \n   注意\n   \n   注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () => this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 Vue 实例，this.a 将是 undefined。\n\n * 示例：\n   \n   var vm = new Vue({\n     data: { a: 1 },\n     methods: {\n       plus: function() {\n         this.a++\n       },\n       // 也可以这样写\n       plus2() {\n         console.log('plus2')\n       },\n     },\n   })\n   vm.plus()\n   vm.a // 2\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n * 参考：事件处理器\n\n * 思考：什么是 method 方法？什么是 function 函数？\n   \n   * method 一般在类中，和实例、对象挂钩\n   * function 一般在类外部\n\n\n# 生命周期\n\n官方文档\n\n回调函数：看字面意思即不是操作者主动调用，而是传递给调用的某个函数后，该函数执行的某一阶段，此时回来调用操作者定义的函数\n\n经常使用的有：\n\n * created：在组件创建完后，会请求数据并放入 data 中\n * mounted：\n * updated：\n * destroyed：一般只有组件 Componet 会进行销毁\n\n\n# 回调函数是什么？\n\n\n# 中文版\n\n\n# 英文版\n\n\n\n\n# MVVM\n\n\n# 简介\n\nMVVM（Model–view–viewmodel）是一种软件架构模式。\n\nMVVM 有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或 GUI 代码实现的。MVVM 的VM是一个值转换器，[1] 这意味着 VM 负责从 Model 中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，VM 比 V 做得更多，并且处理大部分 V 的显示逻辑。VM 可以实现中介者模式，组织对 V 所支持的用例集的后端逻辑的访问。\n\nMVVM 是马丁·福勒的 PM（Presentation Model）设计模式的变体。MVVM 以相同的方式抽象出视图的状态和行为，但 PM 以不依赖于特定用户界面平台的方式抽象出视图（创建了 VM）。MVVM 和 PM 都来自MVC模式。\n\n\n# 组成\n\n * 模型\n   \n   模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。\n\n * 视图\n   \n   就像在MVC和MVP模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。\n\n * 视图模型\n   \n   视图模型是暴露公共属性和命令的视图的抽象。MVVM 没有 MVC 模式的控制器，也没有 MVP 模式的 presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。\n\n * 绑定器\n   \n   声明性数据和命令绑定隐含在 MVVM 模式中。在 Microsoft解决方案堆中，绑定器是一种名为XAML的标记语言。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。\n\n\n# Vue 实现 MVVM\n\n\n\n * ViewModel\n   \n   同步 Model 和 View 的对象。在 Vue.js 中，每个 Vue 实例都是一个 ViewModel。它们由Vue构造函数或其子类实例化：\n   \n   var vm = new Vue({\n     /* options */\n   })\n   \n   \n   1\n   2\n   3\n   \n\n * View\n   \n   由 Vue 实例管理的实际 DOM。\n   \n   vm.$el // The View\n   \n   \n   1\n   \n   \n   Vue.js 使用基于 DOM 的模板。每个 Vue 实例都与一个对应的 DOM 元素相关联。创建 Vue 实例后，它递归遍历根元素的所有子节点，同时设置必要的数据绑定。在视图被编译之后，它会对数据变化做出反应。\n   \n   使用 Vue.js 时，除了自定义指令（稍后说明）之外，您几乎不需要亲自接触 DOM。数据更改时，视图更新将自动触发。这些视图更新是非常精细的，精度可降至 textNode。它们也可以批处理并异步执行以提高性能。\n\n * Model\n   \n   稍微修改的普通 JavaScript 对象。\n   \n   vm.$data // The Model\n   \n   \n   1\n   \n   \n   在 Vue.js 中，模型只是简单的 JavaScript 对象或数据对象。 一旦在 Vue 实例中将对象用作数据，它就会变成反应性（响应式）的。 您可以操纵它们的属性，并且 Vue 实例正在观察它们且在他们被更改时收到通知。 Vue.js 通过将数据对象的属性转换为 ES5 getter / setter 来实现透明的反应性。 无需进行脏检查，也不必明确通知 Vue 更新视图。 每当数据更改时，视图都会在下一帧更新。\n   \n   Vue 实例代理它们所观察的数据对象上的所有属性。所以一旦一个对象{a: 1}被观察到，两个vm.$data。和vm.a将返回相同的值，并设置vm.a = 2将修改vm.$data。\n   \n   数据对象在适当的地方进行了修改，因此通过引用修改它与修改vm.$data具有相同的效果。这使得多个 Vue 实例可以观察同一段数据。在较大的应用程序中，还建议将 Vue 实例视为纯视图，并将数据操作逻辑外部化到更离散的存储层。\n   \n   这里需要注意的是，一旦开始观察，Vue.js 将无法检测到新添加或删除的属性。为了解决这个问题，使用$add、$set和$delete方法对观察到的对象进行了扩充。\n   \n   下面是在 Vue.js 中如何实现响应性更新的高级概述：\n   \n   \n\n\n# 响应式原理\n\n响应式原理\n\n\n# 源码\n\n在 Github 上下载源码时注意 Branch 和 Tag，一般选择稳定版即 Tag 版。\n\n从哪开始查看呢？直接找到 /src/core/index.js即可",normalizedContent:"# 简介\n\n代码\n\n配套的代码在 github 中\n\n\n# vue.js 是什么\n\nvue 是一套用于构建用户界面的渐进式框架（可以只用 vue，根据后续需要使用其他如 router、vuex 等）。\n\n与其它大型框架不同的是，vue 被设计为可以自底向上逐层应用。vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，vue 也完全能够为复杂的单页应用提供驱动。\n\n特点如下：\n\n * 解耦视图和数据\n * 可复用的组件\n * 前端路由\n * 状态管理\n * 虚拟 dom\n\n\n# 安装\n\n官方的安装文档\n\n\n# script 引入\n\n直接下载并用 <script>标签引入，vue 会被注册为一个全局变量。\n\n提示\n\n在开发环境下不要使用压缩版本，不然你就失去了所有常见错误相关的警告!\n\n * 开发版本：包含完整的警告和调试模式\n * 生产版本：删除了警告，33.30kb min+gzip\n\n\n# cdn\n\n看文档\n\n\n# npm\n\n在用 vue 构建大型应用时推荐使用 npm 安装[1]。npm 能很好地和诸如 webpack 或 browserify 模块打包器配合使用。同时 vue 也提供配套工具来开发单文件组件。\n\n # 最新稳定版\n$ npm install vue\n\n\n1\n2\n\n\n\n# 其他\n\n\n# hello world\n\n<html>\n  <div id=\"app\">\n    <h1>当前计数{{ count }}</h1>\n    \x3c!-- <button @click='count++'>-</button>也可这样写，‘’中当作方法中写即可，但不推荐 --\x3e\n    <button @click=\"decrement\">-</button>\n    <button @click=\"increment\">+</button>\n  </div>\n</html>\n<script src=\"https://cdn.jsdelivr.net/npm/vue/dist/vue.js\"><\/script>\n<script>\n  new vue({\n    el: '#app',\n    data: {\n      count: 0,\n    },\n    methods: {\n      // 方法不推荐使用“箭头函数”，因为不能传递 this 对象\n      // 可以使用 es5 对象字面量写法，也可以使用 es6 对象字面量增强写法\n      // es5\n      increment: function(e) {\n        this.count++\n        // 默认方法会传递对象e，包含 mouseevent 对象，其中有 target 属性包含了触发该事件的元素\n        // 但是若上述 html 中改为 @click='sub()' 则不包含该对象\n        console.log(e)\n      },\n      // es6\n      decrement() {\n        this.count--\n      },\n    },\n  })\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\nsee the pen pogervz by apple54whn (@conanan) on codepen.\n\n\n# options\n\n在new vue(options)中的 options 对象可以传递什么选项呢？文档\n\n\n# el—dom 🔥\n\n * 类型：string | element\n\n * 限制：只在用 new 创建实例时生效。\n\n * 详细：\n   \n   提供一个在页面上已存在的 dom 元素作为 vue 实例的挂载目标。可以是 css 选择器，也可以是一个 htmlelement 实例。在实例挂载之后，元素可以用 vm.$el 访问。如果在实例化时存在这个选项，实例将立即进入编译过程，否则，需要显式调用 vm.$mount() 手动开启编译。\n   \n   注意\n   \n   提供的元素只能作为挂载点。不同于 vue 1.x，所有的挂载元素会被 vue 生成的 dom 替换。因此不推荐挂载 root 实例到 <html> 或者 <body> 上。\n\n\n# data—数据 🔥\n\n * 类型：object | function\n\n * 限制：组件的定义只接受 function。因为组件是用来复用的，不同页面每次 new vue()后需要返回不同的 data。\n\n * 详细：\n   \n   vue 实例的数据对象。vue 将会递归将 data 的属性转换为 getter/setter，从而让 data 的属性能够响应数据变化。对象必须是纯粹的对象 (含有零个或多个的 key/value 对)：浏览器 api 创建的原生对象，原型上的属性会被忽略。大概来说，data 应该只能是数据 - 不推荐观察拥有状态行为的对象。\n   \n   一旦观察过，你就无法在根数据对象上添加响应式属性。因此推荐在创建实例之前，就声明所有的根级响应式属性。\n   \n   实例创建之后，可以通过 vm.$data 访问原始数据对象。vue 实例也代理了 data 对象上所有的属性，因此访问 vm.a 等价于访问 vm.$data.a。\n   \n   以 _ 或 $ 开头的属性 不会 被 vue 实例代理，因为它们可能和 vue 内置的属性、api 方法冲突。你可以使用例如 vm.$data._property 的方式访问这些属性。\n   \n   当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象！通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象。类似于data是个静态全局变量。\n   \n   如果需要，可以通过将 vm.$data 传入 json.parse(json.stringify(...)) 得到深拷贝的原始数据对象。\n\n * 示例：\n   \n   var data = { a: 1 }\n   \n   // 直接创建一个实例\n   var vm = new vue({\n     data: data,\n   })\n   vm.a // => 1\n   vm.$data === data // => true\n   \n   // vue.extend() 中 data 必须是函数\n   var component = vue.extend({\n     data: function() {\n       return { a: 1 }\n     },\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   \n   \n   注意，如果你为 data 属性使用了箭头函数，则 this 不会指向这个组件的实例，不过你仍然可以将其实例作为函数的第一个参数来访问。\n   \n   data: (vm) => ({ a: vm.myprop })\n   \n   \n   1\n   \n\n\n# props—数据\n\n * 类型：array | object\n\n * 详细：\n   \n   props 可以是数组或对象，用于接收来自父组件（当前页面使用一个组件，则这个页面称为父组件）的数据。props 可以是简单的数组，或者使用对象作为替代，对象允许配置高级选项，如类型检测、自定义验证和设置默认值。\n   \n   你可以基于对象的语法使用以下选项：\n   \n   * type: 可以是下列原生构造函数中的一种：string、 number、 boolean、 array、 object、 date、 function、symbol、任何自定义构造函数、或上述内容组成的数组。会检查一个 prop 是否是给定的类型，否则抛出警告。prop 类型的更多信息在此。\n   * default: any 为该 prop 指定一个默认值。如果该 prop 没有被传入，则换做用这个值。对象或数组的默认值必须从一个工厂函数返回。\n   * required: boolean 定义该 prop 是否是必填项。在非生产环境中，如果这个值为 truthy 且该 prop 没有被传入的，则一个控制台警告将会被抛出。\n   * validator: function 自定义验证函数会将该 prop 的值作为唯一的参数代入。在非生产环境下，如果该函数返回一个 falsy 的值 (也就是验证失败)，一个控制台警告将会被抛出。你可以在这里查阅更多 prop 验证的相关信息。\n\n * 示例：\n   \n   // 简单语法\n   vue.component('props-demo-simple', {\n     props: ['size', 'mymessage'],\n   })\n   \n   // 对象语法，提供验证\n   vue.component('props-demo-advanced', {\n     props: {\n       // 检测类型\n       height: number,\n       // 检测类型 + 其他验证\n       age: {\n         type: number,\n         default: 0,\n         required: true,\n         validator: function(value) {\n           return value >= 0\n         },\n       },\n     },\n   })\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   \n\n * 参考：props\n\n\n# methods—数据\n\n * 类型：{ [key: string]: function }\n\n * 详细：\n   \n   methods 将被混入到 vue 实例中。可以直接通过 vm 实例访问这些方法，或者在指令表达式中使用。方法中的 this 自动绑定为 vue 实例。\n   \n   注意\n   \n   注意，不应该使用箭头函数来定义 method 函数 (例如 plus: () => this.a++)。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向 vue 实例，this.a 将是 undefined。\n\n * 示例：\n   \n   var vm = new vue({\n     data: { a: 1 },\n     methods: {\n       plus: function() {\n         this.a++\n       },\n       // 也可以这样写\n       plus2() {\n         console.log('plus2')\n       },\n     },\n   })\n   vm.plus()\n   vm.a // 2\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   \n\n * 参考：事件处理器\n\n * 思考：什么是 method 方法？什么是 function 函数？\n   \n   * method 一般在类中，和实例、对象挂钩\n   * function 一般在类外部\n\n\n# 生命周期\n\n官方文档\n\n回调函数：看字面意思即不是操作者主动调用，而是传递给调用的某个函数后，该函数执行的某一阶段，此时回来调用操作者定义的函数\n\n经常使用的有：\n\n * created：在组件创建完后，会请求数据并放入 data 中\n * mounted：\n * updated：\n * destroyed：一般只有组件 componet 会进行销毁\n\n\n# 回调函数是什么？\n\n\n# 中文版\n\n\n# 英文版\n\n\n\n\n# mvvm\n\n\n# 简介\n\nmvvm（model–view–viewmodel）是一种软件架构模式。\n\nmvvm 有助于将图形用户界面的开发与业务逻辑或后端逻辑（数据模型）的开发分离开来，这是通过置标语言或 gui 代码实现的。mvvm 的vm是一个值转换器，[1] 这意味着 vm 负责从 model 中暴露（转换）数据对象，以便轻松管理和呈现对象。在这方面，vm 比 v 做得更多，并且处理大部分 v 的显示逻辑。vm 可以实现中介者模式，组织对 v 所支持的用例集的后端逻辑的访问。\n\nmvvm 是马丁·福勒的 pm（presentation model）设计模式的变体。mvvm 以相同的方式抽象出视图的状态和行为，但 pm 以不依赖于特定用户界面平台的方式抽象出视图（创建了 vm）。mvvm 和 pm 都来自mvc模式。\n\n\n# 组成\n\n * 模型\n   \n   模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。\n\n * 视图\n   \n   就像在mvc和mvp模式中一样，视图是用户在屏幕上看到的结构、布局和外观（ui）。\n\n * 视图模型\n   \n   视图模型是暴露公共属性和命令的视图的抽象。mvvm 没有 mvc 模式的控制器，也没有 mvp 模式的 presenter，有的是一个绑定器。在视图模型中，绑定器在视图和数据绑定器之间进行通信。\n\n * 绑定器\n   \n   声明性数据和命令绑定隐含在 mvvm 模式中。在 microsoft解决方案堆中，绑定器是一种名为xaml的标记语言。绑定器使开发人员免于被迫编写样板式逻辑来同步视图模型和视图。在微软的堆之外实现时，声明性数据绑定技术的出现是实现该模式的一个关键因素。\n\n\n# vue 实现 mvvm\n\n\n\n * viewmodel\n   \n   同步 model 和 view 的对象。在 vue.js 中，每个 vue 实例都是一个 viewmodel。它们由vue构造函数或其子类实例化：\n   \n   var vm = new vue({\n     /* options */\n   })\n   \n   \n   1\n   2\n   3\n   \n\n * view\n   \n   由 vue 实例管理的实际 dom。\n   \n   vm.$el // the view\n   \n   \n   1\n   \n   \n   vue.js 使用基于 dom 的模板。每个 vue 实例都与一个对应的 dom 元素相关联。创建 vue 实例后，它递归遍历根元素的所有子节点，同时设置必要的数据绑定。在视图被编译之后，它会对数据变化做出反应。\n   \n   使用 vue.js 时，除了自定义指令（稍后说明）之外，您几乎不需要亲自接触 dom。数据更改时，视图更新将自动触发。这些视图更新是非常精细的，精度可降至 textnode。它们也可以批处理并异步执行以提高性能。\n\n * model\n   \n   稍微修改的普通 javascript 对象。\n   \n   vm.$data // the model\n   \n   \n   1\n   \n   \n   在 vue.js 中，模型只是简单的 javascript 对象或数据对象。 一旦在 vue 实例中将对象用作数据，它就会变成反应性（响应式）的。 您可以操纵它们的属性，并且 vue 实例正在观察它们且在他们被更改时收到通知。 vue.js 通过将数据对象的属性转换为 es5 getter / setter 来实现透明的反应性。 无需进行脏检查，也不必明确通知 vue 更新视图。 每当数据更改时，视图都会在下一帧更新。\n   \n   vue 实例代理它们所观察的数据对象上的所有属性。所以一旦一个对象{a: 1}被观察到，两个vm.$data。和vm.a将返回相同的值，并设置vm.a = 2将修改vm.$data。\n   \n   数据对象在适当的地方进行了修改，因此通过引用修改它与修改vm.$data具有相同的效果。这使得多个 vue 实例可以观察同一段数据。在较大的应用程序中，还建议将 vue 实例视为纯视图，并将数据操作逻辑外部化到更离散的存储层。\n   \n   这里需要注意的是，一旦开始观察，vue.js 将无法检测到新添加或删除的属性。为了解决这个问题，使用$add、$set和$delete方法对观察到的对象进行了扩充。\n   \n   下面是在 vue.js 中如何实现响应性更新的高级概述：\n   \n   \n\n\n# 响应式原理\n\n响应式原理\n\n\n# 源码\n\n在 github 上下载源码时注意 branch 和 tag，一般选择稳定版即 tag 版。\n\n从哪开始查看呢？直接找到 /src/core/index.js即可",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"插值语法",frontmatter:{title:"插值语法",date:"2020-12-27T00:30:47.000Z",permalink:"/pages/49b47f/",categories:["Vue","基础"],tags:[null]},regularPath:"/1402.Vue2.x/100.%E5%9F%BA%E7%A1%80/102.%E6%8F%92%E5%80%BC%E8%AF%AD%E6%B3%95.html",relativePath:"1402.Vue2.x/100.基础/102.插值语法.md",key:"v-e910ea2e",path:"/pages/49b47f/",headers:[{level:2,title:"Mustache 语法 🔥",slug:"mustache-语法-🔥",normalizedTitle:"mustache 语法 🔥",charIndex:40},{level:2,title:"v-once 指令 🔥",slug:"v-once-指令-🔥",normalizedTitle:"v-once 指令 🔥",charIndex:1030},{level:2,title:"v-text  指令",slug:"v-text-指令",normalizedTitle:"v-text  指令",charIndex:null},{level:2,title:"v-html 指令 🔥",slug:"v-html-指令-🔥",normalizedTitle:"v-html 指令 🔥",charIndex:2792},{level:2,title:"v-pre 指令 🔥",slug:"v-pre-指令-🔥",normalizedTitle:"v-pre 指令 🔥",charIndex:3725},{level:2,title:"v-cloak 指令",slug:"v-cloak-指令",normalizedTitle:"v-cloak 指令",charIndex:4286},{level:2,title:"过滤器 🔥",slug:"过滤器-🔥",normalizedTitle:"过滤器 🔥",charIndex:5204}],headersStr:"Mustache 语法 🔥 v-once 指令 🔥 v-text  指令 v-html 指令 🔥 v-pre 指令 🔥 v-cloak 指令 过滤器 🔥",content:'# 插值语法—文本\n\n将 data 中数据插入到 HTML 模版内容中\n\n\n# Mustache 语法 🔥\n\nMustache 语法，双大括号\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vue</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <h2>{{message}}</h2>\n      <h2>{{message}}李银河</h2>\n      \x3c!-- 表达式 --\x3e\n      <h2>{{lastName + firstName}}</h2>\n      <h2>{{lastName + " "+firstName}}</h2>\n      <h2>{{lastName}}@{{firstName}}</h2>\n      <h2>{{count*2}}</h2>\n    </div>\n\n    <script src="./lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "你好！",\n          firstName: "三",\n          lastName: "张",\n          count: 100,\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nMustache 标签将会被替代为对应 data 数据对象上属性的值。\n\n无论何时，绑定的 data 数据对象上属性发生了改变，插值处的内容都会更新。\n\nMustache 中存放的是变量对象，也可以放表达式、方法（最后需带括号）（不推荐），若用引号引用则视作字符串不再解析。\n\n\n# v-once 指令 🔥\n\n只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 单个元素 --\x3e\n      <h2>This will change: {{message}}</h2>\n      <h2 v-once>This will never change: {{message}}</h2>\n\n      \x3c!-- 有子元素 --\x3e\n      <div>\n        <h2>{{message}}</h2>\n      </div>\n      <div v-once>\n        <h2>{{message}}</h2>\n      </div>\n\n      \x3c!-- 组件 --\x3e\n      <my-component v-once :comment="message"></my-component>\n      <my-component :comment="message"></my-component>\n\n      \x3c!-- `v-for` 指令--\x3e\n      <ul>\n        <li v-for="i in list" :key="i">{{i}}</li>\n      </ul>\n      <ul>\n        <li v-for="i in list" :key="i" v-once>{{i}}</li>\n      </ul>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 这里写的组件必须在 new Vue() 前定义！\n      Vue.component("my-component", {\n        data: function () {\n          return {\n            count: 0,\n          };\n        },\n        props: {\n          comment: "",\n        },\n        template: "<h1>{{comment}} my-component</h1>",\n      });\n\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Test 1",\n          list: [1, 2, 3],\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# v-text 指令\n\n作用和 Mustache 相似，更新元素的 textContent。但是会覆盖该标签的内容！不灵活，一般使用较少！如果要更新部分的 textContent ，需要使用 {{ Mustache }} 插值。\n\n\n# v-html 指令 🔥\n\n双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML，你需要使用 v-html 指令：\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      mustache:\n      <span>{{url}}</span><br />\n\n      v-html:\n      <span v-html="url"></span><br />\n\n      v-text:\n      <span v-text="url"></span><br />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n          url: \'<a href="https://www.qq.com">QQ</a>\',\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n属性值会直接作为 HTML——会忽略解析属性值中的数据绑定。注意，你不能使用 v-html 来复合局部模板，因为 Vue 不是基于字符串的模板引擎。反之，对于用户界面 (UI)，组件更适合作为可重用和可组合的基本单位。\n\n\n# v-pre 指令 🔥\n\n如<pre>，跳过这个元素和它的子元素的编译过程。可用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <span v-pre>{{ this will not be compiled }}</span>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# v-cloak 指令\n\ncloak\n\n披风; 斗篷; 大衣; 氅。这里为挡住之类的意思。\n\n区别 clock 时钟\n\n这个指令保持在元素上直到关联实例结束编译，可以据此来实现判断。\n\n上述含义为，在 Vue 编译完前 HTML 中有 v-cloak 属性，在 Vue 编译完后该属性被删掉。\n\n基本也不会使用，以后这个模版会渲染为函数，和虚拟DOM有关，不会显示 mustache 语法的。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n    <style>\n      /* 属性选择器 */\n      [v-cloak] {\n        display: none;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      <h2 v-cloak>{{message}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      setTimeout(() => {\n        const vm = new Vue({\n          el: "#app",\n          data: {\n            message: "Hello",\n          },\n          methods: {},\n        });\n      }, 2000);\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 过滤器 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vue</title>\n    <style>\n      table {\n        /* 合并细线边框 */\n        border-collapse: collapse;\n        /* 单元格之间水平、垂直距离，与 border-collapse 冲突，不常用 */\n        /*border-spacing: 10px 20px;*/\n        /* 表格居中 */\n        margin: 100px auto;\n      }\n      th,\n      td {\n        /* 边框 */\n        border: 1px solid skyblue;\n        /* 内边距 */\n        padding: 20px;\n        /* 让td居中，th本来就是居中的 */\n        text-align: center;\n        /* 默认情况下元素在th,td中是垂直居中的，也可以通过 vertical-align 来修改*/\n        /* 由此可得，对一个父元素设置 display: table-cell，可以直接使用 vertical-align 来垂直居中*/\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      <div v-if="books.length >= 1">\n        <table>\n          <thead>\n            <tr>\n              <th></th>\n              <th>书籍名称</th>\n              <th>出版日期</th>\n              <th>价格</th>\n              <th>购买数量</th>\n              <th>操作</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr v-for="(book,index) in books" :key="book.id">\n              <td>{{book.id}}</td>\n              <td>{{book.name}}</td>\n              <td>{{book.time}}</td>\n              \x3c!-- <td>{{\'¥\'+book.price.toFixed(2)}}</td> --\x3e\n              \x3c!-- 这么多地方使用，可以复用 --\x3e\n              \x3c!-- 方式1:方法。计算属性也可以 --\x3e\n              \x3c!-- <td>{{formartPrice(book.price)}}</td> --\x3e\n              \x3c!-- 方式2:过滤器 --\x3e\n              <td>{{book.price | formartPrice}}</td>\n\n              <td>\n                <button @click="decrement(book)" :disabled="book.count === 1">\n                  -\n                </button>\n                {{book.count}}\n                <button @click="increment(book)">+</button>\n              </td>\n              <td><button @click="remove(index)">移除</button></td>\n            </tr>\n          </tbody>\n        </table>\n        \x3c!-- 总价：{{\'¥\'+totalPrice.toFixed(2)}} --\x3e\n        \x3c!-- 总价：{{formartPrice(totalPrice)}} --\x3e\n        总价：{{totalPrice | formartPrice}}\n      </div>\n      <div v-else>\n        购物车为空\n      </div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // vue.js文件中定义了 Vue 对象，使用时可以 new 构造出，并且它还有参数（对象类型）\n      const vm = new Vue({\n        el: "#app",\n        // 声明式编程（声明式渲染），不再使用命令式\n        data: {\n          books: [\n            { id: 1, name: "Java", time: "2006-02", price: 110.0, count: 1 },\n            { id: 2, name: "Kotlin", time: "2016-03", price: 120.0, count: 1 },\n            { id: 3, name: "Clojure", time: "2008-12", price: 112.0, count: 1 },\n            { id: 4, name: "JVM", time: "2002-8", price: 200.0, count: 1 },\n          ],\n        },\n        methods: {\n          increment(book) {\n            book.count++;\n          },\n          decrement(book) {\n            // if (book.count === 1) {\n            //   return;\n            // }\n            book.count--;\n          },\n          remove(index) {\n            this.books.splice(index, 1);\n          },\n          formartPrice(price) {\n            return "¥" + price.toFixed(2);\n          },\n        },\n        computed: {\n          totalPrice() {\n            // let totalPrice = 0;\n            // this.books.forEach((item) => {\n            //   totalPrice += item.price * item.count;\n            // });\n            // return totalPrice;\n\n            return this.books.reduce((previous, current, index, arr) => {\n              return previous + current.price * current.count;\n            }, 0);\n          },\n        },\n        filters: {\n          formartPrice(price) {\n            return "¥" + price.toFixed(2);\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n',normalizedContent:'# 插值语法—文本\n\n将 data 中数据插入到 html 模版内容中\n\n\n# mustache 语法 🔥\n\nmustache 语法，双大括号\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>vue</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <h2>{{message}}</h2>\n      <h2>{{message}}李银河</h2>\n      \x3c!-- 表达式 --\x3e\n      <h2>{{lastname + firstname}}</h2>\n      <h2>{{lastname + " "+firstname}}</h2>\n      <h2>{{lastname}}@{{firstname}}</h2>\n      <h2>{{count*2}}</h2>\n    </div>\n\n    <script src="./lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "你好！",\n          firstname: "三",\n          lastname: "张",\n          count: 100,\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nmustache 标签将会被替代为对应 data 数据对象上属性的值。\n\n无论何时，绑定的 data 数据对象上属性发生了改变，插值处的内容都会更新。\n\nmustache 中存放的是变量对象，也可以放表达式、方法（最后需带括号）（不推荐），若用引号引用则视作字符串不再解析。\n\n\n# v-once 指令 🔥\n\n只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。通过使用 v-once 指令，你也能执行一次性地插值，当数据改变时，插值处的内容不会更新。但请留心这会影响到该节点上的其它数据绑定\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 单个元素 --\x3e\n      <h2>this will change: {{message}}</h2>\n      <h2 v-once>this will never change: {{message}}</h2>\n\n      \x3c!-- 有子元素 --\x3e\n      <div>\n        <h2>{{message}}</h2>\n      </div>\n      <div v-once>\n        <h2>{{message}}</h2>\n      </div>\n\n      \x3c!-- 组件 --\x3e\n      <my-component v-once :comment="message"></my-component>\n      <my-component :comment="message"></my-component>\n\n      \x3c!-- `v-for` 指令--\x3e\n      <ul>\n        <li v-for="i in list" :key="i">{{i}}</li>\n      </ul>\n      <ul>\n        <li v-for="i in list" :key="i" v-once>{{i}}</li>\n      </ul>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 这里写的组件必须在 new vue() 前定义！\n      vue.component("my-component", {\n        data: function () {\n          return {\n            count: 0,\n          };\n        },\n        props: {\n          comment: "",\n        },\n        template: "<h1>{{comment}} my-component</h1>",\n      });\n\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "test 1",\n          list: [1, 2, 3],\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# v-text 指令\n\n作用和 mustache 相似，更新元素的 textcontent。但是会覆盖该标签的内容！不灵活，一般使用较少！如果要更新部分的 textcontent ，需要使用 {{ mustache }} 插值。\n\n\n# v-html 指令 🔥\n\n双大括号会将数据解释为普通文本，而非 html 代码。为了输出真正的 html，你需要使用 v-html 指令：\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      mustache:\n      <span>{{url}}</span><br />\n\n      v-html:\n      <span v-html="url"></span><br />\n\n      v-text:\n      <span v-text="url"></span><br />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n          url: \'<a href="https://www.qq.com">qq</a>\',\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n属性值会直接作为 html——会忽略解析属性值中的数据绑定。注意，你不能使用 v-html 来复合局部模板，因为 vue 不是基于字符串的模板引擎。反之，对于用户界面 (ui)，组件更适合作为可重用和可组合的基本单位。\n\n\n# v-pre 指令 🔥\n\n如<pre>，跳过这个元素和它的子元素的编译过程。可用来显示原始 mustache 标签。跳过大量没有指令的节点会加快编译。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <span v-pre>{{ this will not be compiled }}</span>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# v-cloak 指令\n\ncloak\n\n披风; 斗篷; 大衣; 氅。这里为挡住之类的意思。\n\n区别 clock 时钟\n\n这个指令保持在元素上直到关联实例结束编译，可以据此来实现判断。\n\n上述含义为，在 vue 编译完前 html 中有 v-cloak 属性，在 vue 编译完后该属性被删掉。\n\n基本也不会使用，以后这个模版会渲染为函数，和虚拟dom有关，不会显示 mustache 语法的。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n    <style>\n      /* 属性选择器 */\n      [v-cloak] {\n        display: none;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      <h2 v-cloak>{{message}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      settimeout(() => {\n        const vm = new vue({\n          el: "#app",\n          data: {\n            message: "hello",\n          },\n          methods: {},\n        });\n      }, 2000);\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 过滤器 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>vue</title>\n    <style>\n      table {\n        /* 合并细线边框 */\n        border-collapse: collapse;\n        /* 单元格之间水平、垂直距离，与 border-collapse 冲突，不常用 */\n        /*border-spacing: 10px 20px;*/\n        /* 表格居中 */\n        margin: 100px auto;\n      }\n      th,\n      td {\n        /* 边框 */\n        border: 1px solid skyblue;\n        /* 内边距 */\n        padding: 20px;\n        /* 让td居中，th本来就是居中的 */\n        text-align: center;\n        /* 默认情况下元素在th,td中是垂直居中的，也可以通过 vertical-align 来修改*/\n        /* 由此可得，对一个父元素设置 display: table-cell，可以直接使用 vertical-align 来垂直居中*/\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      <div v-if="books.length >= 1">\n        <table>\n          <thead>\n            <tr>\n              <th></th>\n              <th>书籍名称</th>\n              <th>出版日期</th>\n              <th>价格</th>\n              <th>购买数量</th>\n              <th>操作</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr v-for="(book,index) in books" :key="book.id">\n              <td>{{book.id}}</td>\n              <td>{{book.name}}</td>\n              <td>{{book.time}}</td>\n              \x3c!-- <td>{{\'¥\'+book.price.tofixed(2)}}</td> --\x3e\n              \x3c!-- 这么多地方使用，可以复用 --\x3e\n              \x3c!-- 方式1:方法。计算属性也可以 --\x3e\n              \x3c!-- <td>{{formartprice(book.price)}}</td> --\x3e\n              \x3c!-- 方式2:过滤器 --\x3e\n              <td>{{book.price | formartprice}}</td>\n\n              <td>\n                <button @click="decrement(book)" :disabled="book.count === 1">\n                  -\n                </button>\n                {{book.count}}\n                <button @click="increment(book)">+</button>\n              </td>\n              <td><button @click="remove(index)">移除</button></td>\n            </tr>\n          </tbody>\n        </table>\n        \x3c!-- 总价：{{\'¥\'+totalprice.tofixed(2)}} --\x3e\n        \x3c!-- 总价：{{formartprice(totalprice)}} --\x3e\n        总价：{{totalprice | formartprice}}\n      </div>\n      <div v-else>\n        购物车为空\n      </div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // vue.js文件中定义了 vue 对象，使用时可以 new 构造出，并且它还有参数（对象类型）\n      const vm = new vue({\n        el: "#app",\n        // 声明式编程（声明式渲染），不再使用命令式\n        data: {\n          books: [\n            { id: 1, name: "java", time: "2006-02", price: 110.0, count: 1 },\n            { id: 2, name: "kotlin", time: "2016-03", price: 120.0, count: 1 },\n            { id: 3, name: "clojure", time: "2008-12", price: 112.0, count: 1 },\n            { id: 4, name: "jvm", time: "2002-8", price: 200.0, count: 1 },\n          ],\n        },\n        methods: {\n          increment(book) {\n            book.count++;\n          },\n          decrement(book) {\n            // if (book.count === 1) {\n            //   return;\n            // }\n            book.count--;\n          },\n          remove(index) {\n            this.books.splice(index, 1);\n          },\n          formartprice(price) {\n            return "¥" + price.tofixed(2);\n          },\n        },\n        computed: {\n          totalprice() {\n            // let totalprice = 0;\n            // this.books.foreach((item) => {\n            //   totalprice += item.price * item.count;\n            // });\n            // return totalprice;\n\n            return this.books.reduce((previous, current, index, arr) => {\n              return previous + current.price * current.count;\n            }, 0);\n          },\n        },\n        filters: {\n          formartprice(price) {\n            return "¥" + price.tofixed(2);\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"绑定属性",frontmatter:{title:"绑定属性",date:"2020-12-27T00:30:47.000Z",permalink:"/pages/18d9ea/",categories:["Vue","基础"],tags:[null]},regularPath:"/1402.Vue2.x/100.%E5%9F%BA%E7%A1%80/103.%E7%BB%91%E5%AE%9A%E5%B1%9E%E6%80%A7.html",relativePath:"1402.Vue2.x/100.基础/103.绑定属性.md",key:"v-9dd99cf6",path:"/pages/18d9ea/",headers:[{level:2,title:":  v-bind",slug:"v-bind",normalizedTitle:":  v-bind",charIndex:null},{level:2,title:"绑定 HTML class 🔥",slug:"绑定-html-class-🔥",normalizedTitle:"绑定 html class 🔥",charIndex:2327},{level:3,title:"绑定对象（使用很多）",slug:"绑定对象-使用很多",normalizedTitle:"绑定对象（使用很多）",charIndex:2348},{level:3,title:"绑定数组（使用较少）",slug:"绑定数组-使用较少",normalizedTitle:"绑定数组（使用较少）",charIndex:4282},{level:2,title:"绑定内联样式 style—组件化 🔥",slug:"绑定内联样式-style-组件化-🔥",normalizedTitle:"绑定内联样式 style—组件化 🔥",charIndex:5853},{level:3,title:"绑定对象（使用很多）",slug:"绑定对象-使用很多-2",normalizedTitle:"绑定对象（使用很多）",charIndex:2348},{level:3,title:"绑定数组（使用较少）",slug:"绑定数组-使用较少-2",normalizedTitle:"绑定数组（使用较少）",charIndex:4282},{level:2,title:"内联字符串拼接 🔥",slug:"内联字符串拼接-🔥",normalizedTitle:"内联字符串拼接 🔥",charIndex:8690},{level:2,title:"作业1—点击行换色 🔥",slug:"作业1-点击行换色-🔥",normalizedTitle:"作业1—点击行换色 🔥",charIndex:9486}],headersStr:":  v-bind 绑定 HTML class 🔥 绑定对象（使用很多） 绑定数组（使用较少） 绑定内联样式 style—组件化 🔥 绑定对象（使用很多） 绑定数组（使用较少） 内联字符串拼接 🔥 作业1—点击行换色 🔥",content:'# 属性绑定\n\n将 data 中数据插入到 HTML 模版属性中\n\n\n# : v-bind\n\n * 预期：any (with argument) | Object (without argument)\n\n * 参数：attrOrProp (optional)。大致理解 attr 为 HTML 属性（可自定义），prop 为 JS 属性\n\n * 修饰符：\n   \n   * .prop - 作为一个 DOM property 绑定而不是作为 attribute 绑定。(差别在哪里？)\n   * .camel - (2.1.0+) 将 kebab-case 特性名转换为 camelCase. (从 2.1.0 开始支持)。见Style绑定\n   * .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。\n\n * 用法：动态地绑定一个或多个特性，或向另一个组件传递 props 值\n   \n   * 在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。\n   \n   * 在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。\n   \n   * 没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。\n\n * 示例：\n   \n   <!DOCTYPE html>\n   <html lang="en">\n     <head>\n       <meta charset="UTF-8" />\n       <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n       <title>Title</title>\n     </head>\n   \n     <body>\n       <div id="app">\n         <a :href="href">QQ</a>\n       </div>\n   \n       <script src="/lib/vue.js"><\/script>\n       <script>\n         const vm = new Vue({\n           el: "#app",\n           data: {\n             message: "Hello",\n             href: "https://www.qq.com",\n           },\n         });\n       <\/script>\n     </body>\n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n   \n   \x3c!-- 绑定一个属性 --\x3e\n   <img v-bind:src="imageSrc">\n   \x3c!-- 缩写 --\x3e\n   <img :src="imageSrc">\n   \n   \x3c!-- 动态特性名 (2.6.0+) --\x3e\n   <button v-bind:[key]="value"></button>\n   \x3c!-- 动态特性名缩写 (2.6.0+) --\x3e\n   <button :[key]="value"></button>\n   \n   \x3c!-- 绑定一个有属性的对象 --\x3e\n   <div v-bind="{ id: someProp, \'other-attr\': otherProp }"></div>\n   \n   \x3c!-- 通过 prop 修饰符绑定 DOM 属性 --\x3e\n   <div v-bind:text-content.prop="text"></div>\n   \n   \x3c!-- prop 绑定。“prop”必须在 my-component 中声明。--\x3e\n   <my-component :prop="someThing"></my-component>\n   \n   \x3c!-- 通过 $props 将父组件的 props 一起传给子组件 --\x3e\n   <child-component v-bind="$props"></child-component>\n   \n   \x3c!-- XLink --\x3e\n   <svg><a :xlink:special="foo"></a></svg>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n   \n   .camel 修饰符允许在使用 DOM 模板时将 v-bind 属性名称驼峰化，例如 SVG 的 viewBox 属性：\n   \n   <svg :view-box.camel="viewBox"></svg>\n   \n   \n   1\n   \n   \n   在使用字符串模板或通过 vue-loader/vueify 编译时，无需使用 .camel。\n\n\n# 绑定 HTML class 🔥\n\n\n# 绑定对象（使用很多）\n\n * 根据值的truthy（真值，除 false、0、""、null、undefined 和 NaN 以外）来决定键的渲染。\n   \n   :class="{class1: boolean, class2: boolean}"\n   \n   \n   1\n   \n\n * 会和普通的 class 共存。\n   \n   <span class="class1" :class="class2"></span>\n   \n   \n   1\n   \n\n * 若过于复杂，可放入 methods 或 compute 中。method必须加括号来调用该方法（与@调用不一样！）；compute 属性不用加括号。方法中只要返回对象或数组。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n    <style>\n      .active {\n        color: red;\n      }\n\n      .underline {\n        text-decoration: underline;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      class对象写死：\n      <span :class="{active: true, underline: false}">{{message}}</span><br />\n      class对象绑定：\n      <span :class="{active: isActive, underline: isUnderline}"\n        >{{message}}</span\n      >\n      <button @click="changeActive">切换 active</button><br />\n      class对象方法绑定：\n      <span :class="myClassMthod()">{{message}}</span><br />\n      class对象计算属性绑定：\n      <span :class="myClassCompute">{{message}}</span><br />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n          isActive: true,\n          isUnderline: false,\n        },\n        computed: {\n          myClassCompute: function () {\n            return { active: this.isActive, underline: this.isUnderline };\n          },\n        },\n        methods: {\n          changeActive() {\n            this.isActive = !this.isActive;\n          },\n          myClassMthod() {\n            return { active: this.isActive, underline: this.isUnderline };\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 绑定数组（使用较少）\n\n细节同绑定对象\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n    <style>\n      .active {\n        color: red;\n      }\n\n      .underline {\n        text-decoration: underline;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      class数组写死：\n      <span :class="[\'active\',\'underline\']">{{message}}</span><br />\n      class数组绑定：\n      <span :class="[active,underline]">{{message}}</span><br />\n\n      class数组方法绑定：\n      <span :class="myClassMthod()">{{message}}</span><br />\n      class数组计算属性绑定：\n      <span :class="myClassCompute">{{message}}</span><br />\n      多个条件 class，可以在数组中包含对象。当 is3 和 is4 都为真时，渲染为三个 class，否则哪个为真渲染哪个\n      <span :class="[active, { class3: is3, class4: is4 }]"></span>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n          active: "class1",\n          underline: "class2",\n          is3: true,\n          is4: false,\n        },\n        computed: {\n          myClassCompute: function () {\n            return [this.active, this.underline];\n          },\n        },\n        methods: {\n          myClassMthod() {\n            return [this.active, this.underline];\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 绑定内联样式 style—组件化 🔥\n\n常用于组件化开发时改变组建的样式！！！\n\n\n# 绑定对象（使用很多）\n\n与绑定 Class 不同的是：对象的键不是类名，而是属性名，且属性名称支持 kebab-case 和 camelCase。值为一个变量，常量需要使用引号包裹，否则当变量编译时报错。\n\n同样可以封装到 methods 或 computed 中，略\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n    <style></style>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 写死 --\x3e\n      <h2 :style="{fontSize: \'16px\'}">{{message}}</h2>\n      \x3c!-- 动态 --\x3e\n      <h2 :style="{fontSize: finalSize1}">{{message}}</h2>\n      <h2 :style="{fontSize: finalSize2 + \'px\', backgroundColor: finalBgc}">\n        {{message}}\n      </h2>\n      \x3c!-- 方法 --\x3e\n      <h2 :style="myStyleMethod()">\n        {{message}}\n      </h2>\n      \x3c!-- 计算属性 --\x3e\n      <h2 :style="myStyleComputed">\n        {{message}}\n      </h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n          finalSize1: "24px",\n          finalSize2: "24",\n          finalBgc: "skyblue",\n        },\n        computed: {\n          myStyleComputed: function () {\n            return {\n              fontSize: this.finalSize2 + "px",\n              backgroundColor: this.finalBgc,\n            };\n          },\n        },\n        methods: {\n          myStyleMethod() {\n            return {\n              fontSize: this.finalSize2 + "px",\n              backgroundColor: this.finalBgc,\n            };\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 绑定数组（使用较少）\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n    <style></style>\n  </head>\n\n  <body>\n    <div id="app">\n      <h2 :style="[baseStyle1, baseStyle2]">Hello</h2>\n      <h2 :style="myBaseStyleMethod()">Hello</h2>\n      <h2 :style="myBaseStyleComputed">Hello</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          // style 中也是键制对，必须用对象\n          baseStyle1: { fontSize: "32px" },\n          baseStyle2: { background: "skyblue" },\n        },\n        computed: {\n          myBaseStyleComputed: function () {\n            return [this.baseStyle1, this.baseStyle2];\n          },\n        },\n        methods: {\n          myBaseStyleMethod: function () {\n            return [this.baseStyle1, this.baseStyle2];\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 内联字符串拼接 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <img src="https://cn.vuejs.org/images/logo.png" alt="" />\n      \x3c!-- 内联字符串拼接，fileName为变量 --\x3e\n      <img :src="\'https://cn.vuejs.org/images/\' + fileName" />\n      \x3c!-- 字符串模板 --\x3e\n      <img :src="`https://cn.vuejs.org/images/${fileName}`" />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n          fileName: "logo.png",\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 作业1—点击行换色 🔥\n\n注意，尽量不要直接操作 DOM，学习的是 Vue，尽量通过 Vue 来完成。\n\n思考：使用 v-bind 时，如何可以让选中的行变色？需要有个变量存储“选中的行”，常量为 for 循环出的 index，分析这俩间的关系即可得出，当“选中的行” 等于 index 时，激活 class 即可\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n    <style>\n      .active {\n        color: red;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      <ul>\n        <li\n          v-for="(item,index) in movies"\n          @click="changeColor(index)"\n          :class="{active: currentIndex === index}"\n        >\n          {{index}}-{{item}}\n        </li>\n      </ul>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          movies: ["名侦探柯南", "怪盗基德", "犬夜叉", "龙珠"],\n          currentIndex: 0, // 当前选中的行数\n        },\n        methods: {\n          changeColor(index) {\n            console.log(index);\n            this.currentIndex = index;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',normalizedContent:'# 属性绑定\n\n将 data 中数据插入到 html 模版属性中\n\n\n# : v-bind\n\n * 预期：any (with argument) | object (without argument)\n\n * 参数：attrorprop (optional)。大致理解 attr 为 html 属性（可自定义），prop 为 js 属性\n\n * 修饰符：\n   \n   * .prop - 作为一个 dom property 绑定而不是作为 attribute 绑定。(差别在哪里？)\n   * .camel - (2.1.0+) 将 kebab-case 特性名转换为 camelcase. (从 2.1.0 开始支持)。见style绑定\n   * .sync (2.3.0+) 语法糖，会扩展成一个更新父组件绑定值的 v-on 侦听器。\n\n * 用法：动态地绑定一个或多个特性，或向另一个组件传递 props 值\n   \n   * 在绑定 class 或 style 特性时，支持其它类型的值，如数组或对象。可以通过下面的教程链接查看详情。\n   \n   * 在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。\n   \n   * 没有参数时，可以绑定到一个包含键值对的对象。注意此时 class 和 style 绑定不支持数组和对象。\n\n * 示例：\n   \n   <!doctype html>\n   <html lang="en">\n     <head>\n       <meta charset="utf-8" />\n       <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n       <title>title</title>\n     </head>\n   \n     <body>\n       <div id="app">\n         <a :href="href">qq</a>\n       </div>\n   \n       <script src="/lib/vue.js"><\/script>\n       <script>\n         const vm = new vue({\n           el: "#app",\n           data: {\n             message: "hello",\n             href: "https://www.qq.com",\n           },\n         });\n       <\/script>\n     </body>\n   </html>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   \n   \n   \x3c!-- 绑定一个属性 --\x3e\n   <img v-bind:src="imagesrc">\n   \x3c!-- 缩写 --\x3e\n   <img :src="imagesrc">\n   \n   \x3c!-- 动态特性名 (2.6.0+) --\x3e\n   <button v-bind:[key]="value"></button>\n   \x3c!-- 动态特性名缩写 (2.6.0+) --\x3e\n   <button :[key]="value"></button>\n   \n   \x3c!-- 绑定一个有属性的对象 --\x3e\n   <div v-bind="{ id: someprop, \'other-attr\': otherprop }"></div>\n   \n   \x3c!-- 通过 prop 修饰符绑定 dom 属性 --\x3e\n   <div v-bind:text-content.prop="text"></div>\n   \n   \x3c!-- prop 绑定。“prop”必须在 my-component 中声明。--\x3e\n   <my-component :prop="something"></my-component>\n   \n   \x3c!-- 通过 $props 将父组件的 props 一起传给子组件 --\x3e\n   <child-component v-bind="$props"></child-component>\n   \n   \x3c!-- xlink --\x3e\n   <svg><a :xlink:special="foo"></a></svg>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   \n   \n   .camel 修饰符允许在使用 dom 模板时将 v-bind 属性名称驼峰化，例如 svg 的 viewbox 属性：\n   \n   <svg :view-box.camel="viewbox"></svg>\n   \n   \n   1\n   \n   \n   在使用字符串模板或通过 vue-loader/vueify 编译时，无需使用 .camel。\n\n\n# 绑定 html class 🔥\n\n\n# 绑定对象（使用很多）\n\n * 根据值的truthy（真值，除 false、0、""、null、undefined 和 nan 以外）来决定键的渲染。\n   \n   :class="{class1: boolean, class2: boolean}"\n   \n   \n   1\n   \n\n * 会和普通的 class 共存。\n   \n   <span class="class1" :class="class2"></span>\n   \n   \n   1\n   \n\n * 若过于复杂，可放入 methods 或 compute 中。method必须加括号来调用该方法（与@调用不一样！）；compute 属性不用加括号。方法中只要返回对象或数组。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n    <style>\n      .active {\n        color: red;\n      }\n\n      .underline {\n        text-decoration: underline;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      class对象写死：\n      <span :class="{active: true, underline: false}">{{message}}</span><br />\n      class对象绑定：\n      <span :class="{active: isactive, underline: isunderline}"\n        >{{message}}</span\n      >\n      <button @click="changeactive">切换 active</button><br />\n      class对象方法绑定：\n      <span :class="myclassmthod()">{{message}}</span><br />\n      class对象计算属性绑定：\n      <span :class="myclasscompute">{{message}}</span><br />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n          isactive: true,\n          isunderline: false,\n        },\n        computed: {\n          myclasscompute: function () {\n            return { active: this.isactive, underline: this.isunderline };\n          },\n        },\n        methods: {\n          changeactive() {\n            this.isactive = !this.isactive;\n          },\n          myclassmthod() {\n            return { active: this.isactive, underline: this.isunderline };\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n\n\n\n# 绑定数组（使用较少）\n\n细节同绑定对象\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n    <style>\n      .active {\n        color: red;\n      }\n\n      .underline {\n        text-decoration: underline;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      class数组写死：\n      <span :class="[\'active\',\'underline\']">{{message}}</span><br />\n      class数组绑定：\n      <span :class="[active,underline]">{{message}}</span><br />\n\n      class数组方法绑定：\n      <span :class="myclassmthod()">{{message}}</span><br />\n      class数组计算属性绑定：\n      <span :class="myclasscompute">{{message}}</span><br />\n      多个条件 class，可以在数组中包含对象。当 is3 和 is4 都为真时，渲染为三个 class，否则哪个为真渲染哪个\n      <span :class="[active, { class3: is3, class4: is4 }]"></span>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n          active: "class1",\n          underline: "class2",\n          is3: true,\n          is4: false,\n        },\n        computed: {\n          myclasscompute: function () {\n            return [this.active, this.underline];\n          },\n        },\n        methods: {\n          myclassmthod() {\n            return [this.active, this.underline];\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 绑定内联样式 style—组件化 🔥\n\n常用于组件化开发时改变组建的样式！！！\n\n\n# 绑定对象（使用很多）\n\n与绑定 class 不同的是：对象的键不是类名，而是属性名，且属性名称支持 kebab-case 和 camelcase。值为一个变量，常量需要使用引号包裹，否则当变量编译时报错。\n\n同样可以封装到 methods 或 computed 中，略\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n    <style></style>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 写死 --\x3e\n      <h2 :style="{fontsize: \'16px\'}">{{message}}</h2>\n      \x3c!-- 动态 --\x3e\n      <h2 :style="{fontsize: finalsize1}">{{message}}</h2>\n      <h2 :style="{fontsize: finalsize2 + \'px\', backgroundcolor: finalbgc}">\n        {{message}}\n      </h2>\n      \x3c!-- 方法 --\x3e\n      <h2 :style="mystylemethod()">\n        {{message}}\n      </h2>\n      \x3c!-- 计算属性 --\x3e\n      <h2 :style="mystylecomputed">\n        {{message}}\n      </h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n          finalsize1: "24px",\n          finalsize2: "24",\n          finalbgc: "skyblue",\n        },\n        computed: {\n          mystylecomputed: function () {\n            return {\n              fontsize: this.finalsize2 + "px",\n              backgroundcolor: this.finalbgc,\n            };\n          },\n        },\n        methods: {\n          mystylemethod() {\n            return {\n              fontsize: this.finalsize2 + "px",\n              backgroundcolor: this.finalbgc,\n            };\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 绑定数组（使用较少）\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n    <style></style>\n  </head>\n\n  <body>\n    <div id="app">\n      <h2 :style="[basestyle1, basestyle2]">hello</h2>\n      <h2 :style="mybasestylemethod()">hello</h2>\n      <h2 :style="mybasestylecomputed">hello</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          // style 中也是键制对，必须用对象\n          basestyle1: { fontsize: "32px" },\n          basestyle2: { background: "skyblue" },\n        },\n        computed: {\n          mybasestylecomputed: function () {\n            return [this.basestyle1, this.basestyle2];\n          },\n        },\n        methods: {\n          mybasestylemethod: function () {\n            return [this.basestyle1, this.basestyle2];\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n\n# 内联字符串拼接 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <img src="https://cn.vuejs.org/images/logo.png" alt="" />\n      \x3c!-- 内联字符串拼接，filename为变量 --\x3e\n      <img :src="\'https://cn.vuejs.org/images/\' + filename" />\n      \x3c!-- 字符串模板 --\x3e\n      <img :src="`https://cn.vuejs.org/images/${filename}`" />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n          filename: "logo.png",\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# 作业1—点击行换色 🔥\n\n注意，尽量不要直接操作 dom，学习的是 vue，尽量通过 vue 来完成。\n\n思考：使用 v-bind 时，如何可以让选中的行变色？需要有个变量存储“选中的行”，常量为 for 循环出的 index，分析这俩间的关系即可得出，当“选中的行” 等于 index 时，激活 class 即可\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n    <style>\n      .active {\n        color: red;\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      <ul>\n        <li\n          v-for="(item,index) in movies"\n          @click="changecolor(index)"\n          :class="{active: currentindex === index}"\n        >\n          {{index}}-{{item}}\n        </li>\n      </ul>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          movies: ["名侦探柯南", "怪盗基德", "犬夜叉", "龙珠"],\n          currentindex: 0, // 当前选中的行数\n        },\n        methods: {\n          changecolor(index) {\n            console.log(index);\n            this.currentindex = index;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"计算属性和侦听器",frontmatter:{title:"计算属性和侦听器",date:"2020-12-27T00:30:47.000Z",permalink:"/pages/10562f/",categories:["Vue","基础"],tags:[null]},regularPath:"/1402.Vue2.x/100.%E5%9F%BA%E7%A1%80/104.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E4%BE%A6%E5%90%AC%E5%99%A8.html",relativePath:"1402.Vue2.x/100.基础/104.计算属性和侦听器.md",key:"v-8d0417cc",path:"/pages/10562f/",headers:[{level:2,title:"计算“属性”",slug:"计算-属性",normalizedTitle:"计算“属性”",charIndex:15},{level:3,title:"缘由",slug:"缘由",normalizedTitle:"缘由",charIndex:26},{level:3,title:"计算属性的 setter、getter",slug:"计算属性的-setter、getter",normalizedTitle:"计算属性的 setter、getter",charIndex:3220},{level:3,title:"计算属性（缓存） VS 方法",slug:"计算属性-缓存-vs-方法",normalizedTitle:"计算属性（缓存） vs 方法",charIndex:4699},{level:3,title:"计算属性 vs 侦听属性 ❎",slug:"计算属性-vs-侦听属性-❎",normalizedTitle:"计算属性 vs 侦听属性 ❎",charIndex:6217},{level:2,title:"侦听器 ❎",slug:"侦听器-❎",normalizedTitle:"侦听器 ❎",charIndex:7038}],headersStr:"计算“属性” 缘由 计算属性的 setter、getter 计算属性（缓存） VS 方法 计算属性 vs 侦听属性 ❎ 侦听器 ❎",content:'# 计算属性和侦听器\n\n\n# 计算“属性”\n\n\n# 缘由\n\n模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。\n\n当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。所以，对于任何复杂逻辑，你都应当使用计算属性。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 在模板中放入太多的逻辑会让模板过重且难以维护 --\x3e\n      <h2>{{ message.split(\'\').reverse().join(\'\') }}</h2>\n      \x3c!-- 计算属性 --\x3e\n      <h2>{{ reversedMessage }}</h2>\n\n      \x3c!-- 在模板中放入太多的逻辑会让模板过重且难以维护 --\x3e\n      <h2>{{firstName +" "+ lastName}}</h2>\n      \x3c!-- 方法 --\x3e\n      <h2>{{fullNameMethod()}}</h2>\n      \x3c!-- 计算属性 --\x3e\n      <h2>{{fullNameComputed}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n          firstName: "Steven",\n          lastName: "Jobs",\n        },\n        // `this` 指向 vm 实例\n        computed: {\n          reversedMessage() {\n            return this.message.split("").reverse().join("");// 字符串反转\n          },\n          fullNameComputed() {\n            console.log("fullName computed");\n            return this.firstName + " " + this.lastName;\n          },\n        },\n        methods: {\n          fullNameMethod() {\n            console.log("fullName methods");\n            return this.firstName + " " + this.lastName;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n可以像绑定普通属性一样在模板中绑定计算属性。Vue 知道 this.reversedMessage 依赖于 this.message，因此当 this.message 发生改变时，所有依赖 this.reversedMessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。\n\n如下例子，计算书本总价格，可以使用计算属性：\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vue</title>\n  </head>\n\n  <body>\n    <div id="app">\n      总价：{{totalPrice}}\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // vue.js文件中定义了 Vue 对象，使用时可以 new 构造出，并且它还有参数（对象类型）\n      const vm = new Vue({\n        el: "#app",\n        // 声明式编程（声明式渲染），不再使用命令式\n        data: {\n          books: [\n            { id: 1, name: "Java", price: 110 },\n            { id: 2, name: "Kotlin", price: 120 },\n            { id: 3, name: "Clojure", price: 112 },\n            { id: 4, name: "JVM", price: 200 },\n          ],\n        },\n        methods: {},\n        computed: {\n          // 匿名函数\n          totalPrice() {\n            let totalPrice = 0;\n            this.books.forEach((item) => {\n              totalPrice += item.price;\n            });\n            return totalPrice;\n          },\n          // 正常函数\n          totalPrice2: function () {\n            let totalPrice = 0;\n            this.books.forEach((item) => {\n              totalPrice += item.price;\n            });\n            return totalPrice;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 计算属性的 setter、getter\n\n计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 计算属性 --\x3e\n      <h2>{{fullNameComputed}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          firstName: "Steven",\n          lastName: "Jobs",\n        },\n        computed: {\n          // 1 简写\n          //   fullNameComputed() {\n          //     console.log("fullName computed");\n          //     return this.firstName + " " + this.lastName;\n          //   },\n\n          // 2 实际上，一般计算属性无需写setter方法，再简化就成为上述简写形式了\n          fullNameComputed: {\n            get: function () {\n              console.log("getter");\n              return this.firstName + " " + this.lastName;\n            },\n            set: function (value) {\n              console.log("setter", value);\n              var [firstName, lastName] = value.split(" ");\n              this.firstName = firstName;\n              this.lastName = lastName;\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n运行 vm.fullName = \'John Doe\' 时setter 会被调用，vm.firstName 和 vm.lastName 也会相应地被更新。\n\n\n# 计算属性（缓存） VS 方法\n\n计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。\n\n如下例子，fullNameMethod 调用了3次，而 fullNameComputed 只调用了1次\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 拼接 --\x3e\n      <h2>{{ firstName + " " + lastName}}</h2>\n      \x3c!-- 方法 --\x3e\n      <h2>{{fullNameMethod()}}</h2>\n      <h2>{{fullNameMethod()}}</h2>\n      <h2>{{fullNameMethod()}}</h2>\n\n      \x3c!-- 计算属性 --\x3e\n      <h2>{{fullNameComputed}}</h2>\n      <h2>{{fullNameComputed}}</h2>\n      <h2>{{fullNameComputed}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          firstName: "Steven",\n          lastName: "Jobs",\n        },\n        computed: {\n          // 1 简写\n          fullNameComputed() {\n            console.log("fullName computed");\n            return this.firstName + " " + this.lastName;\n          },\n        },\n        methods: {\n          fullNameMethod() {\n            console.log("fullName methods");\n            return this.firstName + " " + this.lastName;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n这也同样意味着下面的计算属性将不再更新，因为 Date.now() 不是响应式依赖：\n\ncomputed: {\n  now: function () {\n    return Date.now()\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 计算属性 vs 侦听属性 ❎\n\nVue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 AngularJS。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子：\n\n<div id="demo">{{ fullName }}</div>\n\n\n1\n\n\nvar vm = new Vue({\n  el: \'#demo\',\n  data: {\n    firstName: \'Foo\',\n    lastName: \'Bar\',\n    fullName: \'Foo Bar\'\n  },\n  watch: {\n    firstName: function (val) {\n      this.fullName = val + \' \' + this.lastName\n    },\n    lastName: function (val) {\n      this.fullName = this.firstName + \' \' + val\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码是命令式且重复的。将它与计算属性的版本进行比较：\n\nvar vm = new Vue({\n  el: \'#demo\',\n  data: {\n    firstName: \'Foo\',\n    lastName: \'Bar\'\n  },\n  computed: {\n    fullName: function () {\n      return this.firstName + \' \' + this.lastName\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n显而易见好得多了\n\n\n# 侦听器 ❎\n\n虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。',normalizedContent:'# 计算属性和侦听器\n\n\n# 计算“属性”\n\n\n# 缘由\n\n模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。\n\n当你想要在模板中多次引用此处的翻转字符串时，就会更加难以处理。所以，对于任何复杂逻辑，你都应当使用计算属性。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 在模板中放入太多的逻辑会让模板过重且难以维护 --\x3e\n      <h2>{{ message.split(\'\').reverse().join(\'\') }}</h2>\n      \x3c!-- 计算属性 --\x3e\n      <h2>{{ reversedmessage }}</h2>\n\n      \x3c!-- 在模板中放入太多的逻辑会让模板过重且难以维护 --\x3e\n      <h2>{{firstname +" "+ lastname}}</h2>\n      \x3c!-- 方法 --\x3e\n      <h2>{{fullnamemethod()}}</h2>\n      \x3c!-- 计算属性 --\x3e\n      <h2>{{fullnamecomputed}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n          firstname: "steven",\n          lastname: "jobs",\n        },\n        // `this` 指向 vm 实例\n        computed: {\n          reversedmessage() {\n            return this.message.split("").reverse().join("");// 字符串反转\n          },\n          fullnamecomputed() {\n            console.log("fullname computed");\n            return this.firstname + " " + this.lastname;\n          },\n        },\n        methods: {\n          fullnamemethod() {\n            console.log("fullname methods");\n            return this.firstname + " " + this.lastname;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n可以像绑定普通属性一样在模板中绑定计算属性。vue 知道 this.reversedmessage 依赖于 this.message，因此当 this.message 发生改变时，所有依赖 this.reversedmessage 的绑定也会更新。而且最妙的是我们已经以声明的方式创建了这种依赖关系：计算属性的 getter 函数是没有副作用 (side effect) 的，这使它更易于测试和理解。\n\n如下例子，计算书本总价格，可以使用计算属性：\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>vue</title>\n  </head>\n\n  <body>\n    <div id="app">\n      总价：{{totalprice}}\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // vue.js文件中定义了 vue 对象，使用时可以 new 构造出，并且它还有参数（对象类型）\n      const vm = new vue({\n        el: "#app",\n        // 声明式编程（声明式渲染），不再使用命令式\n        data: {\n          books: [\n            { id: 1, name: "java", price: 110 },\n            { id: 2, name: "kotlin", price: 120 },\n            { id: 3, name: "clojure", price: 112 },\n            { id: 4, name: "jvm", price: 200 },\n          ],\n        },\n        methods: {},\n        computed: {\n          // 匿名函数\n          totalprice() {\n            let totalprice = 0;\n            this.books.foreach((item) => {\n              totalprice += item.price;\n            });\n            return totalprice;\n          },\n          // 正常函数\n          totalprice2: function () {\n            let totalprice = 0;\n            this.books.foreach((item) => {\n              totalprice += item.price;\n            });\n            return totalprice;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 计算属性的 setter、getter\n\n计算属性默认只有 getter ，不过在需要时你也可以提供一个 setter ：\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 计算属性 --\x3e\n      <h2>{{fullnamecomputed}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          firstname: "steven",\n          lastname: "jobs",\n        },\n        computed: {\n          // 1 简写\n          //   fullnamecomputed() {\n          //     console.log("fullname computed");\n          //     return this.firstname + " " + this.lastname;\n          //   },\n\n          // 2 实际上，一般计算属性无需写setter方法，再简化就成为上述简写形式了\n          fullnamecomputed: {\n            get: function () {\n              console.log("getter");\n              return this.firstname + " " + this.lastname;\n            },\n            set: function (value) {\n              console.log("setter", value);\n              var [firstname, lastname] = value.split(" ");\n              this.firstname = firstname;\n              this.lastname = lastname;\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n运行 vm.fullname = \'john doe\' 时setter 会被调用，vm.firstname 和 vm.lastname 也会相应地被更新。\n\n\n# 计算属性（缓存） vs 方法\n\n计算属性是基于它们的响应式依赖进行缓存的。只在相关响应式依赖发生改变时它们才会重新求值。\n\n如下例子，fullnamemethod 调用了3次，而 fullnamecomputed 只调用了1次\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 拼接 --\x3e\n      <h2>{{ firstname + " " + lastname}}</h2>\n      \x3c!-- 方法 --\x3e\n      <h2>{{fullnamemethod()}}</h2>\n      <h2>{{fullnamemethod()}}</h2>\n      <h2>{{fullnamemethod()}}</h2>\n\n      \x3c!-- 计算属性 --\x3e\n      <h2>{{fullnamecomputed}}</h2>\n      <h2>{{fullnamecomputed}}</h2>\n      <h2>{{fullnamecomputed}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          firstname: "steven",\n          lastname: "jobs",\n        },\n        computed: {\n          // 1 简写\n          fullnamecomputed() {\n            console.log("fullname computed");\n            return this.firstname + " " + this.lastname;\n          },\n        },\n        methods: {\n          fullnamemethod() {\n            console.log("fullname methods");\n            return this.firstname + " " + this.lastname;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n这也同样意味着下面的计算属性将不再更新，因为 date.now() 不是响应式依赖：\n\ncomputed: {\n  now: function () {\n    return date.now()\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n\n# 计算属性 vs 侦听属性 ❎\n\nvue 提供了一种更通用的方式来观察和响应 vue 实例上的数据变动：侦听属性。当你有一些数据需要随着其它数据变动而变动时，你很容易滥用 watch——特别是如果你之前使用过 angularjs。然而，通常更好的做法是使用计算属性而不是命令式的 watch 回调。细想一下这个例子：\n\n<div id="demo">{{ fullname }}</div>\n\n\n1\n\n\nvar vm = new vue({\n  el: \'#demo\',\n  data: {\n    firstname: \'foo\',\n    lastname: \'bar\',\n    fullname: \'foo bar\'\n  },\n  watch: {\n    firstname: function (val) {\n      this.fullname = val + \' \' + this.lastname\n    },\n    lastname: function (val) {\n      this.fullname = this.firstname + \' \' + val\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n上面代码是命令式且重复的。将它与计算属性的版本进行比较：\n\nvar vm = new vue({\n  el: \'#demo\',\n  data: {\n    firstname: \'foo\',\n    lastname: \'bar\'\n  },\n  computed: {\n    fullname: function () {\n      return this.firstname + \' \' + this.lastname\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n显而易见好得多了\n\n\n# 侦听器 ❎\n\n虽然计算属性在大多数情况下更合适，但有时也需要一个自定义的侦听器。这就是为什么 vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"事件监听",frontmatter:{title:"事件监听",date:"2020-12-27T00:30:47.000Z",permalink:"/pages/5aff0b/",categories:["Vue","基础"],tags:[null]},regularPath:"/1402.Vue2.x/100.%E5%9F%BA%E7%A1%80/105.%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC.html",relativePath:"1402.Vue2.x/100.基础/105.事件监听.md",key:"v-46373fc2",path:"/pages/5aff0b/",headers:[{level:2,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:11},{level:2,title:"事件修饰符",slug:"事件修饰符",normalizedTitle:"事件修饰符",charIndex:3323},{level:3,title:".stop",slug:"stop",normalizedTitle:".stop",charIndex:3397},{level:3,title:".prevent",slug:"prevent",normalizedTitle:".prevent",charIndex:3372},{level:3,title:".once",slug:"once",normalizedTitle:".once",charIndex:3514},{level:2,title:"按键修饰符",slug:"按键修饰符",normalizedTitle:"按键修饰符",charIndex:6650},{level:3,title:".enter",slug:"enter",normalizedTitle:".enter",charIndex:6701},{level:3,title:".native 组件",slug:"native-组件",normalizedTitle:".native 组件",charIndex:7563}],headersStr:"使用 事件修饰符 .stop .prevent .once 按键修饰符 .enter .native 组件",content:'# 事件监听\n\n\n# 使用\n\n可以用 v-on 指令监听 DOM 事件，并在触发时运行一些 JavaScript 代码。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <button v-on:click="counter += 1">Add 1</button>\n      <p>The button above has been clicked {{ counter }} times.</p>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          counter: 0,\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n然而许多事件处理逻辑会更为复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。有时也需要在内联语句处理器中访问原始的 DOM 事件。可以用特殊变量 $event 把它传入方法\n\n * 情况1：方法定义时没有参数要接收，调用方法后不加()或添加()都没关系\n * 情况2：方法定义时只想接收一个原生 DOM 事件event参数，调用方法不能加()，默认会传递event参数。若添加了()，将不会传递event参数。也可以添加($event)来传递（不过没必要）。\n * 情况3：方法定义时有自定义参数，则调用方法时必须传递参数(params...)。若还需要event参数，调用时可传递(params,$event)参数\n\n具体查看下面代码：\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <button v-on:click="counter1 += 1">button1</button>\n      <p>The button1 above has been clicked {{ counter1 }} times.</p>\n\n      \x3c!-- 不传递参数 --\x3e\n      <button @click="increment2">button2</button>\n      <p>The button2 above has been clicked {{ counter2 }} times.</p>\n\n      \x3c!-- 传递event --\x3e\n      <button @click="increment3">button3</button>\n      <p>The button3 above has been clicked {{ counter3 }} times.</p>\n\n      \x3c!-- 传递参数 --\x3e\n      <button @click="increment4(5)">button4</button>\n      <p>The button4 above has been clicked {{ counter4 }} times.</p>\n\n      \x3c!-- 传递参数+event --\x3e\n      <button @click="increment5(5,$event)">button5</button>\n      <p>The button5 above has been clicked {{ counter5 }} times.</p>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          counter1: 0,\n          counter2: 0,\n          counter3: 0,\n          counter4: 0,\n          counter5: 0,\n        },\n        methods: {\n          // 不传递参数\n          increment2() {\n            this.counter2++;\n          },\n          // 传递event\n          increment3(event) {\n            this.counter3++;\n            // `event` 是原生 DOM 事件\n            if (event) {\n              console.log(event);\n              alert(event.target.tagName);\n            }\n          },\n          // 传递参数\n          increment4(num) {\n            alert(num);\n            this.counter4++;\n          },\n          // 传递参数+event\n          increment5(num, event) {\n            alert(num);\n            this.counter5++;\n            // `event` 是原生 DOM 事件\n            if (event) {\n              console.log(event);\n              alert(event.target.tagName);\n            }\n          },\n        },\n      });\n\n      // 也可以用 JavaScript 直接调用方法。一般不用\n      // vm.increment2();\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# 事件修饰符\n\nVue.js 为 v-on 提供了事件修饰符来处理 DOM 事件细节，如：event.preventDefault() 或 event.stopPropagation()。\n\nVue.js通过由点.表示的指令后缀来调用修饰符：\n\n * .stop：停止事件传播，不再派发事件\n * .prevent：停止事件的默认动作\n * .capture\n * .self\n * .once\n\n\n# .stop\n\n停止事件传播，不再派发事件（冒泡）。底层为 JS 原生调用 event.stopProgatation()\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      .stop\n      <div @click="divClick">\n        div<button @click.stop="btnClick">btn</button>\n      </div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        methods: {\n          divClick() {\n            console.log("divClick");\n          },\n          btnClick() {\n            console.log("btnClick");\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# .prevent\n\n停止事件的默认动作，如表单提交。底层为 JS 原生调用 event.preventDefault()\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      .prevent\n      <form action="http://www.qq.com" method="post" @submit.prevent>\n        \x3c!--.prevent--\x3e\n        <input type="submit" value="提交" />\n      </form>\n        \n      <form action="http://www.baidu.com" method="post">\n        \x3c!--.prevent--\x3e\n        <input type="submit" value="提交" @click.prevent="submitClick" />\n      </form>\n      <hr />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        methods: {\n          submitClick() {\n            console.log("submitClick");\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n原生实现\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <form action="http://www.qq.com" method="post" onsubmit="return checkForm();">\n        <input type="submit" value="提交">\n    </form>\n\n   <script>\n    function checkForm() {\n        return false;\n    };\n<\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# .once\n\n事件将只会触发一次\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      .once\n      <button @click.once="onceClick">OnceClick</button>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        methods: {\n          onceClick() {\n            console.log("onceClick");\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 按键修饰符\n\nVue 允许为 v-on 在监听键盘事件时添加按键修饰符：\n\n全部的按键别名：\n\n * .enter\n * .tab\n * .delete (捕获 "删除" 和 "退格" 键)\n * .esc\n * .space\n * .up\n * .down\n * .left\n * .right\n * .ctrl\n * .alt\n * .shift\n * .meta\n\n\n# .enter\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      .enter\n      <input type="text" @keyup.enter="keyUp" />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        methods: {\n          keyUp() {\n            // 未使用.enter前，任何按键keyup都会触发\n            console.log("keyUp.按了回车");\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# .native 组件\n\n监听组件根元素的原生事件',normalizedContent:'# 事件监听\n\n\n# 使用\n\n可以用 v-on 指令监听 dom 事件，并在触发时运行一些 javascript 代码。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <button v-on:click="counter += 1">add 1</button>\n      <p>the button above has been clicked {{ counter }} times.</p>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          counter: 0,\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n然而许多事件处理逻辑会更为复杂，所以直接把 javascript 代码写在 v-on 指令中是不可行的。因此 v-on 还可以接收一个需要调用的方法名称。有时也需要在内联语句处理器中访问原始的 dom 事件。可以用特殊变量 $event 把它传入方法\n\n * 情况1：方法定义时没有参数要接收，调用方法后不加()或添加()都没关系\n * 情况2：方法定义时只想接收一个原生 dom 事件event参数，调用方法不能加()，默认会传递event参数。若添加了()，将不会传递event参数。也可以添加($event)来传递（不过没必要）。\n * 情况3：方法定义时有自定义参数，则调用方法时必须传递参数(params...)。若还需要event参数，调用时可传递(params,$event)参数\n\n具体查看下面代码：\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <button v-on:click="counter1 += 1">button1</button>\n      <p>the button1 above has been clicked {{ counter1 }} times.</p>\n\n      \x3c!-- 不传递参数 --\x3e\n      <button @click="increment2">button2</button>\n      <p>the button2 above has been clicked {{ counter2 }} times.</p>\n\n      \x3c!-- 传递event --\x3e\n      <button @click="increment3">button3</button>\n      <p>the button3 above has been clicked {{ counter3 }} times.</p>\n\n      \x3c!-- 传递参数 --\x3e\n      <button @click="increment4(5)">button4</button>\n      <p>the button4 above has been clicked {{ counter4 }} times.</p>\n\n      \x3c!-- 传递参数+event --\x3e\n      <button @click="increment5(5,$event)">button5</button>\n      <p>the button5 above has been clicked {{ counter5 }} times.</p>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          counter1: 0,\n          counter2: 0,\n          counter3: 0,\n          counter4: 0,\n          counter5: 0,\n        },\n        methods: {\n          // 不传递参数\n          increment2() {\n            this.counter2++;\n          },\n          // 传递event\n          increment3(event) {\n            this.counter3++;\n            // `event` 是原生 dom 事件\n            if (event) {\n              console.log(event);\n              alert(event.target.tagname);\n            }\n          },\n          // 传递参数\n          increment4(num) {\n            alert(num);\n            this.counter4++;\n          },\n          // 传递参数+event\n          increment5(num, event) {\n            alert(num);\n            this.counter5++;\n            // `event` 是原生 dom 事件\n            if (event) {\n              console.log(event);\n              alert(event.target.tagname);\n            }\n          },\n        },\n      });\n\n      // 也可以用 javascript 直接调用方法。一般不用\n      // vm.increment2();\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n\n\n\n# 事件修饰符\n\nvue.js 为 v-on 提供了事件修饰符来处理 dom 事件细节，如：event.preventdefault() 或 event.stoppropagation()。\n\nvue.js通过由点.表示的指令后缀来调用修饰符：\n\n * .stop：停止事件传播，不再派发事件\n * .prevent：停止事件的默认动作\n * .capture\n * .self\n * .once\n\n\n# .stop\n\n停止事件传播，不再派发事件（冒泡）。底层为 js 原生调用 event.stopprogatation()\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      .stop\n      <div @click="divclick">\n        div<button @click.stop="btnclick">btn</button>\n      </div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        methods: {\n          divclick() {\n            console.log("divclick");\n          },\n          btnclick() {\n            console.log("btnclick");\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# .prevent\n\n停止事件的默认动作，如表单提交。底层为 js 原生调用 event.preventdefault()\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      .prevent\n      <form action="http://www.qq.com" method="post" @submit.prevent>\n        \x3c!--.prevent--\x3e\n        <input type="submit" value="提交" />\n      </form>\n        \n      <form action="http://www.baidu.com" method="post">\n        \x3c!--.prevent--\x3e\n        <input type="submit" value="提交" @click.prevent="submitclick" />\n      </form>\n      <hr />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        methods: {\n          submitclick() {\n            console.log("submitclick");\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\n原生实现\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <form action="http://www.qq.com" method="post" onsubmit="return checkform();">\n        <input type="submit" value="提交">\n    </form>\n\n   <script>\n    function checkform() {\n        return false;\n    };\n<\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# .once\n\n事件将只会触发一次\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      .once\n      <button @click.once="onceclick">onceclick</button>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        methods: {\n          onceclick() {\n            console.log("onceclick");\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 按键修饰符\n\nvue 允许为 v-on 在监听键盘事件时添加按键修饰符：\n\n全部的按键别名：\n\n * .enter\n * .tab\n * .delete (捕获 "删除" 和 "退格" 键)\n * .esc\n * .space\n * .up\n * .down\n * .left\n * .right\n * .ctrl\n * .alt\n * .shift\n * .meta\n\n\n# .enter\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      .enter\n      <input type="text" @keyup.enter="keyup" />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        methods: {\n          keyup() {\n            // 未使用.enter前，任何按键keyup都会触发\n            console.log("keyup.按了回车");\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# .native 组件\n\n监听组件根元素的原生事件',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"条件和循环",frontmatter:{title:"条件和循环",date:"2020-12-27T00:30:47.000Z",permalink:"/pages/7627a1/",categories:["Vue","基础"],tags:[null]},regularPath:"/1402.Vue2.x/100.%E5%9F%BA%E7%A1%80/106.%E6%9D%A1%E4%BB%B6%E5%92%8C%E5%BE%AA%E7%8E%AF.html",relativePath:"1402.Vue2.x/100.基础/106.条件和循环.md",key:"v-24f2dc8c",path:"/pages/7627a1/",headers:[{level:2,title:"v-if & v-else-if & v-else",slug:"v-if-v-else-if-v-else",normalizedTitle:"v-if &amp; v-else-if &amp; v-else",charIndex:null},{level:2,title:"账号切换案例 & Virtual DOM 复用",slug:"账号切换案例-virtual-dom-复用",normalizedTitle:"账号切换案例 &amp; virtual dom 复用",charIndex:null},{level:2,title:"v-if & v-show",slug:"v-if-v-show",normalizedTitle:"v-if &amp; v-show",charIndex:null},{level:2,title:"v-for & key",slug:"v-for-key",normalizedTitle:"v-for &amp; key",charIndex:null},{level:3,title:"v-for",slug:"v-for",normalizedTitle:"v-for",charIndex:2467},{level:3,title:"key",slug:"key",normalizedTitle:"key",charIndex:1627},{level:2,title:"数组中哪些方法是响应式的？",slug:"数组中哪些方法是响应式的",normalizedTitle:"数组中哪些方法是响应式的？",charIndex:6109},{level:2,title:"购物车案例",slug:"购物车案例",normalizedTitle:"购物车案例",charIndex:7651}],headersStr:"v-if & v-else-if & v-else 账号切换案例 & Virtual DOM 复用 v-if & v-show v-for & key v-for key 数组中哪些方法是响应式的？ 购物车案例",content:'# 条件和循环\n\n\n# v-if & v-else-if & v-else\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <h2 v-if="score>=90">优秀</h2>\n      <h2 v-else-if="score>=80">良好</h2>\n      <h2 v-else-if="score>=60">及格</h2>\n      <h2 v-else>不及格</h2>\n\n      \x3c!-- 但是不推荐这样写，推荐使用计算属性 --\x3e\n      {{result}}\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          score: 88,\n        },\n        computed: {\n          result() {\n            let showMessage = \'\'\n            if (this.score >= 90) {\n              showMessage = \'优秀\'\n            } else if (this.score >= 80) {\n              showMessage = \'良好\'\n            } else if (this.score >= 60) {\n              showMessage = \'及格\'\n            } else {\n              showMessage = \'不及格\'\n            }\n            return showMessage\n          },\n        },\n        methods: {},\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 账号切换案例 & Virtual DOM 复用\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <span v-if="isUser">\n        <label for="username">用户账号</label>\n        <input\n          type="text"\n          id="username"\n          placeholder="用户账号"\n          key="username"\n        />\n      </span>\n      <span v-else>\n        <label for="username">用户邮箱</label>\n        <input type="email" id="email" placeholder="用户邮箱" key="email" />\n      </span>\n      <button @click="isUser = !isUser">切换</button>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          isUser: true,\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n小问题：\n\n * 在有输入内容情况下，切换类型，会发现内容依然存在，没有被清空\n * 按理说已经切换到另一个 input 元素中了，且另一个元素没有输入内容\n\n解答：\n\n * 因为 Vue 的 Virtual DOM 在进行渲染时，出于性能考虑，会尽可能复用已存在的元素，而不是重新创建新的元素\n * 在上面的案例中，Vue 发现原来的 input 元素不再使用，直接作为 else 中的 input 来使用了\n\n解决：\n\n * 若不希望出现 Vue 重复利用问题，可以给对应的 input 元素添加不同的 key\n * 但是有的时候又需要不清空，根据需要选择\n * 类似的 v-for 时要指定 key 也是该原因（但是是为了更好的复用）\n\n\n# v-if & v-show\n\n区别：\n\n * v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。它也是惰性的：如果在初始渲染时条件为假，则什么也不做（DOM 中不存在）——直到条件第一次变为真时，才会开始渲染条件块。\n\n * v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换，display: none。\n\n总结：一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n\n\n# v-for & key\n\n\n# v-for\n\n不推荐遍历对象，直接调用即可\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 便利对象，获取 value --\x3e\n      <ul>\n        <li v-for="value in info">{{value}}</li>\n      </ul>\n\n      \x3c!-- 便利对象，获取 (value,key) --\x3e\n      <ul>\n        <li v-for="(value,key) in info">{{value}}-{{key}}</li>\n      </ul>\n\n      \x3c!-- 便利对象，获取 (value,key,index) --\x3e\n      <ul>\n        <li v-for="(value,key,index) in info">{{value}}-{{key}}-{{index}}</li>\n      </ul>\n\n      \x3c!-- 便利数组，获取 value --\x3e\n      <ul>\n        <li v-for="item in infoList">\n          {{item.name}}-{{item.age}}-{{item.sex}}\n        </li>\n      </ul>\n\n      \x3c!-- 便利数组，获取  (value,index)  --\x3e\n      <ul>\n        <li v-for="(item,index) in infoList">\n          {{item.name}}-{{item.age}}-{{item.sex}}-{{index}}\n        </li>\n      </ul>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          message: \'Hello\',\n          info: {\n            name: \'conanan\',\n            age: 18,\n            sex: \'male\',\n          },\n          infoList: [\n            {\n              name: \'conanan\',\n              age: 18,\n              sex: \'male\',\n            },\n            {\n              name: \'zhangsan\',\n              age: 33,\n              sex: \'male\',\n            },\n            {\n              name: \'lisi\',\n              age: 44,\n              sex: \'female\',\n            },\n          ],\n        },\n        methods: {},\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# key\n\n建议尽可能在使用 v-for 时提供 key attribute（无论是元素还是组件），除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。它是 Vue 识别节点的一个通用机制，并不仅与 v-for 特别关联。\n\n这和 Vue 的 Virtual DOM 的 Diff 算法有关\n\n当 Vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出。为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute。\n\n看如下例子：\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <ul>\n        <li v-for="(item,index) in array">{{item}}：<input type="text" /></li>\n      </ul>\n      <ul>\n        <li v-for="(item,index) in array" :key="item">\n          {{item}}：<input type="text" />\n        </li>\n      </ul>\n      <button @click="add">在1和2间添加</button>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          message: \'Hello\',\n          array: [1, 2, 3],\n        },\n        methods: {\n          add() {\n            this.array.splice(1, 0, 9)\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\ninput 中填入值\n\n点击按钮后结果如图：\n\n显而易见，上面的没有使用 key，它就地更新，重用了组件。下面的使用了 key，不会重用组件，添加正确。具体再总结吧！\n\n\n# 数组中哪些方法是响应式的？\n\nVue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\n\n * push()\n * pop()\n * shift()\n * unshift()\n * splice()\n * sort()\n * reverse()\n\n注意：直接修改数组中某个值，不是响应式的！\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <ul>\n        <li v-for="item in letters">{{item}}</li>\n      </ul>\n      <button @click="arrayMethod">btn</button>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          letters: [\'a\', \'b\', \'c\', \'d\'],\n        },\n        methods: {\n          arrayMethod() {\n            // push 向末尾添加\n            // this.letters.push("e");\n            // this.letters.push("e"，"f","g");\n            // pop 从末尾删除\n            // this.letters.pop();\n            // shift 从首部删除\n            // this.letters.shift();\n            // unshift 向首部添加\n            // this.letters.unshift("-a");\n            // this.letters.unshift("-c", "-b", "-a"); // [\'-c\',\'-b\',\'-a\',\'a\',\'b\',\'c\']\n            // splice 删除并添加一个值，修改一个值时使用。增删改都可以完成\n            this.letters.splice(1, 1, \'bbb\')\n            // reverse 反转\n            // this.letters.reverse();\n            // sort 排序\n            // this.letters.sort();\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 购物车案例\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Vue</title>\n    <style>\n      table {\n        /* 合并细线边框 */\n        border-collapse: collapse;\n        /* 单元格之间水平、垂直距离，与 border-collapse 冲突，不常用 */\n        /*border-spacing: 10px 20px;*/\n        /* 表格居中 */\n        margin: 100px auto;\n      }\n      th,\n      td {\n        /* 边框 */\n        border: 1px solid skyblue;\n        /* 内边距 */\n        padding: 20px;\n        /* 让td居中，th本来就是居中的 */\n        text-align: center;\n        /* 默认情况下元素在th,td中是垂直居中的，也可以通过 vertical-align 来修改*/\n        /* 由此可得，对一个父元素设置 display: table-cell，可以直接使用 vertical-align 来垂直居中*/\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      <div v-if="books.length >= 1">\n        <table>\n          <thead>\n            <tr>\n              <th></th>\n              <th>书籍名称</th>\n              <th>出版日期</th>\n              <th>价格</th>\n              <th>购买数量</th>\n              <th>操作</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr v-for="(book,index) in books" :key="book.id">\n              <td>{{book.id}}</td>\n              <td>{{book.name}}</td>\n              <td>{{book.time}}</td>\n              \x3c!-- <td>{{\'¥\'+book.price.toFixed(2)}}</td> --\x3e\n              \x3c!-- 这么多地方使用，可以复用 --\x3e\n              \x3c!-- 方式1:方法。计算属性也可以 --\x3e\n              \x3c!-- <td>{{formartPrice(book.price)}}</td> --\x3e\n              \x3c!-- 方式2:过滤器 --\x3e\n              <td>{{book.price | formartPrice}}</td>\n\n              <td>\n                <button @click="decrement(book)" :disabled="book.count === 1">\n                  -\n                </button>\n                {{book.count}}\n                <button @click="increment(book)">+</button>\n              </td>\n              <td><button @click="remove(index)">移除</button></td>\n            </tr>\n          </tbody>\n        </table>\n        \x3c!-- 总价：{{\'¥\'+totalPrice.toFixed(2)}} --\x3e\n        \x3c!-- 总价：{{formartPrice(totalPrice)}} --\x3e\n        总价：{{totalPrice | formartPrice}}\n      </div>\n      <div v-else>\n        购物车为空\n      </div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // vue.js文件中定义了 Vue 对象，使用时可以 new 构造出，并且它还有参数（对象类型）\n      const vm = new Vue({\n        el: \'#app\',\n        // 声明式编程（声明式渲染），不再使用命令式\n        data: {\n          books: [\n            { id: 1, name: \'Java\', time: \'2006-02\', price: 110.0, count: 1 },\n            { id: 2, name: \'Kotlin\', time: \'2016-03\', price: 120.0, count: 1 },\n            { id: 3, name: \'Clojure\', time: \'2008-12\', price: 112.0, count: 1 },\n            { id: 4, name: \'JVM\', time: \'2002-8\', price: 200.0, count: 1 },\n          ],\n        },\n        methods: {\n          increment(book) {\n            book.count++\n          },\n          decrement(book) {\n            // if (book.count === 1) {\n            //   return;\n            // }\n            book.count--\n          },\n          remove(index) {\n            this.books.splice(index, 1)\n          },\n          formartPrice(price) {\n            return \'¥\' + price.toFixed(2)\n          },\n        },\n        computed: {\n          totalPrice() {\n            // let totalPrice = 0;\n            // this.books.forEach((item) => {\n            //   totalPrice += item.price * item.count;\n            // });\n            // return totalPrice;\n\n            return this.books.reduce((previous, current, index, arr) => {\n              return previous + current.price * current.count\n            }, 0)\n          },\n        },\n        filters: {\n          formartPrice(price) {\n            return \'¥\' + price.toFixed(2)\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n',normalizedContent:'# 条件和循环\n\n\n# v-if & v-else-if & v-else\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <h2 v-if="score>=90">优秀</h2>\n      <h2 v-else-if="score>=80">良好</h2>\n      <h2 v-else-if="score>=60">及格</h2>\n      <h2 v-else>不及格</h2>\n\n      \x3c!-- 但是不推荐这样写，推荐使用计算属性 --\x3e\n      {{result}}\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          score: 88,\n        },\n        computed: {\n          result() {\n            let showmessage = \'\'\n            if (this.score >= 90) {\n              showmessage = \'优秀\'\n            } else if (this.score >= 80) {\n              showmessage = \'良好\'\n            } else if (this.score >= 60) {\n              showmessage = \'及格\'\n            } else {\n              showmessage = \'不及格\'\n            }\n            return showmessage\n          },\n        },\n        methods: {},\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 账号切换案例 & virtual dom 复用\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <span v-if="isuser">\n        <label for="username">用户账号</label>\n        <input\n          type="text"\n          id="username"\n          placeholder="用户账号"\n          key="username"\n        />\n      </span>\n      <span v-else>\n        <label for="username">用户邮箱</label>\n        <input type="email" id="email" placeholder="用户邮箱" key="email" />\n      </span>\n      <button @click="isuser = !isuser">切换</button>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          isuser: true,\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n小问题：\n\n * 在有输入内容情况下，切换类型，会发现内容依然存在，没有被清空\n * 按理说已经切换到另一个 input 元素中了，且另一个元素没有输入内容\n\n解答：\n\n * 因为 vue 的 virtual dom 在进行渲染时，出于性能考虑，会尽可能复用已存在的元素，而不是重新创建新的元素\n * 在上面的案例中，vue 发现原来的 input 元素不再使用，直接作为 else 中的 input 来使用了\n\n解决：\n\n * 若不希望出现 vue 重复利用问题，可以给对应的 input 元素添加不同的 key\n * 但是有的时候又需要不清空，根据需要选择\n * 类似的 v-for 时要指定 key 也是该原因（但是是为了更好的复用）\n\n\n# v-if & v-show\n\n区别：\n\n * v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。它也是惰性的：如果在初始渲染时条件为假，则什么也不做（dom 中不存在）——直到条件第一次变为真时，才会开始渲染条件块。\n\n * v-show 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 css 进行切换，display: none。\n\n总结：一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。\n\n\n# v-for & key\n\n\n# v-for\n\n不推荐遍历对象，直接调用即可\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 便利对象，获取 value --\x3e\n      <ul>\n        <li v-for="value in info">{{value}}</li>\n      </ul>\n\n      \x3c!-- 便利对象，获取 (value,key) --\x3e\n      <ul>\n        <li v-for="(value,key) in info">{{value}}-{{key}}</li>\n      </ul>\n\n      \x3c!-- 便利对象，获取 (value,key,index) --\x3e\n      <ul>\n        <li v-for="(value,key,index) in info">{{value}}-{{key}}-{{index}}</li>\n      </ul>\n\n      \x3c!-- 便利数组，获取 value --\x3e\n      <ul>\n        <li v-for="item in infolist">\n          {{item.name}}-{{item.age}}-{{item.sex}}\n        </li>\n      </ul>\n\n      \x3c!-- 便利数组，获取  (value,index)  --\x3e\n      <ul>\n        <li v-for="(item,index) in infolist">\n          {{item.name}}-{{item.age}}-{{item.sex}}-{{index}}\n        </li>\n      </ul>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          message: \'hello\',\n          info: {\n            name: \'conanan\',\n            age: 18,\n            sex: \'male\',\n          },\n          infolist: [\n            {\n              name: \'conanan\',\n              age: 18,\n              sex: \'male\',\n            },\n            {\n              name: \'zhangsan\',\n              age: 33,\n              sex: \'male\',\n            },\n            {\n              name: \'lisi\',\n              age: 44,\n              sex: \'female\',\n            },\n          ],\n        },\n        methods: {},\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# key\n\n建议尽可能在使用 v-for 时提供 key attribute（无论是元素还是组件），除非遍历输出的 dom 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。它是 vue 识别节点的一个通用机制，并不仅与 v-for 特别关联。\n\n这和 vue 的 virtual dom 的 diff 算法有关\n\n当 vue 正在更新使用 v-for 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，vue 将不会移动 dom 元素来匹配数据项的顺序，而是就地更新每个元素，并且确保它们在每个索引位置正确渲染。这个默认的模式是高效的，但是只适用于不依赖子组件状态或临时 dom 状态 (例如：表单输入值) 的列表渲染输出。为了给 vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key attribute。\n\n看如下例子：\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <ul>\n        <li v-for="(item,index) in array">{{item}}：<input type="text" /></li>\n      </ul>\n      <ul>\n        <li v-for="(item,index) in array" :key="item">\n          {{item}}：<input type="text" />\n        </li>\n      </ul>\n      <button @click="add">在1和2间添加</button>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          message: \'hello\',\n          array: [1, 2, 3],\n        },\n        methods: {\n          add() {\n            this.array.splice(1, 0, 9)\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\ninput 中填入值\n\n点击按钮后结果如图：\n\n显而易见，上面的没有使用 key，它就地更新，重用了组件。下面的使用了 key，不会重用组件，添加正确。具体再总结吧！\n\n\n# 数组中哪些方法是响应式的？\n\nvue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：\n\n * push()\n * pop()\n * shift()\n * unshift()\n * splice()\n * sort()\n * reverse()\n\n注意：直接修改数组中某个值，不是响应式的！\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <ul>\n        <li v-for="item in letters">{{item}}</li>\n      </ul>\n      <button @click="arraymethod">btn</button>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          letters: [\'a\', \'b\', \'c\', \'d\'],\n        },\n        methods: {\n          arraymethod() {\n            // push 向末尾添加\n            // this.letters.push("e");\n            // this.letters.push("e"，"f","g");\n            // pop 从末尾删除\n            // this.letters.pop();\n            // shift 从首部删除\n            // this.letters.shift();\n            // unshift 向首部添加\n            // this.letters.unshift("-a");\n            // this.letters.unshift("-c", "-b", "-a"); // [\'-c\',\'-b\',\'-a\',\'a\',\'b\',\'c\']\n            // splice 删除并添加一个值，修改一个值时使用。增删改都可以完成\n            this.letters.splice(1, 1, \'bbb\')\n            // reverse 反转\n            // this.letters.reverse();\n            // sort 排序\n            // this.letters.sort();\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n\n# 购物车案例\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>vue</title>\n    <style>\n      table {\n        /* 合并细线边框 */\n        border-collapse: collapse;\n        /* 单元格之间水平、垂直距离，与 border-collapse 冲突，不常用 */\n        /*border-spacing: 10px 20px;*/\n        /* 表格居中 */\n        margin: 100px auto;\n      }\n      th,\n      td {\n        /* 边框 */\n        border: 1px solid skyblue;\n        /* 内边距 */\n        padding: 20px;\n        /* 让td居中，th本来就是居中的 */\n        text-align: center;\n        /* 默认情况下元素在th,td中是垂直居中的，也可以通过 vertical-align 来修改*/\n        /* 由此可得，对一个父元素设置 display: table-cell，可以直接使用 vertical-align 来垂直居中*/\n      }\n    </style>\n  </head>\n\n  <body>\n    <div id="app">\n      <div v-if="books.length >= 1">\n        <table>\n          <thead>\n            <tr>\n              <th></th>\n              <th>书籍名称</th>\n              <th>出版日期</th>\n              <th>价格</th>\n              <th>购买数量</th>\n              <th>操作</th>\n            </tr>\n          </thead>\n          <tbody>\n            <tr v-for="(book,index) in books" :key="book.id">\n              <td>{{book.id}}</td>\n              <td>{{book.name}}</td>\n              <td>{{book.time}}</td>\n              \x3c!-- <td>{{\'¥\'+book.price.tofixed(2)}}</td> --\x3e\n              \x3c!-- 这么多地方使用，可以复用 --\x3e\n              \x3c!-- 方式1:方法。计算属性也可以 --\x3e\n              \x3c!-- <td>{{formartprice(book.price)}}</td> --\x3e\n              \x3c!-- 方式2:过滤器 --\x3e\n              <td>{{book.price | formartprice}}</td>\n\n              <td>\n                <button @click="decrement(book)" :disabled="book.count === 1">\n                  -\n                </button>\n                {{book.count}}\n                <button @click="increment(book)">+</button>\n              </td>\n              <td><button @click="remove(index)">移除</button></td>\n            </tr>\n          </tbody>\n        </table>\n        \x3c!-- 总价：{{\'¥\'+totalprice.tofixed(2)}} --\x3e\n        \x3c!-- 总价：{{formartprice(totalprice)}} --\x3e\n        总价：{{totalprice | formartprice}}\n      </div>\n      <div v-else>\n        购物车为空\n      </div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // vue.js文件中定义了 vue 对象，使用时可以 new 构造出，并且它还有参数（对象类型）\n      const vm = new vue({\n        el: \'#app\',\n        // 声明式编程（声明式渲染），不再使用命令式\n        data: {\n          books: [\n            { id: 1, name: \'java\', time: \'2006-02\', price: 110.0, count: 1 },\n            { id: 2, name: \'kotlin\', time: \'2016-03\', price: 120.0, count: 1 },\n            { id: 3, name: \'clojure\', time: \'2008-12\', price: 112.0, count: 1 },\n            { id: 4, name: \'jvm\', time: \'2002-8\', price: 200.0, count: 1 },\n          ],\n        },\n        methods: {\n          increment(book) {\n            book.count++\n          },\n          decrement(book) {\n            // if (book.count === 1) {\n            //   return;\n            // }\n            book.count--\n          },\n          remove(index) {\n            this.books.splice(index, 1)\n          },\n          formartprice(price) {\n            return \'¥\' + price.tofixed(2)\n          },\n        },\n        computed: {\n          totalprice() {\n            // let totalprice = 0;\n            // this.books.foreach((item) => {\n            //   totalprice += item.price * item.count;\n            // });\n            // return totalprice;\n\n            return this.books.reduce((previous, current, index, arr) => {\n              return previous + current.price * current.count\n            }, 0)\n          },\n        },\n        filters: {\n          formartprice(price) {\n            return \'¥\' + price.tofixed(2)\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"表单双向绑定",frontmatter:{title:"表单双向绑定",date:"2020-12-27T00:30:47.000Z",permalink:"/pages/6780f9/",categories:["Vue","基础"],tags:[null]},regularPath:"/1402.Vue2.x/100.%E5%9F%BA%E7%A1%80/107.%E8%A1%A8%E5%8D%95%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.html",relativePath:"1402.Vue2.x/100.基础/107.表单双向绑定.md",key:"v-57d26e26",path:"/pages/6780f9/",headers:[{level:2,title:"input",slug:"input",normalizedTitle:"input",charIndex:21},{level:2,title:"radio",slug:"radio",normalizedTitle:"radio",charIndex:1679},{level:2,title:"单个 & 多个 checkbox & 实际开发",slug:"单个-多个-checkbox-实际开发",normalizedTitle:"单个 &amp; 多个 checkbox &amp; 实际开发",charIndex:null},{level:2,title:"单选 & 多选 select",slug:"单选-多选-select",normalizedTitle:"单选 &amp; 多选 select",charIndex:null},{level:2,title:"修饰符",slug:"修饰符",normalizedTitle:"修饰符",charIndex:5440},{level:3,title:".lazy",slug:"lazy",normalizedTitle:".lazy",charIndex:5448},{level:3,title:".number",slug:"number",normalizedTitle:".number",charIndex:5565},{level:3,title:".trim",slug:"trim",normalizedTitle:".trim",charIndex:5707}],headersStr:"input radio 单个 & 多个 checkbox & 实际开发 单选 & 多选 select 修饰符 .lazy .number .trim",content:'# 表单双向绑定—v-model\n\n\n# input\n\n可用于<input>,<select>, 或 <textarea> 元素！\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app"><input type="text" v-model="message" />{{message}}</div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意：当一个 <input>,<select>, 或 <textarea> 元素的 value 被修改时，会触发 input 事件。\n\n每当元素的 value 改变，input 事件都会被触发。这与 change 事件不同。change 事件仅当 value 被提交时触发，如按回车键，从一个 options 列表中选择一个值等。\n\nV-model 可以用如下实现\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <input type="text" v-model="message" />\n      <h2>{{message}}</h2>\n      <input type="text" :value="message" @input="valueChange" />\n      <input\n        type="text"\n        :value="message"\n        @input="message = $event.target.value"\n      />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        methods: {\n          valueChange(event) {\n            this.message = event.target.value;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# radio\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <label for="male">男</label>\n      <input type="radio" name="sex" id="male" value="男" v-model="sex" />\n      <label for="female">女</label>\n      <input type="radio" name="sex" id="female" value="女" v-model="sex" />\n      \x3c!-- 此时name可以省略 --\x3e\n      <br />\n      <h2>性别：{{sex}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n          sex: "女",\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 单个 & 多个 checkbox & 实际开发\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 单个 --\x3e\n      <label for="agree">同意协议</label>\n      <input type="checkbox" name="agree" id="agree" v-model="agree" />\n      \x3c!-- name 可以省略 --\x3e\n      <button :disabled="!agree">下一步</button>\n      <br />\n      <h2>{{agree}}</h2>\n\n      <hr />\n\n      \x3c!-- 多个 --\x3e\n      <input\n        type="checkbox"\n        name="hobby"\n        id="hobby"\n        v-model="hobby"\n        value="唱"\n      />唱\n      <input\n        type="checkbox"\n        name="hobby"\n        id="hobby"\n        v-model="hobby"\n        value="跳"\n      />跳\n      <input\n        type="checkbox"\n        name="hobby"\n        id="hobby"\n        v-model="hobby"\n        value="篮球"\n      />篮球\n      \x3c!-- name 可以省略 --\x3e\n      <br />\n      <h2>{{hobby}}</h2>\n      <hr />\n\n      \x3c!-- 真实开发 --\x3e\n      <label v-for="(item,index) in originHobbies" :for="item">\n        <input\n          type="checkbox"\n          :id="item"\n          name="selectedHobbies"\n          :value="item"\n          v-model="selectedHobbies"\n        />{{item}}\n      </label>\n      <h2>{{selectedHobbies}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          agree: false,\n          hobby: [],\n          // 真实开发\n          originHobbies: ["唱", "跳", "篮球", "rap"],\n          selectedHobbies: [],\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 单选 & 多选 select\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <select name="hobby" id="hobby" v-model="hobby">\n        <option value="唱">唱</option>\n        <option value="跳">跳</option>\n        <option value="篮球">篮球</option>\n      </select>\n      <h2>{{hobby}}</h2>\n      <hr />\n\n      <select name="hobbies" id="hobbies" v-model="hobbies" multiple>\n        <option value="唱">唱</option>\n        <option value="跳">跳</option>\n        <option value="篮球">篮球</option>\n        <option value="rap">rap</option>\n      </select>\n      <h2>{{hobbies}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          hobby: "篮球",\n          hobbies: [],\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 修饰符\n\n\n# .lazy\n\n在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件之后进行同步，如失去焦点或回车后\n\n\n# .number\n\n如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符。这通常很有用，因为即使在 type="number" 时，HTML 输入元素的值也总会返回字符串。如果这个值无法被 parseFloat() 解析，则会返回原始的值。\n\n\n# .trim\n\n如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <input type="text" v-model.lazy="username" />{{username}}\n      <hr />\n      <input type="number" v-model.number="age" />{{age}} {{typeof age}}\n      <hr />\n      <input type="text" v-model.trim="name" />{{name}}\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          username: "Hello",\n          age: 0,\n          name: "",\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',normalizedContent:'# 表单双向绑定—v-model\n\n\n# input\n\n可用于<input>,<select>, 或 <textarea> 元素！\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app"><input type="text" v-model="message" />{{message}}</div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n注意：当一个 <input>,<select>, 或 <textarea> 元素的 value 被修改时，会触发 input 事件。\n\n每当元素的 value 改变，input 事件都会被触发。这与 change 事件不同。change 事件仅当 value 被提交时触发，如按回车键，从一个 options 列表中选择一个值等。\n\nv-model 可以用如下实现\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <input type="text" v-model="message" />\n      <h2>{{message}}</h2>\n      <input type="text" :value="message" @input="valuechange" />\n      <input\n        type="text"\n        :value="message"\n        @input="message = $event.target.value"\n      />\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        methods: {\n          valuechange(event) {\n            this.message = event.target.value;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# radio\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <label for="male">男</label>\n      <input type="radio" name="sex" id="male" value="男" v-model="sex" />\n      <label for="female">女</label>\n      <input type="radio" name="sex" id="female" value="女" v-model="sex" />\n      \x3c!-- 此时name可以省略 --\x3e\n      <br />\n      <h2>性别：{{sex}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n          sex: "女",\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 单个 & 多个 checkbox & 实际开发\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 单个 --\x3e\n      <label for="agree">同意协议</label>\n      <input type="checkbox" name="agree" id="agree" v-model="agree" />\n      \x3c!-- name 可以省略 --\x3e\n      <button :disabled="!agree">下一步</button>\n      <br />\n      <h2>{{agree}}</h2>\n\n      <hr />\n\n      \x3c!-- 多个 --\x3e\n      <input\n        type="checkbox"\n        name="hobby"\n        id="hobby"\n        v-model="hobby"\n        value="唱"\n      />唱\n      <input\n        type="checkbox"\n        name="hobby"\n        id="hobby"\n        v-model="hobby"\n        value="跳"\n      />跳\n      <input\n        type="checkbox"\n        name="hobby"\n        id="hobby"\n        v-model="hobby"\n        value="篮球"\n      />篮球\n      \x3c!-- name 可以省略 --\x3e\n      <br />\n      <h2>{{hobby}}</h2>\n      <hr />\n\n      \x3c!-- 真实开发 --\x3e\n      <label v-for="(item,index) in originhobbies" :for="item">\n        <input\n          type="checkbox"\n          :id="item"\n          name="selectedhobbies"\n          :value="item"\n          v-model="selectedhobbies"\n        />{{item}}\n      </label>\n      <h2>{{selectedhobbies}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          agree: false,\n          hobby: [],\n          // 真实开发\n          originhobbies: ["唱", "跳", "篮球", "rap"],\n          selectedhobbies: [],\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n\n\n\n# 单选 & 多选 select\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <select name="hobby" id="hobby" v-model="hobby">\n        <option value="唱">唱</option>\n        <option value="跳">跳</option>\n        <option value="篮球">篮球</option>\n      </select>\n      <h2>{{hobby}}</h2>\n      <hr />\n\n      <select name="hobbies" id="hobbies" v-model="hobbies" multiple>\n        <option value="唱">唱</option>\n        <option value="跳">跳</option>\n        <option value="篮球">篮球</option>\n        <option value="rap">rap</option>\n      </select>\n      <h2>{{hobbies}}</h2>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          hobby: "篮球",\n          hobbies: [],\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 修饰符\n\n\n# .lazy\n\n在默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步 (除了上述输入法组合文字时)。你可以添加 lazy 修饰符，从而转为在 change 事件之后进行同步，如失去焦点或回车后\n\n\n# .number\n\n如果想自动将用户的输入值转为数值类型，可以给 v-model 添加 number 修饰符。这通常很有用，因为即使在 type="number" 时，html 输入元素的值也总会返回字符串。如果这个值无法被 parsefloat() 解析，则会返回原始的值。\n\n\n# .trim\n\n如果要自动过滤用户输入的首尾空白字符，可以给 v-model 添加 trim 修饰符\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <input type="text" v-model.lazy="username" />{{username}}\n      <hr />\n      <input type="number" v-model.number="age" />{{age}} {{typeof age}}\n      <hr />\n      <input type="text" v-model.trim="name" />{{name}}\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          username: "hello",\n          age: 0,\n          name: "",\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"组件化开发",frontmatter:{title:"组件化开发",date:"2020-12-27T00:30:57.000Z",permalink:"/pages/15ab90/",categories:["Vue","组件"],tags:[null]},regularPath:"/1402.Vue2.x/200.%E7%BB%84%E4%BB%B6/201.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html",relativePath:"1402.Vue2.x/200.组件/201.组件化开发.md",key:"v-872bc0d8",path:"/pages/15ab90/",headers:[{level:2,title:"使用步骤",slug:"使用步骤",normalizedTitle:"使用步骤",charIndex:23},{level:2,title:"全局组件",slug:"全局组件",normalizedTitle:"全局组件",charIndex:1162},{level:2,title:"局部组件 🔥",slug:"局部组件-🔥",normalizedTitle:"局部组件 🔥",charIndex:2815},{level:2,title:"父组件 & 子组件",slug:"父组件-子组件",normalizedTitle:"父组件 &amp; 子组件",charIndex:null},{level:2,title:"组件名称大小写 🔥",slug:"组件名称大小写-🔥",normalizedTitle:"组件名称大小写 🔥",charIndex:5856},{level:3,title:"使用 kebab-case",slug:"使用-kebab-case",normalizedTitle:"使用 kebab-case",charIndex:5885},{level:3,title:"使用 PascalCase 🔥",slug:"使用-pascalcase-🔥",normalizedTitle:"使用 pascalcase 🔥",charIndex:6029},{level:2,title:"组件组册语法糖 🔥",slug:"组件组册语法糖-🔥",normalizedTitle:"组件组册语法糖 🔥",charIndex:6212},{level:2,title:"组件模板分离 🔥",slug:"组件模板分离-🔥",normalizedTitle:"组件模板分离 🔥",charIndex:7417},{level:2,title:"组件的数据 data 🔥",slug:"组件的数据-data-🔥",normalizedTitle:"组件的数据 data 🔥",charIndex:9009},{level:2,title:"父子组件的通信 props & $emit 🔥",slug:"父子组件的通信-props-emit-🔥",normalizedTitle:"父子组件的通信 props &amp; $emit 🔥",charIndex:null},{level:3,title:"父传子—props",slug:"父传子-props",normalizedTitle:"父传子—props",charIndex:11031},{level:3,title:"子传父—$emit 发出自定义事件",slug:"子传父-emit-发出自定义事件",normalizedTitle:"子传父—$emit 发出自定义事件",charIndex:14528},{level:2,title:"单向数据流 🔥",slug:"单向数据流-🔥",normalizedTitle:"单向数据流 🔥",charIndex:16232},{level:3,title:"v-bind & @input 实现",slug:"v-bind-input-实现",normalizedTitle:"v-bind &amp; @input 实现",charIndex:null},{level:3,title:"watch 实现",slug:"watch-实现",normalizedTitle:"watch 实现",charIndex:19994},{level:2,title:"父子组件的访问—$refs 🔥",slug:"父子组件的访问-refs-🔥",normalizedTitle:"父子组件的访问—$refs 🔥",charIndex:22898},{level:3,title:"父访问子—$children & $refs 🔥",slug:"父访问子-children-refs-🔥",normalizedTitle:"父访问子—$children &amp; $refs 🔥",charIndex:null},{level:3,title:"子访问父—$parent & $root",slug:"子访问父-parent-root",normalizedTitle:"子访问父—$parent &amp; $root",charIndex:null}],headersStr:"使用步骤 全局组件 局部组件 🔥 父组件 & 子组件 组件名称大小写 🔥 使用 kebab-case 使用 PascalCase 🔥 组件组册语法糖 🔥 组件模板分离 🔥 组件的数据 data 🔥 父子组件的通信 props & $emit 🔥 父传子—props 子传父—$emit 发出自定义事件 单向数据流 🔥 v-bind & @input 实现 watch 实现 父子组件的访问—$refs 🔥 父访问子—$children & $refs 🔥 子访问父—$parent & $root",content:'# 组件化开发\n\n就是为了封装&复用\n\n\n# 使用步骤\n\n 1. 创建组件构造器\n 2. 注册组件\n 3. 使用组件\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      <my-component></my-component>\n      <my-component></my-component>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 1 创建组件构造器。含义如下：\n      // 调用Vue.extend()创建的是一个组件构造器\n      // 通常在创建组件构造器时，传入template代表我们自定义的模板，该模板就是在使用到组件的地方，要显示的HTML代码\n      // 事实上，该写法在 Vue2.x的文档中几乎已经看不到了，它会直接使用下面要讲到的语法糖\n      const myComponent = Vue.extend({\n        template: `\n            <div>\n                <h2>标题</h2>\n                <p>内容1</p>\n                <p>内容2</p>\n            </div>`,\n      });\n\n      // 2 注册组件\n      Vue.component("my-component", myComponent);\n\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 全局组件\n\n调用 Vue.component() 注册的为全局组件\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 Vue 实例下，否则不生效 --\x3e\n      <my-component></my-component>\n      <div><my-component></my-component></div>\n    </div>\n    \x3c!-- 不生效 --\x3e\n    <my-component></my-component>\n\n    <div id="app2">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 Vue 实例下，否则不生效 --\x3e\n      <my-component></my-component>\n      <div><my-component></my-component></div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 1 创建组件构造器。含义如下：\n      // 调用Vue.extend()创建的是一个组件构造器\n      // 通常在创建组件构造器时，传入template代表我们自定义的模板，该模板就是在使用到组件的地方，要显示的HTML代码\n      // 事实上，该写法在 Vue2.x的文档中几乎已经看不到了，它会直接使用下面要讲到的语法糖\n      const myComponent = Vue.extend({\n        template: `\n            <div>\n                <h2>标题</h2>\n                <p>内容1</p>\n                <p>内容2</p>\n            </div>`,\n      });\n\n      // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 Vue 实例下使用）\n      // 调用 Vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n      Vue.component("my-component", myComponent);\n\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n      });\n\n      const vm2 = new Vue({\n        el: "#app2",\n        data: {\n          message: "Hello",\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 局部组件 🔥\n\n开发中一般还是更多使用局部组件\n\n注册在某一 Vue 实例中的组件为局部组件\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 Vue 实例下，否则不生效 --\x3e\n      <comp></comp>\n      <div><comp></comp></div>\n    </div>\n    \x3c!-- 不生效 --\x3e\n    <comp></comp>\n\n    <div id="app2">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 Vue 实例下，否则不生效 --\x3e\n      <comp></comp>\n      <div><comp></comp></div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 1 创建组件构造器。含义如下：\n      // 调用Vue.extend()创建的是一个组件构造器\n      // 通常在创建组件构造器时，传入template代表我们自定义的模板，该模板就是在使用到组件的地方，要显示的HTML代码\n      // 事实上，该写法在 Vue2.x的文档中几乎已经看不到了，它会直接使用下面要讲到的语法糖\n      const myComponent = Vue.extend({\n        template: `\n            <div>\n                <h2>标题</h2>\n                <p>内容1</p>\n                <p>内容2</p>\n            </div>`,\n      });\n\n      // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 Vue 实例下使用）\n      // 调用 Vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n      //   Vue.component("my-component", myComponent);\n\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        components: {\n          comp: myComponent,\n        },\n      });\n\n      const vm2 = new Vue({\n        el: "#app2",\n        data: {\n          message: "Hello",\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 父组件 & 子组件\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 Vue 实例下，否则不生效 --\x3e\n      <my-component2></my-component2>\n\n      \x3c!-- my-component1并没有在 app 的 Vue 实例中注册，无法使用 --\x3e\n      <my-component1></my-component1>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 创建组件构造器1（子组件）\n      const myComponent1 = Vue.extend({\n        template: `\n            <div>\n                <h2>标题1</h2>\n                <p>内容1</p>\n            </div>`,\n      });\n\n      // 创建组件构造器2（父组件）\n      const myComponent2 = Vue.extend({\n        template: `\n            <div>\n                <h2>标题2</h2>\n                <p>内容2</p>\n                <my-component1></my-component1>\n            </div>`,\n        components: {\n          "my-component1": myComponent1,\n        },\n      });\n\n      // root 组件\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        components: {\n          "my-component2": myComponent2,\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 组件名称大小写 🔥\n\n定义组件名的方式有两种：\n\n\n# 使用 kebab-case\n\nVue.component(\'my-component-name\', { /* ... */ })\n\n\n1\n\n\n当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 ``。\n\n\n# 使用 PascalCase 🔥\n\nVue.component(\'MyComponentName\', { /* ... */ })\n\n\n1\n\n\n当使用 PascalCase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。\n\n\n# 组件组册语法糖 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 Vue 实例下，否则不生效 --\x3e\n      <my-component1></my-component1>\n      <div><my-component2></my-component2></div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 Vue 实例下使用）。底层还是调用Vue.extend()\n      // 调用 Vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n      Vue.component("my-component1", {\n        template: `\n            <div>\n                <h2>标题1</h2>\n                <p>内容1</p>\n            </div>`,\n      });\n\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        components: {\n          "my-component2": {\n            template: `\n            <div>\n                <h2>标题2</h2>\n                <p>内容2</p>\n            </div>`,\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 组件模板分离 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 Vue 实例下，否则不生效 --\x3e\n      <my-component1></my-component1>\n\n      <div><my-component2></my-component2></div>\n    </div>\n\n    \x3c!-- 方式1:script标签，type="text/x-template" --\x3e\n    <script type="text/x-template" id="myComponent1">\n      <div>\n          <h2>标题1</h2>\n          <p>内容1</p>\n      </div>\n    <\/script>\n\n    \x3c!-- 方式2:template标签。推荐--\x3e\n\n    <template id="myComponent2">\n      <div>\n        <h2>标题2</h2>\n        <p>内容2</p>\n      </div>\n    </template>\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 Vue 实例下使用）。底层还是调用Vue.extend()\n      // 调用 Vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n      Vue.component("my-component1", {\n        template: "#myComponent1",\n      });\n\n      const MyComponent2 = {\n        template: "#myComponent2",\n      };\n\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        // components: {\n        //   myComponent2: myComponent2,\n        // },\n        // 对象增强写法，使用时，可以使用<my-omponent2>或<MyComponent2>。注意两种命名方式使用标签时的区别\n        components: {\n          MyComponent2,\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 组件的数据 data 🔥\n\ndata 必须是一个返回组件中定义的实例对象的 function。\n\n因为组件是用来复用的，若data是一个对象，则多个组件间对data会进行数据共享！使用 function 后每个组件都有其自己的数据，互不干扰。\n\n<!DOCTYPE html>\n<html lang="en">\n <head>\n   <meta charset="UTF-8" />\n   <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n   <title>Title</title>\n </head>\n\n <body>\n   <div id="app">\n     \x3c!-- 3 使用组件 --\x3e\n     \x3c!-- 组件必须挂载在某个 Vue 实例下，否则不生效 --\x3e\n     <my-component1></my-component1>\n\n     <div><my-component2></my-component2></div>\n   </div>\n\n   \x3c!-- 方式1:script标签，type="text/x-template" --\x3e\n   <script type="text/x-template" id="myComponent1">\n     <div>\n         <h2>{{title}}</h2>\n         <p>{{content}}</p>\n     </div>\n   <\/script>\n\n   \x3c!-- 方式2:template标签 --\x3e\n\n   <template id="myComponent2">\n     <div>\n       <h2>{{title}}</h2>\n       <p>{{content}}</p>\n     </div>\n   </template>\n   <script src="/lib/vue.js"><\/script>\n   <script>\n     // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 Vue 实例下使用）。底层还是调用Vue.extend()\n     // 调用 Vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n     Vue.component("my-component1", {\n       template: "#myComponent1",\n       data() {\n         return {\n           title: "标题111",\n           content: "内容111",\n         };\n       },\n     });\n\n     const myComponent2 = {\n       template: "#myComponent2",\n       data() {\n         return {\n           title: "标题222",\n           content: "内容222",\n         };\n       },\n     };\n\n     const vm = new Vue({\n       el: "#app",\n       data: {\n         message: "Hello",\n       },\n       components: {\n         "my-component2": myComponent2,\n       },\n     });\n   <\/script>\n </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 父子组件的通信 props & $emit 🔥\n\nprops 为 properties 缩写\n\n场景1：父传子？比如请求后端获取的轮播图url数组，如何传递到轮播图子组件？等等。。。\n\n场景2：子传父？比如一个页面有多个自组件构成，点击一个自组件后，父组件需要切换另一个自组件的数据，如何发事件通知？\n\n如何进行父子组件的通信？\n\n * 方式1：通过 props 向子组件传递数据\n * 方式2：通过自定义事件 $emit 向父组件发送消息\n\n\n# 父传子—props\n\nprops 的值有两种方式：\n\n * 字符串数组：数组中的字符串就是传递时的名称\n * 对象：对象可以设置传递时的类型（有类型限制），默认值等。推荐\n   * type 可以是下列原生构造函数中的一个：\n     * String\n     * Number\n     * Boolean\n     * Array\n     * Object\n     * Date\n     * Function\n     * Symbol\n   * type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认\n   * 注意驼峰命名时v-bind的名称问题，推荐使用驼峰！\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component\n        v-bind:c-message="message"\n        :cmovies="movies"\n        :author="author"\n        :student="student"\n      ></my-component>\n      <hr />\n      <my-component></my-component>\n    </div>\n\n    <template id="myComponent">\n      \x3c!-- template中只能包含一个root元素 --\x3e\n      <div>\n        <div>{{cMessage}}</div>\n        <ul>\n          <li v-for="movie in cmovies">{{movie}}</li>\n        </ul>\n        <div>{{author}}</div>\n        <div>{{student}}</div>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      class Person {\n        constructor(firstName, lastName) {\n          this.firstName = firstName;\n          this.lastName = lastName;\n        }\n      }\n\n      function Person2(firstName, lastName) {\n        this.firstName = firstName;\n        this.lastName = lastName;\n      }\n\n      // 大驼峰是为了方便注册组件时使用ES6对象语法\n      const MyComponent = {\n        template: "#myComponent",\n        data() {\n          return {};\n        },\n        // 1 字符串数组，不常用\n        // props: ["cmessage", "cmovies"],\n\n        // 2 对象，常用\n        // 2.1 类型限制\n        // props: {\n        //   cmessage: [String, Number], // 多个类型\n        //   cmovies: Array,\n        // },\n\n        // 2.2 带有默认值，必传值\n        props: {\n          // 驼峰命名时，v-bind处必须使用c-message来绑定，其他地方可以使用驼峰\n          cMessage: {\n            type: [String, Number], // 多个类型\n            default: "Hello MyComponent",\n            required: true, // 没有提供值会报错，但是还是会先显示默认值\n            // 自定义验证传入的值\n            validator(value) {\n              console.log(value);\n              // 传入的值必须为数组其中一个\n              return ["Hello", "World"].indexOf(value) > -1;\n            },\n          },\n          cmovies: {\n            type: Array,\n            // 新版本在 default 是 Object 或 Array 时，返回值必须是 function\n            default() {\n              return ["业火的向日葵", "漆黑的追踪者"];\n            },\n            required: true, // 没有提供值会报错，但是还是会先显示默认值\n          },\n          author: {\n            // 自定义类型\n            type: Person,\n          },\n          student: {\n            // 自定义类型\n            type: Person,\n          },\n        },\n      };\n\n      const author = new Person("san", "zhang");\n      const student = new Person2("si", "li");\n\n      // root 根组件\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n          movies: [\n            "引爆摩天楼",\n            "迷宫的十字路口",\n            "月光下的魔术师",\n            "沉默的十五分钟",\n          ],\n          author,\n          student,\n        },\n        methods: {},\n        components: {\n          MyComponent,\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n\n\n\n# 子传父—$emit 发出自定义事件\n\n * 在子组件中，通过$emit(\'自定义事件名\'[,params])发送事件，来触发子组件上绑定的自定义事件\n * 在父组件中，通过v-on来监听子组件的自定义事件，绑定到父组件的方法中\n * 注意驼峰命名问题\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component @category-click="categoryClick"></my-component>\n    </div>\n\n    <template id="myComponent">\n      \x3c!-- template中只能包含一个root元素 --\x3e\n      <div>\n        <button v-for="category in categories" @click="btnClick(category)">\n          {{category.name}}\n        </button>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 子组件\n      // 大驼峰是为了方便注册组件时使用ES6对象语法\n      const MyComponent = {\n        template: "#myComponent",\n        data() {\n          return {\n            categories: [\n              { id: 1, name: "热门推荐" },\n              { id: 2, name: "手机数码" },\n              { id: 3, name: "美妆护肤" },\n              { id: 4, name: "户外健身" },\n            ],\n          };\n        },\n        methods: {\n          btnClick(category) {\n            // 发出自定义事件，注意驼峰问题！！！\n            this.$emit("category-click", category);\n          },\n        },\n      };\n      // root 父组件\n      const vm = new Vue({\n        el: "#app",\n        components: {\n          MyComponent,\n        },\n        methods: {\n          categoryClick(category) {\n            console.log("category", category);\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 单向数据流 🔥\n\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。\n\n额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。\n\n\n# v-bind & @input 实现\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component\n        :num1="number1"\n        :num2="number2"\n        @change-number1="changeNumber1"\n        @change-number2="changeNumber2"\n      ></my-component>\n    </div>\n\n    <template id="myComponent">\n      <div>\n        props:{{num1}} <br />\n        data:{{dNum1}} <br />\n\n        props:<input type="text" v-model="num1" />不推荐直接修改<br />\n        data:<input\n          type="text"\n          v-model="dNum1"\n        />通过data修改，但没有影响父组件中的值<br />\n        props:\n        <input\n          type="text"\n          :value="dNum1"\n          @input="num1Input"\n        />通过$emit修改父组件中传递给子组件的值，来间接修改props值。修改\n        data，也可以直接绑定props的值<br />\n        <hr />\n\n        props:{{num2}} <br />\n        data:{{dNum2}} <br />\n        props:<input type="text" v-model="num2" />不推荐直接修改<br />\n        data:<input\n          type="text"\n          v-model="dNum2"\n        />通过data修改，但没有影响父组件中的值<br />\n        props:\n        <input\n          type="text"\n          :value="dNum2"\n          @input="num2Input"\n        />通过$emit修改父组件中传递给子组件的值，来间接修改props值。修改\n        data，也可以直接绑定props的值<br />\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data() {\n          return {\n            number1: 1,\n            number2: 2,\n          };\n        },\n        methods: {\n          changeNumber1(value) {\n            this.number1 = Number.parseInt(value);\n          },\n          changeNumber2(value) {\n            this.number2 = Number.parseInt(value);\n          },\n        },\n        components: {\n          MyComponent: {\n            template: "#myComponent",\n            data() {\n              return {\n                dNum1: this.num1,\n                dNum2: this.num2,\n              };\n            },\n            props: {\n              num1: {\n                type: Number,\n                default: 1,\n                required: true,\n              },\n              num2: {\n                type: Number,\n                default: 2,\n                required: true,\n              },\n            },\n            methods: {\n              num1Input(event) {\n                console.log(event.target.value);\n                this.$emit("change-number1", event.target.value);\n\n                // 注意，子组件中 data 数据不会随父组件更新了自组件的 props 后更改\n                this.dNum1 = event.target.value;\n              },\n              num2Input(event) {\n                console.log(event.target.value);\n                this.$emit("change-number2", event.target.value);\n\n                // 注意，子组件中 data 数据不会随父组件更新了自组件的 props 后更改\n                this.dNum2 = event.target.value;\n              },\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n\n每次直接修改 props 中数据控制台就会报错\n\n[Vue warn]: Avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. Instead, use a data or computed property based on the prop\'s value. Prop being mutated: "num1"\n\n\n1\n\n\n\n# watch 实现\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component\n        :num1="number1"\n        :num2="number2"\n        @change-number1="changeNumber1"\n        @change-number2="changeNumber2"\n      ></my-component>\n    </div>\n\n    <template id="myComponent">\n      <div>\n        props:{{num1}} <br />\n        data:{{dNum1}} <br />\n\n        props:<input type="text" v-model="num1" />不推荐直接修改<br />\n        data:<input\n          type="text"\n          v-model="dNum1"\n        />通过data修改，但没有影响父组件中的值<br />\n        props:\n        <input\n          type="text"\n          v-model="dNum1"\n        />通过$emit修改父组件中传递给子组件的值，来间接修改props值。修改\n        data，也可以直接绑定props的值<br />\n        <hr />\n\n        props:{{num2}} <br />\n        data:{{dNum2}} <br />\n        props:<input type="text" v-model="num2" />不推荐直接修改<br />\n        data:<input\n          type="text"\n          v-model="dNum2"\n        />通过data修改，但没有影响父组件中的值<br />\n        props:\n        <input\n          type="text"\n          v-model="dNum2"\n        />通过$emit修改父组件中传递给子组件的值，来间接修改props值。修改\n        data，也可以直接绑定props的值<br />\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data() {\n          return {\n            number1: 1,\n            number2: 2,\n          };\n        },\n        methods: {\n          changeNumber1(value) {\n            this.number1 = Number.parseInt(value);\n          },\n          changeNumber2(value) {\n            this.number2 = Number.parseInt(value);\n          },\n        },\n        components: {\n          MyComponent: {\n            template: "#myComponent",\n            data() {\n              return {\n                dNum1: this.num1,\n                dNum2: this.num2,\n              };\n            },\n            props: {\n              num1: {\n                type: Number,\n                default: 1,\n                required: true,\n              },\n              num2: {\n                type: Number,\n                default: 2,\n                required: true,\n              },\n            },\n            // watch只能监听data中数据\n            watch: {\n              dNum1(newValue, oldValue) {\n                this.$emit("change-number1", newValue);\n              },\n              dNum2(newValue) {\n                this.$emit("change-number2", newValue);\n              },\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n\n\n\n# 父子组件的访问—$refs 🔥\n\n基本上只有 $refs会使用很多，其他的基本不使用\n\n\n# 父访问子—$children & $refs 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component ref="a"></my-component>\n      <my-component></my-component>\n      <button @click="btnClick">父组件按钮</button>\n    </div>\n\n    <template id="myComponent">\n      <div>我是子组件</div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        methods: {\n          btnClick() {\n            // $children，是数组，使用很少\n            // console.log(this.$children);\n            // this.$children.forEach((child) => {\n            //   child.showMessage();\n            //   console.log(child.message);\n            // });\n            // $refs，是对象，默认为空，只有有ref属性的才会放入该对象中\n            console.log(this.$refs.a);\n            console.log(this.$refs["a"]);\n            this.$refs.a.showMessage();\n            console.log(this.$refs.a.message);\n          },\n        },\n        components: {\n          MyComponent: {\n            template: "#myComponent",\n            data() {\n              return {\n                message: "Hello",\n              };\n            },\n            methods: {\n              showMessage() {\n                console.log("showMessage");\n              },\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 子访问父—$parent & $root\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <outer-component ref="a"></outer-component>\n    </div>\n\n    <template id="outerComponent">\n      <div>\n        <inner-component></inner-component>\n      </div>\n    </template>\n\n    <template id="innerComponent">\n      <div>\n        <div>我是子组件</div>\n        <button @click="btnClick">子组件按钮</button>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello Vue",\n        },\n        components: {\n          OuterComponent: {\n            template: "#outerComponent",\n            data() {\n              return {\n                message: "Hello OuterComponent",\n              };\n            },\n            components: {\n              innerComponent: {\n                template: "#innerComponent",\n                methods: {\n                  btnClick() {\n                    // 打印出的为 VueComponent。基本不会使用\n                    console.log(this.$parent);\n                    console.log(this.$parent.message);\n\n                    // 打印出的为 Vue。基本不会使用，以后 Vue 实例中仅仅会放 Router 等，不会放数据，方法等\n                    console.log(this.$root);\n                    console.log(this.$root.message);\n                  },\n                },\n              },\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n',normalizedContent:'# 组件化开发\n\n就是为了封装&复用\n\n\n# 使用步骤\n\n 1. 创建组件构造器\n 2. 注册组件\n 3. 使用组件\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      <my-component></my-component>\n      <my-component></my-component>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 1 创建组件构造器。含义如下：\n      // 调用vue.extend()创建的是一个组件构造器\n      // 通常在创建组件构造器时，传入template代表我们自定义的模板，该模板就是在使用到组件的地方，要显示的html代码\n      // 事实上，该写法在 vue2.x的文档中几乎已经看不到了，它会直接使用下面要讲到的语法糖\n      const mycomponent = vue.extend({\n        template: `\n            <div>\n                <h2>标题</h2>\n                <p>内容1</p>\n                <p>内容2</p>\n            </div>`,\n      });\n\n      // 2 注册组件\n      vue.component("my-component", mycomponent);\n\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        methods: {},\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# 全局组件\n\n调用 vue.component() 注册的为全局组件\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 vue 实例下，否则不生效 --\x3e\n      <my-component></my-component>\n      <div><my-component></my-component></div>\n    </div>\n    \x3c!-- 不生效 --\x3e\n    <my-component></my-component>\n\n    <div id="app2">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 vue 实例下，否则不生效 --\x3e\n      <my-component></my-component>\n      <div><my-component></my-component></div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 1 创建组件构造器。含义如下：\n      // 调用vue.extend()创建的是一个组件构造器\n      // 通常在创建组件构造器时，传入template代表我们自定义的模板，该模板就是在使用到组件的地方，要显示的html代码\n      // 事实上，该写法在 vue2.x的文档中几乎已经看不到了，它会直接使用下面要讲到的语法糖\n      const mycomponent = vue.extend({\n        template: `\n            <div>\n                <h2>标题</h2>\n                <p>内容1</p>\n                <p>内容2</p>\n            </div>`,\n      });\n\n      // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 vue 实例下使用）\n      // 调用 vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n      vue.component("my-component", mycomponent);\n\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n      });\n\n      const vm2 = new vue({\n        el: "#app2",\n        data: {\n          message: "hello",\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 局部组件 🔥\n\n开发中一般还是更多使用局部组件\n\n注册在某一 vue 实例中的组件为局部组件\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 vue 实例下，否则不生效 --\x3e\n      <comp></comp>\n      <div><comp></comp></div>\n    </div>\n    \x3c!-- 不生效 --\x3e\n    <comp></comp>\n\n    <div id="app2">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 vue 实例下，否则不生效 --\x3e\n      <comp></comp>\n      <div><comp></comp></div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 1 创建组件构造器。含义如下：\n      // 调用vue.extend()创建的是一个组件构造器\n      // 通常在创建组件构造器时，传入template代表我们自定义的模板，该模板就是在使用到组件的地方，要显示的html代码\n      // 事实上，该写法在 vue2.x的文档中几乎已经看不到了，它会直接使用下面要讲到的语法糖\n      const mycomponent = vue.extend({\n        template: `\n            <div>\n                <h2>标题</h2>\n                <p>内容1</p>\n                <p>内容2</p>\n            </div>`,\n      });\n\n      // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 vue 实例下使用）\n      // 调用 vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n      //   vue.component("my-component", mycomponent);\n\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        components: {\n          comp: mycomponent,\n        },\n      });\n\n      const vm2 = new vue({\n        el: "#app2",\n        data: {\n          message: "hello",\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n\n\n\n# 父组件 & 子组件\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 vue 实例下，否则不生效 --\x3e\n      <my-component2></my-component2>\n\n      \x3c!-- my-component1并没有在 app 的 vue 实例中注册，无法使用 --\x3e\n      <my-component1></my-component1>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 创建组件构造器1（子组件）\n      const mycomponent1 = vue.extend({\n        template: `\n            <div>\n                <h2>标题1</h2>\n                <p>内容1</p>\n            </div>`,\n      });\n\n      // 创建组件构造器2（父组件）\n      const mycomponent2 = vue.extend({\n        template: `\n            <div>\n                <h2>标题2</h2>\n                <p>内容2</p>\n                <my-component1></my-component1>\n            </div>`,\n        components: {\n          "my-component1": mycomponent1,\n        },\n      });\n\n      // root 组件\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        components: {\n          "my-component2": mycomponent2,\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 组件名称大小写 🔥\n\n定义组件名的方式有两种：\n\n\n# 使用 kebab-case\n\nvue.component(\'my-component-name\', { /* ... */ })\n\n\n1\n\n\n当使用 kebab-case (短横线分隔命名) 定义一个组件时，你也必须在引用这个自定义元素时使用 kebab-case，例如 ``。\n\n\n# 使用 pascalcase 🔥\n\nvue.component(\'mycomponentname\', { /* ... */ })\n\n\n1\n\n\n当使用 pascalcase (首字母大写命名) 定义一个组件时，你在引用这个自定义元素时两种命名法都可以使用。注意，尽管如此，直接在 dom (即非字符串的模板) 中使用时只有 kebab-case 是有效的。\n\n\n# 组件组册语法糖 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 vue 实例下，否则不生效 --\x3e\n      <my-component1></my-component1>\n      <div><my-component2></my-component2></div>\n    </div>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 vue 实例下使用）。底层还是调用vue.extend()\n      // 调用 vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n      vue.component("my-component1", {\n        template: `\n            <div>\n                <h2>标题1</h2>\n                <p>内容1</p>\n            </div>`,\n      });\n\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        components: {\n          "my-component2": {\n            template: `\n            <div>\n                <h2>标题2</h2>\n                <p>内容2</p>\n            </div>`,\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 组件模板分离 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 3 使用组件 --\x3e\n      \x3c!-- 组件必须挂载在某个 vue 实例下，否则不生效 --\x3e\n      <my-component1></my-component1>\n\n      <div><my-component2></my-component2></div>\n    </div>\n\n    \x3c!-- 方式1:script标签，type="text/x-template" --\x3e\n    <script type="text/x-template" id="mycomponent1">\n      <div>\n          <h2>标题1</h2>\n          <p>内容1</p>\n      </div>\n    <\/script>\n\n    \x3c!-- 方式2:template标签。推荐--\x3e\n\n    <template id="mycomponent2">\n      <div>\n        <h2>标题2</h2>\n        <p>内容2</p>\n      </div>\n    </template>\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 vue 实例下使用）。底层还是调用vue.extend()\n      // 调用 vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n      vue.component("my-component1", {\n        template: "#mycomponent1",\n      });\n\n      const mycomponent2 = {\n        template: "#mycomponent2",\n      };\n\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        // components: {\n        //   mycomponent2: mycomponent2,\n        // },\n        // 对象增强写法，使用时，可以使用<my-omponent2>或<mycomponent2>。注意两种命名方式使用标签时的区别\n        components: {\n          mycomponent2,\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n\n\n\n# 组件的数据 data 🔥\n\ndata 必须是一个返回组件中定义的实例对象的 function。\n\n因为组件是用来复用的，若data是一个对象，则多个组件间对data会进行数据共享！使用 function 后每个组件都有其自己的数据，互不干扰。\n\n<!doctype html>\n<html lang="en">\n <head>\n   <meta charset="utf-8" />\n   <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n   <title>title</title>\n </head>\n\n <body>\n   <div id="app">\n     \x3c!-- 3 使用组件 --\x3e\n     \x3c!-- 组件必须挂载在某个 vue 实例下，否则不生效 --\x3e\n     <my-component1></my-component1>\n\n     <div><my-component2></my-component2></div>\n   </div>\n\n   \x3c!-- 方式1:script标签，type="text/x-template" --\x3e\n   <script type="text/x-template" id="mycomponent1">\n     <div>\n         <h2>{{title}}</h2>\n         <p>{{content}}</p>\n     </div>\n   <\/script>\n\n   \x3c!-- 方式2:template标签 --\x3e\n\n   <template id="mycomponent2">\n     <div>\n       <h2>{{title}}</h2>\n       <p>{{content}}</p>\n     </div>\n   </template>\n   <script src="/lib/vue.js"><\/script>\n   <script>\n     // 2 注册组件（该方式组册的为全局组件，意味着可以在多个 vue 实例下使用）。底层还是调用vue.extend()\n     // 调用 vue.component() 是将刚才的组件构造器注册为一个全局组件，并给它起一个组件的标签名称\n     vue.component("my-component1", {\n       template: "#mycomponent1",\n       data() {\n         return {\n           title: "标题111",\n           content: "内容111",\n         };\n       },\n     });\n\n     const mycomponent2 = {\n       template: "#mycomponent2",\n       data() {\n         return {\n           title: "标题222",\n           content: "内容222",\n         };\n       },\n     };\n\n     const vm = new vue({\n       el: "#app",\n       data: {\n         message: "hello",\n       },\n       components: {\n         "my-component2": mycomponent2,\n       },\n     });\n   <\/script>\n </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 父子组件的通信 props & $emit 🔥\n\nprops 为 properties 缩写\n\n场景1：父传子？比如请求后端获取的轮播图url数组，如何传递到轮播图子组件？等等。。。\n\n场景2：子传父？比如一个页面有多个自组件构成，点击一个自组件后，父组件需要切换另一个自组件的数据，如何发事件通知？\n\n如何进行父子组件的通信？\n\n * 方式1：通过 props 向子组件传递数据\n * 方式2：通过自定义事件 $emit 向父组件发送消息\n\n\n# 父传子—props\n\nprops 的值有两种方式：\n\n * 字符串数组：数组中的字符串就是传递时的名称\n * 对象：对象可以设置传递时的类型（有类型限制），默认值等。推荐\n   * type 可以是下列原生构造函数中的一个：\n     * string\n     * number\n     * boolean\n     * array\n     * object\n     * date\n     * function\n     * symbol\n   * type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认\n   * 注意驼峰命名时v-bind的名称问题，推荐使用驼峰！\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component\n        v-bind:c-message="message"\n        :cmovies="movies"\n        :author="author"\n        :student="student"\n      ></my-component>\n      <hr />\n      <my-component></my-component>\n    </div>\n\n    <template id="mycomponent">\n      \x3c!-- template中只能包含一个root元素 --\x3e\n      <div>\n        <div>{{cmessage}}</div>\n        <ul>\n          <li v-for="movie in cmovies">{{movie}}</li>\n        </ul>\n        <div>{{author}}</div>\n        <div>{{student}}</div>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      class person {\n        constructor(firstname, lastname) {\n          this.firstname = firstname;\n          this.lastname = lastname;\n        }\n      }\n\n      function person2(firstname, lastname) {\n        this.firstname = firstname;\n        this.lastname = lastname;\n      }\n\n      // 大驼峰是为了方便注册组件时使用es6对象语法\n      const mycomponent = {\n        template: "#mycomponent",\n        data() {\n          return {};\n        },\n        // 1 字符串数组，不常用\n        // props: ["cmessage", "cmovies"],\n\n        // 2 对象，常用\n        // 2.1 类型限制\n        // props: {\n        //   cmessage: [string, number], // 多个类型\n        //   cmovies: array,\n        // },\n\n        // 2.2 带有默认值，必传值\n        props: {\n          // 驼峰命名时，v-bind处必须使用c-message来绑定，其他地方可以使用驼峰\n          cmessage: {\n            type: [string, number], // 多个类型\n            default: "hello mycomponent",\n            required: true, // 没有提供值会报错，但是还是会先显示默认值\n            // 自定义验证传入的值\n            validator(value) {\n              console.log(value);\n              // 传入的值必须为数组其中一个\n              return ["hello", "world"].indexof(value) > -1;\n            },\n          },\n          cmovies: {\n            type: array,\n            // 新版本在 default 是 object 或 array 时，返回值必须是 function\n            default() {\n              return ["业火的向日葵", "漆黑的追踪者"];\n            },\n            required: true, // 没有提供值会报错，但是还是会先显示默认值\n          },\n          author: {\n            // 自定义类型\n            type: person,\n          },\n          student: {\n            // 自定义类型\n            type: person,\n          },\n        },\n      };\n\n      const author = new person("san", "zhang");\n      const student = new person2("si", "li");\n\n      // root 根组件\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n          movies: [\n            "引爆摩天楼",\n            "迷宫的十字路口",\n            "月光下的魔术师",\n            "沉默的十五分钟",\n          ],\n          author,\n          student,\n        },\n        methods: {},\n        components: {\n          mycomponent,\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n\n\n\n# 子传父—$emit 发出自定义事件\n\n * 在子组件中，通过$emit(\'自定义事件名\'[,params])发送事件，来触发子组件上绑定的自定义事件\n * 在父组件中，通过v-on来监听子组件的自定义事件，绑定到父组件的方法中\n * 注意驼峰命名问题\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component @category-click="categoryclick"></my-component>\n    </div>\n\n    <template id="mycomponent">\n      \x3c!-- template中只能包含一个root元素 --\x3e\n      <div>\n        <button v-for="category in categories" @click="btnclick(category)">\n          {{category.name}}\n        </button>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      // 子组件\n      // 大驼峰是为了方便注册组件时使用es6对象语法\n      const mycomponent = {\n        template: "#mycomponent",\n        data() {\n          return {\n            categories: [\n              { id: 1, name: "热门推荐" },\n              { id: 2, name: "手机数码" },\n              { id: 3, name: "美妆护肤" },\n              { id: 4, name: "户外健身" },\n            ],\n          };\n        },\n        methods: {\n          btnclick(category) {\n            // 发出自定义事件，注意驼峰问题！！！\n            this.$emit("category-click", category);\n          },\n        },\n      };\n      // root 父组件\n      const vm = new vue({\n        el: "#app",\n        components: {\n          mycomponent,\n        },\n        methods: {\n          categoryclick(category) {\n            console.log("category", category);\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 单向数据流 🔥\n\n所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外变更父级组件的状态，从而导致你的应用的数据流向难以理解。\n\n额外的，每次父级组件发生变更时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，vue 会在浏览器的控制台中发出警告。\n\n\n# v-bind & @input 实现\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component\n        :num1="number1"\n        :num2="number2"\n        @change-number1="changenumber1"\n        @change-number2="changenumber2"\n      ></my-component>\n    </div>\n\n    <template id="mycomponent">\n      <div>\n        props:{{num1}} <br />\n        data:{{dnum1}} <br />\n\n        props:<input type="text" v-model="num1" />不推荐直接修改<br />\n        data:<input\n          type="text"\n          v-model="dnum1"\n        />通过data修改，但没有影响父组件中的值<br />\n        props:\n        <input\n          type="text"\n          :value="dnum1"\n          @input="num1input"\n        />通过$emit修改父组件中传递给子组件的值，来间接修改props值。修改\n        data，也可以直接绑定props的值<br />\n        <hr />\n\n        props:{{num2}} <br />\n        data:{{dnum2}} <br />\n        props:<input type="text" v-model="num2" />不推荐直接修改<br />\n        data:<input\n          type="text"\n          v-model="dnum2"\n        />通过data修改，但没有影响父组件中的值<br />\n        props:\n        <input\n          type="text"\n          :value="dnum2"\n          @input="num2input"\n        />通过$emit修改父组件中传递给子组件的值，来间接修改props值。修改\n        data，也可以直接绑定props的值<br />\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data() {\n          return {\n            number1: 1,\n            number2: 2,\n          };\n        },\n        methods: {\n          changenumber1(value) {\n            this.number1 = number.parseint(value);\n          },\n          changenumber2(value) {\n            this.number2 = number.parseint(value);\n          },\n        },\n        components: {\n          mycomponent: {\n            template: "#mycomponent",\n            data() {\n              return {\n                dnum1: this.num1,\n                dnum2: this.num2,\n              };\n            },\n            props: {\n              num1: {\n                type: number,\n                default: 1,\n                required: true,\n              },\n              num2: {\n                type: number,\n                default: 2,\n                required: true,\n              },\n            },\n            methods: {\n              num1input(event) {\n                console.log(event.target.value);\n                this.$emit("change-number1", event.target.value);\n\n                // 注意，子组件中 data 数据不会随父组件更新了自组件的 props 后更改\n                this.dnum1 = event.target.value;\n              },\n              num2input(event) {\n                console.log(event.target.value);\n                this.$emit("change-number2", event.target.value);\n\n                // 注意，子组件中 data 数据不会随父组件更新了自组件的 props 后更改\n                this.dnum2 = event.target.value;\n              },\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n\n\n每次直接修改 props 中数据控制台就会报错\n\n[vue warn]: avoid mutating a prop directly since the value will be overwritten whenever the parent component re-renders. instead, use a data or computed property based on the prop\'s value. prop being mutated: "num1"\n\n\n1\n\n\n\n# watch 实现\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component\n        :num1="number1"\n        :num2="number2"\n        @change-number1="changenumber1"\n        @change-number2="changenumber2"\n      ></my-component>\n    </div>\n\n    <template id="mycomponent">\n      <div>\n        props:{{num1}} <br />\n        data:{{dnum1}} <br />\n\n        props:<input type="text" v-model="num1" />不推荐直接修改<br />\n        data:<input\n          type="text"\n          v-model="dnum1"\n        />通过data修改，但没有影响父组件中的值<br />\n        props:\n        <input\n          type="text"\n          v-model="dnum1"\n        />通过$emit修改父组件中传递给子组件的值，来间接修改props值。修改\n        data，也可以直接绑定props的值<br />\n        <hr />\n\n        props:{{num2}} <br />\n        data:{{dnum2}} <br />\n        props:<input type="text" v-model="num2" />不推荐直接修改<br />\n        data:<input\n          type="text"\n          v-model="dnum2"\n        />通过data修改，但没有影响父组件中的值<br />\n        props:\n        <input\n          type="text"\n          v-model="dnum2"\n        />通过$emit修改父组件中传递给子组件的值，来间接修改props值。修改\n        data，也可以直接绑定props的值<br />\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data() {\n          return {\n            number1: 1,\n            number2: 2,\n          };\n        },\n        methods: {\n          changenumber1(value) {\n            this.number1 = number.parseint(value);\n          },\n          changenumber2(value) {\n            this.number2 = number.parseint(value);\n          },\n        },\n        components: {\n          mycomponent: {\n            template: "#mycomponent",\n            data() {\n              return {\n                dnum1: this.num1,\n                dnum2: this.num2,\n              };\n            },\n            props: {\n              num1: {\n                type: number,\n                default: 1,\n                required: true,\n              },\n              num2: {\n                type: number,\n                default: 2,\n                required: true,\n              },\n            },\n            // watch只能监听data中数据\n            watch: {\n              dnum1(newvalue, oldvalue) {\n                this.$emit("change-number1", newvalue);\n              },\n              dnum2(newvalue) {\n                this.$emit("change-number2", newvalue);\n              },\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n\n\n\n# 父子组件的访问—$refs 🔥\n\n基本上只有 $refs会使用很多，其他的基本不使用\n\n\n# 父访问子—$children & $refs 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component ref="a"></my-component>\n      <my-component></my-component>\n      <button @click="btnclick">父组件按钮</button>\n    </div>\n\n    <template id="mycomponent">\n      <div>我是子组件</div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        methods: {\n          btnclick() {\n            // $children，是数组，使用很少\n            // console.log(this.$children);\n            // this.$children.foreach((child) => {\n            //   child.showmessage();\n            //   console.log(child.message);\n            // });\n            // $refs，是对象，默认为空，只有有ref属性的才会放入该对象中\n            console.log(this.$refs.a);\n            console.log(this.$refs["a"]);\n            this.$refs.a.showmessage();\n            console.log(this.$refs.a.message);\n          },\n        },\n        components: {\n          mycomponent: {\n            template: "#mycomponent",\n            data() {\n              return {\n                message: "hello",\n              };\n            },\n            methods: {\n              showmessage() {\n                console.log("showmessage");\n              },\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 子访问父—$parent & $root\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <outer-component ref="a"></outer-component>\n    </div>\n\n    <template id="outercomponent">\n      <div>\n        <inner-component></inner-component>\n      </div>\n    </template>\n\n    <template id="innercomponent">\n      <div>\n        <div>我是子组件</div>\n        <button @click="btnclick">子组件按钮</button>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello vue",\n        },\n        components: {\n          outercomponent: {\n            template: "#outercomponent",\n            data() {\n              return {\n                message: "hello outercomponent",\n              };\n            },\n            components: {\n              innercomponent: {\n                template: "#innercomponent",\n                methods: {\n                  btnclick() {\n                    // 打印出的为 vuecomponent。基本不会使用\n                    console.log(this.$parent);\n                    console.log(this.$parent.message);\n\n                    // 打印出的为 vue。基本不会使用，以后 vue 实例中仅仅会放 router 等，不会放数据，方法等\n                    console.log(this.$root);\n                    console.log(this.$root.message);\n                  },\n                },\n              },\n            },\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"插槽",frontmatter:{title:"插槽",date:"2020-12-27T00:30:57.000Z",permalink:"/pages/cca4b3/",categories:["Vue","组件"],tags:[null]},regularPath:"/1402.Vue2.x/200.%E7%BB%84%E4%BB%B6/202.%E6%8F%92%E6%A7%BD.html",relativePath:"1402.Vue2.x/200.组件/202.插槽.md",key:"v-9ebbc8cc",path:"/pages/cca4b3/",headers:[{level:2,title:"基本使用",slug:"基本使用",normalizedTitle:"基本使用",charIndex:203},{level:2,title:"具名插槽",slug:"具名插槽",normalizedTitle:"具名插槽",charIndex:1691},{level:3,title:"2.6.0 后语法",slug:"_2-6-0-后语法",normalizedTitle:"2.6.0 后语法",charIndex:1700},{level:3,title:"2.6.0 前语法",slug:"_2-6-0-前语法",normalizedTitle:"2.6.0 前语法",charIndex:3841},{level:2,title:"作用域插槽",slug:"作用域插槽",normalizedTitle:"作用域插槽",charIndex:5881},{level:3,title:"编译作用域",slug:"编译作用域",normalizedTitle:"编译作用域",charIndex:5891},{level:3,title:"作用域插槽—2.6.0 后语法",slug:"作用域插槽-2-6-0-后语法",normalizedTitle:"作用域插槽—2.6.0 后语法",charIndex:7052},{level:3,title:"作用域插槽—2.6.0 前语法",slug:"作用域插槽-2-6-0-前语法",normalizedTitle:"作用域插槽—2.6.0 前语法",charIndex:9291},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:11337}],headersStr:"基本使用 具名插槽 2.6.0 后语法 2.6.0 前语法 作用域插槽 编译作用域 作用域插槽—2.6.0 后语法 作用域插槽—2.6.0 前语法 示例",content:'# 插槽 slot\n\nslot noun\n\n/slɑːt/\n\na long, narrow hole, especially one for putting coins into or for fitting a separate piece into\n\n为什么使用 slot\n\n类似 USB 插槽，用于扩展，让使用者决定组件显示的内容。抽取共性，留有扩展。不需要通过状态来控制显示与否！类似接口\n\n\n# 基本使用\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component>\n        <button>666</button>\n      </my-component>\n      <hr />\n      <my-component>\n        <a href="#">QQ</a>\n      </my-component>\n      <hr />\n      <my-component> </my-component>\n      <hr />\n      <my-component>\n        \x3c!-- 会把所有内容替换到插槽里 --\x3e\n        <button>666</button>\n        <a href="#">QQ</a>\n      </my-component>\n    </div>\n\n    <template id="myComponent">\n      <div>\n        <h2>组件</h2>\n        \x3c!-- 若没有<slot></slot>标签，则这个组件只能显示h2（当然可以自定义h2中的内容，此处不再赘述），\n            其他时候想添加一个button，添加一个img都不可以\n            但是当有了<slot></slot>标签后，则可以自定义显示的东西。还可以有默认值 --\x3e\n        <slot>\n          <button>\n            默认插槽值\n          </button>\n        </slot>\n        \x3c!-- 自闭合标签也行，但是没有默认值了 --\x3e\n        \x3c!-- <slot /> --\x3e\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          message: \'Hello\',\n        },\n        methods: {},\n        components: {\n          MyComponent: {\n            template: \'#myComponent\',\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 具名插槽\n\n\n# 2.6.0 后语法\n\n注意 v-slot 只能添加在 <template> 上，除非当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这一点和已经废弃的 slot 不同。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 正常工作时显示 li --\x3e\n      <current-user :user="outerUser"></current-user>\n\n      \x3c!-- 代码不会正常工作，因为只有 <current-user> 组件可以访问到 user(props或data中，一般都会封装在props中) 而我们提供的内容是在父级渲染的。 --\x3e\n      \x3c!-- <current-user :user="outerUser">\n        {{ user.firstName }}\n      </current-user> --\x3e\n\n      <current-user :user="outerUser">\n        \x3c!-- 如下三种方式写都可以 --\x3e\n        \x3c!-- <template v-slot:default="props"> --\x3e\n        \x3c!-- <template v-slot="props"> --\x3e\n        \x3c!-- props 名称可以自定义，推荐使用 props，由于子组件传递过来的值一般都在 props 中。user 是在模版中定义的 attribute --\x3e\n        <template #default="props">\n          {{ props.user.firstName }}\n        </template>\n      </current-user>\n    </div>\n\n    <template id="currentUser">\n      <div>\n        \x3c!-- :user="user" 中第一个是作为 attribute 可以自定义（在使用时必须为该 attr），第二个为绑定的子组件中的 props 或 data 数据，一般为 props 的数据 --\x3e\n        <slot :user="user">{{ user.lastName }}</slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          message: \'Hello\',\n          outerUser: {\n            firstName: \'si\',\n            lastName: \'li\',\n          },\n        },\n        methods: {},\n        components: {\n          CurrentUser: {\n            template: \'#currentUser\',\n            props: {\n              user: {\n                type: Object,\n                default() {\n                  return {\n                    firstName: \'san\',\n                    lastName: \'zhang\',\n                  }\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 2.6.0 前语法\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 正常工作时显示 li --\x3e\n      <current-user :user="outerUser"></current-user>\n\n      \x3c!-- 代码不会正常工作，因为只有 <current-user> 组件可以访问到 user(props或data中，一般都会封装在props中) 而我们提供的内容是在父级渲染的。 --\x3e\n      \x3c!-- <current-user :user="outerUser">\n        {{ user.firstName }}\n      </current-user> --\x3e\n\n      <current-user :user="outerUser">\n        \x3c!-- 如下两种方式写都可以（#name是v-slot的语法糖） --\x3e\n        \x3c!-- <template slot="default" slot-scope="props"> --\x3e\n        \x3c!-- props 名称可以自定义，推荐使用 props，由于子组件传递过来的值一般都在 props 中。user 是在模版中定义的 attribute --\x3e\n        <template slot-scope="props">\n          {{ props.user.firstName }}\n        </template>\n      </current-user>\n    </div>\n\n    <template id="currentUser">\n      <div>\n        \x3c!-- :user="user" 中第一个是作为 attribute 可以自定义（在使用时必须为该 attr），第二个为绑定的子组件中的 props 或 data 数据，一般为 props 的数据 --\x3e\n        <slot :user="user">{{ user.lastName }}</slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          message: \'Hello\',\n          outerUser: {\n            firstName: \'si\',\n            lastName: \'li\',\n          },\n        },\n        methods: {},\n        components: {\n          CurrentUser: {\n            template: \'#currentUser\',\n            props: {\n              user: {\n                type: Object,\n                default() {\n                  return {\n                    firstName: \'san\',\n                    lastName: \'zhang\',\n                  }\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 作用域插槽\n\n\n# 编译作用域\n\n父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 凡是在 Vue 实例管理的 el 中的，都是在 Vue 实例中 --\x3e\n      <my-component v-show="isShow"> </my-component>\n      <hr />\n    </div>\n\n    <template id="myComponent">\n      \x3c!-- 只有在组件作用域中写的，才算是组件作用域，在组件中 --\x3e\n      <div>\n        <h2>组件</h2>\n        <button v-show="isShow">按钮</button>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          message: \'Hello\',\n          isShow: true,\n        },\n        methods: {},\n        components: {\n          MyComponent: {\n            template: \'#myComponent\',\n            data() {\n              return {\n                isShow: false,\n              }\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 作用域插槽—2.6.0 后语法\n\n让插槽内容能够访问子组件中才有的数据是很有用的，如下例子：\n\n为了让 user 在父级的插槽内容中可用，我们可以将 user 作为slot元素的一个 attribute 绑定上去。\n\n绑定在 <slot> 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 正常工作时显示 li --\x3e\n      <current-user :user="outerUser"></current-user>\n\n      \x3c!-- 代码不会正常工作，因为只有 <current-user> 组件可以访问到 user(props或data中，一般都会封装在props中) 而我们提供的内容是在父级渲染的。 --\x3e\n      \x3c!-- <current-user :user="outerUser">\n        {{ user.firstName }}\n      </current-user> --\x3e\n\n      <current-user :user="outerUser">\n        \x3c!-- 如下三种方式写都可以 --\x3e\n        \x3c!-- <template v-slot:default="props"> --\x3e\n        \x3c!-- <template v-slot="props"> --\x3e\n        \x3c!-- props 名称可以自定义，推荐使用 props，由于子组件传递过来的值一般都在 props 中。user 是在模版中定义的 attribute --\x3e\n        <template #default="props">\n          {{ props.user.firstName }}\n        </template>\n      </current-user>\n    </div>\n\n    <template id="currentUser">\n      <div>\n        \x3c!-- :user="user" 中第一个是作为 attribute 可以自定义（在使用时必须为该 attr），第二个为绑定的子组件中的 props 或 data 数据，一般为 props 的数据 --\x3e\n        <slot :user="user">{{ user.lastName }}</slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          message: \'Hello\',\n          outerUser: {\n            firstName: \'si\',\n            lastName: \'li\',\n          },\n        },\n        methods: {},\n        components: {\n          CurrentUser: {\n            template: \'#currentUser\',\n            props: {\n              user: {\n                type: Object,\n                default() {\n                  return {\n                    firstName: \'san\',\n                    lastName: \'zhang\',\n                  }\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 作用域插槽—2.6.0 前语法\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 正常工作时显示 li --\x3e\n      <current-user :user="outerUser"></current-user>\n\n      \x3c!-- 代码不会正常工作，因为只有 <current-user> 组件可以访问到 user(props或data中，一般都会封装在props中) 而我们提供的内容是在父级渲染的。 --\x3e\n      \x3c!-- <current-user :user="outerUser">\n        {{ user.firstName }}\n      </current-user> --\x3e\n\n      <current-user :user="outerUser">\n        \x3c!-- 如下两种方式写都可以（#name是v-slot的语法糖） --\x3e\n        \x3c!-- <template slot="default" slot-scope="props"> --\x3e\n        \x3c!-- props 名称可以自定义，推荐使用 props，由于子组件传递过来的值一般都在 props 中。user 是在模版中定义的 attribute --\x3e\n        <template slot-scope="props">\n          {{ props.user.firstName }}\n        </template>\n      </current-user>\n    </div>\n\n    <template id="currentUser">\n      <div>\n        \x3c!-- :user="user" 中第一个是作为 attribute 可以自定义（在使用时必须为该 attr），第二个为绑定的子组件中的 props 或 data 数据，一般为 props 的数据 --\x3e\n        <slot :user="user">{{ user.lastName }}</slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data: {\n          message: \'Hello\',\n          outerUser: {\n            firstName: \'si\',\n            lastName: \'li\',\n          },\n        },\n        methods: {},\n        components: {\n          CurrentUser: {\n            template: \'#currentUser\',\n            props: {\n              user: {\n                type: Object,\n                default() {\n                  return {\n                    firstName: \'san\',\n                    lastName: \'zhang\',\n                  }\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 示例\n\n父组件替换插槽的标签，但是内容由子组件提供。需求如下：\n\n * 子组件中包括一数组（可以是父组件通过 props 传递的），如 pLanguages: [\'Java\', \'Python\', \'Go\', \'JavaScript\', \'C\']\n * 需要在多个界面进行展示：\n   * 某些界面以水平方向展示\n   * 某些界面以列表形式展示\n   * 某些界面直接展示一个数组\n * 内容在子组件中，希望父组件告诉如何展示\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component></my-component>\n      <my-component :languanges="outerLanguages">\n        \x3c!-- <template v-slot:default="props"> --\x3e\n        \x3c!-- <template v-slot="props"> --\x3e\n        <template #default="props">\n          {{props.languanges.join(\'-\')}}\n        </template>\n      </my-component>\n    </div>\n\n    <template id="myComponent">\n      <div>\n        <slot :languanges="languanges">\n          \x3c!-- slot默认值 --\x3e\n          <ul>\n            <li v-for="lang in languanges">{{lang}}</li>\n          </ul>\n        </slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: \'#app\',\n        data() {\n          return {\n            outerLanguages: [\'Java\', \'Python\', \'Go\', \'JavaScript\', \'C\'],\n          }\n        },\n        methods: {},\n        components: {\n          MyComponent: {\n            template: \'#myComponent\',\n            props: {\n              languanges: {\n                type: Array,\n                default() {\n                  return [\'C\', \'C++\']\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n',normalizedContent:'# 插槽 slot\n\nslot noun\n\n/slɑːt/\n\na long, narrow hole, especially one for putting coins into or for fitting a separate piece into\n\n为什么使用 slot\n\n类似 usb 插槽，用于扩展，让使用者决定组件显示的内容。抽取共性，留有扩展。不需要通过状态来控制显示与否！类似接口\n\n\n# 基本使用\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component>\n        <button>666</button>\n      </my-component>\n      <hr />\n      <my-component>\n        <a href="#">qq</a>\n      </my-component>\n      <hr />\n      <my-component> </my-component>\n      <hr />\n      <my-component>\n        \x3c!-- 会把所有内容替换到插槽里 --\x3e\n        <button>666</button>\n        <a href="#">qq</a>\n      </my-component>\n    </div>\n\n    <template id="mycomponent">\n      <div>\n        <h2>组件</h2>\n        \x3c!-- 若没有<slot></slot>标签，则这个组件只能显示h2（当然可以自定义h2中的内容，此处不再赘述），\n            其他时候想添加一个button，添加一个img都不可以\n            但是当有了<slot></slot>标签后，则可以自定义显示的东西。还可以有默认值 --\x3e\n        <slot>\n          <button>\n            默认插槽值\n          </button>\n        </slot>\n        \x3c!-- 自闭合标签也行，但是没有默认值了 --\x3e\n        \x3c!-- <slot /> --\x3e\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          message: \'hello\',\n        },\n        methods: {},\n        components: {\n          mycomponent: {\n            template: \'#mycomponent\',\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n\n\n\n# 具名插槽\n\n\n# 2.6.0 后语法\n\n注意 v-slot 只能添加在 <template> 上，除非当被提供的内容只有默认插槽时，组件的标签才可以被当作插槽的模板来使用。这一点和已经废弃的 slot 不同。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 正常工作时显示 li --\x3e\n      <current-user :user="outeruser"></current-user>\n\n      \x3c!-- 代码不会正常工作，因为只有 <current-user> 组件可以访问到 user(props或data中，一般都会封装在props中) 而我们提供的内容是在父级渲染的。 --\x3e\n      \x3c!-- <current-user :user="outeruser">\n        {{ user.firstname }}\n      </current-user> --\x3e\n\n      <current-user :user="outeruser">\n        \x3c!-- 如下三种方式写都可以 --\x3e\n        \x3c!-- <template v-slot:default="props"> --\x3e\n        \x3c!-- <template v-slot="props"> --\x3e\n        \x3c!-- props 名称可以自定义，推荐使用 props，由于子组件传递过来的值一般都在 props 中。user 是在模版中定义的 attribute --\x3e\n        <template #default="props">\n          {{ props.user.firstname }}\n        </template>\n      </current-user>\n    </div>\n\n    <template id="currentuser">\n      <div>\n        \x3c!-- :user="user" 中第一个是作为 attribute 可以自定义（在使用时必须为该 attr），第二个为绑定的子组件中的 props 或 data 数据，一般为 props 的数据 --\x3e\n        <slot :user="user">{{ user.lastname }}</slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          message: \'hello\',\n          outeruser: {\n            firstname: \'si\',\n            lastname: \'li\',\n          },\n        },\n        methods: {},\n        components: {\n          currentuser: {\n            template: \'#currentuser\',\n            props: {\n              user: {\n                type: object,\n                default() {\n                  return {\n                    firstname: \'san\',\n                    lastname: \'zhang\',\n                  }\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 2.6.0 前语法\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 正常工作时显示 li --\x3e\n      <current-user :user="outeruser"></current-user>\n\n      \x3c!-- 代码不会正常工作，因为只有 <current-user> 组件可以访问到 user(props或data中，一般都会封装在props中) 而我们提供的内容是在父级渲染的。 --\x3e\n      \x3c!-- <current-user :user="outeruser">\n        {{ user.firstname }}\n      </current-user> --\x3e\n\n      <current-user :user="outeruser">\n        \x3c!-- 如下两种方式写都可以（#name是v-slot的语法糖） --\x3e\n        \x3c!-- <template slot="default" slot-scope="props"> --\x3e\n        \x3c!-- props 名称可以自定义，推荐使用 props，由于子组件传递过来的值一般都在 props 中。user 是在模版中定义的 attribute --\x3e\n        <template slot-scope="props">\n          {{ props.user.firstname }}\n        </template>\n      </current-user>\n    </div>\n\n    <template id="currentuser">\n      <div>\n        \x3c!-- :user="user" 中第一个是作为 attribute 可以自定义（在使用时必须为该 attr），第二个为绑定的子组件中的 props 或 data 数据，一般为 props 的数据 --\x3e\n        <slot :user="user">{{ user.lastname }}</slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          message: \'hello\',\n          outeruser: {\n            firstname: \'si\',\n            lastname: \'li\',\n          },\n        },\n        methods: {},\n        components: {\n          currentuser: {\n            template: \'#currentuser\',\n            props: {\n              user: {\n                type: object,\n                default() {\n                  return {\n                    firstname: \'san\',\n                    lastname: \'zhang\',\n                  }\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 作用域插槽\n\n\n# 编译作用域\n\n父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 凡是在 vue 实例管理的 el 中的，都是在 vue 实例中 --\x3e\n      <my-component v-show="isshow"> </my-component>\n      <hr />\n    </div>\n\n    <template id="mycomponent">\n      \x3c!-- 只有在组件作用域中写的，才算是组件作用域，在组件中 --\x3e\n      <div>\n        <h2>组件</h2>\n        <button v-show="isshow">按钮</button>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          message: \'hello\',\n          isshow: true,\n        },\n        methods: {},\n        components: {\n          mycomponent: {\n            template: \'#mycomponent\',\n            data() {\n              return {\n                isshow: false,\n              }\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# 作用域插槽—2.6.0 后语法\n\n让插槽内容能够访问子组件中才有的数据是很有用的，如下例子：\n\n为了让 user 在父级的插槽内容中可用，我们可以将 user 作为slot元素的一个 attribute 绑定上去。\n\n绑定在 <slot> 元素上的 attribute 被称为插槽 prop。现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字：\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 正常工作时显示 li --\x3e\n      <current-user :user="outeruser"></current-user>\n\n      \x3c!-- 代码不会正常工作，因为只有 <current-user> 组件可以访问到 user(props或data中，一般都会封装在props中) 而我们提供的内容是在父级渲染的。 --\x3e\n      \x3c!-- <current-user :user="outeruser">\n        {{ user.firstname }}\n      </current-user> --\x3e\n\n      <current-user :user="outeruser">\n        \x3c!-- 如下三种方式写都可以 --\x3e\n        \x3c!-- <template v-slot:default="props"> --\x3e\n        \x3c!-- <template v-slot="props"> --\x3e\n        \x3c!-- props 名称可以自定义，推荐使用 props，由于子组件传递过来的值一般都在 props 中。user 是在模版中定义的 attribute --\x3e\n        <template #default="props">\n          {{ props.user.firstname }}\n        </template>\n      </current-user>\n    </div>\n\n    <template id="currentuser">\n      <div>\n        \x3c!-- :user="user" 中第一个是作为 attribute 可以自定义（在使用时必须为该 attr），第二个为绑定的子组件中的 props 或 data 数据，一般为 props 的数据 --\x3e\n        <slot :user="user">{{ user.lastname }}</slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          message: \'hello\',\n          outeruser: {\n            firstname: \'si\',\n            lastname: \'li\',\n          },\n        },\n        methods: {},\n        components: {\n          currentuser: {\n            template: \'#currentuser\',\n            props: {\n              user: {\n                type: object,\n                default() {\n                  return {\n                    firstname: \'san\',\n                    lastname: \'zhang\',\n                  }\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n\n\n\n# 作用域插槽—2.6.0 前语法\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      \x3c!-- 正常工作时显示 li --\x3e\n      <current-user :user="outeruser"></current-user>\n\n      \x3c!-- 代码不会正常工作，因为只有 <current-user> 组件可以访问到 user(props或data中，一般都会封装在props中) 而我们提供的内容是在父级渲染的。 --\x3e\n      \x3c!-- <current-user :user="outeruser">\n        {{ user.firstname }}\n      </current-user> --\x3e\n\n      <current-user :user="outeruser">\n        \x3c!-- 如下两种方式写都可以（#name是v-slot的语法糖） --\x3e\n        \x3c!-- <template slot="default" slot-scope="props"> --\x3e\n        \x3c!-- props 名称可以自定义，推荐使用 props，由于子组件传递过来的值一般都在 props 中。user 是在模版中定义的 attribute --\x3e\n        <template slot-scope="props">\n          {{ props.user.firstname }}\n        </template>\n      </current-user>\n    </div>\n\n    <template id="currentuser">\n      <div>\n        \x3c!-- :user="user" 中第一个是作为 attribute 可以自定义（在使用时必须为该 attr），第二个为绑定的子组件中的 props 或 data 数据，一般为 props 的数据 --\x3e\n        <slot :user="user">{{ user.lastname }}</slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data: {\n          message: \'hello\',\n          outeruser: {\n            firstname: \'si\',\n            lastname: \'li\',\n          },\n        },\n        methods: {},\n        components: {\n          currentuser: {\n            template: \'#currentuser\',\n            props: {\n              user: {\n                type: object,\n                default() {\n                  return {\n                    firstname: \'san\',\n                    lastname: \'zhang\',\n                  }\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n\n\n\n# 示例\n\n父组件替换插槽的标签，但是内容由子组件提供。需求如下：\n\n * 子组件中包括一数组（可以是父组件通过 props 传递的），如 planguages: [\'java\', \'python\', \'go\', \'javascript\', \'c\']\n * 需要在多个界面进行展示：\n   * 某些界面以水平方向展示\n   * 某些界面以列表形式展示\n   * 某些界面直接展示一个数组\n * 内容在子组件中，希望父组件告诉如何展示\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <my-component></my-component>\n      <my-component :languanges="outerlanguages">\n        \x3c!-- <template v-slot:default="props"> --\x3e\n        \x3c!-- <template v-slot="props"> --\x3e\n        <template #default="props">\n          {{props.languanges.join(\'-\')}}\n        </template>\n      </my-component>\n    </div>\n\n    <template id="mycomponent">\n      <div>\n        <slot :languanges="languanges">\n          \x3c!-- slot默认值 --\x3e\n          <ul>\n            <li v-for="lang in languanges">{{lang}}</li>\n          </ul>\n        </slot>\n      </div>\n    </template>\n\n    <script src="/lib/vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: \'#app\',\n        data() {\n          return {\n            outerlanguages: [\'java\', \'python\', \'go\', \'javascript\', \'c\'],\n          }\n        },\n        methods: {},\n        components: {\n          mycomponent: {\n            template: \'#mycomponent\',\n            props: {\n              languanges: {\n                type: array,\n                default() {\n                  return [\'c\', \'c++\']\n                },\n                required: true,\n              },\n            },\n          },\n        },\n      })\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"入门",frontmatter:{title:"入门",date:"2020-12-27T00:50:25.000Z",permalink:"/pages/ac2e39/",categories:["Vue","VueCLI"],tags:[null]},regularPath:"/1402.Vue2.x/300.Vue%20CLI/301.%E5%85%A5%E9%97%A8.html",relativePath:"1402.Vue2.x/300.Vue CLI/301.入门.md",key:"v-9152731e",path:"/pages/ac2e39/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:15},{level:2,title:"创建项目",slug:"创建项目",normalizedTitle:"创建项目",charIndex:124},{level:3,title:"vue create",slug:"vue-create",normalizedTitle:"vue create",charIndex:133},{level:3,title:"vue ui",slug:"vue-ui",normalizedTitle:"vue ui",charIndex:194},{level:3,title:"拉取 2.x 模板 (旧版本)",slug:"拉取-2-x-模板-旧版本",normalizedTitle:"拉取 2.x 模板 (旧版本)",charIndex:286},{level:2,title:"runtime + compiler & runtime",slug:"runtime-compiler-runtime",normalizedTitle:"runtime + compiler &amp; runtime",charIndex:null},{level:3,title:"区别",slug:"区别",normalizedTitle:"区别",charIndex:627},{level:3,title:"render",slug:"render",normalizedTitle:"render",charIndex:879},{level:2,title:"Vue-CLI 2 目录",slug:"vue-cli-2-目录",normalizedTitle:"vue-cli 2 目录",charIndex:2315},{level:3,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:2325},{level:3,title:"build",slug:"build",normalizedTitle:"build",charIndex:2348},{level:3,title:"src & static",slug:"src-static",normalizedTitle:"src &amp; static",charIndex:null},{level:3,title:".babelrc",slug:"babelrc",normalizedTitle:".babelrc",charIndex:3134},{level:3,title:".editorconfig",slug:"editorconfig",normalizedTitle:".editorconfig",charIndex:3504},{level:3,title:".eslintignore",slug:"eslintignore",normalizedTitle:".eslintignore",charIndex:3743},{level:3,title:".postcssrc.js",slug:"postcssrc-js",normalizedTitle:".postcssrc.js",charIndex:3866},{level:3,title:"index.html",slug:"index-html",normalizedTitle:"index.html",charIndex:3899},{level:3,title:"package.json & package-lock.json",slug:"package-json-package-lock-json",normalizedTitle:"package.json &amp; package-lock.json",charIndex:null},{level:2,title:"Vue-CLI 3 介绍",slug:"vue-cli-3-介绍",normalizedTitle:"vue-cli 3 介绍",charIndex:4127}],headersStr:"安装 创建项目 vue create vue ui 拉取 2.x 模板 (旧版本) runtime + compiler & runtime 区别 render Vue-CLI 2 目录 目录 build src & static .babelrc .editorconfig .eslintignore .postcssrc.js index.html package.json & package-lock.json Vue-CLI 3 介绍",content:"# 入门\n\n官方文档\n\n\n# 安装\n\nnpm install -g @vue/cli\n# OR\nyarn global add @vue/cli\n\n\n1\n2\n3\n\n\n用这个命令来检查其版本是否正确：\n\nvue --version\n\n\n1\n\n\n\n# 创建项目\n\n\n# vue create\n\n运行以下命令来创建一个新项目：\n\nvue create hello-world\n\n\n1\n\n\n\n# vue ui\n\n也可以通过 vue ui 命令以图形化界面创建和管理项目：\n\nvue ui\n\n\n1\n\n\n上述命令会打开一个浏览器窗口，并以图形化界面将你引导至项目创建的流程。\n\n\n# 拉取 2.x 模板 (旧版本)\n\nVue CLI >= 3 和旧版使用了相同的 vue 命令，所以 Vue CLI 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：\n\nnpm install -g @vue/cli-init\n# `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同\nvue init webpack my-project\n\n\n1\n2\n3\n\n\n我 tm 模版下载了半天没成功！算逑了\n\n不过 2.x 生成的代码有许多配置（大致能看懂），3.x 开始后就隐藏了，所以可以用于学习了解\n\n\n# runtime + compiler & runtime\n\n推荐 runtime\n\n\n# 区别\n\n区别看下面俩 main.js\n\nruntime + compiler：\n\nimport Vue form 'vue'\nimport App form './App'\n\nVue.config.productionTip = false\n\nnew Vue({\n    el: '#app',\n    components: { App },\n    template: '<App/>'\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从 template --parse--\x3e ast --render--\x3e vdom --\x3e UI\n\ncompiler：\n\nimport Vue form 'vue'\nimport App form './App'\n\nVue.config.productionTip = false\n\nnew Vue({\n    el: '#app',\n    render: h => h(App)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n直接 --render--\x3e vdom --\x3e UI。即使是 .vue 文件中的 template 也会被 vue-template-compiler parse，查看对象中不再有 template，而是有个 render() 函数替代直接渲染\n\n\n# render\n\n普通用法\n\nimport Vue form 'vue'\nimport App form './App'\n\nVue.config.productionTip = false\n\nnew Vue({\n    el: '#app',\n    // createElement('标签名', {标签的属性}, [])\n    render: createElement => createElement('h2',\n                                          {class: 'box'},\n                                           ['Hello World', createElement('button',\n                                                                        {class: 'btn'},\n                                                                        ['按钮'])]\n                                          )\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n传入组件对象。直接 --render--\x3e vdom --\x3e UI\n\nimport Vue form 'vue'\nimport App form './App'\n\nVue.config.productionTip = false\n\nconst cpn = {\n    template: '<div>{{message}}</div>',\n    data(){\n        return {\n            message: '我是组件message'\n        }\n    }\n}\n\nnew Vue({\n    el: '#app',\n    // render: createElement => createElement(cpn)\n\n    // 同样的 App 组件也可以直接传递\n    // render: createElement => createElement(App)\n    // 精简\n    render: h => h(App)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# Vue-CLI 2 目录\n\n\n# 目录\n\n生成的目录如下图，其中 build 和 config 都是配置相关的文件。\n\n\n\n\n# build\n\n如图所示，build 中将 webpack 的配置文件做了分离：\n\n * webpack.base.conf.js（公共配置）\n * webpack.dev.conf.js（开发环境）\n * webpack.prod.conf.js（生产环境）\n\n\n\n我们使用的脚本命令配置在package.json中。\n\n\n\n打包构建：\n\nnpm run build\n\n\n1\n\n\n如果搭建了本地服务器webpack-dev-server，本地开发环境：\n\nnpm run dev\n\n\n1\n\n\n此时npm run build打包命令相当于使用 node 执行 build 文件夹下面的 build.js 文件。\n\n\n\n 1. 检查 dist 文件夹是否已经存在，存在先删除\n 2. 如果没有 err，就使用 webpack 的配置打包 dist 文件夹\n\n在生产环境，即使用 build 打包时候，使用的是webpack.prod.conf.js配置文件。\n\n\n\n源码中，显然使用了webpack-merge插件来合并 prod 配置文件和公共的配置文件，合并成一个配置文件并打包，而webpack.dev.conf.js也是如此操作，在开发环境使用的是 dev 的配置文件。\n\nconfig 文件夹中是 build 的配置文件中所需的一些变量、对象，在webpack.base.conf.js中引入了index.js。\n\nconst config = require('../config')\n\n\n1\n\n\n\n# src & static\n\nsrc 源码目录，就是我们需要写业务代码的地方。\n\nstatic 是放静态资源的地方，static 文件夹下的资源会原封不动的打包复制到 dist 文件夹下。\n\n\n# .babelrc\n\n.babelrc 是 ES 代码相关转化配置。\n\n{\n  \"presets\": [\n    [\"env\", {\n      \"modules\": false,\n      \"targets\": {\n        \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie <= 8\"]\n      }\n    }],\n    \"stage-2\"\n  ],\n  \"plugins\": [\"transform-vue-jsx\", \"transform-runtime\"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 1. browsers 表示需要适配的浏览器，份额大于 1%，最后两个版本，不需要适配 ie8 及以下版本\n 2. babel 需要的插件\n\n\n# .editorconfig\n\n.editorconfig 是编码配置文件。\n\nroot = true\n\n[*]\ncharset = utf-8\nindent_style = space\nindent_size = 2\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n一般是配置编码，代码缩进 2 空格，是否清除空格等。\n\n\n# .eslintignore\n\n.eslintignore 文件忽略一些不规范的代码。\n\n/build/\n/config/\n/dist/\n/*.js\n\n\n1\n2\n3\n4\n\n\n忽略 build、config、dist 文件夹和 js 文件。\n\n\n# .postcssrc.js\n\ncss 转化是配置的一些。\n\n\n# index.html\n\nindex.html 文件是使用html-webpack-plugin插件打包的 index.html 模板。\n\n\n# package.json & package-lock.json\n\n * package.json（包管理，记录大概安装的版本）\n\n * package-lock.json（记录真实安装版本）\n\n所以一般下载开源项目时，要根据 lock 使用的是 npm 还是 yarn 来安装依赖，才能防止版本不一致\n\n\n# Vue-CLI 3 介绍\n\n与 2 的区别\n\n * Vue-CLI 3 基于 webpack4 打造，Vue-CLI 2 是基于 webpack3\n\n * Vue-CLI 3 的设计原则是\"0 配置\"，移除了配置文件，build 和 config 等。最终跑到 node_modules/@vue/cli-service/webpack.config.js，实在要改变则在根目录下创建 vue.config.js，类似 webpack.config.js\n   \n   //在module.exports中修改配置\n   module.exports = {}\n   \n   \n   1\n   2\n   \n\n * Vue-CLI 3 提供vue ui的命令，提供了可视化配置\n\n * 移除了 static 文件夹，新增了 public 文件夹，并将 index.html 移入了 public 文件夹。打包时原封不动！",normalizedContent:"# 入门\n\n官方文档\n\n\n# 安装\n\nnpm install -g @vue/cli\n# or\nyarn global add @vue/cli\n\n\n1\n2\n3\n\n\n用这个命令来检查其版本是否正确：\n\nvue --version\n\n\n1\n\n\n\n# 创建项目\n\n\n# vue create\n\n运行以下命令来创建一个新项目：\n\nvue create hello-world\n\n\n1\n\n\n\n# vue ui\n\n也可以通过 vue ui 命令以图形化界面创建和管理项目：\n\nvue ui\n\n\n1\n\n\n上述命令会打开一个浏览器窗口，并以图形化界面将你引导至项目创建的流程。\n\n\n# 拉取 2.x 模板 (旧版本)\n\nvue cli >= 3 和旧版使用了相同的 vue 命令，所以 vue cli 2 (vue-cli) 被覆盖了。如果你仍然需要使用旧版本的 vue init 功能，你可以全局安装一个桥接工具：\n\nnpm install -g @vue/cli-init\n# `vue init` 的运行效果将会跟 `vue-cli@2.x` 相同\nvue init webpack my-project\n\n\n1\n2\n3\n\n\n我 tm 模版下载了半天没成功！算逑了\n\n不过 2.x 生成的代码有许多配置（大致能看懂），3.x 开始后就隐藏了，所以可以用于学习了解\n\n\n# runtime + compiler & runtime\n\n推荐 runtime\n\n\n# 区别\n\n区别看下面俩 main.js\n\nruntime + compiler：\n\nimport vue form 'vue'\nimport app form './app'\n\nvue.config.productiontip = false\n\nnew vue({\n    el: '#app',\n    components: { app },\n    template: '<app/>'\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n从 template --parse--\x3e ast --render--\x3e vdom --\x3e ui\n\ncompiler：\n\nimport vue form 'vue'\nimport app form './app'\n\nvue.config.productiontip = false\n\nnew vue({\n    el: '#app',\n    render: h => h(app)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n直接 --render--\x3e vdom --\x3e ui。即使是 .vue 文件中的 template 也会被 vue-template-compiler parse，查看对象中不再有 template，而是有个 render() 函数替代直接渲染\n\n\n# render\n\n普通用法\n\nimport vue form 'vue'\nimport app form './app'\n\nvue.config.productiontip = false\n\nnew vue({\n    el: '#app',\n    // createelement('标签名', {标签的属性}, [])\n    render: createelement => createelement('h2',\n                                          {class: 'box'},\n                                           ['hello world', createelement('button',\n                                                                        {class: 'btn'},\n                                                                        ['按钮'])]\n                                          )\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n传入组件对象。直接 --render--\x3e vdom --\x3e ui\n\nimport vue form 'vue'\nimport app form './app'\n\nvue.config.productiontip = false\n\nconst cpn = {\n    template: '<div>{{message}}</div>',\n    data(){\n        return {\n            message: '我是组件message'\n        }\n    }\n}\n\nnew vue({\n    el: '#app',\n    // render: createelement => createelement(cpn)\n\n    // 同样的 app 组件也可以直接传递\n    // render: createelement => createelement(app)\n    // 精简\n    render: h => h(app)\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# vue-cli 2 目录\n\n\n# 目录\n\n生成的目录如下图，其中 build 和 config 都是配置相关的文件。\n\n\n\n\n# build\n\n如图所示，build 中将 webpack 的配置文件做了分离：\n\n * webpack.base.conf.js（公共配置）\n * webpack.dev.conf.js（开发环境）\n * webpack.prod.conf.js（生产环境）\n\n\n\n我们使用的脚本命令配置在package.json中。\n\n\n\n打包构建：\n\nnpm run build\n\n\n1\n\n\n如果搭建了本地服务器webpack-dev-server，本地开发环境：\n\nnpm run dev\n\n\n1\n\n\n此时npm run build打包命令相当于使用 node 执行 build 文件夹下面的 build.js 文件。\n\n\n\n 1. 检查 dist 文件夹是否已经存在，存在先删除\n 2. 如果没有 err，就使用 webpack 的配置打包 dist 文件夹\n\n在生产环境，即使用 build 打包时候，使用的是webpack.prod.conf.js配置文件。\n\n\n\n源码中，显然使用了webpack-merge插件来合并 prod 配置文件和公共的配置文件，合并成一个配置文件并打包，而webpack.dev.conf.js也是如此操作，在开发环境使用的是 dev 的配置文件。\n\nconfig 文件夹中是 build 的配置文件中所需的一些变量、对象，在webpack.base.conf.js中引入了index.js。\n\nconst config = require('../config')\n\n\n1\n\n\n\n# src & static\n\nsrc 源码目录，就是我们需要写业务代码的地方。\n\nstatic 是放静态资源的地方，static 文件夹下的资源会原封不动的打包复制到 dist 文件夹下。\n\n\n# .babelrc\n\n.babelrc 是 es 代码相关转化配置。\n\n{\n  \"presets\": [\n    [\"env\", {\n      \"modules\": false,\n      \"targets\": {\n        \"browsers\": [\"> 1%\", \"last 2 versions\", \"not ie <= 8\"]\n      }\n    }],\n    \"stage-2\"\n  ],\n  \"plugins\": [\"transform-vue-jsx\", \"transform-runtime\"]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n 1. browsers 表示需要适配的浏览器，份额大于 1%，最后两个版本，不需要适配 ie8 及以下版本\n 2. babel 需要的插件\n\n\n# .editorconfig\n\n.editorconfig 是编码配置文件。\n\nroot = true\n\n[*]\ncharset = utf-8\nindent_style = space\nindent_size = 2\nend_of_line = lf\ninsert_final_newline = true\ntrim_trailing_whitespace = true\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n一般是配置编码，代码缩进 2 空格，是否清除空格等。\n\n\n# .eslintignore\n\n.eslintignore 文件忽略一些不规范的代码。\n\n/build/\n/config/\n/dist/\n/*.js\n\n\n1\n2\n3\n4\n\n\n忽略 build、config、dist 文件夹和 js 文件。\n\n\n# .postcssrc.js\n\ncss 转化是配置的一些。\n\n\n# index.html\n\nindex.html 文件是使用html-webpack-plugin插件打包的 index.html 模板。\n\n\n# package.json & package-lock.json\n\n * package.json（包管理，记录大概安装的版本）\n\n * package-lock.json（记录真实安装版本）\n\n所以一般下载开源项目时，要根据 lock 使用的是 npm 还是 yarn 来安装依赖，才能防止版本不一致\n\n\n# vue-cli 3 介绍\n\n与 2 的区别\n\n * vue-cli 3 基于 webpack4 打造，vue-cli 2 是基于 webpack3\n\n * vue-cli 3 的设计原则是\"0 配置\"，移除了配置文件，build 和 config 等。最终跑到 node_modules/@vue/cli-service/webpack.config.js，实在要改变则在根目录下创建 vue.config.js，类似 webpack.config.js\n   \n   //在module.exports中修改配置\n   module.exports = {}\n   \n   \n   1\n   2\n   \n\n * vue-cli 3 提供vue ui的命令，提供了可视化配置\n\n * 移除了 static 文件夹，新增了 public 文件夹，并将 index.html 移入了 public 文件夹。打包时原封不动！",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"入门",frontmatter:{title:"入门",date:"2020-12-27T00:50:31.000Z",permalink:"/pages/9741e2/",categories:["Vue","Vue Router"],tags:[null]},regularPath:"/1402.Vue2.x/400.Vue%20Router/401.Vue%20Router%E5%85%A5%E9%97%A8.html",relativePath:"1402.Vue2.x/400.Vue Router/401.Vue Router入门.md",key:"v-28296e0a",path:"/pages/9741e2/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:9},{level:3,title:"路由简介",slug:"路由简介",normalizedTitle:"路由简介",charIndex:16},{level:3,title:"后端 & 前端路由 🔥",slug:"后端-前端路由-🔥",normalizedTitle:"后端 &amp; 前端路由 🔥",charIndex:null},{level:3,title:"URL 的 hash & HTML5 的 history 🔥",slug:"url-的-hash-html5-的-history-🔥",normalizedTitle:"url 的 hash &amp; html5 的 history 🔥",charIndex:null},{level:2,title:"安装和配置 🔥",slug:"安装和配置-🔥",normalizedTitle:"安装和配置 🔥",charIndex:1705},{level:2,title:"标签路由 🔥",slug:"标签路由-🔥",normalizedTitle:"标签路由 🔥",charIndex:3180},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:387},{level:3,title:"<router-link>",slug:"router-link",normalizedTitle:"<router-link>",charIndex:3925},{level:3,title:"<router-view>",slug:"router-view",normalizedTitle:"<router-view>",charIndex:4845},{level:2,title:"代码路由 🔥",slug:"代码路由-🔥",normalizedTitle:"代码路由 🔥",charIndex:4994},{level:2,title:"动态路由 🔥",slug:"动态路由-🔥",normalizedTitle:"动态路由 🔥",charIndex:6112},{level:2,title:"路由懒加载 🔥",slug:"路由懒加载-🔥",normalizedTitle:"路由懒加载 🔥",charIndex:6717},{level:2,title:"嵌套路由 🔥",slug:"嵌套路由-🔥",normalizedTitle:"嵌套路由 🔥",charIndex:7220},{level:2,title:"传递参数 🔥",slug:"传递参数-🔥",normalizedTitle:"传递参数 🔥",charIndex:9249},{level:3,title:"方式一：动态路由 & params",slug:"方式一-动态路由-params",normalizedTitle:"方式一：动态路由 &amp; params",charIndex:null},{level:3,title:"方式二：query",slug:"方式二-query",normalizedTitle:"方式二：query",charIndex:9394},{level:2,title:"$router & $route 区别 🔥",slug:"router-route-区别-🔥",normalizedTitle:"$router &amp; $route 区别 🔥",charIndex:null}],headersStr:"简介 路由简介 后端 & 前端路由 🔥 URL 的 hash & HTML5 的 history 🔥 安装和配置 🔥 标签路由 🔥 使用 <router-link> <router-view> 代码路由 🔥 动态路由 🔥 路由懒加载 🔥 嵌套路由 🔥 传递参数 🔥 方式一：动态路由 & params 方式二：query $router & $route 区别 🔥",content:"# 入门\n\n\n# 简介\n\n\n# 路由简介\n\n * 路由就是通过互联的网络把信息从源地址传送到目的地的活动，网络工程术语\n * 路由提供了两种机制：路由和传送\n   * 路由是决定数据包从来源到目的地的路径\n   * 转送就是将数据转移\n * 路由表\n   * 路由表本质就是一个映射表，决定了数据包的指向\n\n\n# 后端 & 前端路由 🔥\n\n 1. 后端渲染，服务端渲染（后端路由）阶段：前端请求一个 URL 后，由例如 Java 如 SpringMVC 中 @RequestMapping 来映射到 Java 代码中，并通过 Servlet 和 JSP 技术编写 HTML 页面（JS+CSS）并填充数据，最后返回给前端完整的 HTML，前端直接渲染展示即可。这种由后端处理 URL 和页面映射关系的称为后端路由。\n\n 2. 前后端分离阶段（Gmail 的 Ajax 大量使用） ：前端请求一个 URL 后，可能先从静态资源服务器获取一套 HTML+CSS+JS（服务器中有多套），之后再由 JS 发送 Ajax 请求到后端，由后端返回如 JSON 数据交给前端，前端使用 JS 进行数据填充，渲染 DOM。每次 URL 改变都会请求后端服务器拿静态资源和数据。\n\n 3. 单页面富应用（SPA 页面），前后端分离加上前端路由阶段： 前端第一次请求 URL 后，会从如静态资源服务器获取一套完整的 HTML+CSS+JS（只有一个 HTML，其他 JS 或 CSS 可能会懒加载），之后的 URL 改变不会向后端服务器发送请求，页面不进行整体刷新，而是由其不同的 URL 页面自己发送 Ajax 请求获取数据并由 JS 进行数据填充，渲染 DOM。这种由前端处理 URL 和页面的映射关系称为前端路由。\n    \n    那么如何在 URL 改变后页面还不进行整体刷新呢？且看下面介绍。\n\n\n# URL 的 hash & HTML5 的 history 🔥\n\n提示\n\nVue CLI 初始化项目时推荐选择 history 模式。URL 看起来更友好，没有#这玩意\n\nURL 的 hash 是改变锚点#，其本质上改变的是 window.location.hash 属性，不是 href 属性\n\nlocation.hash = '/user/10000'\nhttp://localhost:8082/#/user/10000\n\nlocation.hash = '/role/1'\nhttp://localhost:8082/#/role/1\n\n\n1\n2\n3\n4\n5\n\n\nHTML5 的 history。是一个栈结构\n\nhistory.pushState('','','/user/100001')\nhttp://localhost:8082/user/100001\n\nhistory.pushState('','','/role/1')\nhttp://localhost:8082/role/1\n\nhistory.back()\nhttp://localhost:8082/user/100001\n\nhistory.forward()\nhttp://localhost:8082/role/1\n\nhistory.replaceState('','','/permission/100')\nhttp://localhost:8082/permission/100\n# 此时将上面的 http://localhost:8082/role/1 替换掉了，之后无法 back 回去，只能 back 到 http://localhost:8082/user/100001\n\n# go 可以更灵活控制，相比 back，forward\nhistory.go(-1)\nhistory.go(1)\nhistory.go(-2)\nhistory.go(2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nVue Router 就是将组件和 URL 映射\n\n\n# 安装和配置 🔥\n\n安装。有的推荐加上--save，代表安装到正式依赖中\n\nnpm install vue-router\n\n\n1\n\n\n模块化工程中使用必须要通过 Vue.use() 明确地安装路由插件功能，创建路由实例，传入路由映射配置\n\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\n// 可以省略后缀(resolve.extensions配置的作用)；不推荐在这里导入，推荐如下懒加载方式\nimport Home from '../components/Home'\n\n// 安装路由插件功能\nVue.use(VueRouter)\n\n// 路由映射配置\nconst routes = [\n  {\n    path: '/', // 或 \"\" 都可以\n    name: 'Index',\n    // 重定向\n    redirect: '/home',\n  },\n  {\n    path: '/home',\n    name: 'Home',\n    component: Home,\n  },\n  {\n    path: '/about',\n    name: 'About',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () =>\n      import(/* webpackChunkName: \"about\" */ '@/components/About'),\n  },\n  {\n    path: '/user/:id',\n    name: 'User',\n    component: () => import('@/components/User'),\n  },\n]\n\n// 创建路由实例，传入路由映射配置\nconst router = new VueRouter({\n  // history模式\n  mode: 'history',\n  base: process.env.BASE_URL,\n  routes,\n})\n\n// 导出\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n在 Vue 实例中挂载创建的路由实例\n\n// /src/main.js\n\nimport Vue from 'vue'\nimport App from './App.vue'\n// 导入，./router 是一个目录，会自动导入 index 文件\nimport router from './router'\n\nVue.config.productionTip = false\n\n// 挂载\nnew Vue({\n  router,\n  render: (h) => h(App),\n}).$mount('#app')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 标签路由 🔥\n\n\n# 使用\n\n\x3c!-- /src/App.vue--\x3e\n\n<template>\n  <div id=\"app\">\n    <div id=\"nav\">\n      <router-link to=\"/home\">Home</router-link>\n      <router-link to=\"/about\">About</router-link>\n    </div>\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App',\n}\n<\/script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\n#nav {\n  padding: 30px;\n}\n\n#nav a {\n  font-weight: bold;\n  color: #2c3e50;\n}\n\n#nav a.router-link-active {\n  color: #42b983;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n那两个组件就不写了。\n\n\n# <router-link>\n\n全局组件，最终被渲染成 a 标签，但是它只是标记路由指向类似一个 a 标签或者按钮一样，若是我们点击 a 标签要跳转页面或者要显示页面，所以就要用上它。\n\n * to属性：用于跳转到指定路径\n\n * tag属性：可以指定<router-link>之后渲染成什么组件使用<router-link to='/home' tag='button'>会被渲染成一个按钮，而不是 a 标签\n\n * relapce属性：在 history 模式下指定<router-link to='/home' tag='button' replace>使用 replaceState 而不是 pushState，此时浏览器的返回按钮将不能返回替换前的路由\n\n * active-class属性：当<router-link>对应的路由匹配成功的时候，会自动给当前元素设置一个router-link-active的 class，设置active-class属性值可以修改默认的名称。\n   \n   * 在进行高亮显示的导航菜单或者底部 tabbar 时，会用到该属性。但是通常不会修改类的属性，会直接使用默认的router-link-active\n   \n   * <router-link to='/home' tag='button' active-class='active'>此时被选中的<router-link>就会有 active 的 class。\n   \n   * 如果每个<router-link>都要加上active-class='active'，那就在路由里面统一更改。\n     \n     const router = new Router({\n       //配置路由和组件之间的应用关系\n       routes,\n       mode: 'history', //修改模式为history\n       linkActiveClass: 'active',\n     })\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n\n\n# <router-view>\n\n用来占位的，就是路由对应的组件展示的地方，该标签会根据当前的路径，动态渲染出不同的组件。\n\n路由切换的时候切换的是它挂载的组件，其他不会发生改变。它默认使用 hash 模式，可以在 src/router/index.js 中配置修改为 history 模式。\n\n\n# 代码路由 🔥\n\n<template>\n  <div id=\"app\">\n    <div id=\"nav\">\n      \x3c!-- 当然也可以使用 router-link 和 tag 来实现。但是必须有 to 属性，所以自己斟酌使用场景。\n\t\t\t这里 button 也不会添加 class --\x3e\n      <button @click=\"goHome\">Home</button>\n      <button @click=\"goAbout\">About</button>\n    </div>\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App',\n  methods: {\n    goHome() {\n      // vue-router 给所有组件都添加了 $router 属性。还有replace方法！\n      console.log(this.$route)\n      // 不判断，则第二次点击同一路由报错\n      if (this.$route.path !== '/home') {\n        this.$router.push('/home')\n      }\n    },\n    goAbout() {\n      if (this.$route.path !== '/about') {\n        this.$router.push('/about')\n      }\n    },\n  },\n}\n<\/script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\n#nav {\n  padding: 30px;\n}\n\n#nav a {\n  font-weight: bold;\n  color: #2c3e50;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 动态路由 🔥\n\n由于路由中的 path是全匹配，例如/user查询所有用户，若此时 URL 为/user/1则匹配不到，但是这个 1 又不能写死！\n\n{\n    path: '/user/:id',\n    name: 'User',\n    component: () => import('@/components/User')\n}\n\n\n1\n2\n3\n4\n5\n\n\n<router-link :to=\"'/user/' + user.id\">User</router-link>\n\x3c!-- user.id 为动态获取的 --\x3e\n\n\n1\n2\n\n\n<template>\n  <div>\n    <h1>User</h1>\n    <h2>{{ userId }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    userId() {\n      // 拿到路由上的动态参数\n      return this.$route.params.id\n    },\n  },\n}\n<\/script>\n\n<style></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意，手动输入 URL 即使匹配到路由，也不会添加 active class！\n\n\n# 路由懒加载 🔥\n\nvue-router 打包文件解析问题：打包时候 JS 太大，页面响应缓慢\n\n如果组件模块化了，当路由被访问的时候才开始加载被选中的组件，这样就是路由懒加载。一个路由对应一个 JS 文件。\n\ncomponent: () => import('@/components/User')\n\n\n1\n\n\n使用npm run build命令将之前创建的项目打包，打开 dist 文件夹，器目录结构如下：\n\n以下是 Vue CLI 2 的代码\n\n * app.xxx.js 是我们自己编写的业务代码\n * vendor.xxx.js 是第三方框架，例如 vue/vue-router/axios 等\n * mainfest.xxx.js 是为了打包的代码做底层支持的，一般是 webpack 帮我们做一些事情\n * 除了这三个还多了 2 个 js，这 2 个 js 文件（0.5bxxx.js 和 1.e5xxx.js）分别是 About 和 User 组件，因为这 2 个组件是懒加载的所以被分开打包了。\n\n此时因为是懒加载，需要用到这个组件的时候才会加载，所以不会一次性请求所有 JS。\n\n\n# 嵌套路由 🔥\n\n平常在一个 home 页面中，我们可能需要/home/news和/home/message访问一些内容，一个路由映射一个组件就像后端一个 api 对应一个 controller 的一个 requestMapping 一样，访问两个路由也会分别渲染这两个组件。\n\n要实现嵌套路由：\n\n * 创建对应的子组件，并且在路由映射router/index.js中配置对应的子路由。\n\n * 在组件内部使用<router-view>标签来占位。\n\n// /router/index.js\n\nimport Vue from 'vue'\nimport VueRouter from 'vue-router'\n\n// 安装路由插件功能\nVue.use(VueRouter)\n\n// 路由映射配置\nconst routes = [\n  {\n    path: '', // 或 \"/\" 都可以\n    name: 'Index',\n    // 重定向\n    redirect: '/home',\n  },\n  {\n    path: '/home',\n    name: 'Home',\n    component: () => import('@/components/Home'),\n    children: [\n      {\n        path: '', // 或 \"/\" 都可以\n        // 后续也不这样使用，使用 keep-alive 来选择上次选择的路由\n        redirect: 'news',\n      },\n      {\n        // 不可以加 /，也不可以加 /home\n        path: 'news',\n        component: () => import('@/components/HomeNews'),\n      },\n      {\n        // 不可以加 /，也不可以加 /home\n        path: 'message',\n        component: () => import('@/components/HomeMessage'),\n      },\n    ],\n  },\n  {\n    path: '/about',\n    name: 'About',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () =>\n      import(/* webpackChunkName: \"about\" */ '@/components/About'),\n  },\n  {\n    path: '/user/:id',\n    name: 'User',\n    component: () => import('@/components/User'),\n  },\n]\n\n// 创建路由实例，传入路由映射配置\nconst router = new VueRouter({\n  // history模式\n  mode: 'history',\n  base: process.env.BASE_URL,\n  routes,\n})\n\n// 导出\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\x3c!-- /components/Home.vue --\x3e\n\n<template>\n  <div>\n    <h1>Home</h1>\n    <router-link to=\"/home/news\">News</router-link>｜\n    <router-link to=\"/home/message\">Message</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'Home',\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 传递参数 🔥\n\n路由跳转间传递参数\n\n\n# 方式一：动态路由 & params\n\n * 配置路由的格式：/user/:id\n * 传递时需要拼接，最终形成的路径：/user/123，/user/xxx\n * 通过$route.params.id获取指定 id\n\n代码查看动态路由\n\n\n# 方式二：query\n\n * 配置路由的格式：/profile，也就是普通的配置\n\n * 传递的方式：对象中使用 query 的 key 作为传递的方式\n\n * 传递形成的路径：/profile?name=conanan&age=18这个 query 传递的是两个键值对\n   \n   /profile?user=%5Bobject%20Object%5D这个 query 传递的是一个对象的键值对，key 为 user，value 是一个对象\n\n<template>\n  <div id=\"app\">\n    <div id=\"nav\">\n      <router-link to=\"/home\">Home</router-link>|\n      <router-link to=\"/about\">About</router-link>|\n      <router-link :to=\"'/user/' + user.id\">User</router-link>|\n      <router-link\n        :to=\"{ path: '/profile', query: { name: 'conanan', age: 18 } }\"\n        >Profile</router-link\n      >\n\n      \x3c!-- 当然也可以使用 router-link 和 tag 来实现。但是必须有 to 属性，所以自己斟酌使用场景。这里 button 也不会添加 class --\x3e\n      \x3c!-- <button @click=\"goHome\">Home</button>\n      <button @click=\"goAbout\">About</button>\n      <button @click=\"goProfile\">Profile</button>--\x3e\n    </div>\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'App',\n  data() {\n    return {\n      user: {\n        id: 10001,\n      },\n    }\n  },\n  methods: {\n    goHome() {\n      // vue-router 给所有组件都添加了 $router 属性。还有replace方法！\n      console.log(this.$route)\n      // 不判断，则第二次点击同一路由报错\n      if (this.$route.path !== '/home') {\n        this.$router.push('/home')\n      }\n    },\n    goAbout() {\n      if (this.$route.path !== '/about') {\n        this.$router.push('/about')\n      }\n    },\n    goProfile() {\n      if (this.$route.path !== '/profile') {\n        this.$router.push({\n          path: '/profile',\n          // query: { name: 'conanan', age: 18 }\n          query: {\n            user: {\n              name: 'conanan',\n              age: 25,\n            },\n          },\n        })\n      }\n    },\n  },\n}\n<\/script>\n\n<style>\n#app {\n  font-family: Avenir, Helvetica, Arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\n#nav {\n  padding: 30px;\n}\n\n#nav a {\n  font-weight: bold;\n  color: #2c3e50;\n}\n\n#nav a.router-link-active {\n  color: #42b983;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n\n# $router & $route 区别 🔥\n\nvue 全局对象this.$router与 main.js 导入的 router 对象是一个对象，也就是我们/router/index.js导出的对象 router，都是同一个 VueRouter 对象。因为所有的组件都继承自 Vue 类的原型（prototype）\n\nthis.$route对象是当前处于活跃的路由，就是 router 中配置的映射关系，有 params 和 query 属性可以用来传递参数。",normalizedContent:"# 入门\n\n\n# 简介\n\n\n# 路由简介\n\n * 路由就是通过互联的网络把信息从源地址传送到目的地的活动，网络工程术语\n * 路由提供了两种机制：路由和传送\n   * 路由是决定数据包从来源到目的地的路径\n   * 转送就是将数据转移\n * 路由表\n   * 路由表本质就是一个映射表，决定了数据包的指向\n\n\n# 后端 & 前端路由 🔥\n\n 1. 后端渲染，服务端渲染（后端路由）阶段：前端请求一个 url 后，由例如 java 如 springmvc 中 @requestmapping 来映射到 java 代码中，并通过 servlet 和 jsp 技术编写 html 页面（js+css）并填充数据，最后返回给前端完整的 html，前端直接渲染展示即可。这种由后端处理 url 和页面映射关系的称为后端路由。\n\n 2. 前后端分离阶段（gmail 的 ajax 大量使用） ：前端请求一个 url 后，可能先从静态资源服务器获取一套 html+css+js（服务器中有多套），之后再由 js 发送 ajax 请求到后端，由后端返回如 json 数据交给前端，前端使用 js 进行数据填充，渲染 dom。每次 url 改变都会请求后端服务器拿静态资源和数据。\n\n 3. 单页面富应用（spa 页面），前后端分离加上前端路由阶段： 前端第一次请求 url 后，会从如静态资源服务器获取一套完整的 html+css+js（只有一个 html，其他 js 或 css 可能会懒加载），之后的 url 改变不会向后端服务器发送请求，页面不进行整体刷新，而是由其不同的 url 页面自己发送 ajax 请求获取数据并由 js 进行数据填充，渲染 dom。这种由前端处理 url 和页面的映射关系称为前端路由。\n    \n    那么如何在 url 改变后页面还不进行整体刷新呢？且看下面介绍。\n\n\n# url 的 hash & html5 的 history 🔥\n\n提示\n\nvue cli 初始化项目时推荐选择 history 模式。url 看起来更友好，没有#这玩意\n\nurl 的 hash 是改变锚点#，其本质上改变的是 window.location.hash 属性，不是 href 属性\n\nlocation.hash = '/user/10000'\nhttp://localhost:8082/#/user/10000\n\nlocation.hash = '/role/1'\nhttp://localhost:8082/#/role/1\n\n\n1\n2\n3\n4\n5\n\n\nhtml5 的 history。是一个栈结构\n\nhistory.pushstate('','','/user/100001')\nhttp://localhost:8082/user/100001\n\nhistory.pushstate('','','/role/1')\nhttp://localhost:8082/role/1\n\nhistory.back()\nhttp://localhost:8082/user/100001\n\nhistory.forward()\nhttp://localhost:8082/role/1\n\nhistory.replacestate('','','/permission/100')\nhttp://localhost:8082/permission/100\n# 此时将上面的 http://localhost:8082/role/1 替换掉了，之后无法 back 回去，只能 back 到 http://localhost:8082/user/100001\n\n# go 可以更灵活控制，相比 back，forward\nhistory.go(-1)\nhistory.go(1)\nhistory.go(-2)\nhistory.go(2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nvue router 就是将组件和 url 映射\n\n\n# 安装和配置 🔥\n\n安装。有的推荐加上--save，代表安装到正式依赖中\n\nnpm install vue-router\n\n\n1\n\n\n模块化工程中使用必须要通过 vue.use() 明确地安装路由插件功能，创建路由实例，传入路由映射配置\n\nimport vue from 'vue'\nimport vuerouter from 'vue-router'\n// 可以省略后缀(resolve.extensions配置的作用)；不推荐在这里导入，推荐如下懒加载方式\nimport home from '../components/home'\n\n// 安装路由插件功能\nvue.use(vuerouter)\n\n// 路由映射配置\nconst routes = [\n  {\n    path: '/', // 或 \"\" 都可以\n    name: 'index',\n    // 重定向\n    redirect: '/home',\n  },\n  {\n    path: '/home',\n    name: 'home',\n    component: home,\n  },\n  {\n    path: '/about',\n    name: 'about',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () =>\n      import(/* webpackchunkname: \"about\" */ '@/components/about'),\n  },\n  {\n    path: '/user/:id',\n    name: 'user',\n    component: () => import('@/components/user'),\n  },\n]\n\n// 创建路由实例，传入路由映射配置\nconst router = new vuerouter({\n  // history模式\n  mode: 'history',\n  base: process.env.base_url,\n  routes,\n})\n\n// 导出\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n\n\n在 vue 实例中挂载创建的路由实例\n\n// /src/main.js\n\nimport vue from 'vue'\nimport app from './app.vue'\n// 导入，./router 是一个目录，会自动导入 index 文件\nimport router from './router'\n\nvue.config.productiontip = false\n\n// 挂载\nnew vue({\n  router,\n  render: (h) => h(app),\n}).$mount('#app')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 标签路由 🔥\n\n\n# 使用\n\n\x3c!-- /src/app.vue--\x3e\n\n<template>\n  <div id=\"app\">\n    <div id=\"nav\">\n      <router-link to=\"/home\">home</router-link>\n      <router-link to=\"/about\">about</router-link>\n    </div>\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'app',\n}\n<\/script>\n\n<style>\n#app {\n  font-family: avenir, helvetica, arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\n#nav {\n  padding: 30px;\n}\n\n#nav a {\n  font-weight: bold;\n  color: #2c3e50;\n}\n\n#nav a.router-link-active {\n  color: #42b983;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n那两个组件就不写了。\n\n\n# <router-link>\n\n全局组件，最终被渲染成 a 标签，但是它只是标记路由指向类似一个 a 标签或者按钮一样，若是我们点击 a 标签要跳转页面或者要显示页面，所以就要用上它。\n\n * to属性：用于跳转到指定路径\n\n * tag属性：可以指定<router-link>之后渲染成什么组件使用<router-link to='/home' tag='button'>会被渲染成一个按钮，而不是 a 标签\n\n * relapce属性：在 history 模式下指定<router-link to='/home' tag='button' replace>使用 replacestate 而不是 pushstate，此时浏览器的返回按钮将不能返回替换前的路由\n\n * active-class属性：当<router-link>对应的路由匹配成功的时候，会自动给当前元素设置一个router-link-active的 class，设置active-class属性值可以修改默认的名称。\n   \n   * 在进行高亮显示的导航菜单或者底部 tabbar 时，会用到该属性。但是通常不会修改类的属性，会直接使用默认的router-link-active\n   \n   * <router-link to='/home' tag='button' active-class='active'>此时被选中的<router-link>就会有 active 的 class。\n   \n   * 如果每个<router-link>都要加上active-class='active'，那就在路由里面统一更改。\n     \n     const router = new router({\n       //配置路由和组件之间的应用关系\n       routes,\n       mode: 'history', //修改模式为history\n       linkactiveclass: 'active',\n     })\n     \n     \n     1\n     2\n     3\n     4\n     5\n     6\n     \n\n\n# <router-view>\n\n用来占位的，就是路由对应的组件展示的地方，该标签会根据当前的路径，动态渲染出不同的组件。\n\n路由切换的时候切换的是它挂载的组件，其他不会发生改变。它默认使用 hash 模式，可以在 src/router/index.js 中配置修改为 history 模式。\n\n\n# 代码路由 🔥\n\n<template>\n  <div id=\"app\">\n    <div id=\"nav\">\n      \x3c!-- 当然也可以使用 router-link 和 tag 来实现。但是必须有 to 属性，所以自己斟酌使用场景。\n\t\t\t这里 button 也不会添加 class --\x3e\n      <button @click=\"gohome\">home</button>\n      <button @click=\"goabout\">about</button>\n    </div>\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'app',\n  methods: {\n    gohome() {\n      // vue-router 给所有组件都添加了 $router 属性。还有replace方法！\n      console.log(this.$route)\n      // 不判断，则第二次点击同一路由报错\n      if (this.$route.path !== '/home') {\n        this.$router.push('/home')\n      }\n    },\n    goabout() {\n      if (this.$route.path !== '/about') {\n        this.$router.push('/about')\n      }\n    },\n  },\n}\n<\/script>\n\n<style>\n#app {\n  font-family: avenir, helvetica, arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\n#nav {\n  padding: 30px;\n}\n\n#nav a {\n  font-weight: bold;\n  color: #2c3e50;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n\n\n\n# 动态路由 🔥\n\n由于路由中的 path是全匹配，例如/user查询所有用户，若此时 url 为/user/1则匹配不到，但是这个 1 又不能写死！\n\n{\n    path: '/user/:id',\n    name: 'user',\n    component: () => import('@/components/user')\n}\n\n\n1\n2\n3\n4\n5\n\n\n<router-link :to=\"'/user/' + user.id\">user</router-link>\n\x3c!-- user.id 为动态获取的 --\x3e\n\n\n1\n2\n\n\n<template>\n  <div>\n    <h1>user</h1>\n    <h2>{{ userid }}</h2>\n  </div>\n</template>\n\n<script>\nexport default {\n  computed: {\n    userid() {\n      // 拿到路由上的动态参数\n      return this.$route.params.id\n    },\n  },\n}\n<\/script>\n\n<style></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n注意，手动输入 url 即使匹配到路由，也不会添加 active class！\n\n\n# 路由懒加载 🔥\n\nvue-router 打包文件解析问题：打包时候 js 太大，页面响应缓慢\n\n如果组件模块化了，当路由被访问的时候才开始加载被选中的组件，这样就是路由懒加载。一个路由对应一个 js 文件。\n\ncomponent: () => import('@/components/user')\n\n\n1\n\n\n使用npm run build命令将之前创建的项目打包，打开 dist 文件夹，器目录结构如下：\n\n以下是 vue cli 2 的代码\n\n * app.xxx.js 是我们自己编写的业务代码\n * vendor.xxx.js 是第三方框架，例如 vue/vue-router/axios 等\n * mainfest.xxx.js 是为了打包的代码做底层支持的，一般是 webpack 帮我们做一些事情\n * 除了这三个还多了 2 个 js，这 2 个 js 文件（0.5bxxx.js 和 1.e5xxx.js）分别是 about 和 user 组件，因为这 2 个组件是懒加载的所以被分开打包了。\n\n此时因为是懒加载，需要用到这个组件的时候才会加载，所以不会一次性请求所有 js。\n\n\n# 嵌套路由 🔥\n\n平常在一个 home 页面中，我们可能需要/home/news和/home/message访问一些内容，一个路由映射一个组件就像后端一个 api 对应一个 controller 的一个 requestmapping 一样，访问两个路由也会分别渲染这两个组件。\n\n要实现嵌套路由：\n\n * 创建对应的子组件，并且在路由映射router/index.js中配置对应的子路由。\n\n * 在组件内部使用<router-view>标签来占位。\n\n// /router/index.js\n\nimport vue from 'vue'\nimport vuerouter from 'vue-router'\n\n// 安装路由插件功能\nvue.use(vuerouter)\n\n// 路由映射配置\nconst routes = [\n  {\n    path: '', // 或 \"/\" 都可以\n    name: 'index',\n    // 重定向\n    redirect: '/home',\n  },\n  {\n    path: '/home',\n    name: 'home',\n    component: () => import('@/components/home'),\n    children: [\n      {\n        path: '', // 或 \"/\" 都可以\n        // 后续也不这样使用，使用 keep-alive 来选择上次选择的路由\n        redirect: 'news',\n      },\n      {\n        // 不可以加 /，也不可以加 /home\n        path: 'news',\n        component: () => import('@/components/homenews'),\n      },\n      {\n        // 不可以加 /，也不可以加 /home\n        path: 'message',\n        component: () => import('@/components/homemessage'),\n      },\n    ],\n  },\n  {\n    path: '/about',\n    name: 'about',\n    // route level code-splitting\n    // this generates a separate chunk (about.[hash].js) for this route\n    // which is lazy-loaded when the route is visited.\n    component: () =>\n      import(/* webpackchunkname: \"about\" */ '@/components/about'),\n  },\n  {\n    path: '/user/:id',\n    name: 'user',\n    component: () => import('@/components/user'),\n  },\n]\n\n// 创建路由实例，传入路由映射配置\nconst router = new vuerouter({\n  // history模式\n  mode: 'history',\n  base: process.env.base_url,\n  routes,\n})\n\n// 导出\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n\x3c!-- /components/home.vue --\x3e\n\n<template>\n  <div>\n    <h1>home</h1>\n    <router-link to=\"/home/news\">news</router-link>｜\n    <router-link to=\"/home/message\">message</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'home',\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 传递参数 🔥\n\n路由跳转间传递参数\n\n\n# 方式一：动态路由 & params\n\n * 配置路由的格式：/user/:id\n * 传递时需要拼接，最终形成的路径：/user/123，/user/xxx\n * 通过$route.params.id获取指定 id\n\n代码查看动态路由\n\n\n# 方式二：query\n\n * 配置路由的格式：/profile，也就是普通的配置\n\n * 传递的方式：对象中使用 query 的 key 作为传递的方式\n\n * 传递形成的路径：/profile?name=conanan&age=18这个 query 传递的是两个键值对\n   \n   /profile?user=%5bobject%20object%5d这个 query 传递的是一个对象的键值对，key 为 user，value 是一个对象\n\n<template>\n  <div id=\"app\">\n    <div id=\"nav\">\n      <router-link to=\"/home\">home</router-link>|\n      <router-link to=\"/about\">about</router-link>|\n      <router-link :to=\"'/user/' + user.id\">user</router-link>|\n      <router-link\n        :to=\"{ path: '/profile', query: { name: 'conanan', age: 18 } }\"\n        >profile</router-link\n      >\n\n      \x3c!-- 当然也可以使用 router-link 和 tag 来实现。但是必须有 to 属性，所以自己斟酌使用场景。这里 button 也不会添加 class --\x3e\n      \x3c!-- <button @click=\"gohome\">home</button>\n      <button @click=\"goabout\">about</button>\n      <button @click=\"goprofile\">profile</button>--\x3e\n    </div>\n    <router-view />\n  </div>\n</template>\n\n<script>\nexport default {\n  name: 'app',\n  data() {\n    return {\n      user: {\n        id: 10001,\n      },\n    }\n  },\n  methods: {\n    gohome() {\n      // vue-router 给所有组件都添加了 $router 属性。还有replace方法！\n      console.log(this.$route)\n      // 不判断，则第二次点击同一路由报错\n      if (this.$route.path !== '/home') {\n        this.$router.push('/home')\n      }\n    },\n    goabout() {\n      if (this.$route.path !== '/about') {\n        this.$router.push('/about')\n      }\n    },\n    goprofile() {\n      if (this.$route.path !== '/profile') {\n        this.$router.push({\n          path: '/profile',\n          // query: { name: 'conanan', age: 18 }\n          query: {\n            user: {\n              name: 'conanan',\n              age: 25,\n            },\n          },\n        })\n      }\n    },\n  },\n}\n<\/script>\n\n<style>\n#app {\n  font-family: avenir, helvetica, arial, sans-serif;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n  text-align: center;\n  color: #2c3e50;\n}\n\n#nav {\n  padding: 30px;\n}\n\n#nav a {\n  font-weight: bold;\n  color: #2c3e50;\n}\n\n#nav a.router-link-active {\n  color: #42b983;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n\n\n\n# $router & $route 区别 🔥\n\nvue 全局对象this.$router与 main.js 导入的 router 对象是一个对象，也就是我们/router/index.js导出的对象 router，都是同一个 vuerouter 对象。因为所有的组件都继承自 vue 类的原型（prototype）\n\nthis.$route对象是当前处于活跃的路由，就是 router 中配置的映射关系，有 params 和 query 属性可以用来传递参数。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"入门",frontmatter:{title:"入门",date:"2020-12-28T00:14:45.000Z",permalink:"/pages/347f26/",categories:["x","基础"],tags:[null]},regularPath:"/1403.Vue3.x/100.%E5%9F%BA%E7%A1%80/101.%E5%85%A5%E9%97%A8.html",relativePath:"1403.Vue3.x/100.基础/101.入门.md",key:"v-7fdbdcfc",path:"/pages/347f26/",headers:[{level:2,title:"Vue.js 是什么",slug:"vue-js-是什么",normalizedTitle:"vue.js 是什么",charIndex:30},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:281},{level:3,title:"CDN",slug:"cdn",normalizedTitle:"cdn",charIndex:297},{level:3,title:"npm",slug:"npm",normalizedTitle:"npm",charIndex:431},{level:3,title:"CLI",slug:"cli",normalizedTitle:"cli",charIndex:439},{level:3,title:"Vite",slug:"vite",normalizedTitle:"vite",charIndex:447},{level:3,title:"对不同构建版本的解释",slug:"对不同构建版本的解释",normalizedTitle:"对不同构建版本的解释",charIndex:456},{level:2,title:"计数器",slug:"计数器",normalizedTitle:"计数器",charIndex:535},{level:3,title:"写法1",slug:"写法1",normalizedTitle:"写法1",charIndex:595},{level:3,title:"写法2",slug:"写法2",normalizedTitle:"写法2",charIndex:1784},{level:3,title:"写法3",slug:"写法3",normalizedTitle:"写法3",charIndex:3235},{level:2,title:"options",slug:"options",normalizedTitle:"options",charIndex:904},{level:3,title:"template",slug:"template",normalizedTitle:"template",charIndex:544},{level:3,title:"data",slug:"data",normalizedTitle:"data",charIndex:1135},{level:3,title:"methods",slug:"methods",normalizedTitle:"methods",charIndex:1218},{level:4,title:"this 绑定问题 🔥",slug:"this-绑定问题-🔥",normalizedTitle:"this 绑定问题 🔥",charIndex:5479},{level:2,title:"VSCode 代码片段 🔥",slug:"vscode-代码片段-🔥",normalizedTitle:"vscode 代码片段 🔥",charIndex:5717},{level:2,title:"v-bind 🔥",slug:"v-bind-🔥",normalizedTitle:"v-bind 🔥",charIndex:5844},{level:2,title:"Todo-List 及组件初识",slug:"todo-list-及组件初识",normalizedTitle:"todo-list 及组件初识",charIndex:5962},{level:2,title:"生命周期函数",slug:"生命周期函数",normalizedTitle:"生命周期函数",charIndex:8305}],headersStr:"Vue.js 是什么 安装 CDN npm CLI Vite 对不同构建版本的解释 计数器 写法1 写法2 写法3 options template data methods this 绑定问题 🔥 VSCode 代码片段 🔥 v-bind 🔥 Todo-List 及组件初识 生命周期函数",content:'# 入门\n\n代码\n\n配套的代码在 Github 中\n\n\n# Vue.js 是什么\n\nVue 是一套用于构建用户界面的渐进式框架（可以只用 Vue，根据后续需要使用其他如 Router、Vuex 等）。\n\n与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n特点如下：\n\n * 解耦视图和数据\n * 可复用的组件\n * 前端路由\n * 状态管理\n * 虚拟 DOM\n\n\n# 安装\n\n官方的安装文档\n\n\n# CDN\n\n对于制作原型或学习，你可以这样使用最新版本\n\n<script src="https://unpkg.com/vue@next"><\/script>\n\n\n1\n\n\n对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏\n\n\n# npm\n\n\n# CLI\n\n\n# Vite\n\n\n# 对不同构建版本的解释\n\n在 npm 包的 dist/ 目录你将会找到很多不同的 Vue.js 构建版本。这里列出了它们之间的差别：\n\n\n\n具体见文档\n\n\n# 计数器\n\n可以将 template 中内容写到 html 中，Vue2 的 el 已被 mount() 替代：\n\n\n# 写法1\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Hello World</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <script>\n      const options = {\n        // template中写么有提示，不方便。和#app不一样！，不能删掉#app\n        template: `\n          <button @click="decrement">-</button>\n          <span>{{counter}}</span>\n          <button @click="increment">+</button>\n        `,\n        data() {\n          return {\n            counter: 0,\n          }\n        },\n        methods: {\n          decrement() {\n            this.counter--\n          },\n          increment() {\n            this.counter++\n          },\n        },\n      }\n\n      // // Vue.createApp 创建 Vue 应用\n      // const app = Vue.createApp(options);\n      // // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      // const vm = app.mount(\'#root\');\n\n      // 可以链式编程：\n      const vm = Vue.createApp(options).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 写法2\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Hello World</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    \x3c!-- 这种提示也不清晰 --\x3e\n    \x3c!-- <script type="x-template" id="temp">\n      <button @click="decrement">-</button>\n      <span>{{counter}}</span>\n      <button @click="increment">+</button>\n    <\/script> --\x3e\n\n    \x3c!-- 推荐 --\x3e\n    <template id="temp">\n      <button @click="decrement">-</button>\n      <span>{{counter}}</span>\n      <button @click="increment">+</button>\n    </template>\n\n    <script>\n      const options = {\n        // 和#app不一样！，不能删掉#app\n        template: \'#temp\', //\n        data() {\n          return {\n            counter: 0,\n          }\n        },\n        methods: {\n          decrement() {\n            this.counter--\n          },\n          increment() {\n            this.counter++\n          },\n        },\n      }\n\n      // // Vue.createApp 创建 Vue 应用\n      // const app = Vue.createApp(options);\n      // // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      // const vm = app.mount(\'#root\');\n\n      // 可以链式编程：\n      const vm = Vue.createApp(options).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 写法3\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Hello World</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n  </head>\n  <body>\n    <div id="app">\n      <button @click="decrement">-</button>\n      <span>{{counter}}</span>\n      <button @click="increment">+</button>\n    </div>\n\n    <script>\n      const options = {\n        // 不写template也可以！\n        data() {\n          return {\n            counter: 0,\n          }\n        },\n        methods: {\n          decrement() {\n            this.counter--\n          },\n          increment() {\n            this.counter++\n          },\n        },\n      }\n\n      // // Vue.createApp 创建 Vue 应用\n      // const app = Vue.createApp(options);\n      // // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      // const vm = app.mount(\'#root\');\n\n      // 可以链式编程：\n      const vm = Vue.createApp(options).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# options\n\n\n# template\n\n表示的是Vue需要帮助我们渲染的模板信息。\n\n * 它里面有很多的HTML标签，这些标签会替换掉我们挂载到的元素（比如id为app的div）的innerHTML;模板中有一些奇怪的语法，比如 {{}}，比如 @click，这些都是模板特有的语法\n * 如果字符串以 # 开始，则它将被用作 querySelector，并使用匹配元素的 innerHTML 作为模板字符串\n\n有如下几种方式：\n\n * 直接写template里面，有点过于别扭了，并且IDE很有可能没有任何提示，阻碍我们编程的效率。Vue还提供了两种方式：\n\n * 使用script标签，并且标记它的类型为 x-template（和layui那种一样），设置id。\n   \n   <script type="x-template" id="temp"><\/script>\n   \n   template: \'#temp\', //\n   \n   \n   1\n   2\n   3\n   \n   \n   注意和mount(\'#app\')不一样！template: \'#temp\' 会把其内容渲染到 mount 中！\n\n * 使用任意标签（通常使用template标签，因为不会被浏览器渲染），设置id。🔥\n   \n   <template id="temp"></template>\n   \n   template: \'#temp\', //\n   \n   \n   1\n   2\n   3\n   \n   \n   注意和mount(\'#app\')不一样！template: \'#temp\' 会把其内容渲染到 mount 中！\n\n * 当然直接写在 mount 的元素中也可以！\n\n\n# data\n\n传入一个函数，并且该函数需要返回一个对象\n\n * 在Vue2.x的时候，也可以传入一个对象（虽然官方推荐是一个函数）\n * 在Vue3.x的时候，必须传入一个函数，否则就会直接在浏览器中报错\n\ndata 中返回的对象会被Vue的响应式系统劫持，之后对该对象的修改或者访问都会在劫持中被处理\n\n * 所以我们在template中通过 {{counter}} 访问counter，可以从对象中获取到数据\n * 我们修改counter的值时，template中的 {{counter}}也会发生改变;\n\n\n# methods\n\nmethods属性是一个对象，通常我们会在这个对象中定义很多的方法：\n\n * 这些方法可以被绑定到 template 模板中;\n * 在该方法中，我们可以使用this关键字来直接访问到data中返回的对象的属性\n\n# this 绑定问题 🔥\n\n * methods 的方法定义为什么不能使用箭头函数（官方文档有给出解释）\n\n * 不使用箭头函数的情况下，this到底指向的是什么? 是 window\n   \n   箭头函数使用this的查找规则，它会在自己的上层作用于中来查找this，最终刚好找到的是script作用于中的this，所以就是window 🔥。\n\n * vue源码中使用 bind 绑定 publicThis 到每个 method 上，存入 ctx[methos]\n\n\n# VSCode 代码片段 🔥\n\n * 第一步，复制自己需要生成代码片段的代码;\n\n * 第二步，https://snippet-generator.app/在该网站中生成代码片段;\n\n * 第三步，在VSCode中配置代码片段;\n   \n   \n\n\n# v-bind 🔥\n\n * 一般使用：v-bind:src=\'src\'或简写:src=\'src\'。只能传递单独的值\n * 在封装高级组件时（底层是如Element的组件），可以使用v-bind=\'info\'来传递info对象！\n\n\n# Todo-List 及组件初识\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Hello World</title>\n  </head>\n  <body>\n    <div id="root">\n      <div>\n        <input v-model="item" />\n        <button @click="handleAddItem" :title="item">添加</button>\n        <ul>\n          <li v-for="(item,index) in list">\n            <todo-item\n              :item="item"\n              :index="index"\n              @handle-delete-item="handleDeleteItem"\n            />\n          </li>\n        </ul>\n      </div>\n    </div>\n\n    \x3c!-- 组件模版分离 --\x3e\n    <template id="todo-item">\n      <span>{{index+1}}</span>\n      <span>--</span>\n      <span>{{item}}</span>\n      <button @click="handleDeleteItem(index)">删除</button>\n    </template>\n\n    <script src="https://unpkg.com/vue@next"><\/script>\n    <script>\n      let options = {\n        data() {\n          return {\n            item: \'\',\n            list: [],\n          }\n        },\n        methods: {\n          handleAddItem() {\n            this.list.push(this.item)\n            this.item = \'\'\n          },\n          handleDeleteItem(index) {\n            this.list.splice(index, 1)\n          },\n        },\n      }\n\n      // Vue.createApp 创建 Vue 应用，存储到 app 中\n      //传入的参数表示，这个应用最外层的组件，该如何展示\n      const app = Vue.createApp(options)\n\n      // 组件\n      app.component(\'todo-item\', {\n        template: `#todo-item`,\n        props: {\n          item: {\n            type: String,\n            default: \'\',\n          },\n          index: {\n            type: Number,\n            default: 0,\n          },\n        },\n        emits: [\'handle-delete-item\'],\n        methods: {\n          handleDeleteItem(index) {\n            this.$emit(\'handle-delete-item\', index)\n          },\n        },\n      })\n\n      // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      // vm 就是 vue 应用的根组件\n      // mvvm 模式，m model 数据， v view 视图，vm viewModal视图数据连接层\n      const vm = app.mount(\'#root\')\n\n      // 改变数据\n      // vm.$data.item = \'测试课程\'\n      // vm.item = \'测试课程\'\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 生命周期函数\n\n注意 Vue2 的 destroy 等已被 unmount 等取代\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Hello World</title>\n  </head>\n  <body>\n    <div id="root">\n      <div>{{counter}}</div>\n    </div>\n\n    <script src="https://unpkg.com/vue@next"><\/script>\n    <script>\n      // 生命周期函数：在某一刻会自动执行的函数\n      // 执行完 Vue.createApp 并且 mount 后开始进行生命周期函数\n\n      let options = {\n        data() {\n          return {\n            counter: 1,\n          }\n        },\n        beforeCreate() {\n          console.log(\n            \'=====[beforeCreate]: after init events & lifecycle。事件绑定、生命周期函数等。即 Vue 应用生成之前，Vue.createApp\',\n            \'。root innerHTML: \',\n            document.getElementById(\'root\').innerHTML // 空\n          )\n        },\n        created() {\n          console.log(\n            \'=====[created]: after init injections & reactivity。依赖注入、响应式（数据双向绑定）等。即 Vue 应用生成之后，Vue.createApp\',\n            \'。root innerHTML: \',\n            document.getElementById(\'root\').innerHTML // 空\n          )\n        },\n        // 组件中有 template 则编译为 render 函数，没有则使用 mount 挂载的 el DOM 元素作为 template 进行编译\n        beforeMount() {\n          console.log(\n            \'=====[beforeMount]: template（或 el） 的 innerHtml 被编译成render函数后。或称为组件被渲染到页面前。app.mount()\',\n            \'。root innerHTML: \',\n            document.getElementById(\'root\').innerHTML // 空，此时没有任何内容！\n          )\n        },\n        mounted() {\n          console.log(\n            \'=====[mounted]: after Create app.$el and replace "el" with it。 组件被渲染到页面后。此时页面的所有数据都可以正常展示！！！app.mount()\',\n            \'。root innerHTML: \',\n            document.getElementById(\'root\').innerHTML // <div>1</div>\n          )\n        },\n        beforeUpdate() {\n          // 执行 vm.counter ++ 改变了 data 中数据即可\n          console.log(\n            \'=====[beforeUpdate]: when data change, before Virtual DOM re-rendered and patch。即 data 变化，且页面重新渲染前执行\',\n            \'。root innerHTML: \',\n            document.getElementById(\'root\').innerHTML // <div>1</div>\n          )\n        },\n        updated() {\n          // 执行 vm.counter ++ 改变了 data 中数据即可\n          console.log(\n            \'=====[updated]: when data change, after Virtual DOM re-rendered and patch。即 data 变化，且页面重新渲染后执行\',\n            \'。root innerHTML: \',\n\n            document.getElementById(\'root\').innerHTML // <div>2</div>\n          )\n        },\n        beforeUnmount() {\n          console.log(\n            \'=====[beforeUnmount]: when app.unmount() is called。即 Vue 应用失效时，类比 beforeMount\',\n            \'。root innerHTML: \',\n            document.getElementById(\'root\').innerHTML // <div>2</div>\n          )\n        },\n        unmounted() {\n          console.log(\n            \'=====[unmounted]: when app.unmount() is called。即 Vue 应用失效，且 DOM 完全销毁之后，类比 mounted\',\n            \'。root innerHTML: \',\n            document.getElementById(\'root\').innerHTML // 空\n          )\n        },\n      }\n\n      // Vue.createApp 创建 Vue 应用\n      // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      const app = Vue.createApp(options)\n      const vm = app.mount(\'#root\')\n\n      // vm.$data.counter = 2\n      vm.counter = 2\n      // app.unmount()\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n',normalizedContent:'# 入门\n\n代码\n\n配套的代码在 github 中\n\n\n# vue.js 是什么\n\nvue 是一套用于构建用户界面的渐进式框架（可以只用 vue，根据后续需要使用其他如 router、vuex 等）。\n\n与其它大型框架不同的是，vue 被设计为可以自底向上逐层应用。vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，vue 也完全能够为复杂的单页应用提供驱动。\n\n特点如下：\n\n * 解耦视图和数据\n * 可复用的组件\n * 前端路由\n * 状态管理\n * 虚拟 dom\n\n\n# 安装\n\n官方的安装文档\n\n\n# cdn\n\n对于制作原型或学习，你可以这样使用最新版本\n\n<script src="https://unpkg.com/vue@next"><\/script>\n\n\n1\n\n\n对于生产环境，我们推荐链接到一个明确的版本号和构建文件，以避免新版本造成的不可预期的破坏\n\n\n# npm\n\n\n# cli\n\n\n# vite\n\n\n# 对不同构建版本的解释\n\n在 npm 包的 dist/ 目录你将会找到很多不同的 vue.js 构建版本。这里列出了它们之间的差别：\n\n\n\n具体见文档\n\n\n# 计数器\n\n可以将 template 中内容写到 html 中，vue2 的 el 已被 mount() 替代：\n\n\n# 写法1\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>hello world</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <script>\n      const options = {\n        // template中写么有提示，不方便。和#app不一样！，不能删掉#app\n        template: `\n          <button @click="decrement">-</button>\n          <span>{{counter}}</span>\n          <button @click="increment">+</button>\n        `,\n        data() {\n          return {\n            counter: 0,\n          }\n        },\n        methods: {\n          decrement() {\n            this.counter--\n          },\n          increment() {\n            this.counter++\n          },\n        },\n      }\n\n      // // vue.createapp 创建 vue 应用\n      // const app = vue.createapp(options);\n      // // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      // const vm = app.mount(\'#root\');\n\n      // 可以链式编程：\n      const vm = vue.createapp(options).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# 写法2\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>hello world</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    \x3c!-- 这种提示也不清晰 --\x3e\n    \x3c!-- <script type="x-template" id="temp">\n      <button @click="decrement">-</button>\n      <span>{{counter}}</span>\n      <button @click="increment">+</button>\n    <\/script> --\x3e\n\n    \x3c!-- 推荐 --\x3e\n    <template id="temp">\n      <button @click="decrement">-</button>\n      <span>{{counter}}</span>\n      <button @click="increment">+</button>\n    </template>\n\n    <script>\n      const options = {\n        // 和#app不一样！，不能删掉#app\n        template: \'#temp\', //\n        data() {\n          return {\n            counter: 0,\n          }\n        },\n        methods: {\n          decrement() {\n            this.counter--\n          },\n          increment() {\n            this.counter++\n          },\n        },\n      }\n\n      // // vue.createapp 创建 vue 应用\n      // const app = vue.createapp(options);\n      // // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      // const vm = app.mount(\'#root\');\n\n      // 可以链式编程：\n      const vm = vue.createapp(options).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n\n\n\n# 写法3\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>hello world</title>\n    <script src="https://unpkg.com/vue@next"><\/script>\n  </head>\n  <body>\n    <div id="app">\n      <button @click="decrement">-</button>\n      <span>{{counter}}</span>\n      <button @click="increment">+</button>\n    </div>\n\n    <script>\n      const options = {\n        // 不写template也可以！\n        data() {\n          return {\n            counter: 0,\n          }\n        },\n        methods: {\n          decrement() {\n            this.counter--\n          },\n          increment() {\n            this.counter++\n          },\n        },\n      }\n\n      // // vue.createapp 创建 vue 应用\n      // const app = vue.createapp(options);\n      // // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      // const vm = app.mount(\'#root\');\n\n      // 可以链式编程：\n      const vm = vue.createapp(options).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# options\n\n\n# template\n\n表示的是vue需要帮助我们渲染的模板信息。\n\n * 它里面有很多的html标签，这些标签会替换掉我们挂载到的元素（比如id为app的div）的innerhtml;模板中有一些奇怪的语法，比如 {{}}，比如 @click，这些都是模板特有的语法\n * 如果字符串以 # 开始，则它将被用作 queryselector，并使用匹配元素的 innerhtml 作为模板字符串\n\n有如下几种方式：\n\n * 直接写template里面，有点过于别扭了，并且ide很有可能没有任何提示，阻碍我们编程的效率。vue还提供了两种方式：\n\n * 使用script标签，并且标记它的类型为 x-template（和layui那种一样），设置id。\n   \n   <script type="x-template" id="temp"><\/script>\n   \n   template: \'#temp\', //\n   \n   \n   1\n   2\n   3\n   \n   \n   注意和mount(\'#app\')不一样！template: \'#temp\' 会把其内容渲染到 mount 中！\n\n * 使用任意标签（通常使用template标签，因为不会被浏览器渲染），设置id。🔥\n   \n   <template id="temp"></template>\n   \n   template: \'#temp\', //\n   \n   \n   1\n   2\n   3\n   \n   \n   注意和mount(\'#app\')不一样！template: \'#temp\' 会把其内容渲染到 mount 中！\n\n * 当然直接写在 mount 的元素中也可以！\n\n\n# data\n\n传入一个函数，并且该函数需要返回一个对象\n\n * 在vue2.x的时候，也可以传入一个对象（虽然官方推荐是一个函数）\n * 在vue3.x的时候，必须传入一个函数，否则就会直接在浏览器中报错\n\ndata 中返回的对象会被vue的响应式系统劫持，之后对该对象的修改或者访问都会在劫持中被处理\n\n * 所以我们在template中通过 {{counter}} 访问counter，可以从对象中获取到数据\n * 我们修改counter的值时，template中的 {{counter}}也会发生改变;\n\n\n# methods\n\nmethods属性是一个对象，通常我们会在这个对象中定义很多的方法：\n\n * 这些方法可以被绑定到 template 模板中;\n * 在该方法中，我们可以使用this关键字来直接访问到data中返回的对象的属性\n\n# this 绑定问题 🔥\n\n * methods 的方法定义为什么不能使用箭头函数（官方文档有给出解释）\n\n * 不使用箭头函数的情况下，this到底指向的是什么? 是 window\n   \n   箭头函数使用this的查找规则，它会在自己的上层作用于中来查找this，最终刚好找到的是script作用于中的this，所以就是window 🔥。\n\n * vue源码中使用 bind 绑定 publicthis 到每个 method 上，存入 ctx[methos]\n\n\n# vscode 代码片段 🔥\n\n * 第一步，复制自己需要生成代码片段的代码;\n\n * 第二步，https://snippet-generator.app/在该网站中生成代码片段;\n\n * 第三步，在vscode中配置代码片段;\n   \n   \n\n\n# v-bind 🔥\n\n * 一般使用：v-bind:src=\'src\'或简写:src=\'src\'。只能传递单独的值\n * 在封装高级组件时（底层是如element的组件），可以使用v-bind=\'info\'来传递info对象！\n\n\n# todo-list 及组件初识\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>hello world</title>\n  </head>\n  <body>\n    <div id="root">\n      <div>\n        <input v-model="item" />\n        <button @click="handleadditem" :title="item">添加</button>\n        <ul>\n          <li v-for="(item,index) in list">\n            <todo-item\n              :item="item"\n              :index="index"\n              @handle-delete-item="handledeleteitem"\n            />\n          </li>\n        </ul>\n      </div>\n    </div>\n\n    \x3c!-- 组件模版分离 --\x3e\n    <template id="todo-item">\n      <span>{{index+1}}</span>\n      <span>--</span>\n      <span>{{item}}</span>\n      <button @click="handledeleteitem(index)">删除</button>\n    </template>\n\n    <script src="https://unpkg.com/vue@next"><\/script>\n    <script>\n      let options = {\n        data() {\n          return {\n            item: \'\',\n            list: [],\n          }\n        },\n        methods: {\n          handleadditem() {\n            this.list.push(this.item)\n            this.item = \'\'\n          },\n          handledeleteitem(index) {\n            this.list.splice(index, 1)\n          },\n        },\n      }\n\n      // vue.createapp 创建 vue 应用，存储到 app 中\n      //传入的参数表示，这个应用最外层的组件，该如何展示\n      const app = vue.createapp(options)\n\n      // 组件\n      app.component(\'todo-item\', {\n        template: `#todo-item`,\n        props: {\n          item: {\n            type: string,\n            default: \'\',\n          },\n          index: {\n            type: number,\n            default: 0,\n          },\n        },\n        emits: [\'handle-delete-item\'],\n        methods: {\n          handledeleteitem(index) {\n            this.$emit(\'handle-delete-item\', index)\n          },\n        },\n      })\n\n      // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      // vm 就是 vue 应用的根组件\n      // mvvm 模式，m model 数据， v view 视图，vm viewmodal视图数据连接层\n      const vm = app.mount(\'#root\')\n\n      // 改变数据\n      // vm.$data.item = \'测试课程\'\n      // vm.item = \'测试课程\'\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n\n\n\n# 生命周期函数\n\n注意 vue2 的 destroy 等已被 unmount 等取代\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>hello world</title>\n  </head>\n  <body>\n    <div id="root">\n      <div>{{counter}}</div>\n    </div>\n\n    <script src="https://unpkg.com/vue@next"><\/script>\n    <script>\n      // 生命周期函数：在某一刻会自动执行的函数\n      // 执行完 vue.createapp 并且 mount 后开始进行生命周期函数\n\n      let options = {\n        data() {\n          return {\n            counter: 1,\n          }\n        },\n        beforecreate() {\n          console.log(\n            \'=====[beforecreate]: after init events & lifecycle。事件绑定、生命周期函数等。即 vue 应用生成之前，vue.createapp\',\n            \'。root innerhtml: \',\n            document.getelementbyid(\'root\').innerhtml // 空\n          )\n        },\n        created() {\n          console.log(\n            \'=====[created]: after init injections & reactivity。依赖注入、响应式（数据双向绑定）等。即 vue 应用生成之后，vue.createapp\',\n            \'。root innerhtml: \',\n            document.getelementbyid(\'root\').innerhtml // 空\n          )\n        },\n        // 组件中有 template 则编译为 render 函数，没有则使用 mount 挂载的 el dom 元素作为 template 进行编译\n        beforemount() {\n          console.log(\n            \'=====[beforemount]: template（或 el） 的 innerhtml 被编译成render函数后。或称为组件被渲染到页面前。app.mount()\',\n            \'。root innerhtml: \',\n            document.getelementbyid(\'root\').innerhtml // 空，此时没有任何内容！\n          )\n        },\n        mounted() {\n          console.log(\n            \'=====[mounted]: after create app.$el and replace "el" with it。 组件被渲染到页面后。此时页面的所有数据都可以正常展示！！！app.mount()\',\n            \'。root innerhtml: \',\n            document.getelementbyid(\'root\').innerhtml // <div>1</div>\n          )\n        },\n        beforeupdate() {\n          // 执行 vm.counter ++ 改变了 data 中数据即可\n          console.log(\n            \'=====[beforeupdate]: when data change, before virtual dom re-rendered and patch。即 data 变化，且页面重新渲染前执行\',\n            \'。root innerhtml: \',\n            document.getelementbyid(\'root\').innerhtml // <div>1</div>\n          )\n        },\n        updated() {\n          // 执行 vm.counter ++ 改变了 data 中数据即可\n          console.log(\n            \'=====[updated]: when data change, after virtual dom re-rendered and patch。即 data 变化，且页面重新渲染后执行\',\n            \'。root innerhtml: \',\n\n            document.getelementbyid(\'root\').innerhtml // <div>2</div>\n          )\n        },\n        beforeunmount() {\n          console.log(\n            \'=====[beforeunmount]: when app.unmount() is called。即 vue 应用失效时，类比 beforemount\',\n            \'。root innerhtml: \',\n            document.getelementbyid(\'root\').innerhtml // <div>2</div>\n          )\n        },\n        unmounted() {\n          console.log(\n            \'=====[unmounted]: when app.unmount() is called。即 vue 应用失效，且 dom 完全销毁之后，类比 mounted\',\n            \'。root innerhtml: \',\n            document.getelementbyid(\'root\').innerhtml // 空\n          )\n        },\n      }\n\n      // vue.createapp 创建 vue 应用\n      // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      const app = vue.createapp(options)\n      const vm = app.mount(\'#root\')\n\n      // vm.$data.counter = 2\n      vm.counter = 2\n      // app.unmount()\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n\n\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"模版语法&指令",frontmatter:{title:"模版语法&指令",date:"2020-12-29T00:31:22.000Z",permalink:"/pages/47f5c4/",categories:["x","基础"],tags:[null]},regularPath:"/1403.Vue3.x/100.%E5%9F%BA%E7%A1%80/102.%E6%A8%A1%E7%89%88%E8%AF%AD%E6%B3%95&%E6%8C%87%E4%BB%A4.html",relativePath:"1403.Vue3.x/100.基础/102.模版语法&指令.md",key:"v-2cd89bf0",path:"/pages/47f5c4/",headers:[{level:2,title:"基础",slug:"基础",normalizedTitle:"基础",charIndex:14},{level:2,title:"v-bind 🔥",slug:"v-bind-🔥",normalizedTitle:"v-bind 🔥",charIndex:111},{level:3,title:"绑定 class",slug:"绑定-class",normalizedTitle:"绑定 class",charIndex:125},{level:3,title:"绑定 style",slug:"绑定-style",normalizedTitle:"绑定 style",charIndex:138},{level:3,title:"动态属性—封装组件 🔥",slug:"动态属性-封装组件-🔥",normalizedTitle:"动态属性—封装组件 🔥",charIndex:151},{level:3,title:"绑定对象—封装组件传递 prop 🔥",slug:"绑定对象-封装组件传递-prop-🔥",normalizedTitle:"绑定对象—封装组件传递 prop 🔥",charIndex:920},{level:2,title:"v-on 🔥",slug:"v-on-🔥",normalizedTitle:"v-on 🔥",charIndex:1845},{level:3,title:"基本&绑定对象—封装组件 🔥",slug:"基本-绑定对象-封装组件-🔥",normalizedTitle:"基本&amp;绑定对象—封装组件 🔥",charIndex:null},{level:3,title:"参数传递 🔥",slug:"参数传递-🔥",normalizedTitle:"参数传递 🔥",charIndex:3460},{level:3,title:"修饰符",slug:"修饰符",normalizedTitle:"修饰符",charIndex:4589}],headersStr:"基础 v-bind 🔥 绑定 class 绑定 style 动态属性—封装组件 🔥 绑定对象—封装组件传递 prop 🔥 v-on 🔥 基本&绑定对象—封装组件 🔥 参数传递 🔥 修饰符",content:'# 模版语法&指令\n\n\n# 基础\n\n * 插值表达式 {{}} Mustache\n * v-html\n * v-text\n * v-once\n * v-pre\n * v-cloak\n * 过滤器（3.0后没有了）\n\n\n# v-bind 🔥\n\n\n# 绑定 class\n\n\n# 绑定 style\n\n\n# 动态属性—封装组件 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      <div :[name]="value">哈哈哈</div>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const App = {\n        template: \'#my-app\',\n        data() {\n          return {\n            name: \'cba\',\n            value: \'kobe\',\n          }\n        },\n      }\n\n      Vue.createApp(App).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 绑定对象—封装组件传递 prop 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      <div v-bind="info">哈哈哈哈</div>\n      \x3c!-- 可以这样写，就是阅读性太差，官方文档也没这样写 --\x3e\n      <div :="info">哈哈哈哈</div>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const App = {\n        template: \'#my-app\',\n        data() {\n          return {\n            info: {\n              name: \'why\',\n              age: 18,\n              height: 1.88,\n            },\n          }\n        },\n      }\n\n      Vue.createApp(App).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# v-on 🔥\n\n\n# 基本&绑定对象—封装组件 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n\n    <style>\n      .area {\n        width: 200px;\n        height: 200px;\n        background: red;\n      }\n    </style>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      \x3c!-- 完整写法: v-on:监听的事件="methods中方法" --\x3e\n      <button v-on:click="btn1Click">按钮1</button>\n      <div class="area" v-on:mousemove="mouseMove">div</div>\n      \x3c!-- 语法糖 --\x3e\n      <button @click="btn1Click">按钮1</button>\n      \x3c!-- 绑定一个表达式: inline statement --\x3e\n      <button @click="counter++">{{counter}}</button>\n      \x3c!-- 绑定一个对象 --\x3e\n      <div class="area" v-on="{click: btn1Click, mousemove: mouseMove}"></div>\n      <div class="area" @="{click: btn1Click, mousemove: mouseMove}"></div>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const App = {\n        template: \'#my-app\',\n        data() {\n          return {\n            message: \'Hello World\',\n            counter: 100,\n          }\n        },\n        methods: {\n          btn1Click() {\n            console.log(\'按钮1发生了点击\')\n          },\n          mouseMove() {\n            console.log(\'鼠标移动\')\n          },\n        },\n      }\n\n      Vue.createApp(App).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 参数传递 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      \x3c!-- 默认传入event对象, 可以在方法中获取 --\x3e\n      <button @click="btn1Click">按钮1</button>\n      \x3c!-- $event可以获取到事件发生时的事件对象 --\x3e\n      <button @click="btn2Click($event, \'coderwhy\', 18)">按钮2</button>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const App = {\n        template: \'#my-app\',\n        data() {\n          return {\n            message: \'Hello World\',\n          }\n        },\n        methods: {\n          btn1Click(event) {\n            console.log(event)\n          },\n          btn2Click(event, name, age) {\n            console.log(name, age, event)\n          },\n        },\n      }\n\n      Vue.createApp(App).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 修饰符',normalizedContent:'# 模版语法&指令\n\n\n# 基础\n\n * 插值表达式 {{}} mustache\n * v-html\n * v-text\n * v-once\n * v-pre\n * v-cloak\n * 过滤器（3.0后没有了）\n\n\n# v-bind 🔥\n\n\n# 绑定 class\n\n\n# 绑定 style\n\n\n# 动态属性—封装组件 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      <div :[name]="value">哈哈哈</div>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const app = {\n        template: \'#my-app\',\n        data() {\n          return {\n            name: \'cba\',\n            value: \'kobe\',\n          }\n        },\n      }\n\n      vue.createapp(app).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# 绑定对象—封装组件传递 prop 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      <div v-bind="info">哈哈哈哈</div>\n      \x3c!-- 可以这样写，就是阅读性太差，官方文档也没这样写 --\x3e\n      <div :="info">哈哈哈哈</div>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const app = {\n        template: \'#my-app\',\n        data() {\n          return {\n            info: {\n              name: \'why\',\n              age: 18,\n              height: 1.88,\n            },\n          }\n        },\n      }\n\n      vue.createapp(app).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# v-on 🔥\n\n\n# 基本&绑定对象—封装组件 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n\n    <style>\n      .area {\n        width: 200px;\n        height: 200px;\n        background: red;\n      }\n    </style>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      \x3c!-- 完整写法: v-on:监听的事件="methods中方法" --\x3e\n      <button v-on:click="btn1click">按钮1</button>\n      <div class="area" v-on:mousemove="mousemove">div</div>\n      \x3c!-- 语法糖 --\x3e\n      <button @click="btn1click">按钮1</button>\n      \x3c!-- 绑定一个表达式: inline statement --\x3e\n      <button @click="counter++">{{counter}}</button>\n      \x3c!-- 绑定一个对象 --\x3e\n      <div class="area" v-on="{click: btn1click, mousemove: mousemove}"></div>\n      <div class="area" @="{click: btn1click, mousemove: mousemove}"></div>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const app = {\n        template: \'#my-app\',\n        data() {\n          return {\n            message: \'hello world\',\n            counter: 100,\n          }\n        },\n        methods: {\n          btn1click() {\n            console.log(\'按钮1发生了点击\')\n          },\n          mousemove() {\n            console.log(\'鼠标移动\')\n          },\n        },\n      }\n\n      vue.createapp(app).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n\n\n\n# 参数传递 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      \x3c!-- 默认传入event对象, 可以在方法中获取 --\x3e\n      <button @click="btn1click">按钮1</button>\n      \x3c!-- $event可以获取到事件发生时的事件对象 --\x3e\n      <button @click="btn2click($event, \'coderwhy\', 18)">按钮2</button>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const app = {\n        template: \'#my-app\',\n        data() {\n          return {\n            message: \'hello world\',\n          }\n        },\n        methods: {\n          btn1click(event) {\n            console.log(event)\n          },\n          btn2click(event, name, age) {\n            console.log(name, age, event)\n          },\n        },\n      }\n\n      vue.createapp(app).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 修饰符',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"条件渲染&列表渲染",frontmatter:{title:"条件渲染&列表渲染",date:"2022-01-13T21:11:35.000Z",permalink:"/pages/3dbba2/",categories:["x","基础"],tags:[null]},regularPath:"/1403.Vue3.x/100.%E5%9F%BA%E7%A1%80/103.%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93&%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93.html",relativePath:"1403.Vue3.x/100.基础/103.条件渲染&列表渲染.md",key:"v-0a8a952c",path:"/pages/3dbba2/",headers:[{level:2,title:"v-if & v-show",slug:"v-if-v-show",normalizedTitle:"v-if &amp; v-show",charIndex:null},{level:2,title:"v-for",slug:"v-for",normalizedTitle:"v-for",charIndex:106},{level:3,title:"数组更新检测 🔥",slug:"数组更新检测-🔥",normalizedTitle:"数组更新检测 🔥",charIndex:162},{level:3,title:"key 的作用 🔥",slug:"key-的作用-🔥",normalizedTitle:"key 的作用 🔥",charIndex:301},{level:3,title:"VNode 🔥",slug:"vnode-🔥",normalizedTitle:"vnode 🔥",charIndex:464},{level:3,title:"虚拟DOM 🔥",slug:"虚拟dom-🔥",normalizedTitle:"虚拟dom 🔥",charIndex:548},{level:3,title:"Vue 源码对于 key 的判断",slug:"vue-源码对于-key-的判断",normalizedTitle:"vue 源码对于 key 的判断",charIndex:615},{level:3,title:"没有 key 时的 diff 算法 🔥",slug:"没有-key-时的-diff-算法-🔥",normalizedTitle:"没有 key 时的 diff 算法 🔥",charIndex:707},{level:3,title:"有 key 时的 diff 算法 🔥",slug:"有-key-时的-diff-算法-🔥",normalizedTitle:"有 key 时的 diff 算法 🔥",charIndex:708}],headersStr:"v-if & v-show v-for 数组更新检测 🔥 key 的作用 🔥 VNode 🔥 虚拟DOM 🔥 Vue 源码对于 key 的判断 没有 key 时的 diff 算法 🔥 有 key 时的 diff 算法 🔥",content:"# 条件渲染&列表渲染\n\n\n# v-if & v-show\n\n * v-show就是 display: none\n * v-show不支持 template\n * v-show不能和v-else一起使用\n\n\n# v-for\n\n也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法\n\n\n# 数组更新检测 🔥\n\n * push()：添加到最后\n\n * pop()：弹出最前面的\n\n * shift()：弹出最后面的\n\n * unshift()：添加到最前面\n\n * splice()：增删改都可以\n\n * sort()：排序\n\n * reverse()：反转\n\n\n# key 的作用 🔥\n\n * key属性主要用在Vue的虚拟DOM算法，在新旧nodes对比时辨识VNodes\n * 如果不使用key，Vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法\n * 而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素\n\n\n# VNode 🔥\n\n全称是Virtual Node，即虚拟节点\n\n无论组件还是元素，在Vue中表示出来都是一个个VNode。是一个Javascript对象\n\n\n\n\n# 虚拟DOM 🔥\n\n如果页面不是一个简单的元素（如div），而是许多元素，那么他们会形成一个个VNode，整体称作虚拟DOM\n\n\n# Vue 源码对于 key 的判断\n\n基于v3.2.9版本\n\n在/vue-next/packages/runtime-core/src/renderer.ts的1600行中\n\n\n\n\n# 没有 key 时的 diff 算法 🔥\n\n\n\n上面的diff算法效率并不高：\n\n * c和d来说它们事实上并不需要有任何的改动\n * 但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增\n\n\n\n\n# 有 key 时的 diff 算法 🔥\n\n\n\n 1. 第一步的操作是从头开始进行遍历、比较\n    \n    1. a和b是一致的会继续进行比较;\n    2. c和f因为key不一致，所以就会break跳出循环;\n    \n    \n\n 2. 第二步的操作是从尾部开始进行遍历、比较:\n    \n    \n\n 3. 第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点（i>e1 && i<=e2)\n    \n    \n\n 4. 第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点\n    \n    \n\n 5. 第五步是最特色的情况，中间还有很多未知的或者乱序的节点\n    \n    \n    \n    可以发现，Vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作：\n    \n    * 在没有key的时候我们的效率是非常低效的;\n    * 在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效;",normalizedContent:"# 条件渲染&列表渲染\n\n\n# v-if & v-show\n\n * v-show就是 display: none\n * v-show不支持 template\n * v-show不能和v-else一起使用\n\n\n# v-for\n\n也可以用 of 替代 in 作为分隔符，因为它更接近 javascript 迭代器的语法\n\n\n# 数组更新检测 🔥\n\n * push()：添加到最后\n\n * pop()：弹出最前面的\n\n * shift()：弹出最后面的\n\n * unshift()：添加到最前面\n\n * splice()：增删改都可以\n\n * sort()：排序\n\n * reverse()：反转\n\n\n# key 的作用 🔥\n\n * key属性主要用在vue的虚拟dom算法，在新旧nodes对比时辨识vnodes\n * 如果不使用key，vue会使用一种最大限度减少动态元素并且尽可能的尝试就地修改/复用相同类型元素的算法\n * 而使用key时，它会基于key的变化重新排列元素顺序，并且会移除/销毁key不存在的元素\n\n\n# vnode 🔥\n\n全称是virtual node，即虚拟节点\n\n无论组件还是元素，在vue中表示出来都是一个个vnode。是一个javascript对象\n\n\n\n\n# 虚拟dom 🔥\n\n如果页面不是一个简单的元素（如div），而是许多元素，那么他们会形成一个个vnode，整体称作虚拟dom\n\n\n# vue 源码对于 key 的判断\n\n基于v3.2.9版本\n\n在/vue-next/packages/runtime-core/src/renderer.ts的1600行中\n\n\n\n\n# 没有 key 时的 diff 算法 🔥\n\n\n\n上面的diff算法效率并不高：\n\n * c和d来说它们事实上并不需要有任何的改动\n * 但是因为我们的c被f所使用了，所有后续所有的内容都要一次进行改动，并且最后进行新增\n\n\n\n\n# 有 key 时的 diff 算法 🔥\n\n\n\n 1. 第一步的操作是从头开始进行遍历、比较\n    \n    1. a和b是一致的会继续进行比较;\n    2. c和f因为key不一致，所以就会break跳出循环;\n    \n    \n\n 2. 第二步的操作是从尾部开始进行遍历、比较:\n    \n    \n\n 3. 第三步是如果旧节点遍历完毕，但是依然有新的节点，那么就新增节点（i>e1 && i<=e2)\n    \n    \n\n 4. 第四步是如果新的节点遍历完毕，但是依然有旧的节点，那么就移除旧节点\n    \n    \n\n 5. 第五步是最特色的情况，中间还有很多未知的或者乱序的节点\n    \n    \n    \n    可以发现，vue在进行diff算法的时候，会尽量利用我们的key来进行优化操作：\n    \n    * 在没有key的时候我们的效率是非常低效的;\n    * 在进行插入或者重置顺序的时候，保持相同的key可以让diff算法更加的高效;",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"计算属性 & 侦听器",frontmatter:{title:null,date:"2022-01-15T20:58:32.000Z",permalink:"/pages/af8c61/",categories:["x","基础"],tags:[null]},regularPath:"/1403.Vue3.x/100.%E5%9F%BA%E7%A1%80/104.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7&%E4%BE%A6%E5%90%AC%E5%99%A8.html",relativePath:"1403.Vue3.x/100.基础/104.计算属性&侦听器.md",key:"v-155f6902",path:"/pages/af8c61/",headers:[{level:2,title:"计算属性 computed 🔥",slug:"计算属性-computed-🔥",normalizedTitle:"计算属性 computed 🔥",charIndex:17},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:38},{level:3,title:"计算属性的setter和getter",slug:"计算属性的setter和getter",normalizedTitle:"计算属性的setter和getter",charIndex:234},{level:3,title:"源码 🔥",slug:"源码-🔥",normalizedTitle:"源码 🔥",charIndex:876},{level:2,title:"侦听器 Watch 🔥",slug:"侦听器-watch-🔥",normalizedTitle:"侦听器 watch 🔥",charIndex:1003},{level:3,title:"介绍",slug:"介绍-2",normalizedTitle:"介绍",charIndex:38},{level:3,title:"Watch Option 用法 🔥",slug:"watch-option-用法-🔥",normalizedTitle:"watch option 用法 🔥",charIndex:1148},{level:3,title:"$watch 实例方法（掌握） 🔥",slug:"watch-实例方法-掌握-🔥",normalizedTitle:"$watch 实例方法（掌握） 🔥",charIndex:2823},{level:4,title:"参数",slug:"参数",normalizedTitle:"参数",charIndex:2845},{level:4,title:"返回",slug:"返回",normalizedTitle:"返回",charIndex:1029},{level:4,title:"用法",slug:"用法",normalizedTitle:"用法",charIndex:134},{level:4,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:3150},{level:4,title:"选项：deep 🔥",slug:"选项-deep-🔥",normalizedTitle:"选项：deep 🔥",charIndex:4989},{level:4,title:"选项：immediate",slug:"选项-immediate",normalizedTitle:"选项：immediate",charIndex:5278},{level:4,title:"选项：flush",slug:"选项-flush",normalizedTitle:"选项：flush",charIndex:5848}],headersStr:"计算属性 computed 🔥 介绍 计算属性的setter和getter 源码 🔥 侦听器 Watch 🔥 介绍 Watch Option 用法 🔥 $watch 实例方法（掌握） 🔥 参数 返回 用法 示例 选项：deep 🔥 选项：immediate 选项：flush",content:"# 计算属性 & 侦听器\n\n\n# 计算属性 computed 🔥\n\n\n# 介绍\n\n * 对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性\n * 计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例\n * 用法:\n   * **选项:**computed\n   * 类型:{ [key: string]: Function | { get: Function, set: Function } }\n\n\n# 计算属性的setter和getter\n\n * 计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数\n * 但是，如果我们确实想设置计算属性的值呢?这个时候我们也可以给计算属性设置一个setter的方法\n\ncomputed: {\n    // fullName 的 getter方法\n    fullName() {\n        return this.firstName + ' ' + this.lastName\n    },\n    // fullName的getter和setter方法\n    fullName: {\n        get: function () {\n            return this.firstName + ' ' + this.lastName\n        },\n        set: function (newValue) {\n            console.log(newValue)\n            const names = newValue.split(' ')\n            this.firstName = names[0]\n            this.lastName = names[1]\n        },\n    },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 源码 🔥\n\nVue内部是如何对我们传入的是一个getter，还是说是一个包含setter和getter的对象进行处理的呢？\n\nvue-next/packages/runtime-core/src/componentOptions.ts中的\n\n\n\n\n# 侦听器 Watch 🔥\n\n\n# 介绍\n\n在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中\n\n * 当数据变化时，template会自动进行更新来显示最新的数据\n * 希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了\n\n\n# Watch Option 用法 🔥\n\n * 选项:watch\n * 类型:{ [key: string]: string | Function | Object | Array}\n\n由类型可知：\n\n * key 是 string 类型，那个数组代表可以监听多个\n * value可以是对应的字符串方法名、回调函数、或者包含额外选项的对象\n\nconst app = createApp({\n  data() {\n    return {\n      a: 1,\n      b: 2,\n      c: {\n        d: 4\n      },\n      e: 5,\n      f: 6\n    }\n  },\n  watch: {\n    // 侦听顶级 property\n    a(val, oldVal) {\n      console.log(`new: ${val}, old: ${oldVal}`)\n    },\n    // 字符串方法名\n    b: 'someMethod',\n    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n    c: {\n      handler(val, oldVal) {\n        console.log('c changed')\n      },\n      deep: true\n    },\n    // 侦听单个嵌套 property\n    'c.d': function (val, oldVal) {\n      // do something\n    },\n    // 该回调将会在侦听开始之后被立即调用\n    e: {\n      handler(val, oldVal) {\n        console.log('e changed')\n      },\n      immediate: true\n    },\n    // 你可以传入回调数组，它们会被逐一调用\n    f: [\n      'handle1',\n      function handle2(val, oldVal) {\n        console.log('handle2 triggered')\n      },\n      {\n        handler: function handle3(val, oldVal) {\n          console.log('handle3 triggered')\n        }\n        /* ... */\n      }\n    ]\n  },\n  methods: {\n    someMethod() {\n      console.log('b changed')\n    },\n    handle1() {\n      console.log('handle 1 triggered')\n    }\n  }\n})\n\nconst vm = app.mount('#app')\n\nvm.a = 3 // => new: 3, old: 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchQuery: newValue => this.updateAutocomplete(newValue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向组件实例，this.updateAutocomplete 将是 undefined\n\n\n# $watch 实例方法（掌握） 🔥\n\n# 参数\n\n * {string | Function} source\n * {Function | Object} callback\n * {Object} [options]\n   * {boolean} deep\n   * {boolean} immediate\n   * {string} flush\n\n# 返回\n\n{Function} unwatch\n\n# 用法\n\n侦听组件实例上的响应式 property 或函数计算结果的变化。回调函数得到的参数为新值和旧值。我们只能将顶层的 data、props 或 computed property 名作为字符串传递。对于更复杂的表达式，用一个函数取代。\n\n# 示例\n\nconst app = createApp({\n  data() {\n    return {\n      a: 1,\n      b: 2,\n      c: {\n        d: 3,\n        e: 4\n      }\n    }\n  },\n  created() {\n    // 顶层property 名\n    this.$watch('a', (newVal, oldVal) => {\n      // 做点什么\n    })\n\n    // 用于监视单个嵌套property 的函数\n    this.$watch(\n      () => this.c.d,\n      (newVal, oldVal) => {\n        // 做点什么\n      }\n    )\n\n    // 用于监视复杂表达式的函数\n    this.$watch(\n      // 表达式 `this.a + this.b` 每次得出一个不同的结果时\n      // 处理函数都会被调用。\n      // 这就像监听一个未被定义的计算属性\n      () => this.a + this.b,\n      (newVal, oldVal) => {\n        // 做点什么\n      }\n    )\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n当侦听的值是一个对象或者数组时，对其属性或元素的任何更改都不会触发侦听器，因为它们**引用（不变）**相同的对象/数组：\n\nconst app = createApp({\n  data() {\n    return {\n      article: {\n        text: 'Vue is awesome!'\n      },\n      comments: ['Indeed!', 'I agree']\n    }\n  },\n  created() {\n    this.$watch('article', () => {\n      console.log('Article changed!')\n    })\n\n    this.$watch('comments', () => {\n      console.log('Comments changed!')\n    })\n  },\n  methods: {\n    // 这些方法不会触发侦听器，因为我们只更改了Object/Array的一个property，\n    // 不是对象/数组本身\n    changeArticleText() {\n      this.article.text = 'Vue 3 is awesome'\n    },\n    addComment() {\n      this.comments.push('New comment')\n    },\n\n    // 这些方法将触发侦听器，因为我们完全替换了对象/数组\n    changeWholeArticle() {\n      this.article = { text: 'Vue 3 is awesome' }\n    },\n    clearComments() {\n      this.comments = []\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n$watch 返回一个取消侦听函数，用来停止触发回调：\n\nconst app = createApp({\n  data() {\n    return {\n      a: 1\n    }\n  }\n})\n\nconst vm = app.mount('#app')\n\nconst unwatch = vm.$watch('a', cb)\n// later, teardown the watcher\nunwatch()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 选项：deep 🔥\n\n为了发现对象内部值的变化，可以在选项参数中指定 deep: true。这个选项同样适用于监听数组变更。\n\n> 注意：当变更（不是替换）对象或数组并使用 deep 选项时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。Vue 不会保留变更之前值的副本。可以参考Vue3中watch的最佳实践来完成！！！\n\nvm.$watch('someObject', callback, {\n  deep: true\n})\nvm.someObject.nestedValue = 123\n// callback is fired\n\n\n1\n2\n3\n4\n5\n\n\n# 选项：immediate\n\n在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调：\n\nvm.$watch('a', callback, {\n  immediate: true\n})\n// 立即以 `a` 的当前值触发 `callback`\n\n\n1\n2\n3\n4\n\n\n注意，在带有 immediate 选项时，你不能在第一次回调时取消侦听给定的 property。\n\n// 这会导致报错\nconst unwatch = vm.$watch(\n  'value',\n  function() {\n    doSomething()\n    unwatch()\n  },\n  { immediate: true }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：\n\nlet unwatch = null\n\nunwatch = vm.$watch(\n  'value',\n  function() {\n    doSomething()\n    if (unwatch) {\n      unwatch()\n    }\n  },\n  { immediate: true }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 选项：flush\n\nflush 选项可以更好地控制回调的时间。它可以设置为 'pre'、'post' 或 'sync'。\n\n默认值是 'pre'，指定的回调应该在渲染前被调用。它允许回调在模板运行前更新了其他值。\n\n'post' 值是可以用来将回调推迟到渲染之后的。如果回调需要通过 $refs 访问更新的 DOM 或子组件，那么则使用该值。\n\n如果 flush 被设置为 'sync'，一旦值发生了变化，回调将被同步调用。\n\n对于 'pre' 和 'post'，回调使用队列进行缓冲。回调只被添加到队列中一次，即使观察值变化了多次。值的中间变化将被跳过，不会传递给回调。\n\n缓冲回调不仅可以提高性能，还有助于保证数据的一致性。在执行数据更新的代码完成之前，侦听器不会被触发。\n\n'sync' 侦听器应少用，因为它们没有这些好处。\n\n更多关于 flush 的信息，请参阅副作用刷新时机。",normalizedContent:"# 计算属性 & 侦听器\n\n\n# 计算属性 computed 🔥\n\n\n# 介绍\n\n * 对于任何包含响应式数据的复杂逻辑，你都应该使用计算属性\n * 计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例\n * 用法:\n   * **选项:**computed\n   * 类型:{ [key: string]: function | { get: function, set: function } }\n\n\n# 计算属性的setter和getter\n\n * 计算属性在大多数情况下，只需要一个getter方法即可，所以我们会将计算属性直接写成一个函数\n * 但是，如果我们确实想设置计算属性的值呢?这个时候我们也可以给计算属性设置一个setter的方法\n\ncomputed: {\n    // fullname 的 getter方法\n    fullname() {\n        return this.firstname + ' ' + this.lastname\n    },\n    // fullname的getter和setter方法\n    fullname: {\n        get: function () {\n            return this.firstname + ' ' + this.lastname\n        },\n        set: function (newvalue) {\n            console.log(newvalue)\n            const names = newvalue.split(' ')\n            this.firstname = names[0]\n            this.lastname = names[1]\n        },\n    },\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# 源码 🔥\n\nvue内部是如何对我们传入的是一个getter，还是说是一个包含setter和getter的对象进行处理的呢？\n\nvue-next/packages/runtime-core/src/componentoptions.ts中的\n\n\n\n\n# 侦听器 watch 🔥\n\n\n# 介绍\n\n在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中\n\n * 当数据变化时，template会自动进行更新来显示最新的数据\n * 希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了\n\n\n# watch option 用法 🔥\n\n * 选项:watch\n * 类型:{ [key: string]: string | function | object | array}\n\n由类型可知：\n\n * key 是 string 类型，那个数组代表可以监听多个\n * value可以是对应的字符串方法名、回调函数、或者包含额外选项的对象\n\nconst app = createapp({\n  data() {\n    return {\n      a: 1,\n      b: 2,\n      c: {\n        d: 4\n      },\n      e: 5,\n      f: 6\n    }\n  },\n  watch: {\n    // 侦听顶级 property\n    a(val, oldval) {\n      console.log(`new: ${val}, old: ${oldval}`)\n    },\n    // 字符串方法名\n    b: 'somemethod',\n    // 该回调会在任何被侦听的对象的 property 改变时被调用，不论其被嵌套多深\n    c: {\n      handler(val, oldval) {\n        console.log('c changed')\n      },\n      deep: true\n    },\n    // 侦听单个嵌套 property\n    'c.d': function (val, oldval) {\n      // do something\n    },\n    // 该回调将会在侦听开始之后被立即调用\n    e: {\n      handler(val, oldval) {\n        console.log('e changed')\n      },\n      immediate: true\n    },\n    // 你可以传入回调数组，它们会被逐一调用\n    f: [\n      'handle1',\n      function handle2(val, oldval) {\n        console.log('handle2 triggered')\n      },\n      {\n        handler: function handle3(val, oldval) {\n          console.log('handle3 triggered')\n        }\n        /* ... */\n      }\n    ]\n  },\n  methods: {\n    somemethod() {\n      console.log('b changed')\n    },\n    handle1() {\n      console.log('handle 1 triggered')\n    }\n  }\n})\n\nconst vm = app.mount('#app')\n\nvm.a = 3 // => new: 3, old: 1\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\n注意，不应该使用箭头函数来定义 watcher 函数 (例如 searchquery: newvalue => this.updateautocomplete(newvalue))。理由是箭头函数绑定了父级作用域的上下文，所以 this 将不会按照期望指向组件实例，this.updateautocomplete 将是 undefined\n\n\n# $watch 实例方法（掌握） 🔥\n\n# 参数\n\n * {string | function} source\n * {function | object} callback\n * {object} [options]\n   * {boolean} deep\n   * {boolean} immediate\n   * {string} flush\n\n# 返回\n\n{function} unwatch\n\n# 用法\n\n侦听组件实例上的响应式 property 或函数计算结果的变化。回调函数得到的参数为新值和旧值。我们只能将顶层的 data、props 或 computed property 名作为字符串传递。对于更复杂的表达式，用一个函数取代。\n\n# 示例\n\nconst app = createapp({\n  data() {\n    return {\n      a: 1,\n      b: 2,\n      c: {\n        d: 3,\n        e: 4\n      }\n    }\n  },\n  created() {\n    // 顶层property 名\n    this.$watch('a', (newval, oldval) => {\n      // 做点什么\n    })\n\n    // 用于监视单个嵌套property 的函数\n    this.$watch(\n      () => this.c.d,\n      (newval, oldval) => {\n        // 做点什么\n      }\n    )\n\n    // 用于监视复杂表达式的函数\n    this.$watch(\n      // 表达式 `this.a + this.b` 每次得出一个不同的结果时\n      // 处理函数都会被调用。\n      // 这就像监听一个未被定义的计算属性\n      () => this.a + this.b,\n      (newval, oldval) => {\n        // 做点什么\n      }\n    )\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n当侦听的值是一个对象或者数组时，对其属性或元素的任何更改都不会触发侦听器，因为它们**引用（不变）**相同的对象/数组：\n\nconst app = createapp({\n  data() {\n    return {\n      article: {\n        text: 'vue is awesome!'\n      },\n      comments: ['indeed!', 'i agree']\n    }\n  },\n  created() {\n    this.$watch('article', () => {\n      console.log('article changed!')\n    })\n\n    this.$watch('comments', () => {\n      console.log('comments changed!')\n    })\n  },\n  methods: {\n    // 这些方法不会触发侦听器，因为我们只更改了object/array的一个property，\n    // 不是对象/数组本身\n    changearticletext() {\n      this.article.text = 'vue 3 is awesome'\n    },\n    addcomment() {\n      this.comments.push('new comment')\n    },\n\n    // 这些方法将触发侦听器，因为我们完全替换了对象/数组\n    changewholearticle() {\n      this.article = { text: 'vue 3 is awesome' }\n    },\n    clearcomments() {\n      this.comments = []\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n$watch 返回一个取消侦听函数，用来停止触发回调：\n\nconst app = createapp({\n  data() {\n    return {\n      a: 1\n    }\n  }\n})\n\nconst vm = app.mount('#app')\n\nconst unwatch = vm.$watch('a', cb)\n// later, teardown the watcher\nunwatch()\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n# 选项：deep 🔥\n\n为了发现对象内部值的变化，可以在选项参数中指定 deep: true。这个选项同样适用于监听数组变更。\n\n> 注意：当变更（不是替换）对象或数组并使用 deep 选项时，旧值将与新值相同，因为它们的引用指向同一个对象/数组。vue 不会保留变更之前值的副本。可以参考vue3中watch的最佳实践来完成！！！\n\nvm.$watch('someobject', callback, {\n  deep: true\n})\nvm.someobject.nestedvalue = 123\n// callback is fired\n\n\n1\n2\n3\n4\n5\n\n\n# 选项：immediate\n\n在选项参数中指定 immediate: true 将立即以表达式的当前值触发回调：\n\nvm.$watch('a', callback, {\n  immediate: true\n})\n// 立即以 `a` 的当前值触发 `callback`\n\n\n1\n2\n3\n4\n\n\n注意，在带有 immediate 选项时，你不能在第一次回调时取消侦听给定的 property。\n\n// 这会导致报错\nconst unwatch = vm.$watch(\n  'value',\n  function() {\n    dosomething()\n    unwatch()\n  },\n  { immediate: true }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n如果你仍然希望在回调内部调用一个取消侦听的函数，你应该先检查其函数的可用性：\n\nlet unwatch = null\n\nunwatch = vm.$watch(\n  'value',\n  function() {\n    dosomething()\n    if (unwatch) {\n      unwatch()\n    }\n  },\n  { immediate: true }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n# 选项：flush\n\nflush 选项可以更好地控制回调的时间。它可以设置为 'pre'、'post' 或 'sync'。\n\n默认值是 'pre'，指定的回调应该在渲染前被调用。它允许回调在模板运行前更新了其他值。\n\n'post' 值是可以用来将回调推迟到渲染之后的。如果回调需要通过 $refs 访问更新的 dom 或子组件，那么则使用该值。\n\n如果 flush 被设置为 'sync'，一旦值发生了变化，回调将被同步调用。\n\n对于 'pre' 和 'post'，回调使用队列进行缓冲。回调只被添加到队列中一次，即使观察值变化了多次。值的中间变化将被跳过，不会传递给回调。\n\n缓冲回调不仅可以提高性能，还有助于保证数据的一致性。在执行数据更新的代码完成之前，侦听器不会被触发。\n\n'sync' 侦听器应少用，因为它们没有这些好处。\n\n更多关于 flush 的信息，请参阅副作用刷新时机。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"表单的双向绑定",frontmatter:{title:"表单的双向绑定",date:"2022-01-16T15:01:28.000Z",permalink:"/pages/973ddb/",categories:["x","基础"],tags:[null]},regularPath:"/1403.Vue3.x/100.%E5%9F%BA%E7%A1%80/105.%E8%A1%A8%E5%8D%95%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.html",relativePath:"1403.Vue3.x/100.基础/105.表单的双向绑定.md",key:"v-12090137",path:"/pages/973ddb/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:22},{level:2,title:"使用 🔥",slug:"使用-🔥",normalizedTitle:"使用 🔥",charIndex:1246},{level:3,title:"绑定 checkbox 注意",slug:"绑定-checkbox-注意",normalizedTitle:"绑定 checkbox 注意",charIndex:4039},{level:3,title:"绑定 select 注意",slug:"绑定-select-注意",normalizedTitle:"绑定 select 注意",charIndex:4229},{level:2,title:"修饰符 🔥",slug:"修饰符-🔥",normalizedTitle:"修饰符 🔥",charIndex:4348},{level:3,title:"lazy 🔥",slug:"lazy-🔥",normalizedTitle:"lazy 🔥",charIndex:4359},{level:3,title:"number 🔥",slug:"number-🔥",normalizedTitle:"number 🔥",charIndex:4498},{level:3,title:"trim 🔥",slug:"trim-🔥",normalizedTitle:"trim 🔥",charIndex:4604},{level:2,title:"组件上使用 🔥",slug:"组件上使用-🔥",normalizedTitle:"组件上使用 🔥",charIndex:4655}],headersStr:"介绍 使用 🔥 绑定 checkbox 注意 绑定 select 注意 修饰符 🔥 lazy 🔥 number 🔥 trim 🔥 组件上使用 🔥",content:'# 表单的双向绑定 v-model\n\n\n# 介绍\n\nv-model指令可以在表单 input、textarea以及select元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n\nv-model 本质上不过是语法糖，它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理\n\n * text 和 textarea 元素使用 value property 和 input 事件；\n * checkbox 和 radio 使用 checked property 和 change 事件；\n * select 字段将 value 作为 prop 并将 change 作为事件。\n\n原理就是v-bind绑定上述值，v-on绑定上述实际。例如一个text类型的input：\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <input type="text" v-model="message" />\n      <h2>{{message}}</h2>\n      <input type="text" :value="message" @input="valueChange" />\n      <input\n        type="text"\n        :value="message"\n        @input="message = $event.target.value"\n      />\n    </div>\n\n    <script src="vue.js"><\/script>\n    <script>\n      const vm = new Vue({\n        el: "#app",\n        data: {\n          message: "Hello",\n        },\n        methods: {\n          valueChange(event) {\n            this.message = event.target.value;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 使用 🔥\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      \x3c!-- 1.绑定textarea --\x3e\n      <label for="intro">\n        自我介绍\n        <textarea\n          name="intro"\n          id="intro"\n          cols="30"\n          rows="10"\n          v-model="intro"\n        ></textarea>\n      </label>\n      <h2>intro: {{intro}}</h2>\n      <hr />\n\n      \x3c!-- 2.radio --\x3e\n      <span>你的爱好: </span>\n      <label for="male">\n        <input id="male" type="radio" v-model="gender" value="male" />男\n      </label>\n      <label for="female">\n        <input id="female" type="radio" v-model="gender" value="female" />女\n      </label>\n      <h2>gender: {{gender}}</h2>\n      <hr />\n\n      \x3c!-- 3.checkbox --\x3e\n      \x3c!-- 3.1.单选框 --\x3e\n      <label for="agree">\n        <input id="agree" type="checkbox" v-model="isAgree" /> 同意协议\n      </label>\n      <h2>isAgree: {{isAgree}}</h2>\n\n      \x3c!-- 3.2.多选框 --\x3e\n      <span>你的爱好: </span>\n      <label for="basketball">\n        <input\n          id="basketball"\n          type="checkbox"\n          v-model="hobbies"\n          value="basketball"\n        />\n        篮球\n      </label>\n      <label for="football">\n        <input\n          id="football"\n          type="checkbox"\n          v-model="hobbies"\n          value="football"\n        />\n        足球\n      </label>\n      <label for="tennis">\n        <input id="tennis" type="checkbox" v-model="hobbies" value="tennis" />\n        网球\n      </label>\n      <h2>hobbies: {{hobbies}}</h2>\n      <hr />\n\n      \x3c!-- 4.select --\x3e\n      \x3c!-- multiple则绑定到数组中，否则绑定到字符串中 --\x3e\n      <span>喜欢的水果: </span>\n      <select v-model="fruit" multiple size="2">\n        <option value="apple">苹果</option>\n        <option value="orange">橘子</option>\n        <option value="banana">香蕉</option>\n      </select>\n      <h2>fruit: {{fruit}}</h2>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const App = {\n        template: \'#my-app\',\n        data() {\n          return {\n            intro: \'Hello World\',\n            isAgree: false,\n            hobbies: [\'basketball\'],\n            gender: \'\',\n            fruit: [\'banana\'], // multiple则绑定到数组中，否则绑定到字符串中\n          }\n        },\n      }\n\n      Vue.createApp(App).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n\n\n\n# 绑定 checkbox 注意\n\nv-model绑定checkbox分单个勾选框和多个勾选框：\n\n * 单个勾选框\n   \n   v-model即为布尔值。此时input的value并不影响v-model的值\n\n * 多个复选框\n   \n   当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。当选中某一个时，就会将input的value添加到数组中\n\n\n# 绑定 select 注意\n\nv-model绑定select也分单个勾选框和多个勾选框：\n\n * 单选\n   \n   v-model绑定的是一个值，整体是string类型\n\n * 多选\n   \n   v-model绑定的是一个数组\n\n\n# 修饰符 🔥\n\n\n# lazy 🔥\n\n默认情况下，v-model在进行双向绑定时，绑定的是input事件，那么会在每次内容输入后就将最新的值和绑定的属性进行同步\n\n如果我们在v-model后跟上.lazy修饰符，那么会将绑定的事件切换为change事件，只有在提交时(比如回车) 才会触发\n\n\n# number 🔥\n\nv-model绑定后的值是string类型的，希望转换为数字类型，那么可以使用.number 修饰符\n\n进行逻辑判断时，如果是一个string类型，在可以转化的情况下会进行隐式转换\n\n\n# trim 🔥\n\n自动过滤用户输入的守卫空白字符，可以给v-model添加 trim 修饰符\n\n\n# 组件上使用 🔥\n\nvue2 和 vue3 有很大区别！！！',normalizedContent:'# 表单的双向绑定 v-model\n\n\n# 介绍\n\nv-model指令可以在表单 input、textarea以及select元素上创建双向数据绑定。它会根据控件类型自动选取正确的方法来更新元素。\n\nv-model 本质上不过是语法糖，它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理\n\n * text 和 textarea 元素使用 value property 和 input 事件；\n * checkbox 和 radio 使用 checked property 和 change 事件；\n * select 字段将 value 作为 prop 并将 change 作为事件。\n\n原理就是v-bind绑定上述值，v-on绑定上述实际。例如一个text类型的input：\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>title</title>\n  </head>\n\n  <body>\n    <div id="app">\n      <input type="text" v-model="message" />\n      <h2>{{message}}</h2>\n      <input type="text" :value="message" @input="valuechange" />\n      <input\n        type="text"\n        :value="message"\n        @input="message = $event.target.value"\n      />\n    </div>\n\n    <script src="vue.js"><\/script>\n    <script>\n      const vm = new vue({\n        el: "#app",\n        data: {\n          message: "hello",\n        },\n        methods: {\n          valuechange(event) {\n            this.message = event.target.value;\n          },\n        },\n      });\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 使用 🔥\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      \x3c!-- 1.绑定textarea --\x3e\n      <label for="intro">\n        自我介绍\n        <textarea\n          name="intro"\n          id="intro"\n          cols="30"\n          rows="10"\n          v-model="intro"\n        ></textarea>\n      </label>\n      <h2>intro: {{intro}}</h2>\n      <hr />\n\n      \x3c!-- 2.radio --\x3e\n      <span>你的爱好: </span>\n      <label for="male">\n        <input id="male" type="radio" v-model="gender" value="male" />男\n      </label>\n      <label for="female">\n        <input id="female" type="radio" v-model="gender" value="female" />女\n      </label>\n      <h2>gender: {{gender}}</h2>\n      <hr />\n\n      \x3c!-- 3.checkbox --\x3e\n      \x3c!-- 3.1.单选框 --\x3e\n      <label for="agree">\n        <input id="agree" type="checkbox" v-model="isagree" /> 同意协议\n      </label>\n      <h2>isagree: {{isagree}}</h2>\n\n      \x3c!-- 3.2.多选框 --\x3e\n      <span>你的爱好: </span>\n      <label for="basketball">\n        <input\n          id="basketball"\n          type="checkbox"\n          v-model="hobbies"\n          value="basketball"\n        />\n        篮球\n      </label>\n      <label for="football">\n        <input\n          id="football"\n          type="checkbox"\n          v-model="hobbies"\n          value="football"\n        />\n        足球\n      </label>\n      <label for="tennis">\n        <input id="tennis" type="checkbox" v-model="hobbies" value="tennis" />\n        网球\n      </label>\n      <h2>hobbies: {{hobbies}}</h2>\n      <hr />\n\n      \x3c!-- 4.select --\x3e\n      \x3c!-- multiple则绑定到数组中，否则绑定到字符串中 --\x3e\n      <span>喜欢的水果: </span>\n      <select v-model="fruit" multiple size="2">\n        <option value="apple">苹果</option>\n        <option value="orange">橘子</option>\n        <option value="banana">香蕉</option>\n      </select>\n      <h2>fruit: {{fruit}}</h2>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const app = {\n        template: \'#my-app\',\n        data() {\n          return {\n            intro: \'hello world\',\n            isagree: false,\n            hobbies: [\'basketball\'],\n            gender: \'\',\n            fruit: [\'banana\'], // multiple则绑定到数组中，否则绑定到字符串中\n          }\n        },\n      }\n\n      vue.createapp(app).mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n\n\n\n# 绑定 checkbox 注意\n\nv-model绑定checkbox分单个勾选框和多个勾选框：\n\n * 单个勾选框\n   \n   v-model即为布尔值。此时input的value并不影响v-model的值\n\n * 多个复选框\n   \n   当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。当选中某一个时，就会将input的value添加到数组中\n\n\n# 绑定 select 注意\n\nv-model绑定select也分单个勾选框和多个勾选框：\n\n * 单选\n   \n   v-model绑定的是一个值，整体是string类型\n\n * 多选\n   \n   v-model绑定的是一个数组\n\n\n# 修饰符 🔥\n\n\n# lazy 🔥\n\n默认情况下，v-model在进行双向绑定时，绑定的是input事件，那么会在每次内容输入后就将最新的值和绑定的属性进行同步\n\n如果我们在v-model后跟上.lazy修饰符，那么会将绑定的事件切换为change事件，只有在提交时(比如回车) 才会触发\n\n\n# number 🔥\n\nv-model绑定后的值是string类型的，希望转换为数字类型，那么可以使用.number 修饰符\n\n进行逻辑判断时，如果是一个string类型，在可以转化的情况下会进行隐式转换\n\n\n# trim 🔥\n\n自动过滤用户输入的守卫空白字符，可以给v-model添加 trim 修饰符\n\n\n# 组件上使用 🔥\n\nvue2 和 vue3 有很大区别！！！',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"搭建项目",frontmatter:{title:"搭建项目",date:"2022-04-04T18:39:52.000Z",permalink:"/pages/3c9e8f/",categories:["x","项目"],tags:[null]},regularPath:"/1403.Vue3.x/1000.%E9%A1%B9%E7%9B%AE/101.%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE.html",relativePath:"1403.Vue3.x/1000.项目/101.搭建项目.md",key:"v-1237fee2",path:"/pages/3c9e8f/",headers:[{level:2,title:"创建项目",slug:"创建项目",normalizedTitle:"创建项目",charIndex:11},{level:2,title:"代码规范",slug:"代码规范",normalizedTitle:"代码规范",charIndex:1099},{level:3,title:"1.1. 集成.editorconfig 配置",slug:"_1-1-集成-editorconfig-配置",normalizedTitle:"1.1. 集成.editorconfig 配置",charIndex:1108},{level:3,title:"1.2. 使用 prettier 工具",slug:"_1-2-使用-prettier-工具",normalizedTitle:"1.2. 使用 prettier 工具",charIndex:1638},{level:3,title:"1.3. 使用 ESLint 检测",slug:"_1-3-使用-eslint-检测",normalizedTitle:"1.3. 使用 eslint 检测",charIndex:2543},{level:3,title:"1.4. git Husky 和 eslint",slug:"_1-4-git-husky-和-eslint",normalizedTitle:"1.4. git husky 和 eslint",charIndex:3041},{level:3,title:"1.5. git commit 规范",slug:"_1-5-git-commit-规范",normalizedTitle:"1.5. git commit 规范",charIndex:3650},{level:4,title:"1.5.1. 代码提交风格",slug:"_1-5-1-代码提交风格",normalizedTitle:"1.5.1. 代码提交风格",charIndex:3672},{level:4,title:"1.5.2. 代码提交验证",slug:"_1-5-2-代码提交验证",normalizedTitle:"1.5.2. 代码提交验证",charIndex:4778},{level:2,title:"第三方库集成",slug:"第三方库集成",normalizedTitle:"第三方库集成",charIndex:5251},{level:3,title:"2.1. vue.config.js配置",slug:"_2-1-vue-config-js配置",normalizedTitle:"2.1. vue.config.js配置",charIndex:5262},{level:3,title:"2.2. vue-router集成",slug:"_2-2-vue-router集成",normalizedTitle:"2.2. vue-router集成",charIndex:6157},{level:3,title:"2.3. vuex集成",slug:"_2-3-vuex集成",normalizedTitle:"2.3. vuex集成",charIndex:7071},{level:3,title:"2.4. element-plus集成",slug:"_2-4-element-plus集成",normalizedTitle:"2.4. element-plus集成",charIndex:7432},{level:4,title:"2.4.1. 全局引入",slug:"_2-4-1-全局引入",normalizedTitle:"2.4.1. 全局引入",charIndex:7711},{level:4,title:"2.4.2. 局部引入（旧）",slug:"_2-4-2-局部引入-旧",normalizedTitle:"2.4.2. 局部引入（旧）",charIndex:8009},{level:4,title:"2.4.3 局部按需导入 🔥",slug:"_2-4-3-局部按需导入-🔥",normalizedTitle:"2.4.3 局部按需导入 🔥",charIndex:9806},{level:3,title:"2.5. axios集成",slug:"_2-5-axios集成",normalizedTitle:"2.5. axios集成",charIndex:11431},{level:3,title:"2.6 环境变量 🔥",slug:"_2-6-环境变量-🔥",normalizedTitle:"2.6 环境变量 🔥",charIndex:13482},{level:3,title:"normalize.css",slug:"normalize-css",normalizedTitle:"normalize.css",charIndex:14955},{level:3,title:"VSCode配置",slug:"vscode配置",normalizedTitle:"vscode配置",charIndex:15072},{level:2,title:"接口文档",slug:"接口文档",normalizedTitle:"接口文档",charIndex:17356}],headersStr:"创建项目 代码规范 1.1. 集成.editorconfig 配置 1.2. 使用 prettier 工具 1.3. 使用 ESLint 检测 1.4. git Husky 和 eslint 1.5. git commit 规范 1.5.1. 代码提交风格 1.5.2. 代码提交验证 第三方库集成 2.1. vue.config.js配置 2.2. vue-router集成 2.3. vuex集成 2.4. element-plus集成 2.4.1. 全局引入 2.4.2. 局部引入（旧） 2.4.3 局部按需导入 🔥 2.5. axios集成 2.6 环境变量 🔥 normalize.css VSCode配置 接口文档",content:'# 搭建项目\n\n\n# 创建项目\n\nvue create vue3-ts-cms\n\nVue CLI v4.5.15\n┌──────────────────────────────────────────┐\n│                                          │\n│   New version available 4.5.15 → 5.0.4   │\n│     Run npm i -g @vue/cli to update!     │\n│                                          │\n└──────────────────────────────────────────┘\n\n? Please pick a preset: Manually select features\n? Check the features needed for your project: Choose Vue version, Babel, TS, CSS Pre-processors, Linter\n\n\n? Choose a version of Vue.js that you want to start the project with 3.x\n? Use class-style component syntax? No\n? Use Babel alongside TypeScript (required for modern mode, auto-detected polyfills, transpiling JSX)?\nYes\n? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Less\n? Pick a linter / formatter config: Prettier\n? Pick additional lint features: Lint on save\n? Where do you prefer placing config for Babel, ESLint, etc.? In dedicated config files\n? Save this as a preset for future projects? (y/N) n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 代码规范\n\n\n# 1.1. 集成.editorconfig 配置\n\nEditorConfig 有助于为不同 IDE 编辑器上处理同一项目的多个开发人员维护一致的编码风格。\n\n# http://editorconfig.org\n\nroot = true\n\n[*] # 表示所有文件适用\ncharset = utf-8 # 设置文件字符集为 utf-8\nindent_style = space # 缩进风格（tab | space）\nindent_size = 2 # 缩进大小\nend_of_line = lf # 控制换行类型(lf | cr | crlf)\ntrim_trailing_whitespace = true # 去除行首的任意空白字符\ninsert_final_newline = true # 始终在文件末尾插入一个新行\n\n[*.md] # 表示仅 md 文件适用以下规则\nmax_line_length = off\ntrim_trailing_whitespace = false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nVSCode 需要安装一个插件：EditorConfig for VS Code\n\n\n\n\n# 1.2. 使用 prettier 工具\n\nPrettier 是一款强大的代码格式化工具，支持 JavaScript、TypeScript、CSS、SCSS、Less、JSX、Angular、Vue、GraphQL、JSON、Markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。\n\n1.安装 prettier\n\nnpm install prettier -D\n\n\n1\n\n\n2.配置.prettierrc 文件：\n\n * useTabs：使用 tab 缩进还是空格缩进，选择 false；\n * tabWidth：tab 是空格的情况下，是几个空格，选择 2 个；\n * printWidth：当行字符的长度，推荐 80，也有人喜欢 100 或者 120；\n * singleQuote：使用单引号还是双引号，选择 true，使用单引号；\n * trailingComma：在多行输入的尾逗号是否添加，可设置为 none、all\n * semi：语句末尾是否要加分号，默认值 true，选择 false 表示不加；\n\n{\n  "useTabs": false,\n  "tabWidth": 2,\n  "printWidth": 80,\n  "singleQuote": true,\n  "trailingComma": "all",\n  "semi": false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n3.创建.prettierignore 忽略文件\n\n/dist/*\n.local\n.output.js\n/node_modules/**\n\n**/*.svg\n**/*.sh\n\n/public/*\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n4.VSCode 需要安装 prettier 的插件\n\n\n\n5.测试 prettier 是否生效\n\n * 测试一：在代码中保存代码；\n * 测试二：配置一次性修改的命令；\n\n在 package.json 中配置一个 scripts：\n\n"prettier": "prettier --write ."\n\n\n1\n\n\n\n# 1.3. 使用 ESLint 检测\n\n1.在前面创建项目的时候，我们就选择了 ESLint，所以 Vue 会默认帮助我们配置需要的 ESLint 环境。\n\n2.VSCode 需要安装 ESLint 插件：\n\n\n\n3.解决 eslint 和 prettier 冲突的问题：\n\n安装插件：（vue 在创建项目时，如果选择 eslint-prettier，那么这两个插件会自动安装）\n\nnpm i eslint-plugin-prettier eslint-config-prettier -D\n\n\n1\n\n\n添加 prettier 插件：\n\n  extends: [\n    "plugin:vue/vue3-essential",\n    "eslint:recommended",\n    "@vue/typescript/recommended",\n    "@vue/prettier",\n    "@vue/prettier/@typescript-eslint",\n    \'plugin:prettier/recommended\'\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.4. git Husky 和 eslint\n\n虽然我们已经要求项目使用 eslint 了，但是不能保证组员提交代码之前都将 eslint 中的问题解决掉了：\n\n * 也就是我们希望保证代码仓库中的代码都是符合 eslint 规范的；\n\n * 那么我们需要在组员执行 git commit 命令的时候对其进行校验，如果不符合 eslint 规范，那么自动通过规范进行修复；\n\n那么如何做到这一点呢？可以通过 Husky 工具：\n\n * husky 是一个 git hook 工具，可以帮助我们触发 git 提交的各个阶段：pre-commit、commit-msg、pre-push\n\n如何使用 husky 呢？\n\n这里我们可以使用自动配置命令：\n\nnpx husky-init && npm install\nnpx husky-init \'&&\' npm install # powershell \n\n\n1\n2\n\n\n这里会做三件事：\n\n1.安装 husky 相关的依赖：\n\n\n\n2.在项目目录下创建 .husky 文件夹：\n\nnpx huksy install\n\n\n1\n\n\n\n\n3.在 package.json 中添加一个脚本：\n\n\n\n接下来，我们需要去完成一个操作：在进行 commit 时，执行 lint 脚本：\n\n\n\n这个时候我们执行 git commit 的时候会自动对代码进行 lint 校验。\n\n\n# 1.5. git commit 规范\n\n# 1.5.1. 代码提交风格\n\n通常我们的 git commit 会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。\n\n\n\n但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：Commitizen\n\n * Commitizen 是一个帮助我们编写规范 commit message 的工具；\n   \n   1.安装 Commitizen\n\nnpm install commitizen -D\n\n\n1\n\n\n2.安装 cz-conventional-changelog，并且初始化 cz-conventional-changelog：\n\nnpx commitizen init cz-conventional-changelog --save-dev --save-exact\n\n\n1\n\n\n这个命令会帮助我们安装 cz-conventional-changelog：\n\n\n\n并且在 package.json 中进行配置：\n\n\n\n这个时候我们提交代码需要使用 npx cz：\n\n * 第一步是选择 type，本次更新的类型\n\nTYPE       作用\nfeat       新增特性 (feature)\nfix        修复 Bug(bug fix)\ndocs       修改文档 (documentation)\nstyle      代码格式修改(white-space, formatting, missing semi colons, etc)\nrefactor   代码重构(refactor)\nperf       改善性能(A code change that improves performance)\ntest       测试(when adding missing tests)\nbuild      变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）\nci         更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: Travis,\n           Circle 等\nchore      变更构建流程或辅助工具(比如更改测试环境)\nrevert     代码回退\n\n * 第二步选择本次修改的范围（作用域）\n\n\n\n * 第三步选择提交的信息\n\n\n\n * 第四步提交详细的描述信息\n\n\n\n * 第五步是否是一次重大的更改\n\n\n\n * 第六步是否影响某个 open issue\n\n\n\n我们也可以在 scripts 中构建一个命令来执行 cz：\n\n\n\n# 1.5.2. 代码提交验证\n\n如果我们按照 cz 来规范了提交风格，但是依然有同事通过 git commit 按照不规范的格式提交应该怎么办呢？\n\n * 我们可以通过 commitlint 来限制提交；\n   \n   1.安装 @commitlint/config-conventional 和 @commitlint/cli\n\nnpm i @commitlint/config-conventional @commitlint/cli -D\n\n\n1\n\n\n2.在根目录创建 commitlint.config.js 文件，配置 commitlint\n\nmodule.exports = {\n  extends: [\'@commitlint/config-conventional\'],\n}\n\n\n1\n2\n3\n\n\n3.使用 husky 生成 commit-msg 文件，验证提交信息：\n\nnpx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"\n\n\n1\n\n\n\n# 第三方库集成\n\n\n# 2.1. vue.config.js配置\n\nvue.config.js有三种配置方式：\n\n * 方式一：直接通过CLI提供给我们的选项来配置：\n   * 比如publicPath：配置应用程序部署的子目录（默认是 /，相当于部署在 https://www.my-app.com/）；\n   * 比如outputDir：修改输出的文件夹；\n * 方式二：通过configureWebpack修改webpack的配置：\n   * 可以是一个对象，直接会被合并；\n   * 可以是一个函数，会接收一个config，可以通过config来修改配置；\n * 方式三：通过chainWebpack修改webpack的配置：\n   * 是一个函数，会接收一个基于 webpack-chain 的config对象，可以对配置进行修改；\n\nconst path = require(\'path\')\n\nmodule.exports = {\n  outputDir: \'./build\',\n  // configureWebpack: {\n  //   resolve: {\n  //     alias: {\n  //       views: \'@/views\'\n  //     }\n  //   }\n  // }\n  // configureWebpack: (config) => {\n  //   config.resolve.alias = {\n  //     \'@\': path.resolve(__dirname, \'src\'),\n  //     views: \'@/views\'\n  //   }\n  // },\n  chainWebpack: (config) => {\n    config.resolve.alias.set(\'@\', path.resolve(__dirname, \'src\')).set(\'views\', \'@/views\')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 2.2. vue-router集成\n\n安装vue-router的最新版本：\n\nnpm install vue-router@next\n\n\n1\n\n\n创建router对象：\n\nimport { createRouter, createWebHashHistory } from \'vue-router\'\nimport { RouteRecordRaw } from \'vue-router\'\n\nconst routes: RouteRecordRaw[] = [\n  {\n    path: \'/\',\n    redirect: \'/main\'\n  },\n  {\n    path: \'/main\',\n    component: () => import(\'../views/main/main.vue\')\n  },\n  {\n    path: \'/login\',\n    component: () => import(\'../views/login/login.vue\')\n  }\n]\n\nconst router = createRouter({\n  routes,\n  history: createWebHashHistory()\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n安装router：\n\nimport router from \'./router\'\n\ncreateApp(App).use(router).mount(\'#app\')\n\n\n1\n2\n3\n\n\n在App.vue中配置跳转：\n\n<template>\n  <div id="app">\n    <router-link to="/login">登录</router-link>\n    <router-link to="/main">首页</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.3. vuex集成\n\n安装vuex：\n\nnpm install vuex@next\n\n\n1\n\n\n创建store对象：\n\nimport { createStore } from \'vuex\'\n\nconst store = createStore({\n  state() {\n    return {\n      name: \'coderwhy\'\n    }\n  }\n})\n\nexport default store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n安装store：\n\ncreateApp(App).use(router).use(store).mount(\'#app\')\n\n\n1\n\n\n在App.vue中使用：\n\n<h2>{{ $store.state.name }}</h2>\n\n\n1\n\n\n\n# 2.4. element-plus集成\n\nElement Plus，一套为开发者、设计师和产品经理准备的基于 Vue 3.0 的桌面端组件库：\n\n * 相信很多同学在Vue2中都使用过element-ui，而element-plus正是element-ui针对于vue3开发的一个UI组件库；\n * 它的使用方式和很多其他的组件库是一样的，所以学会element-plus，其他类似于ant-design-vue、NaiveUI、VantUI都是差不多的；\n\n安装element-plus\n\nnpm install element-plus\n\n\n1\n\n\n# 2.4.1. 全局引入\n\n一种引入element-plus的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：\n\nimport ElementPlus from \'element-plus\'\nimport \'element-plus/lib/theme-chalk/index.css\'\n\nimport router from \'./router\'\nimport store from \'./store\'\n\ncreateApp(App).use(router).use(store).use(ElementPlus).mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2.4.2. 局部引入（旧）\n\n也就是在开发中用到某个组件对某个组件进行引入：\n\n<template>\n  <div id="app">\n    <router-link to="/login">登录</router-link>\n    <router-link to="/main">首页</router-link>\n    <router-view></router-view>\n\n    <h2>{{ $store.state.name }}</h2>\n\n    <el-button>默认按钮</el-button>\n    <el-button type="primary">主要按钮</el-button>\n    <el-button type="success">成功按钮</el-button>\n    <el-button type="info">信息按钮</el-button>\n    <el-button type="warning">警告按钮</el-button>\n    <el-button type="danger">危险按钮</el-button>\n  </div>\n</template>\n\n<script lang="ts">\nimport { defineComponent } from \'vue\'\n\nimport { ElButton } from \'element-plus\'\n\nexport default defineComponent({\n  name: \'App\',\n  components: {\n    ElButton\n  }\n})\n<\/script>\n\n<style lang="less">\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n但是我们会发现是没有对应的样式的，引入样式有两种方式：\n\n * 全局引用样式（像之前做的那样）；\n * 局部引用样式（通过babel的插件）；\n\n1.安装babel的插件：\n\nnpm install babel-plugin-import -D\n\n\n1\n\n\n2.配置babel.config.js\n\nmodule.exports = {\n  plugins: [\n    [\n      \'import\',\n      {\n        libraryName: \'element-plus\',\n        customStyleName: (name) => {\n          return `element-plus/lib/theme-chalk/${name}.css`\n        }\n      }\n    ]\n  ],\n  presets: [\'@vue/cli-plugin-babel/preset\']\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n但是这里依然有个弊端：\n\n * 这些组件我们在多个页面或者组件中使用的时候，都需要导入并且在components中进行注册；\n * 所以我们可以将它们在全局注册一次；\n\nimport {\n  ElButton,\n  ElTable,\n  ElAlert,\n  ElAside,\n  ElAutocomplete,\n  ElAvatar,\n  ElBacktop,\n  ElBadge,\n} from \'element-plus\'\n\nconst app = createApp(App)\n\nconst components = [\n  ElButton,\n  ElTable,\n  ElAlert,\n  ElAside,\n  ElAutocomplete,\n  ElAvatar,\n  ElBacktop,\n  ElBadge\n]\n\nfor (const cpn of components) {\n  app.component(cpn.name, cpn)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 2.4.3 局部按需导入 🔥\n\n参考文档\n\n首先你需要安装unplugin-vue-components 和 unplugin-auto-import这两款插件\n\nnpm install -D unplugin-vue-components unplugin-auto-import\n\n\n1\n\n\n然后把下列代码插入到你的 Vite 或 Webpack 的配置文件中\n\n// vue.config.js\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst AutoImport = require(\'unplugin-auto-import/webpack\')\nconst Components = require(\'unplugin-vue-components/webpack\')\nconst { ElementPlusResolver } = require(\'unplugin-vue-components/resolvers\')\n\nmodule.exports = {\n  configureWebpack: {\n    plugins: [\n      // 自动导入\n      AutoImport({\n        resolvers: [ElementPlusResolver()],\n      }),\n      // 自动导入\n      Components({\n        resolvers: [ElementPlusResolver()],\n      }),\n    ],\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n// vite.config.ts\nimport AutoImport from \'unplugin-auto-import/vite\'\nimport Components from \'unplugin-vue-components/vite\'\nimport { ElementPlusResolver } from \'unplugin-vue-components/resolvers\'\n\nexport default {\n  plugins: [\n    // ...\n    AutoImport({\n      resolvers: [ElementPlusResolver()],\n    }),\n    Components({\n      resolvers: [ElementPlusResolver()],\n    }),\n  ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// webpack.config.js\nconst AutoImport = require(\'unplugin-auto-import/webpack\')\nconst Components = require(\'unplugin-vue-components/webpack\')\nconst { ElementPlusResolver } = require(\'unplugin-vue-components/resolvers\')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    AutoImport({\n      resolvers: [ElementPlusResolver()],\n    }),\n    Components({\n      resolvers: [ElementPlusResolver()],\n    }),\n  ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.5. axios集成\n\n安装axios：\n\nnpm install axios\n\n\n1\n\n\n封装axios：\n\nimport axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from \'axios\'\nimport { Result } from \'./types\'\nimport { useUserStore } from \'/@/store/modules/user\'\n\nclass HYRequest {\n  private instance: AxiosInstance\n\n  private readonly options: AxiosRequestConfig\n\n  constructor(options: AxiosRequestConfig) {\n    this.options = options\n    this.instance = axios.create(options)\n\n    this.instance.interceptors.request.use(\n      (config) => {\n        const token = useUserStore().getToken\n        if (token) {\n          config.headers.Authorization = `Bearer ${token}`\n        }\n        return config\n      },\n      (err) => {\n        return err\n      }\n    )\n\n    this.instance.interceptors.response.use(\n      (res) => {\n        // 拦截响应的数据\n        if (res.data.code === 0) {\n          return res.data.data\n        }\n        return res.data\n      },\n      (err) => {\n        return err\n      }\n    )\n  }\n\n  request<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.instance\n        .request<any, AxiosResponse<Result<T>>>(config)\n        .then((res) => {\n          resolve((res as unknown) as Promise<T>)\n        })\n        .catch((err) => {\n          reject(err)\n        })\n    })\n  }\n\n  get<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return this.request({ ...config, method: \'GET\' })\n  }\n\n  post<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return this.request({ ...config, method: \'POST\' })\n  }\n\n  patch<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return this.request({ ...config, method: \'PATCH\' })\n  }\n\n  delete<T = any>(config: AxiosRequestConfig): Promise<T> {\n    return this.request({ ...config, method: \'DELETE\' })\n  }\n}\n\nexport default HYRequest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\nreponseInterceptor 封装泛型问题\n\n\n\n\n# 2.6 环境变量 🔥\n\n在开发中，有时候我们需要根据不同的环境设置不同的环境变量，常见的有三种环境:\n\n * 开发环境:development;\n * 生产环境:production;\n * 测试环境:test;\n\n如何区分环境变量呢?常见有三种方式:\n\n * 方式一:手动修改不同的变量;\n * 方式二:根据process.env.NODE_ENV的值进行区分; 🔥\n * 方式三:编写不同的环境变量配置文件（vue-cli支持的）\n\n// config.ts\n// 1.方式一: 手动的切换不同的环境(不推荐)\n// const BASE_URL = \'http://coderwhy.org/dev\'\n// const BASE_NAME = \'coderwhy\'\n\n// const BASE_URL = \'http://coderwhy.org/prod\'\n// const BASE_NAME = \'kobe\'\n\n// const BASE_URL = \'http://coderwhy.org/test\'\n// const BASE_NAME = \'james\'\n\n// 2.根据process.env.NODE_ENV区分\n// 开发环境: development\n// 生成环境: production\n// 测试环境: test\n\nlet BASE_URL = \'\'\nconst TIME_OUT = 10000\n\nif (process.env.NODE_ENV === \'development\') {\n  BASE_URL = \'http://123.207.32.32:8000/\'\n} else if (process.env.NODE_ENV === \'production\') {\n  BASE_URL = \'http://coderwhy.org/prod\'\n} else {\n  BASE_URL = \'http://coderwhy.org/test\'\n}\n\nexport { BASE_URL, TIME_OUT }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nVue-cli 模式和环境变量\n\n模式是 Vue CLI 项目中一个重要的概念。默认情况下，一个 Vue CLI 项目有三个模式：\n\n * development 模式用于 vue-cli-service serve\n * test 模式用于 vue-cli-service test:unit\n * production 模式用于 vue-cli-service build 和 vue-cli-service test:e2e\n\n你可以通过传递 --mode 选项参数为命令行覆写默认的模式。例如，如果你想要在构建命令中使用开发环境变量：\n\n.env.development\n\nVUE_APP_BASE_URL=https://coderwhy.org/dev\nVUE_APP_BASE_NAME=coderwhy\n\n\n1\n2\n\n\n.env.production\n\nVUE_APP_BASE_URL=https://coderwhy.org/prod\nVUE_APP_BASE_NAME=kobe\n\n\n1\n2\n\n\n使用\n\nconsole.log(process.env.VUE_APP_SECRET)\n\n\n1\n\n\n\n# normalize.css\n\nnpm i normalize.css\n\n\n1\n\n\nmain.ts\n\nimport \'normalize.css\'\nimport \'./assets/css/index.less\'\n\n\n1\n2\n\n\n\n# VSCode配置\n\n{\n  "workbench.iconTheme": "vscode-great-icons",\n  "editor.fontSize": 17,\n  "eslint.migration.2_x": "off",\n  "[javascript]": {\n    "editor.defaultFormatter": "dbaeumer.vscode-eslint"\n  },\n  "files.autoSave": "afterDelay",\n  "editor.tabSize": 2,\n  "terminal.integrated.fontSize": 16,\n  "editor.renderWhitespace": "all",\n  "editor.quickSuggestions": {\n    "strings": true\n  },\n  "debug.console.fontSize": 15,\n  "window.zoomLevel": 1,\n  "emmet.includeLanguages": {\n    "javascript": "javascriptreact"\n  },\n  "explorer.confirmDragAndDrop": false,\n  "workbench.tree.indent": 16,\n  "javascript.updateImportsOnFileMove.enabled": "always",\n  "editor.wordWrap": "on",\n  "path-intellisense.mappings": {\n    "@": "${workspaceRoot}/src"\n  },\n  "hediet.vscode-drawio.local-storage": "eyIuZHJhd2lvLWNvbmZpZyI6IntcImxhbmd1YWdlXCI6XCJcIixcImN1c3RvbUZvbnRzXCI6W10sXCJsaWJyYXJpZXNcIjpcImdlbmVyYWw7YmFzaWM7YXJyb3dzMjtmbG93Y2hhcnQ7ZXI7c2l0ZW1hcDt1bWw7YnBtbjt3ZWJpY29uc1wiLFwiY3VzdG9tTGlicmFyaWVzXCI6W1wiTC5zY3JhdGNocGFkXCJdLFwicGx1Z2luc1wiOltdLFwicmVjZW50Q29sb3JzXCI6W1wiRkYwMDAwXCIsXCIwMENDNjZcIixcIm5vbmVcIixcIkNDRTVGRlwiLFwiNTI1MjUyXCIsXCJGRjMzMzNcIixcIjMzMzMzM1wiLFwiMzMwMDAwXCIsXCIwMENDQ0NcIixcIkZGNjZCM1wiLFwiRkZGRkZGMDBcIl0sXCJmb3JtYXRXaWR0aFwiOjI0MCxcImNyZWF0ZVRhcmdldFwiOmZhbHNlLFwicGFnZUZvcm1hdFwiOntcInhcIjowLFwieVwiOjAsXCJ3aWR0aFwiOjExNjksXCJoZWlnaHRcIjoxNjU0fSxcInNlYXJjaFwiOnRydWUsXCJzaG93U3RhcnRTY3JlZW5cIjp0cnVlLFwiZ3JpZENvbG9yXCI6XCIjZDBkMGQwXCIsXCJkYXJrR3JpZENvbG9yXCI6XCIjNmU2ZTZlXCIsXCJhdXRvc2F2ZVwiOnRydWUsXCJyZXNpemVJbWFnZXNcIjpudWxsLFwib3BlbkNvdW50ZXJcIjowLFwidmVyc2lvblwiOjE4LFwidW5pdFwiOjEsXCJpc1J1bGVyT25cIjpmYWxzZSxcInVpXCI6XCJcIn0ifQ==",\n  "hediet.vscode-drawio.theme": "Kennedy",\n  "editor.fontFamily": "Source Code Pro, \'Courier New\', monospace",\n  "editor.smoothScrolling": true,\n  "editor.formatOnSave": true,\n  "editor.defaultFormatter": "esbenp.prettier-vscode",\n  "workbench.colorTheme": "Atom One Dark",\n  "vetur.completion.autoImport": false,\n  "security.workspace.trust.untrustedFiles": "open",\n  "eslint.lintTask.enable": true,\n  "eslint.alwaysShowStatus": true,\n  "editor.codeActionsOnSave": {\n    "source.fixAll.eslint": true\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 接口文档\n\nhttps://documenter.getpostman.com/view/12387168/TzsfmQvw\n\nbaseURL的值：\n\nhttp://152.136.185.210:5000\n\n\n1\n\n\n设置全局token的方法：\n\nconst res = pm.response.json();\npm.globals.set("token", res.data.token);\n\n\n1\n2\n\n\n接口文档v2版本：（有部分更新）\n\nhttps://documenter.getpostman.com/view/12387168/TzzDKb12',normalizedContent:'# 搭建项目\n\n\n# 创建项目\n\nvue create vue3-ts-cms\n\nvue cli v4.5.15\n┌──────────────────────────────────────────┐\n│                                          │\n│   new version available 4.5.15 → 5.0.4   │\n│     run npm i -g @vue/cli to update!     │\n│                                          │\n└──────────────────────────────────────────┘\n\n? please pick a preset: manually select features\n? check the features needed for your project: choose vue version, babel, ts, css pre-processors, linter\n\n\n? choose a version of vue.js that you want to start the project with 3.x\n? use class-style component syntax? no\n? use babel alongside typescript (required for modern mode, auto-detected polyfills, transpiling jsx)?\nyes\n? pick a css pre-processor (postcss, autoprefixer and css modules are supported by default): less\n? pick a linter / formatter config: prettier\n? pick additional lint features: lint on save\n? where do you prefer placing config for babel, eslint, etc.? in dedicated config files\n? save this as a preset for future projects? (y/n) n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 代码规范\n\n\n# 1.1. 集成.editorconfig 配置\n\neditorconfig 有助于为不同 ide 编辑器上处理同一项目的多个开发人员维护一致的编码风格。\n\n# http://editorconfig.org\n\nroot = true\n\n[*] # 表示所有文件适用\ncharset = utf-8 # 设置文件字符集为 utf-8\nindent_style = space # 缩进风格（tab | space）\nindent_size = 2 # 缩进大小\nend_of_line = lf # 控制换行类型(lf | cr | crlf)\ntrim_trailing_whitespace = true # 去除行首的任意空白字符\ninsert_final_newline = true # 始终在文件末尾插入一个新行\n\n[*.md] # 表示仅 md 文件适用以下规则\nmax_line_length = off\ntrim_trailing_whitespace = false\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nvscode 需要安装一个插件：editorconfig for vs code\n\n\n\n\n# 1.2. 使用 prettier 工具\n\nprettier 是一款强大的代码格式化工具，支持 javascript、typescript、css、scss、less、jsx、angular、vue、graphql、json、markdown 等语言，基本上前端能用到的文件格式它都可以搞定，是当下最流行的代码格式化工具。\n\n1.安装 prettier\n\nnpm install prettier -d\n\n\n1\n\n\n2.配置.prettierrc 文件：\n\n * usetabs：使用 tab 缩进还是空格缩进，选择 false；\n * tabwidth：tab 是空格的情况下，是几个空格，选择 2 个；\n * printwidth：当行字符的长度，推荐 80，也有人喜欢 100 或者 120；\n * singlequote：使用单引号还是双引号，选择 true，使用单引号；\n * trailingcomma：在多行输入的尾逗号是否添加，可设置为 none、all\n * semi：语句末尾是否要加分号，默认值 true，选择 false 表示不加；\n\n{\n  "usetabs": false,\n  "tabwidth": 2,\n  "printwidth": 80,\n  "singlequote": true,\n  "trailingcomma": "all",\n  "semi": false\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n3.创建.prettierignore 忽略文件\n\n/dist/*\n.local\n.output.js\n/node_modules/**\n\n**/*.svg\n**/*.sh\n\n/public/*\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n4.vscode 需要安装 prettier 的插件\n\n\n\n5.测试 prettier 是否生效\n\n * 测试一：在代码中保存代码；\n * 测试二：配置一次性修改的命令；\n\n在 package.json 中配置一个 scripts：\n\n"prettier": "prettier --write ."\n\n\n1\n\n\n\n# 1.3. 使用 eslint 检测\n\n1.在前面创建项目的时候，我们就选择了 eslint，所以 vue 会默认帮助我们配置需要的 eslint 环境。\n\n2.vscode 需要安装 eslint 插件：\n\n\n\n3.解决 eslint 和 prettier 冲突的问题：\n\n安装插件：（vue 在创建项目时，如果选择 eslint-prettier，那么这两个插件会自动安装）\n\nnpm i eslint-plugin-prettier eslint-config-prettier -d\n\n\n1\n\n\n添加 prettier 插件：\n\n  extends: [\n    "plugin:vue/vue3-essential",\n    "eslint:recommended",\n    "@vue/typescript/recommended",\n    "@vue/prettier",\n    "@vue/prettier/@typescript-eslint",\n    \'plugin:prettier/recommended\'\n  ],\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n# 1.4. git husky 和 eslint\n\n虽然我们已经要求项目使用 eslint 了，但是不能保证组员提交代码之前都将 eslint 中的问题解决掉了：\n\n * 也就是我们希望保证代码仓库中的代码都是符合 eslint 规范的；\n\n * 那么我们需要在组员执行 git commit 命令的时候对其进行校验，如果不符合 eslint 规范，那么自动通过规范进行修复；\n\n那么如何做到这一点呢？可以通过 husky 工具：\n\n * husky 是一个 git hook 工具，可以帮助我们触发 git 提交的各个阶段：pre-commit、commit-msg、pre-push\n\n如何使用 husky 呢？\n\n这里我们可以使用自动配置命令：\n\nnpx husky-init && npm install\nnpx husky-init \'&&\' npm install # powershell \n\n\n1\n2\n\n\n这里会做三件事：\n\n1.安装 husky 相关的依赖：\n\n\n\n2.在项目目录下创建 .husky 文件夹：\n\nnpx huksy install\n\n\n1\n\n\n\n\n3.在 package.json 中添加一个脚本：\n\n\n\n接下来，我们需要去完成一个操作：在进行 commit 时，执行 lint 脚本：\n\n\n\n这个时候我们执行 git commit 的时候会自动对代码进行 lint 校验。\n\n\n# 1.5. git commit 规范\n\n# 1.5.1. 代码提交风格\n\n通常我们的 git commit 会按照统一的风格来提交，这样可以快速定位每次提交的内容，方便之后对版本进行控制。\n\n\n\n但是如果每次手动来编写这些是比较麻烦的事情，我们可以使用一个工具：commitizen\n\n * commitizen 是一个帮助我们编写规范 commit message 的工具；\n   \n   1.安装 commitizen\n\nnpm install commitizen -d\n\n\n1\n\n\n2.安装 cz-conventional-changelog，并且初始化 cz-conventional-changelog：\n\nnpx commitizen init cz-conventional-changelog --save-dev --save-exact\n\n\n1\n\n\n这个命令会帮助我们安装 cz-conventional-changelog：\n\n\n\n并且在 package.json 中进行配置：\n\n\n\n这个时候我们提交代码需要使用 npx cz：\n\n * 第一步是选择 type，本次更新的类型\n\ntype       作用\nfeat       新增特性 (feature)\nfix        修复 bug(bug fix)\ndocs       修改文档 (documentation)\nstyle      代码格式修改(white-space, formatting, missing semi colons, etc)\nrefactor   代码重构(refactor)\nperf       改善性能(a code change that improves performance)\ntest       测试(when adding missing tests)\nbuild      变更项目构建或外部依赖（例如 scopes: webpack、gulp、npm 等）\nci         更改持续集成软件的配置文件和 package 中的 scripts 命令，例如 scopes: travis,\n           circle 等\nchore      变更构建流程或辅助工具(比如更改测试环境)\nrevert     代码回退\n\n * 第二步选择本次修改的范围（作用域）\n\n\n\n * 第三步选择提交的信息\n\n\n\n * 第四步提交详细的描述信息\n\n\n\n * 第五步是否是一次重大的更改\n\n\n\n * 第六步是否影响某个 open issue\n\n\n\n我们也可以在 scripts 中构建一个命令来执行 cz：\n\n\n\n# 1.5.2. 代码提交验证\n\n如果我们按照 cz 来规范了提交风格，但是依然有同事通过 git commit 按照不规范的格式提交应该怎么办呢？\n\n * 我们可以通过 commitlint 来限制提交；\n   \n   1.安装 @commitlint/config-conventional 和 @commitlint/cli\n\nnpm i @commitlint/config-conventional @commitlint/cli -d\n\n\n1\n\n\n2.在根目录创建 commitlint.config.js 文件，配置 commitlint\n\nmodule.exports = {\n  extends: [\'@commitlint/config-conventional\'],\n}\n\n\n1\n2\n3\n\n\n3.使用 husky 生成 commit-msg 文件，验证提交信息：\n\nnpx husky add .husky/commit-msg "npx --no-install commitlint --edit $1"\n\n\n1\n\n\n\n# 第三方库集成\n\n\n# 2.1. vue.config.js配置\n\nvue.config.js有三种配置方式：\n\n * 方式一：直接通过cli提供给我们的选项来配置：\n   * 比如publicpath：配置应用程序部署的子目录（默认是 /，相当于部署在 https://www.my-app.com/）；\n   * 比如outputdir：修改输出的文件夹；\n * 方式二：通过configurewebpack修改webpack的配置：\n   * 可以是一个对象，直接会被合并；\n   * 可以是一个函数，会接收一个config，可以通过config来修改配置；\n * 方式三：通过chainwebpack修改webpack的配置：\n   * 是一个函数，会接收一个基于 webpack-chain 的config对象，可以对配置进行修改；\n\nconst path = require(\'path\')\n\nmodule.exports = {\n  outputdir: \'./build\',\n  // configurewebpack: {\n  //   resolve: {\n  //     alias: {\n  //       views: \'@/views\'\n  //     }\n  //   }\n  // }\n  // configurewebpack: (config) => {\n  //   config.resolve.alias = {\n  //     \'@\': path.resolve(__dirname, \'src\'),\n  //     views: \'@/views\'\n  //   }\n  // },\n  chainwebpack: (config) => {\n    config.resolve.alias.set(\'@\', path.resolve(__dirname, \'src\')).set(\'views\', \'@/views\')\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 2.2. vue-router集成\n\n安装vue-router的最新版本：\n\nnpm install vue-router@next\n\n\n1\n\n\n创建router对象：\n\nimport { createrouter, createwebhashhistory } from \'vue-router\'\nimport { routerecordraw } from \'vue-router\'\n\nconst routes: routerecordraw[] = [\n  {\n    path: \'/\',\n    redirect: \'/main\'\n  },\n  {\n    path: \'/main\',\n    component: () => import(\'../views/main/main.vue\')\n  },\n  {\n    path: \'/login\',\n    component: () => import(\'../views/login/login.vue\')\n  }\n]\n\nconst router = createrouter({\n  routes,\n  history: createwebhashhistory()\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\n安装router：\n\nimport router from \'./router\'\n\ncreateapp(app).use(router).mount(\'#app\')\n\n\n1\n2\n3\n\n\n在app.vue中配置跳转：\n\n<template>\n  <div id="app">\n    <router-link to="/login">登录</router-link>\n    <router-link to="/main">首页</router-link>\n    <router-view></router-view>\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 2.3. vuex集成\n\n安装vuex：\n\nnpm install vuex@next\n\n\n1\n\n\n创建store对象：\n\nimport { createstore } from \'vuex\'\n\nconst store = createstore({\n  state() {\n    return {\n      name: \'coderwhy\'\n    }\n  }\n})\n\nexport default store\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n安装store：\n\ncreateapp(app).use(router).use(store).mount(\'#app\')\n\n\n1\n\n\n在app.vue中使用：\n\n<h2>{{ $store.state.name }}</h2>\n\n\n1\n\n\n\n# 2.4. element-plus集成\n\nelement plus，一套为开发者、设计师和产品经理准备的基于 vue 3.0 的桌面端组件库：\n\n * 相信很多同学在vue2中都使用过element-ui，而element-plus正是element-ui针对于vue3开发的一个ui组件库；\n * 它的使用方式和很多其他的组件库是一样的，所以学会element-plus，其他类似于ant-design-vue、naiveui、vantui都是差不多的；\n\n安装element-plus\n\nnpm install element-plus\n\n\n1\n\n\n# 2.4.1. 全局引入\n\n一种引入element-plus的方式是全局引入，代表的含义是所有的组件和插件都会被自动注册：\n\nimport elementplus from \'element-plus\'\nimport \'element-plus/lib/theme-chalk/index.css\'\n\nimport router from \'./router\'\nimport store from \'./store\'\n\ncreateapp(app).use(router).use(store).use(elementplus).mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n# 2.4.2. 局部引入（旧）\n\n也就是在开发中用到某个组件对某个组件进行引入：\n\n<template>\n  <div id="app">\n    <router-link to="/login">登录</router-link>\n    <router-link to="/main">首页</router-link>\n    <router-view></router-view>\n\n    <h2>{{ $store.state.name }}</h2>\n\n    <el-button>默认按钮</el-button>\n    <el-button type="primary">主要按钮</el-button>\n    <el-button type="success">成功按钮</el-button>\n    <el-button type="info">信息按钮</el-button>\n    <el-button type="warning">警告按钮</el-button>\n    <el-button type="danger">危险按钮</el-button>\n  </div>\n</template>\n\n<script lang="ts">\nimport { definecomponent } from \'vue\'\n\nimport { elbutton } from \'element-plus\'\n\nexport default definecomponent({\n  name: \'app\',\n  components: {\n    elbutton\n  }\n})\n<\/script>\n\n<style lang="less">\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n但是我们会发现是没有对应的样式的，引入样式有两种方式：\n\n * 全局引用样式（像之前做的那样）；\n * 局部引用样式（通过babel的插件）；\n\n1.安装babel的插件：\n\nnpm install babel-plugin-import -d\n\n\n1\n\n\n2.配置babel.config.js\n\nmodule.exports = {\n  plugins: [\n    [\n      \'import\',\n      {\n        libraryname: \'element-plus\',\n        customstylename: (name) => {\n          return `element-plus/lib/theme-chalk/${name}.css`\n        }\n      }\n    ]\n  ],\n  presets: [\'@vue/cli-plugin-babel/preset\']\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n但是这里依然有个弊端：\n\n * 这些组件我们在多个页面或者组件中使用的时候，都需要导入并且在components中进行注册；\n * 所以我们可以将它们在全局注册一次；\n\nimport {\n  elbutton,\n  eltable,\n  elalert,\n  elaside,\n  elautocomplete,\n  elavatar,\n  elbacktop,\n  elbadge,\n} from \'element-plus\'\n\nconst app = createapp(app)\n\nconst components = [\n  elbutton,\n  eltable,\n  elalert,\n  elaside,\n  elautocomplete,\n  elavatar,\n  elbacktop,\n  elbadge\n]\n\nfor (const cpn of components) {\n  app.component(cpn.name, cpn)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n# 2.4.3 局部按需导入 🔥\n\n参考文档\n\n首先你需要安装unplugin-vue-components 和 unplugin-auto-import这两款插件\n\nnpm install -d unplugin-vue-components unplugin-auto-import\n\n\n1\n\n\n然后把下列代码插入到你的 vite 或 webpack 的配置文件中\n\n// vue.config.js\n/* eslint-disable @typescript-eslint/no-var-requires */\nconst autoimport = require(\'unplugin-auto-import/webpack\')\nconst components = require(\'unplugin-vue-components/webpack\')\nconst { elementplusresolver } = require(\'unplugin-vue-components/resolvers\')\n\nmodule.exports = {\n  configurewebpack: {\n    plugins: [\n      // 自动导入\n      autoimport({\n        resolvers: [elementplusresolver()],\n      }),\n      // 自动导入\n      components({\n        resolvers: [elementplusresolver()],\n      }),\n    ],\n  },\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n// vite.config.ts\nimport autoimport from \'unplugin-auto-import/vite\'\nimport components from \'unplugin-vue-components/vite\'\nimport { elementplusresolver } from \'unplugin-vue-components/resolvers\'\n\nexport default {\n  plugins: [\n    // ...\n    autoimport({\n      resolvers: [elementplusresolver()],\n    }),\n    components({\n      resolvers: [elementplusresolver()],\n    }),\n  ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n// webpack.config.js\nconst autoimport = require(\'unplugin-auto-import/webpack\')\nconst components = require(\'unplugin-vue-components/webpack\')\nconst { elementplusresolver } = require(\'unplugin-vue-components/resolvers\')\n\nmodule.exports = {\n  // ...\n  plugins: [\n    autoimport({\n      resolvers: [elementplusresolver()],\n    }),\n    components({\n      resolvers: [elementplusresolver()],\n    }),\n  ],\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# 2.5. axios集成\n\n安装axios：\n\nnpm install axios\n\n\n1\n\n\n封装axios：\n\nimport axios, { axiosinstance, axiosrequestconfig, axiosresponse } from \'axios\'\nimport { result } from \'./types\'\nimport { useuserstore } from \'/@/store/modules/user\'\n\nclass hyrequest {\n  private instance: axiosinstance\n\n  private readonly options: axiosrequestconfig\n\n  constructor(options: axiosrequestconfig) {\n    this.options = options\n    this.instance = axios.create(options)\n\n    this.instance.interceptors.request.use(\n      (config) => {\n        const token = useuserstore().gettoken\n        if (token) {\n          config.headers.authorization = `bearer ${token}`\n        }\n        return config\n      },\n      (err) => {\n        return err\n      }\n    )\n\n    this.instance.interceptors.response.use(\n      (res) => {\n        // 拦截响应的数据\n        if (res.data.code === 0) {\n          return res.data.data\n        }\n        return res.data\n      },\n      (err) => {\n        return err\n      }\n    )\n  }\n\n  request<t = any>(config: axiosrequestconfig): promise<t> {\n    return new promise((resolve, reject) => {\n      this.instance\n        .request<any, axiosresponse<result<t>>>(config)\n        .then((res) => {\n          resolve((res as unknown) as promise<t>)\n        })\n        .catch((err) => {\n          reject(err)\n        })\n    })\n  }\n\n  get<t = any>(config: axiosrequestconfig): promise<t> {\n    return this.request({ ...config, method: \'get\' })\n  }\n\n  post<t = any>(config: axiosrequestconfig): promise<t> {\n    return this.request({ ...config, method: \'post\' })\n  }\n\n  patch<t = any>(config: axiosrequestconfig): promise<t> {\n    return this.request({ ...config, method: \'patch\' })\n  }\n\n  delete<t = any>(config: axiosrequestconfig): promise<t> {\n    return this.request({ ...config, method: \'delete\' })\n  }\n}\n\nexport default hyrequest\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n\n\nreponseinterceptor 封装泛型问题\n\n\n\n\n# 2.6 环境变量 🔥\n\n在开发中，有时候我们需要根据不同的环境设置不同的环境变量，常见的有三种环境:\n\n * 开发环境:development;\n * 生产环境:production;\n * 测试环境:test;\n\n如何区分环境变量呢?常见有三种方式:\n\n * 方式一:手动修改不同的变量;\n * 方式二:根据process.env.node_env的值进行区分; 🔥\n * 方式三:编写不同的环境变量配置文件（vue-cli支持的）\n\n// config.ts\n// 1.方式一: 手动的切换不同的环境(不推荐)\n// const base_url = \'http://coderwhy.org/dev\'\n// const base_name = \'coderwhy\'\n\n// const base_url = \'http://coderwhy.org/prod\'\n// const base_name = \'kobe\'\n\n// const base_url = \'http://coderwhy.org/test\'\n// const base_name = \'james\'\n\n// 2.根据process.env.node_env区分\n// 开发环境: development\n// 生成环境: production\n// 测试环境: test\n\nlet base_url = \'\'\nconst time_out = 10000\n\nif (process.env.node_env === \'development\') {\n  base_url = \'http://123.207.32.32:8000/\'\n} else if (process.env.node_env === \'production\') {\n  base_url = \'http://coderwhy.org/prod\'\n} else {\n  base_url = \'http://coderwhy.org/test\'\n}\n\nexport { base_url, time_out }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nvue-cli 模式和环境变量\n\n模式是 vue cli 项目中一个重要的概念。默认情况下，一个 vue cli 项目有三个模式：\n\n * development 模式用于 vue-cli-service serve\n * test 模式用于 vue-cli-service test:unit\n * production 模式用于 vue-cli-service build 和 vue-cli-service test:e2e\n\n你可以通过传递 --mode 选项参数为命令行覆写默认的模式。例如，如果你想要在构建命令中使用开发环境变量：\n\n.env.development\n\nvue_app_base_url=https://coderwhy.org/dev\nvue_app_base_name=coderwhy\n\n\n1\n2\n\n\n.env.production\n\nvue_app_base_url=https://coderwhy.org/prod\nvue_app_base_name=kobe\n\n\n1\n2\n\n\n使用\n\nconsole.log(process.env.vue_app_secret)\n\n\n1\n\n\n\n# normalize.css\n\nnpm i normalize.css\n\n\n1\n\n\nmain.ts\n\nimport \'normalize.css\'\nimport \'./assets/css/index.less\'\n\n\n1\n2\n\n\n\n# vscode配置\n\n{\n  "workbench.icontheme": "vscode-great-icons",\n  "editor.fontsize": 17,\n  "eslint.migration.2_x": "off",\n  "[javascript]": {\n    "editor.defaultformatter": "dbaeumer.vscode-eslint"\n  },\n  "files.autosave": "afterdelay",\n  "editor.tabsize": 2,\n  "terminal.integrated.fontsize": 16,\n  "editor.renderwhitespace": "all",\n  "editor.quicksuggestions": {\n    "strings": true\n  },\n  "debug.console.fontsize": 15,\n  "window.zoomlevel": 1,\n  "emmet.includelanguages": {\n    "javascript": "javascriptreact"\n  },\n  "explorer.confirmdraganddrop": false,\n  "workbench.tree.indent": 16,\n  "javascript.updateimportsonfilemove.enabled": "always",\n  "editor.wordwrap": "on",\n  "path-intellisense.mappings": {\n    "@": "${workspaceroot}/src"\n  },\n  "hediet.vscode-drawio.local-storage": "eyiuzhjhd2lvlwnvbmzpzyi6intcimxhbmd1ywdlxci6xcjciixcimn1c3rvbuzvbnrzxci6w10sxcjsawjyyxjpzxncijpcimdlbmvyyww7ymfzawm7yxjyb3dzmjtmbg93y2hhcnq7zxi7c2l0zw1hcdt1bww7ynbtbjt3zwjpy29uc1wilfwiy3vzdg9ttglicmfyawvzxci6w1witc5zy3jhdgnocgfkxcjdlfwicgx1z2luc1wioltdlfwicmvjzw50q29sb3jzxci6w1wirkywmdawxcisxciwmendnjzciixcim5vbmvciixcikndrtvgrlwilfwinti1mjuyxcisxcjgrjmzmznciixcijmzmzmzm1wilfwimzmwmdawxcisxciwmendq0nciixcikzgnjzcm1wilfwirkzgrkzgmdbcil0sxcjmb3jtyxrxawr0afwioji0mcxcimnyzwf0zvrhcmdldfwiomzhbhnllfwicgfnzuzvcm1hdfwiontcinhcijowlfwievwiojasxcj3awr0afwiojexnjksxcjozwlnahrcijoxnju0fsxcinnlyxjjafwionrydwusxcjzag93u3rhcnrty3jlzw5cijp0cnvllfwiz3jpzenvbg9yxci6xcijzdbkmgqwxcisxcjkyxjrr3jpzenvbg9yxci6xcijnmu2ztzlxcisxcjhdxrvc2f2zvwionrydwusxcjyzxnpemvjbwfnzxncijpudwxslfwib3blbknvdw50zxjcijowlfwidmvyc2lvblwioje4lfwidw5pdfwiojesxcjpc1j1bgvyt25cijpmywxzzsxcinvpxci6xcjcin0ifq==",\n  "hediet.vscode-drawio.theme": "kennedy",\n  "editor.fontfamily": "source code pro, \'courier new\', monospace",\n  "editor.smoothscrolling": true,\n  "editor.formatonsave": true,\n  "editor.defaultformatter": "esbenp.prettier-vscode",\n  "workbench.colortheme": "atom one dark",\n  "vetur.completion.autoimport": false,\n  "security.workspace.trust.untrustedfiles": "open",\n  "eslint.linttask.enable": true,\n  "eslint.alwaysshowstatus": true,\n  "editor.codeactionsonsave": {\n    "source.fixall.eslint": true\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 接口文档\n\nhttps://documenter.getpostman.com/view/12387168/tzsfmqvw\n\nbaseurl的值：\n\nhttp://152.136.185.210:5000\n\n\n1\n\n\n设置全局token的方法：\n\nconst res = pm.response.json();\npm.globals.set("token", res.data.token);\n\n\n1\n2\n\n\n接口文档v2版本：（有部分更新）\n\nhttps://documenter.getpostman.com/view/12387168/tzzdkb12',charsets:{cjk:!0},lastUpdated:"2022/04/30, 01:54:50",lastUpdatedTimestamp:165128369e4},{title:"组件化开发",frontmatter:{title:"组件化开发",date:"2022-01-16T16:20:57.000Z",permalink:"/pages/d2d257/",categories:["x","基础"],tags:[null]},regularPath:"/1403.Vue3.x/100.%E5%9F%BA%E7%A1%80/106.%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91.html",relativePath:"1403.Vue3.x/100.基础/106.组件化开发.md",key:"v-c516b5da",path:"/pages/d2d257/",headers:[{level:2,title:"组件的名称 🔥",slug:"组件的名称-🔥",normalizedTitle:"组件的名称 🔥",charIndex:12},{level:2,title:"全局组件",slug:"全局组件",normalizedTitle:"全局组件",charIndex:270},{level:2,title:"局部组件",slug:"局部组件",normalizedTitle:"局部组件",charIndex:2271}],headersStr:"组件的名称 🔥 全局组件 局部组件",content:'# 组件化开发\n\n\n# 组件的名称 🔥\n\n * 使用kebab-case(短横线分割符)\n   \n   必须在引用这个自定义元素时使用 kebab-case， 例如 <my-component-name>\n\n * 使用PascalCase(驼峰标识符)\n   \n   引用这个自定义元素时两种命名法都可以使用。即<my-component-name>和<MyComponentName>都可以\n   \n   但是直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的（html中，不是使用单文件模板）\n\n\n# 全局组件\n\n在任何其他的组件中都可以使用的组件\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      <component-a></component-a>\n      <component-b></component-b>\n\n      \x3c!-- <component-c></component-c> --\x3e\n      \x3c!-- <ComponentName></ComponentName> --\x3e\n      <component-name></component-name>\n    </template>\n\n    <template id="component-a">\n      <h2>{{title}}</h2>\n      <p>{{desc}}</p>\n      <button @click="btnClick">按钮点击</button>\n    </template>\n\n    <template id="component-b">\n      <div>\n        <input type="text" v-model="message" />\n        <h2>{{message}}</h2>\n      </div>\n    </template>\n\n    <template id="component-c">\n      <h2>ComponentC</h2>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const App = {\n        template: \'#my-app\',\n      }\n\n      const app = Vue.createApp(App)\n\n      // 使用app注册一个全局组件app.component()\n      // 全局组件: 意味着注册的这个组件可以在任何的组件模板中使用\n      app.component(\'component-a\', {\n        template: \'#component-a\',\n        data() {\n          return {\n            title: \'我是标题\',\n            desc: \'我是内容, 哈哈哈哈哈\',\n          }\n        },\n        methods: {\n          btnClick() {\n            console.log(\'按钮的点击\')\n          },\n        },\n      })\n\n      app.component(\'component-b\', {\n        template: \'#component-b\',\n        data() {\n          return {\n            message: \'Hello World\',\n          }\n        },\n      })\n\n      app.component(\'ComponentName\', {\n        template: \'#component-c\',\n      })\n\n      app.mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# 局部组件\n\n全局组件往往是在应用程序一开始就会全局组件完成，那么就意味着如果某些组件我们并没有用到，也会一起被注册：\n\n * 比如我们注册了三个全局组件:ComponentA、ComponentB、ComponentC;\n * 在开发中我们只使用了ComponentA、ComponentB，如果ComponentC没有用到但是我们依然在全局进行了注册，那么就意味着类似于webpack这种打包工具在打包我们的项目时，我们依然会对其进行打包;\n * 这样最终打包出的JavaScript包就会有关于ComponentC的内容，用户在下载对应的JavaScript时也会增加包的大小;\n\n开发中我们通常使用组件的时候采用的都是局部注册\n\n * 局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册。比如之前的App组件中，我们有data、computed、methods等选项了，事实上还可以有一个components选项\n * 该components选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      <h2>{{message}}</h2>\n      <component-a></component-a>\n    </template>\n\n    <template id="component-a">\n      <h2>我是组件A</h2>\n      <p>我是内容, 哈哈哈哈</p>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const ComponentA = {\n        template: \'#component-a\',\n      }\n\n      const App = {\n        template: \'#my-app\',\n        components: {\n          // key: 组件名称\n          // value: 组件对象\n          ComponentA: ComponentA,\n        },\n        data() {\n          return {\n            message: \'Hello World\',\n          }\n        },\n      }\n\n      const app = Vue.createApp(App)\n      // app.component("ComponentA", ComponentA);// 这种就是全局注册了！\n      app.mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n',normalizedContent:'# 组件化开发\n\n\n# 组件的名称 🔥\n\n * 使用kebab-case(短横线分割符)\n   \n   必须在引用这个自定义元素时使用 kebab-case， 例如 <my-component-name>\n\n * 使用pascalcase(驼峰标识符)\n   \n   引用这个自定义元素时两种命名法都可以使用。即<my-component-name>和<mycomponentname>都可以\n   \n   但是直接在 dom (即非字符串的模板) 中使用时只有 kebab-case 是有效的（html中，不是使用单文件模板）\n\n\n# 全局组件\n\n在任何其他的组件中都可以使用的组件\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      <component-a></component-a>\n      <component-b></component-b>\n\n      \x3c!-- <component-c></component-c> --\x3e\n      \x3c!-- <componentname></componentname> --\x3e\n      <component-name></component-name>\n    </template>\n\n    <template id="component-a">\n      <h2>{{title}}</h2>\n      <p>{{desc}}</p>\n      <button @click="btnclick">按钮点击</button>\n    </template>\n\n    <template id="component-b">\n      <div>\n        <input type="text" v-model="message" />\n        <h2>{{message}}</h2>\n      </div>\n    </template>\n\n    <template id="component-c">\n      <h2>componentc</h2>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const app = {\n        template: \'#my-app\',\n      }\n\n      const app = vue.createapp(app)\n\n      // 使用app注册一个全局组件app.component()\n      // 全局组件: 意味着注册的这个组件可以在任何的组件模板中使用\n      app.component(\'component-a\', {\n        template: \'#component-a\',\n        data() {\n          return {\n            title: \'我是标题\',\n            desc: \'我是内容, 哈哈哈哈哈\',\n          }\n        },\n        methods: {\n          btnclick() {\n            console.log(\'按钮的点击\')\n          },\n        },\n      })\n\n      app.component(\'component-b\', {\n        template: \'#component-b\',\n        data() {\n          return {\n            message: \'hello world\',\n          }\n        },\n      })\n\n      app.component(\'componentname\', {\n        template: \'#component-c\',\n      })\n\n      app.mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n\n\n\n# 局部组件\n\n全局组件往往是在应用程序一开始就会全局组件完成，那么就意味着如果某些组件我们并没有用到，也会一起被注册：\n\n * 比如我们注册了三个全局组件:componenta、componentb、componentc;\n * 在开发中我们只使用了componenta、componentb，如果componentc没有用到但是我们依然在全局进行了注册，那么就意味着类似于webpack这种打包工具在打包我们的项目时，我们依然会对其进行打包;\n * 这样最终打包出的javascript包就会有关于componentc的内容，用户在下载对应的javascript时也会增加包的大小;\n\n开发中我们通常使用组件的时候采用的都是局部注册\n\n * 局部注册是在我们需要使用到的组件中，通过components属性选项来进行注册。比如之前的app组件中，我们有data、computed、methods等选项了，事实上还可以有一个components选项\n * 该components选项对应的是一个对象，对象中的键值对是 组件的名称: 组件对象\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    <div id="app"></div>\n\n    <template id="my-app">\n      <h2>{{message}}</h2>\n      <component-a></component-a>\n    </template>\n\n    <template id="component-a">\n      <h2>我是组件a</h2>\n      <p>我是内容, 哈哈哈哈</p>\n    </template>\n\n    <script src="../lib/vue@3.2.26.js"><\/script>\n    <script>\n      const componenta = {\n        template: \'#component-a\',\n      }\n\n      const app = {\n        template: \'#my-app\',\n        components: {\n          // key: 组件名称\n          // value: 组件对象\n          componenta: componenta,\n        },\n        data() {\n          return {\n            message: \'hello world\',\n          }\n        },\n      }\n\n      const app = vue.createapp(app)\n      // app.component("componenta", componenta);// 这种就是全局注册了！\n      app.mount(\'#app\')\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"重点",frontmatter:{title:"重点",date:"2022-04-12T20:56:43.000Z",permalink:"/pages/b5412c/",categories:["x","项目"],tags:[null]},regularPath:"/1403.Vue3.x/1000.%E9%A1%B9%E7%9B%AE/102.%E9%87%8D%E7%82%B9.html",relativePath:"1403.Vue3.x/1000.项目/102.重点.md",key:"v-16cea650",path:"/pages/b5412c/",headers:[{level:2,title:"ref 组件类型实例",slug:"ref-组件类型实例",normalizedTitle:"ref 组件类型实例",charIndex:9},{level:2,title:"Vuex 要点",slug:"vuex-要点",normalizedTitle:"vuex 要点",charIndex:247},{level:2,title:"Vuex & TS 结合",slug:"vuex-ts-结合",normalizedTitle:"vuex &amp; ts 结合",charIndex:null},{level:2,title:"template 中别名",slug:"template-中别名",normalizedTitle:"template 中别名",charIndex:897},{level:2,title:"icon",slug:"icon",normalizedTitle:"icon",charIndex:1027},{level:2,title:"动态路由",slug:"动态路由",normalizedTitle:"动态路由",charIndex:1061},{level:2,title:"封装配置Form 🔥",slug:"封装配置form-🔥",normalizedTitle:"封装配置form 🔥",charIndex:1155},{level:2,title:"封装配置Table 🔥",slug:"封装配置table-🔥",normalizedTitle:"封装配置table 🔥",charIndex:1190},{level:2,title:"可视化 🔥",slug:"可视化-🔥",normalizedTitle:"可视化 🔥",charIndex:1275},{level:3,title:"echarts 封装",slug:"echarts-封装",normalizedTitle:"echarts 封装",charIndex:1439},{level:3,title:"SVG & Canvas",slug:"svg-canvas",normalizedTitle:"svg &amp; canvas",charIndex:null},{level:3,title:"地图",slug:"地图",normalizedTitle:"地图",charIndex:3488}],headersStr:"ref 组件类型实例 Vuex 要点 Vuex & TS 结合 template 中别名 icon 动态路由 封装配置Form 🔥 封装配置Table 🔥 可视化 🔥 echarts 封装 SVG & Canvas 地图",content:"# 重点\n\n\n# ref 组件类型实例\n\nimport LoginAccount from './login-account.vue' // vue组件\nconst accountRef = ref<InstanceType<typeof LoginAccount>>()\n\nconst handleLoginClick = () => {\n  accountRef.value?.loginAction()\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 组件——类\n * 组件实例——对象\n\n\n# Vuex 要点\n\n * Vuex 中保存的数据在刷新后会消失！所以在main.ts中写从localstorage中获取数据并写入Vuex！\n\n\n# Vuex & TS 结合\n\nstore/types.ts\n\nimport { ILoginState } from './login/types'\n\nexport interface IRootState {\n  name: string\n  age: number\n}\n\nexport interface IRootWithModule {\n  login: ILoginState\n}\n\nexport type IStoreType = IRootState & IRootWithModule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nstore/index.ts\n\nimport { useStore as useVuexStore } from 'vuex'\n\nexport function useStore(): Store<IStoreType> {\n  return useVuexStore()\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用\n\nimport { useStore } from '@/store'\n\nconst store = useStore()\nconst userMenus = computed(() => store.state.login.userMenus)\n\n\n1\n2\n3\n4\n\n\n\n# template 中别名\n\n * @映射到src，在template中需要使用~@\n   \n   <img class=\"img\" src=\"~@/assets/img/logo.svg\" alt=\"logo\" />\n   \n   \n   1\n   \n\n\n# icon\n\nel-icon 最新使用指南 SVG Icon\n\n\n# 动态路由\n\n * 前端路由（no）\n\n * 前端配置url映射componet\n   \n   可以利用coderwhy npm包进行生成\n\n * 后端返回url+componet\n\n\n# 封装配置Form 🔥\n\n * 表单\n * 查询\n * 重置\n\n\n# 封装配置Table 🔥\n\n * table\n * 分页\n * 单选、多选\n * 序号\n * 按钮插槽、右侧option插槽等\n * 其他动态插槽\n * 树表格\n\n\n# 可视化 🔥\n\n前端进行数据可视化的工具非常多，常见的框架:\n\n * ECharts 、g2、d3、vis、hightChart等等;\n * g2框架封装:bizcharts(react) viser(vue);\n * 地理可视化: g2、L7、高德的 Loca、 菜鸟的 鸟图;\n * 3D可视化:three.js;\n\n\n# echarts 封装\n\nconst chartRef = ref(); // 通过该方式可以获取dom对象\n\n\n1\n\n\n注意要在 onMounted 中 init，否则还未绑定模板，获取不到 dom\n\nHooks 封装！\n\nuseEchart.ts\n\nimport * as echarts from 'echarts'\n\nimport chinaMapData from '../data/china.json'\n\necharts.registerMap('china', chinaMapData)\n\nexport default function (el: HTMLElement) {\n  const echartInstance = echarts.init(el)\n\n  const setOptions = (options: echarts.EChartsOption) => {\n    echartInstance.setOption(options)\n  }\n\n  const updateSize = () => {\n    echartInstance.resize()\n  }\n\n  window.addEventListener('resize', () => {\n    echartInstance.resize()\n  })\n\n  return {\n    echartInstance,\n    setOptions,\n    updateSize\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nbase-echart.vue\n\n<template>\n  <div class=\"base-echart\">\n    <div ref=\"echartDivRef\" :style=\"{ width: width, height: height }\"></div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { ref, onMounted, defineProps, withDefaults, watchEffect } from 'vue'\nimport { EChartsOption } from 'echarts'\nimport useEchart from '../hooks/useEchart'\n\n// 定义props\nconst props = withDefaults(\n  defineProps<{\n    options: EChartsOption\n    width?: string\n    height?: string\n  }>(),\n  {\n    width: '100%',\n    height: '360px'\n  }\n)\n\nconst echartDivRef = ref<HTMLElement>()\n\nonMounted(() => {\n  const { setOptions } = useEchart(echartDivRef.value!)\n\n  watchEffect(() => {\n    setOptions(props.options)\n  })\n})\n<\/script>\n\n<style scoped></style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# SVG & Canvas\n\n一般来说，Canvas 更适合绘制图形元素数量非常大(这一般是由数据量大导致)的图表(如热力图、地理坐标 系或平行坐标系上的大规模线图或散点图等)，也利于实现某些视觉特效;\n\n但是，在不少场景中，SVG 具有重要的优势:它的内存占用更低(这对移动端尤其重要)、渲染性能略高、并 且用户使用浏览器内置的缩放功能时不会模糊;\n\n那么到底选择哪一个渲染器呢?\n\n * 在软硬件环境较好，数据量不大的场景下(例如 PC 端做商务报表)，两种渲染器都可以适用，并不需要太多纠结;\n\n * 在环境较差，出现性能问题需要优化的场景下，可以通过试验来确定使用哪种渲染器;\n   \n   * 比如在须要创建很多 ECharts 实例且浏览器易崩溃的情况下(可能是因为 Canvas 数量多导致内存占用超出手机承受能力)，可以使用 SVG 渲染器来进行改善;\n   * 大略得说，如果图表运行在低端安卓机，或者我们在使用一些特定图表如 水球图等，SVG 渲染器可能效果更好;\n   * 数据量很大、较多交互时，可以选用 Canvas 渲染器\n\n\n# 地图",normalizedContent:"# 重点\n\n\n# ref 组件类型实例\n\nimport loginaccount from './login-account.vue' // vue组件\nconst accountref = ref<instancetype<typeof loginaccount>>()\n\nconst handleloginclick = () => {\n  accountref.value?.loginaction()\n}\n\n\n1\n2\n3\n4\n5\n6\n\n * 组件——类\n * 组件实例——对象\n\n\n# vuex 要点\n\n * vuex 中保存的数据在刷新后会消失！所以在main.ts中写从localstorage中获取数据并写入vuex！\n\n\n# vuex & ts 结合\n\nstore/types.ts\n\nimport { iloginstate } from './login/types'\n\nexport interface irootstate {\n  name: string\n  age: number\n}\n\nexport interface irootwithmodule {\n  login: iloginstate\n}\n\nexport type istoretype = irootstate & irootwithmodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\nstore/index.ts\n\nimport { usestore as usevuexstore } from 'vuex'\n\nexport function usestore(): store<istoretype> {\n  return usevuexstore()\n}\n\n\n1\n2\n3\n4\n5\n\n\n使用\n\nimport { usestore } from '@/store'\n\nconst store = usestore()\nconst usermenus = computed(() => store.state.login.usermenus)\n\n\n1\n2\n3\n4\n\n\n\n# template 中别名\n\n * @映射到src，在template中需要使用~@\n   \n   <img class=\"img\" src=\"~@/assets/img/logo.svg\" alt=\"logo\" />\n   \n   \n   1\n   \n\n\n# icon\n\nel-icon 最新使用指南 svg icon\n\n\n# 动态路由\n\n * 前端路由（no）\n\n * 前端配置url映射componet\n   \n   可以利用coderwhy npm包进行生成\n\n * 后端返回url+componet\n\n\n# 封装配置form 🔥\n\n * 表单\n * 查询\n * 重置\n\n\n# 封装配置table 🔥\n\n * table\n * 分页\n * 单选、多选\n * 序号\n * 按钮插槽、右侧option插槽等\n * 其他动态插槽\n * 树表格\n\n\n# 可视化 🔥\n\n前端进行数据可视化的工具非常多，常见的框架:\n\n * echarts 、g2、d3、vis、hightchart等等;\n * g2框架封装:bizcharts(react) viser(vue);\n * 地理可视化: g2、l7、高德的 loca、 菜鸟的 鸟图;\n * 3d可视化:three.js;\n\n\n# echarts 封装\n\nconst chartref = ref(); // 通过该方式可以获取dom对象\n\n\n1\n\n\n注意要在 onmounted 中 init，否则还未绑定模板，获取不到 dom\n\nhooks 封装！\n\nuseechart.ts\n\nimport * as echarts from 'echarts'\n\nimport chinamapdata from '../data/china.json'\n\necharts.registermap('china', chinamapdata)\n\nexport default function (el: htmlelement) {\n  const echartinstance = echarts.init(el)\n\n  const setoptions = (options: echarts.echartsoption) => {\n    echartinstance.setoption(options)\n  }\n\n  const updatesize = () => {\n    echartinstance.resize()\n  }\n\n  window.addeventlistener('resize', () => {\n    echartinstance.resize()\n  })\n\n  return {\n    echartinstance,\n    setoptions,\n    updatesize\n  }\n}\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n\n\nbase-echart.vue\n\n<template>\n  <div class=\"base-echart\">\n    <div ref=\"echartdivref\" :style=\"{ width: width, height: height }\"></div>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { ref, onmounted, defineprops, withdefaults, watcheffect } from 'vue'\nimport { echartsoption } from 'echarts'\nimport useechart from '../hooks/useechart'\n\n// 定义props\nconst props = withdefaults(\n  defineprops<{\n    options: echartsoption\n    width?: string\n    height?: string\n  }>(),\n  {\n    width: '100%',\n    height: '360px'\n  }\n)\n\nconst echartdivref = ref<htmlelement>()\n\nonmounted(() => {\n  const { setoptions } = useechart(echartdivref.value!)\n\n  watcheffect(() => {\n    setoptions(props.options)\n  })\n})\n<\/script>\n\n<style scoped></style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n\n# svg & canvas\n\n一般来说，canvas 更适合绘制图形元素数量非常大(这一般是由数据量大导致)的图表(如热力图、地理坐标 系或平行坐标系上的大规模线图或散点图等)，也利于实现某些视觉特效;\n\n但是，在不少场景中，svg 具有重要的优势:它的内存占用更低(这对移动端尤其重要)、渲染性能略高、并 且用户使用浏览器内置的缩放功能时不会模糊;\n\n那么到底选择哪一个渲染器呢?\n\n * 在软硬件环境较好，数据量不大的场景下(例如 pc 端做商务报表)，两种渲染器都可以适用，并不需要太多纠结;\n\n * 在环境较差，出现性能问题需要优化的场景下，可以通过试验来确定使用哪种渲染器;\n   \n   * 比如在须要创建很多 echarts 实例且浏览器易崩溃的情况下(可能是因为 canvas 数量多导致内存占用超出手机承受能力)，可以使用 svg 渲染器来进行改善;\n   * 大略得说，如果图表运行在低端安卓机，或者我们在使用一些特定图表如 水球图等，svg 渲染器可能效果更好;\n   * 数据量很大、较多交互时，可以选用 canvas 渲染器\n\n\n# 地图",charsets:{cjk:!0},lastUpdated:"2022/04/30, 01:54:50",lastUpdatedTimestamp:165128369e4},{title:"父子组件通讯",frontmatter:{title:"父子组件通讯",date:"2022-01-29T23:27:05.000Z",permalink:"/pages/e8afc3/",categories:["x","组件"],tags:[null]},regularPath:"/1403.Vue3.x/200.%E7%BB%84%E4%BB%B6/201.%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",relativePath:"1403.Vue3.x/200.组件/201.父子组件通讯.md",key:"v-35b5c424",path:"/pages/e8afc3/",headers:[{level:2,title:"VSCode 插件推荐",slug:"vscode-插件推荐",normalizedTitle:"vscode 插件推荐",charIndex:13},{level:2,title:"父传子—props",slug:"父传子-props",normalizedTitle:"父传子—props",charIndex:139},{level:3,title:"字符串数组",slug:"字符串数组",normalizedTitle:"字符串数组",charIndex:169},{level:3,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:196},{level:3,title:"传入一个对象的所有 property 🔥",slug:"传入一个对象的所有-property-🔥",normalizedTitle:"传入一个对象的所有 property 🔥",charIndex:684},{level:3,title:"非Prop的Attribute",slug:"非prop的attribute",normalizedTitle:"非prop的attribute",charIndex:1001},{level:2,title:"子传父—$emit",slug:"子传父-emit",normalizedTitle:"子传父—$emit",charIndex:1567},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:540},{level:3,title:"自定义事件的参数",slug:"自定义事件的参数",normalizedTitle:"自定义事件的参数",charIndex:1687},{level:3,title:"对传递的参数进行验证",slug:"对传递的参数进行验证",normalizedTitle:"对传递的参数进行验证",charIndex:1729},{level:2,title:"父子组件的访问—$refs等 🔥",slug:"父子组件的访问-refs等-🔥",normalizedTitle:"父子组件的访问—$refs等 🔥",charIndex:2024},{level:3,title:"父访问子— $refs 🔥",slug:"父访问子-refs-🔥",normalizedTitle:"父访问子— $refs 🔥",charIndex:2071},{level:3,title:"子访问父—$parent & $root",slug:"子访问父-parent-root",normalizedTitle:"子访问父—$parent &amp; $root",charIndex:null}],headersStr:"VSCode 插件推荐 父传子—props 字符串数组 对象 传入一个对象的所有 property 🔥 非Prop的Attribute 子传父—$emit 使用 自定义事件的参数 对传递的参数进行验证 父子组件的访问—$refs等 🔥 父访问子— $refs 🔥 子访问父—$parent & $root",content:'# 父子组件通讯\n\n\n# VSCode 插件推荐\n\n * Volar（Vue3 推荐，Vue2推荐Vetur）\n   \n   注意，可以在 Extensions 中配置自动导入，根据习惯启用或禁止\n\n * Vue VSCode Snippets（依赖Vetur！！！）\n\n\n# 父传子—props\n\nprops 的值有两种方式：\n\n\n# 字符串数组\n\n数组中的字符串就是传递时的名称\n\n\n# 对象\n\n对象可以设置传递时的类型（有类型限制），默认值等。推荐\n\n * type 可以是下列原生构造函数中的一个：\n   * String\n   * Number\n   * Boolean\n   * Array，注意！\n   * Object，注意！\n   * Date\n   * Function\n   * Symbol\n * type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认\n\n注意：\n\n * 对象或数组默认值必须从一个工厂函数获取\n\n * Prop 的大小写命名 (camelCase vs kebab-case)\n   \n   * HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名\n   * 如果使用字符串模板，那么这个限制就不存在了。实际采用 Vue-Loader 不会有该问题，只会出现在script引入的项目中\n\n\n# 传入一个对象的所有 property 🔥\n\n如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：\n\npost: {\n  id: 1,\n  title: \'My Journey with Vue\'\n}\n\n\n1\n2\n3\n4\n\n\n下面的模板：\n\n<blog-post v-bind="post"></blog-post>\n\n\n1\n\n\n等价于：\n\n<blog-post v-bind:id="post.id" v-bind:title="post.title"></blog-post>\n\n\n1\n\n\n\n# 非Prop的Attribute\n\n什么是非Prop的Attribute呢?\n\n * 当我们传递给一个组件某个属性，但是该属性并没有定义对应的props或者emits时，就称之为 非Prop的 Attribute\n * 常见的包括class、style、id属性等\n\nAttribute继承\n\n * 当组件有单个根节点时，非Prop的Attribute将自动添加到根节点的Attribute中\n\n禁用Attribute继承和多根节点，禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素\n\n * 在组件中设置 inheritAttrs: false\n   \n   export default {\n       inheritAttrs: false,\n       props: { }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 可以通过 $attrs来访问所有的非props的attribute\n   \n   多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上\n   \n   <h2 :id="$attrs.id">MultiRootElement</h2>\n   \n   \n   1\n   \n\n\n# 子传父—$emit\n\n\n# 使用\n\n * 在子组件中，通过$emit(\'自定义事件名\'[,params])发送自定义事件，来触发子组件上绑定的自定义事件\n * 在父组件中，通过v-on来监听子组件的自定义事件，绑定到父组件的方法中\n\n\n# 自定义事件的参数\n\nthis.$emit("add", 10);\n\n\n1\n\n\n\n# 对传递的参数进行验证\n\n在vue3当中，我们可以对传递的参数进行验证\n\n// emits: ["add", "sub", "addN"],\n// 对象写法的目的是为了进行参数的验证\nemits: {\n  add: null,\n  sub: null,\n  addN: (num, name, age) => {\n    console.log(num, name, age);\n    if (num > 10) {\n      return true\n    }\n    return false;\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 父子组件的访问—$refs等 🔥\n\n基本上只有 $refs会使用，其他的基本不使用\n\n\n# 父访问子— $refs 🔥\n\n组件实例有一个$refs属性，是一个对象Object，持有注册过 ref attribute 的所有 DOM 元素和组件实例\n\n注意：在Vue3中已经移除了$children的属性！！！\n\n\n# 子访问父—$parent & $root\n\n * 通过$parent来访问父元素\n * 通过$root来访问根组件',normalizedContent:'# 父子组件通讯\n\n\n# vscode 插件推荐\n\n * volar（vue3 推荐，vue2推荐vetur）\n   \n   注意，可以在 extensions 中配置自动导入，根据习惯启用或禁止\n\n * vue vscode snippets（依赖vetur！！！）\n\n\n# 父传子—props\n\nprops 的值有两种方式：\n\n\n# 字符串数组\n\n数组中的字符串就是传递时的名称\n\n\n# 对象\n\n对象可以设置传递时的类型（有类型限制），默认值等。推荐\n\n * type 可以是下列原生构造函数中的一个：\n   * string\n   * number\n   * boolean\n   * array，注意！\n   * object，注意！\n   * date\n   * function\n   * symbol\n * type 还可以是一个自定义的构造函数，并且通过 instanceof 来进行检查确认\n\n注意：\n\n * 对象或数组默认值必须从一个工厂函数获取\n\n * prop 的大小写命名 (camelcase vs kebab-case)\n   \n   * html 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符。这意味着当你使用 dom 中的模板时，camelcase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名\n   * 如果使用字符串模板，那么这个限制就不存在了。实际采用 vue-loader 不会有该问题，只会出现在script引入的项目中\n\n\n# 传入一个对象的所有 property 🔥\n\n如果你想要将一个对象的所有 property 都作为 prop 传入，你可以使用不带参数的 v-bind (取代 v-bind:prop-name)。例如，对于一个给定的对象 post：\n\npost: {\n  id: 1,\n  title: \'my journey with vue\'\n}\n\n\n1\n2\n3\n4\n\n\n下面的模板：\n\n<blog-post v-bind="post"></blog-post>\n\n\n1\n\n\n等价于：\n\n<blog-post v-bind:id="post.id" v-bind:title="post.title"></blog-post>\n\n\n1\n\n\n\n# 非prop的attribute\n\n什么是非prop的attribute呢?\n\n * 当我们传递给一个组件某个属性，但是该属性并没有定义对应的props或者emits时，就称之为 非prop的 attribute\n * 常见的包括class、style、id属性等\n\nattribute继承\n\n * 当组件有单个根节点时，非prop的attribute将自动添加到根节点的attribute中\n\n禁用attribute继承和多根节点，禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素\n\n * 在组件中设置 inheritattrs: false\n   \n   export default {\n       inheritattrs: false,\n       props: { }\n   }\n   \n   \n   1\n   2\n   3\n   4\n   \n\n * 可以通过 $attrs来访问所有的非props的attribute\n   \n   多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上\n   \n   <h2 :id="$attrs.id">multirootelement</h2>\n   \n   \n   1\n   \n\n\n# 子传父—$emit\n\n\n# 使用\n\n * 在子组件中，通过$emit(\'自定义事件名\'[,params])发送自定义事件，来触发子组件上绑定的自定义事件\n * 在父组件中，通过v-on来监听子组件的自定义事件，绑定到父组件的方法中\n\n\n# 自定义事件的参数\n\nthis.$emit("add", 10);\n\n\n1\n\n\n\n# 对传递的参数进行验证\n\n在vue3当中，我们可以对传递的参数进行验证\n\n// emits: ["add", "sub", "addn"],\n// 对象写法的目的是为了进行参数的验证\nemits: {\n  add: null,\n  sub: null,\n  addn: (num, name, age) => {\n    console.log(num, name, age);\n    if (num > 10) {\n      return true\n    }\n    return false;\n  }\n},\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 父子组件的访问—$refs等 🔥\n\n基本上只有 $refs会使用，其他的基本不使用\n\n\n# 父访问子— $refs 🔥\n\n组件实例有一个$refs属性，是一个对象object，持有注册过 ref attribute 的所有 dom 元素和组件实例\n\n注意：在vue3中已经移除了$children的属性！！！\n\n\n# 子访问父—$parent & $root\n\n * 通过$parent来访问父元素\n * 通过$root来访问根组件',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"非父子组件通讯",frontmatter:{title:"非父子组件通讯",date:"2022-01-30T22:29:03.000Z",permalink:"/pages/9026a0/",categories:["x","组件"],tags:[null]},regularPath:"/1403.Vue3.x/200.%E7%BB%84%E4%BB%B6/202.%E9%9D%9E%E7%88%B6%E5%AD%90%E7%BB%84%E4%BB%B6%E9%80%9A%E8%AE%AF.html",relativePath:"1403.Vue3.x/200.组件/202.非父子组件通讯.md",key:"v-543b1f60",path:"/pages/9026a0/",headers:[{level:2,title:"Provide/Inject—依赖注入",slug:"provide-inject-依赖注入",normalizedTitle:"provide/inject—依赖注入",charIndex:72},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:96},{level:3,title:"注意",slug:"注意",normalizedTitle:"注意",charIndex:299},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:344},{level:2,title:"Mitt 全局事件总线",slug:"mitt-全局事件总线",normalizedTitle:"mitt 全局事件总线",charIndex:1707},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:1856},{level:3,title:"封装 eventbus.js & constant.js",slug:"封装-eventbus-js-constant-js",normalizedTitle:"封装 eventbus.js &amp; constant.js",charIndex:null},{level:3,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:1779},{level:3,title:"示例",slug:"示例-2",normalizedTitle:"示例",charIndex:344}],headersStr:"Provide/Inject—依赖注入 介绍 注意 示例 Mitt 全局事件总线 安装 封装 eventbus.js & constant.js 方法 示例",content:"# 非父子组件通讯\n\n在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信，这里我们主要讲两种方式。\n\n\n# Provide/Inject—依赖注入\n\n\n# 介绍\n\n比如有一些深度嵌套的组件，子孙组件想要获取爷父组件的部分内容。在这种情况下，如果我们仍然将props沿着组件链逐级传递下 去，就会非常的麻烦。对于这种情况下，我们可以使用 Provide 和 Inject：\n\n * 无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者\n * 父组件有一个 provide 选项来提供数据;\n * 子组件有一个 inject 选项来开始使用这些数据\n\n\n# 注意\n\n * provide 函数绑定 this\n * computed 响应式\n\n\n# 示例\n\nApp.vue\n\n<template>\n  <div>\n    <home></home>\n    <button @click=\"addName\">+name</button>\n  </div>\n</template>\n\n<script>\nimport Home from './Home.vue'\nimport { computed } from 'vue'\n\nexport default {\n  components: {\n    Home,\n  },\n  // provide 对象中的 this 为 undefined，\n  // 为了绑定 Vue 实例，可以使用类似 data 函数一样的方式实现\n  // provide: { name: 'why' },\n  provide() {\n    return {\n      name: 'why',\n      age: 18,\n      // length 需要在 name 的长度变化时改变，可以使用计算属性，computed 返回的是 ref 对象，需要 .value 获取值\n      length: computed(() => this.names.length), // ref对象 .value\n    }\n  },\n  data() {\n    return {\n      names: ['abc', 'cba', 'nba'],\n    }\n  },\n  methods: {\n    addName() {\n      this.names.push('why')\n      console.log(this.names)\n    },\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nHome.vue\n\n<template>\n  <div>\n    <home-content></home-content>\n  </div>\n</template>\n\n<script>\n  import HomeContent from './HomeContent.vue';\n\n  export default {\n    components: {\n      HomeContent\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nHomeContent.vue\n\n<template>\n  <div>\n    HomeContent: {{name}} - {{age}} - {{length.value}}\n  </div>\n</template>\n\n<script>\n  export default {\n    // 也不知道从哪注入的？是不是全局的？？？\n    inject: [\"name\", \"age\", \"length\"],\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# Mitt 全局事件总线\n\n替代Vue实例，其实可以获取到Vue实例，就是比较麻烦。\n\nVue3从实例中移除了 $on、$off 和 $once 方法，所以我们如果希望继续使用全局事件总线，要通过第三方的库: Vue3官方有推荐一些库，例如 mitt(推荐) 或 tiny-emitter;\n\n\n# 安装\n\n npm install mitt\n\n\n1\n\n\n\n# 封装 eventbus.js & constant.js\n\neventbus.js mitt 封装\n\nimport mitt from 'mitt'\n\n// 可以返回多个对象\nconst emitter = mitt()\n// export const emitter1 = mitt();\n// export const emitter2 = mitt();\n// export const emitter3 = mitt();\n\nexport default emitter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nconstant.js 事件名常量\n\nexport const WHY_EVENT = \"why\";\n\n\n1\n\n\n\n# 方法\n\n * emit\n\n * on\n\n * off：取消掉之前注册的函数监听\n   \n   // 取消 emitter 中所有监听\n   emitter.all.clear()\n   \n   // 定义一个函数\n   function onFoo() {}\n   emitter.on('foo', onFoo) // 监听\n   emitter.on('foo', onFoo) // 取消监听\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n\n# 示例\n\nApp.vue\n\n<template>\n  <div>\n    <home/>\n    <about/>\n  </div>\n</template>\n\n<script>\n  import Home from './Home.vue';\n  import About from './About.vue';\n\n  export default {\n    components: {\n      Home,\n      About\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nHome.vue\n\n<template>\n  <div>\n    <home-content></home-content>\n  </div>\n</template>\n\n<script>\n  import HomeContent from './HomeContent.vue';\n\n  export default {\n    components: {\n      HomeContent\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nHomeContent.vue\n\n<template>\n  <div>\n  </div>\n</template>\n\n<script>\n  import emitter from './utils/eventbus';\n\n  export default {\n    created() {\n      emitter.on(\"why\", (info) => {\n        console.log(\"why:\", info);\n      });\n\n      emitter.on(\"kobe\", (info) => {\n        console.log(\"kobe:\", info);\n      });\n\n      emitter.on(\"*\", (type, info) => {\n        console.log(\"* listener:\", type, info);\n      })\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nAbout.vue\n\n<template>\n  <div>\n    <button @click=\"btnClick\">按钮点击</button>\n  </div>\n</template>\n\n<script>\n  import emitter from './utils/eventbus';\n\n  export default {\n    methods: {\n      btnClick() {\n        console.log(\"about按钮的点击\");\n        emitter.emit(\"why\", {name: \"why\", age: 18});\n        // emitter.emit(\"kobe\", {name: \"kobe\", age: 30});\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",normalizedContent:"# 非父子组件通讯\n\n在开发中，我们构建了组件树之后，除了父子组件之间的通信之外，还会有非父子组件之间的通信，这里我们主要讲两种方式。\n\n\n# provide/inject—依赖注入\n\n\n# 介绍\n\n比如有一些深度嵌套的组件，子孙组件想要获取爷父组件的部分内容。在这种情况下，如果我们仍然将props沿着组件链逐级传递下 去，就会非常的麻烦。对于这种情况下，我们可以使用 provide 和 inject：\n\n * 无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者\n * 父组件有一个 provide 选项来提供数据;\n * 子组件有一个 inject 选项来开始使用这些数据\n\n\n# 注意\n\n * provide 函数绑定 this\n * computed 响应式\n\n\n# 示例\n\napp.vue\n\n<template>\n  <div>\n    <home></home>\n    <button @click=\"addname\">+name</button>\n  </div>\n</template>\n\n<script>\nimport home from './home.vue'\nimport { computed } from 'vue'\n\nexport default {\n  components: {\n    home,\n  },\n  // provide 对象中的 this 为 undefined，\n  // 为了绑定 vue 实例，可以使用类似 data 函数一样的方式实现\n  // provide: { name: 'why' },\n  provide() {\n    return {\n      name: 'why',\n      age: 18,\n      // length 需要在 name 的长度变化时改变，可以使用计算属性，computed 返回的是 ref 对象，需要 .value 获取值\n      length: computed(() => this.names.length), // ref对象 .value\n    }\n  },\n  data() {\n    return {\n      names: ['abc', 'cba', 'nba'],\n    }\n  },\n  methods: {\n    addname() {\n      this.names.push('why')\n      console.log(this.names)\n    },\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n\n\nhome.vue\n\n<template>\n  <div>\n    <home-content></home-content>\n  </div>\n</template>\n\n<script>\n  import homecontent from './homecontent.vue';\n\n  export default {\n    components: {\n      homecontent\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nhomecontent.vue\n\n<template>\n  <div>\n    homecontent: {{name}} - {{age}} - {{length.value}}\n  </div>\n</template>\n\n<script>\n  export default {\n    // 也不知道从哪注入的？是不是全局的？？？\n    inject: [\"name\", \"age\", \"length\"],\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n\n# mitt 全局事件总线\n\n替代vue实例，其实可以获取到vue实例，就是比较麻烦。\n\nvue3从实例中移除了 $on、$off 和 $once 方法，所以我们如果希望继续使用全局事件总线，要通过第三方的库: vue3官方有推荐一些库，例如 mitt(推荐) 或 tiny-emitter;\n\n\n# 安装\n\n npm install mitt\n\n\n1\n\n\n\n# 封装 eventbus.js & constant.js\n\neventbus.js mitt 封装\n\nimport mitt from 'mitt'\n\n// 可以返回多个对象\nconst emitter = mitt()\n// export const emitter1 = mitt();\n// export const emitter2 = mitt();\n// export const emitter3 = mitt();\n\nexport default emitter\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\nconstant.js 事件名常量\n\nexport const why_event = \"why\";\n\n\n1\n\n\n\n# 方法\n\n * emit\n\n * on\n\n * off：取消掉之前注册的函数监听\n   \n   // 取消 emitter 中所有监听\n   emitter.all.clear()\n   \n   // 定义一个函数\n   function onfoo() {}\n   emitter.on('foo', onfoo) // 监听\n   emitter.on('foo', onfoo) // 取消监听\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n\n# 示例\n\napp.vue\n\n<template>\n  <div>\n    <home/>\n    <about/>\n  </div>\n</template>\n\n<script>\n  import home from './home.vue';\n  import about from './about.vue';\n\n  export default {\n    components: {\n      home,\n      about\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nhome.vue\n\n<template>\n  <div>\n    <home-content></home-content>\n  </div>\n</template>\n\n<script>\n  import homecontent from './homecontent.vue';\n\n  export default {\n    components: {\n      homecontent\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\nhomecontent.vue\n\n<template>\n  <div>\n  </div>\n</template>\n\n<script>\n  import emitter from './utils/eventbus';\n\n  export default {\n    created() {\n      emitter.on(\"why\", (info) => {\n        console.log(\"why:\", info);\n      });\n\n      emitter.on(\"kobe\", (info) => {\n        console.log(\"kobe:\", info);\n      });\n\n      emitter.on(\"*\", (type, info) => {\n        console.log(\"* listener:\", type, info);\n      })\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n\n\nabout.vue\n\n<template>\n  <div>\n    <button @click=\"btnclick\">按钮点击</button>\n  </div>\n</template>\n\n<script>\n  import emitter from './utils/eventbus';\n\n  export default {\n    methods: {\n      btnclick() {\n        console.log(\"about按钮的点击\");\n        emitter.emit(\"why\", {name: \"why\", age: 18});\n        // emitter.emit(\"kobe\", {name: \"kobe\", age: 30});\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"插槽",frontmatter:{sstitle:"插槽",date:"2022-01-30T23:14:04.000Z",permalink:"/pages/fff569/",categories:["x","组件"],tags:[null],title:"插槽"},regularPath:"/1403.Vue3.x/200.%E7%BB%84%E4%BB%B6/203.%E6%8F%92%E6%A7%BD.html",relativePath:"1403.Vue3.x/200.组件/203.插槽.md",key:"v-bb49f58c",path:"/pages/fff569/",headers:[{level:2,title:"基本使用 & 默认内容",slug:"基本使用-默认内容",normalizedTitle:"基本使用 &amp; 默认内容",charIndex:null},{level:2,title:"具名插槽 🔥",slug:"具名插槽-🔥",normalizedTitle:"具名插槽 🔥",charIndex:1532},{level:2,title:"作用域插槽 🔥",slug:"作用域插槽-🔥",normalizedTitle:"作用域插槽 🔥",charIndex:3201},{level:3,title:"渲染作用域 🔥",slug:"渲染作用域-🔥",normalizedTitle:"渲染作用域 🔥",charIndex:3214},{level:3,title:"作用域插槽 🔥",slug:"作用域插槽-🔥-2",normalizedTitle:"作用域插槽 🔥",charIndex:3201},{level:3,title:"独占默认插槽的缩写",slug:"独占默认插槽的缩写",normalizedTitle:"独占默认插槽的缩写",charIndex:3512},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:3524}],headersStr:"基本使用 & 默认内容 具名插槽 🔥 作用域插槽 🔥 渲染作用域 🔥 作用域插槽 🔥 独占默认插槽的缩写 示例",content:'# 插槽 Slot\n\n\n# 基本使用 & 默认内容\n\nApp.vue\n\n<template>\n  <div>\n    <my-slot-cpn>\n      \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽都写入 button--\x3e\n      <button>我是按钮</button>\n    </my-slot-cpn>\n    <hr />\n\n    \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽都写入 我是普通的文本--\x3e\n    <my-slot-cpn> 我是普通的文本 </my-slot-cpn>\n    <hr />\n\n    <my-slot-cpn>\n      \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽都写入 my-button 组件--\x3e\n      <my-button />\n    </my-slot-cpn>\n    <hr />\n\n    \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽启用默认值--\x3e\n    <my-slot-cpn />\n    <hr />\n\n    \x3c!-- 插入了很多的内容 --\x3e\n    <my-slot-cpn>\n      \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽分别！！！插入如下3个元素！！！总共出现9个！！！--\x3e\n      <h2>哈哈哈</h2>\n      <button>我是按钮</button>\n      <strong>我是strong</strong>\n    </my-slot-cpn>\n  </div>\n</template>\n\n<script>\nimport MySlotCpn from \'./MySlotCpn.vue\'\nimport MyButton from \'./MyButton.vue\'\n\nexport default {\n  components: {\n    MySlotCpn,\n    MyButton,\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nMySlotCpn.vue\n\n<template>\n  <div>\n    <h2>组件开始</h2>\n    <slot>\n      <i>我是默认的i元素</i>\n    </slot>\n    <slot>\n      <i>我是默认的i元素</i>\n    </slot>\n    <slot>\n      <i>我是默认的i元素</i>\n    </slot>\n    <h2>组件结束</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nMyButton.vue\n\n<template>\n  <div>\n    <button>coderwhy button</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 具名插槽 🔥\n\n * v-slot:left 可以简写为 #left\n * 一个不带 name 的slot，会带有隐含的名字 default\n * 动态插槽名：通过 v-slot:[dynamicSlotName]方式动态绑定一个名称\n\nApp.vue\n\n<template>\n  <div>\n    <nav-bar :name="name">\n      <template #left>\n        <button>左边的按钮</button>\n      </template>\n      <template #center>\n        <h2>我是标题</h2>\n      </template>\n      <template #right>\n        <i>右边的i元素</i>\n      </template>\n      <template #[name]>\n        <i>why内容</i>\n      </template>\n    </nav-bar>\n  </div>\n</template>\n\n<script>\nimport NavBar from \'./NavBar.vue\'\n\nexport default {\n  components: {\n    NavBar,\n  },\n  data() {\n    return {\n      name: \'why\',\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nNavBar.vue\n\n<template>\n  <div class="nav-bar">\n    \x3c!-- <slot name="default"></slot> --\x3e\n    <div class="left">\n      <slot name="left"></slot>\n    </div>\n    <div class="center">\n      <slot name="center"></slot>\n    </div>\n    <div class="right">\n      <slot name="right"></slot>\n    </div>\n    <div class="addition">\n      <slot :name="name"></slot>\n    </div>\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      name: String\n    }\n    // data() {\n    //   return {\n    //     name: "why"\n    //   }\n    // }\n  }\n<\/script>\n\n<style scoped>\n  .nav-bar {\n    display: flex;\n  }\n\n  .left, .right, .center {\n    height: 44px;\n  }\n\n  .left, .right, .addition {\n    width: 80px;\n    background-color: red;\n  }\n\n  .center {\n    flex: 1;\n    background-color: blue;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 作用域插槽 🔥\n\n\n# 渲染作用域 🔥\n\n * 父级模板里的所有内容都是在父级作用域中编译的;\n * 子模板里的所有内容都是在子作用域中编译的;\n\n如何理解这句话呢?我们来看一个案例:\n\n * 在我们的案例中ChildCpn自然是可以让问自己作用域中的title内容的;\n * 但是在App中，是访问不了ChildCpn中的内容的，因为它们是跨作用域的访问;\n\n\n\n\n# 作用域插槽 🔥\n\n有时候我们希望插槽可以访问到子组件中的内容是非常重要的\n\n * 当一个组件被用来渲染一个数组时，我们使用插槽，并且希望插槽中不要显示直接每项的内容，样式需通过父组件定义;\n * 这个Vue给我们提供了作用域插槽;\n\n\n\n\n# 独占默认插槽的缩写\n\n见示例\n\n\n# 示例\n\nApp.vue\n\n<template>\n  <div>\n    <show-names :names="names">\n      <template v-slot="coderwhy">\n        <button>{{ coderwhy.item }}-{{ coderwhy.index }}</button>\n      </template>\n    </show-names>\n\n    \x3c!-- 独占默认default插槽，无需写template --\x3e\n    <show-names :names="names" v-slot="coderwhy">\n      <button>{{ coderwhy.item }}-{{ coderwhy.index }}</button>\n    </show-names>\n\n    \x3c!-- 注意: 如果还有其他的具名插槽, 那么默认插槽也必须使用template来编写 --\x3e\n    <show-names :names="names">\n      <template v-slot="coderwhy">\n        <button>{{ coderwhy.item }}-{{ coderwhy.index }}</button>\n      </template>\n\n      <template v-slot:why>\n        <h2>我是why的插入内容</h2>\n      </template>\n    </show-names>\n\n    <show-names :names="names">\n      <template v-slot="slotProps">\n        <strong>{{ slotProps.item }}-{{ slotProps.index }}</strong>\n      </template>\n    </show-names>\n  </div>\n</template>\n\n<script>\nimport ChildCpn from \'./ChildCpn.vue\'\nimport ShowNames from \'./ShowNames.vue\'\n\nexport default {\n  components: {\n    ChildCpn,\n    ShowNames,\n  },\n  data() {\n    return {\n      names: [\'why\', \'kobe\', \'james\', \'curry\'],\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\nShowNames.vue\n\n<template>\n  <div>\n    <template v-for="(item, index) in names" :key="item">\n      <slot :item="item" :index="index"></slot>\n\n      <slot name="why"></slot>\n    </template>\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      names: {\n        type: Array,\n        default: () => []\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',normalizedContent:'# 插槽 slot\n\n\n# 基本使用 & 默认内容\n\napp.vue\n\n<template>\n  <div>\n    <my-slot-cpn>\n      \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽都写入 button--\x3e\n      <button>我是按钮</button>\n    </my-slot-cpn>\n    <hr />\n\n    \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽都写入 我是普通的文本--\x3e\n    <my-slot-cpn> 我是普通的文本 </my-slot-cpn>\n    <hr />\n\n    <my-slot-cpn>\n      \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽都写入 my-button 组件--\x3e\n      <my-button />\n    </my-slot-cpn>\n    <hr />\n\n    \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽启用默认值--\x3e\n    <my-slot-cpn />\n    <hr />\n\n    \x3c!-- 插入了很多的内容 --\x3e\n    <my-slot-cpn>\n      \x3c!-- 注意，这里面会对 my-slot-cpn 中定义的 3 个插槽分别！！！插入如下3个元素！！！总共出现9个！！！--\x3e\n      <h2>哈哈哈</h2>\n      <button>我是按钮</button>\n      <strong>我是strong</strong>\n    </my-slot-cpn>\n  </div>\n</template>\n\n<script>\nimport myslotcpn from \'./myslotcpn.vue\'\nimport mybutton from \'./mybutton.vue\'\n\nexport default {\n  components: {\n    myslotcpn,\n    mybutton,\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\nmyslotcpn.vue\n\n<template>\n  <div>\n    <h2>组件开始</h2>\n    <slot>\n      <i>我是默认的i元素</i>\n    </slot>\n    <slot>\n      <i>我是默认的i元素</i>\n    </slot>\n    <slot>\n      <i>我是默认的i元素</i>\n    </slot>\n    <h2>组件结束</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nmybutton.vue\n\n<template>\n  <div>\n    <button>coderwhy button</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 具名插槽 🔥\n\n * v-slot:left 可以简写为 #left\n * 一个不带 name 的slot，会带有隐含的名字 default\n * 动态插槽名：通过 v-slot:[dynamicslotname]方式动态绑定一个名称\n\napp.vue\n\n<template>\n  <div>\n    <nav-bar :name="name">\n      <template #left>\n        <button>左边的按钮</button>\n      </template>\n      <template #center>\n        <h2>我是标题</h2>\n      </template>\n      <template #right>\n        <i>右边的i元素</i>\n      </template>\n      <template #[name]>\n        <i>why内容</i>\n      </template>\n    </nav-bar>\n  </div>\n</template>\n\n<script>\nimport navbar from \'./navbar.vue\'\n\nexport default {\n  components: {\n    navbar,\n  },\n  data() {\n    return {\n      name: \'why\',\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\nnavbar.vue\n\n<template>\n  <div class="nav-bar">\n    \x3c!-- <slot name="default"></slot> --\x3e\n    <div class="left">\n      <slot name="left"></slot>\n    </div>\n    <div class="center">\n      <slot name="center"></slot>\n    </div>\n    <div class="right">\n      <slot name="right"></slot>\n    </div>\n    <div class="addition">\n      <slot :name="name"></slot>\n    </div>\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      name: string\n    }\n    // data() {\n    //   return {\n    //     name: "why"\n    //   }\n    // }\n  }\n<\/script>\n\n<style scoped>\n  .nav-bar {\n    display: flex;\n  }\n\n  .left, .right, .center {\n    height: 44px;\n  }\n\n  .left, .right, .addition {\n    width: 80px;\n    background-color: red;\n  }\n\n  .center {\n    flex: 1;\n    background-color: blue;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 作用域插槽 🔥\n\n\n# 渲染作用域 🔥\n\n * 父级模板里的所有内容都是在父级作用域中编译的;\n * 子模板里的所有内容都是在子作用域中编译的;\n\n如何理解这句话呢?我们来看一个案例:\n\n * 在我们的案例中childcpn自然是可以让问自己作用域中的title内容的;\n * 但是在app中，是访问不了childcpn中的内容的，因为它们是跨作用域的访问;\n\n\n\n\n# 作用域插槽 🔥\n\n有时候我们希望插槽可以访问到子组件中的内容是非常重要的\n\n * 当一个组件被用来渲染一个数组时，我们使用插槽，并且希望插槽中不要显示直接每项的内容，样式需通过父组件定义;\n * 这个vue给我们提供了作用域插槽;\n\n\n\n\n# 独占默认插槽的缩写\n\n见示例\n\n\n# 示例\n\napp.vue\n\n<template>\n  <div>\n    <show-names :names="names">\n      <template v-slot="coderwhy">\n        <button>{{ coderwhy.item }}-{{ coderwhy.index }}</button>\n      </template>\n    </show-names>\n\n    \x3c!-- 独占默认default插槽，无需写template --\x3e\n    <show-names :names="names" v-slot="coderwhy">\n      <button>{{ coderwhy.item }}-{{ coderwhy.index }}</button>\n    </show-names>\n\n    \x3c!-- 注意: 如果还有其他的具名插槽, 那么默认插槽也必须使用template来编写 --\x3e\n    <show-names :names="names">\n      <template v-slot="coderwhy">\n        <button>{{ coderwhy.item }}-{{ coderwhy.index }}</button>\n      </template>\n\n      <template v-slot:why>\n        <h2>我是why的插入内容</h2>\n      </template>\n    </show-names>\n\n    <show-names :names="names">\n      <template v-slot="slotprops">\n        <strong>{{ slotprops.item }}-{{ slotprops.index }}</strong>\n      </template>\n    </show-names>\n  </div>\n</template>\n\n<script>\nimport childcpn from \'./childcpn.vue\'\nimport shownames from \'./shownames.vue\'\n\nexport default {\n  components: {\n    childcpn,\n    shownames,\n  },\n  data() {\n    return {\n      names: [\'why\', \'kobe\', \'james\', \'curry\'],\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\nshownames.vue\n\n<template>\n  <div>\n    <template v-for="(item, index) in names" :key="item">\n      <slot :item="item" :index="index"></slot>\n\n      <slot name="why"></slot>\n    </template>\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      names: {\n        type: array,\n        default: () => []\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"动态组件",frontmatter:{title:"动态组件",date:"2022-01-31T00:28:42.000Z",permalink:"/pages/4e1afb/",categories:["x","组件"],tags:[null]},regularPath:"/1403.Vue3.x/200.%E7%BB%84%E4%BB%B6/204.%E5%8A%A8%E6%80%81%E7%BB%84%E4%BB%B6.html",relativePath:"1403.Vue3.x/200.组件/204.动态组件.md",key:"v-448d3032",path:"/pages/4e1afb/",headers:[{level:2,title:"tabs 示例",slug:"tabs-示例",normalizedTitle:"tabs 示例",charIndex:11},{level:2,title:"keep-alive",slug:"keep-alive",normalizedTitle:"keep-alive",charIndex:865},{level:2,title:"缓存组件的生命周期",slug:"缓存组件的生命周期",normalizedTitle:"缓存组件的生命周期",charIndex:1262},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:16}],headersStr:"tabs 示例 keep-alive 缓存组件的生命周期 示例",content:'# 动态组件\n\n\n# tabs 示例\n\n * v-on 监听的事件也可能不一样！！\n * v-bind 绑定的数据也可能不一样\n\n<template>\n  <tabs v-for="pane of panes" :key="pane.key">\n    <component :is="pane.component" v-on="pane.event" v-bind="propData" />\n  </tabs>\n</template>\n\n<script>\nimport Main from \'./Main.vue\'\nimport Add from \'./Add.vue\'\n\nexport default {\n  components: {\n    Main,\n    Add,\n  },\n  data() {\n    return {\n      propData: {\n        id: \'1\',\n        name: \'conanan\',\n      },\n      panes: [\n        {\n          key: \'1\',\n          tab: \'main页面\',\n          component: Main,\n          event: { mainEvent1, mainEvent2 },\n        },\n        {\n          key: \'2\',\n          tab: \'add页面\',\n          component: Add,\n          event: { addEvent },\n        },\n      ],\n    }\n  },\n}\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# keep-alive\n\n和上面tabs的实现方式不一样！！这里component只有一个！！！\n\n在开发中某些情况我们希望继续保持组件的状态，而不是销毁掉，这个时候我们就可以使用一个内置组件: keep-alive\n\nkeep-alive有一些属性:\n\n * include - string | RegExp | Array。只有名称匹配的组件会被缓存;\n * exclude - string | RegExp | Array。任何名称匹配的组件都会被缓存;\n * max - number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁\n\ninclude 和 exclude prop 允许组件有条件地缓存:\n\n * 二者都可以用逗号分隔字符串、正则表达式或一个数组来表示;\n * 匹配首先检查组件自身的 name 选项\n\n\n# 缓存组件的生命周期\n\n * 对于缓存的组件来说，再次进入时，我们是不会执行created或者mounted等生命周期函数的\n\n * 但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件\n\n * 这个时候我们可以使用 activated 和 deactivated 这两个生命周期钩子函数来监听\n\n\n# 示例\n\nApp.vue\n\n<template>\n  <div>\n    <button v-for="item in tabs" :key="item"\n            @click="itemClick(item)"\n            :class="{active: currentTab === item}">\n      {{item}}\n    </button>\n\n    \x3c!-- 2.动态组件 --\x3e\n    <keep-alive include="home,about">\n      <component :is="currentTab"\n                 name="coderwhy"\n                 :age="18"\n                 @pageClick="pageClick">\n      </component>\n    </keep-alive>\n    \n\n    \x3c!-- 1.v-if的判断实现 --\x3e\n    \x3c!-- <template v-if="currentTab === \'home\'">\n      <home></home>\n    </template>\n    <template v-else-if="currentTab === \'about\'">\n      <about></about>\n    </template>\n    <template v-else>\n      <category></category>\n    </template> --\x3e\n  </div>\n</template>\n\n<script>\n  import Home from \'./pages/Home.vue\';\n  import About from \'./pages/About.vue\';\n  import Category from \'./pages/Category.vue\';\n\n  export default {\n    components: {\n      Home,\n      About,\n      Category\n    },\n    data() {\n      return {\n        tabs: ["home", "about", "category"],\n        currentTab: "home"\n      }\n    },\n    methods: {\n      itemClick(item) {\n        this.currentTab = item;\n      },\n      pageClick() {\n        console.log("page内部发生了点击");\n      }\n    }\n  }\n<\/script>\n\n<style scoped>\n  .active {\n    color: red;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\nAbout.vue\n\n<template>\n  <div>\n    About组件\n    <button @click="counter++">{{counter}}</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: "about",  \n    data() {\n      return {\n        counter: 0\n      }\n    },\n    created() {\n      console.log("about created");\n    },\n    unmounted() {\n      console.log("about unmounted");\n    },\n    activated() {\n      console.log("about activated");\n    },\n    deactivated() {\n      console.log("about deactivated");\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\nCategory.vue\n\n<template>\n  <div>\n    Category组件\n    <button @click="counter++">{{counter}}</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: "category",  \n    data() {\n      return {\n        counter: 0\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nHome.vue\n\n<template>\n  <div @click="divClick">\n    Home组件: {{name}} - {{age}}\n  </div>\n</template>\n\n<script>\n  export default {\n    name: "home",  \n    props: {\n      name: {\n        type: String,\n        default: ""\n      },\n      age: {\n        type: Number,\n        default: 0\n      }\n    },\n    emits: ["pageClick"],\n    methods: {\n      divClick() {\n        this.$emit("pageClick");\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',normalizedContent:'# 动态组件\n\n\n# tabs 示例\n\n * v-on 监听的事件也可能不一样！！\n * v-bind 绑定的数据也可能不一样\n\n<template>\n  <tabs v-for="pane of panes" :key="pane.key">\n    <component :is="pane.component" v-on="pane.event" v-bind="propdata" />\n  </tabs>\n</template>\n\n<script>\nimport main from \'./main.vue\'\nimport add from \'./add.vue\'\n\nexport default {\n  components: {\n    main,\n    add,\n  },\n  data() {\n    return {\n      propdata: {\n        id: \'1\',\n        name: \'conanan\',\n      },\n      panes: [\n        {\n          key: \'1\',\n          tab: \'main页面\',\n          component: main,\n          event: { mainevent1, mainevent2 },\n        },\n        {\n          key: \'2\',\n          tab: \'add页面\',\n          component: add,\n          event: { addevent },\n        },\n      ],\n    }\n  },\n}\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# keep-alive\n\n和上面tabs的实现方式不一样！！这里component只有一个！！！\n\n在开发中某些情况我们希望继续保持组件的状态，而不是销毁掉，这个时候我们就可以使用一个内置组件: keep-alive\n\nkeep-alive有一些属性:\n\n * include - string | regexp | array。只有名称匹配的组件会被缓存;\n * exclude - string | regexp | array。任何名称匹配的组件都会被缓存;\n * max - number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁\n\ninclude 和 exclude prop 允许组件有条件地缓存:\n\n * 二者都可以用逗号分隔字符串、正则表达式或一个数组来表示;\n * 匹配首先检查组件自身的 name 选项\n\n\n# 缓存组件的生命周期\n\n * 对于缓存的组件来说，再次进入时，我们是不会执行created或者mounted等生命周期函数的\n\n * 但是有时候我们确实希望监听到何时重新进入到了组件，何时离开了组件\n\n * 这个时候我们可以使用 activated 和 deactivated 这两个生命周期钩子函数来监听\n\n\n# 示例\n\napp.vue\n\n<template>\n  <div>\n    <button v-for="item in tabs" :key="item"\n            @click="itemclick(item)"\n            :class="{active: currenttab === item}">\n      {{item}}\n    </button>\n\n    \x3c!-- 2.动态组件 --\x3e\n    <keep-alive include="home,about">\n      <component :is="currenttab"\n                 name="coderwhy"\n                 :age="18"\n                 @pageclick="pageclick">\n      </component>\n    </keep-alive>\n    \n\n    \x3c!-- 1.v-if的判断实现 --\x3e\n    \x3c!-- <template v-if="currenttab === \'home\'">\n      <home></home>\n    </template>\n    <template v-else-if="currenttab === \'about\'">\n      <about></about>\n    </template>\n    <template v-else>\n      <category></category>\n    </template> --\x3e\n  </div>\n</template>\n\n<script>\n  import home from \'./pages/home.vue\';\n  import about from \'./pages/about.vue\';\n  import category from \'./pages/category.vue\';\n\n  export default {\n    components: {\n      home,\n      about,\n      category\n    },\n    data() {\n      return {\n        tabs: ["home", "about", "category"],\n        currenttab: "home"\n      }\n    },\n    methods: {\n      itemclick(item) {\n        this.currenttab = item;\n      },\n      pageclick() {\n        console.log("page内部发生了点击");\n      }\n    }\n  }\n<\/script>\n\n<style scoped>\n  .active {\n    color: red;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n\n\nabout.vue\n\n<template>\n  <div>\n    about组件\n    <button @click="counter++">{{counter}}</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: "about",  \n    data() {\n      return {\n        counter: 0\n      }\n    },\n    created() {\n      console.log("about created");\n    },\n    unmounted() {\n      console.log("about unmounted");\n    },\n    activated() {\n      console.log("about activated");\n    },\n    deactivated() {\n      console.log("about deactivated");\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\ncategory.vue\n\n<template>\n  <div>\n    category组件\n    <button @click="counter++">{{counter}}</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    name: "category",  \n    data() {\n      return {\n        counter: 0\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n\n\nhome.vue\n\n<template>\n  <div @click="divclick">\n    home组件: {{name}} - {{age}}\n  </div>\n</template>\n\n<script>\n  export default {\n    name: "home",  \n    props: {\n      name: {\n        type: string,\n        default: ""\n      },\n      age: {\n        type: number,\n        default: 0\n      }\n    },\n    emits: ["pageclick"],\n    methods: {\n      divclick() {\n        this.$emit("pageclick");\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"异步组件",frontmatter:{title:"异步组件",date:"2022-01-31T00:49:16.000Z",permalink:"/pages/f515e4/",categories:["x","组件"],tags:[null]},regularPath:"/1403.Vue3.x/200.%E7%BB%84%E4%BB%B6/205.%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6.html",relativePath:"1403.Vue3.x/200.组件/205.异步组件.md",key:"v-50a06977",path:"/pages/f515e4/",headers:[{level:2,title:"Webpack的代码分包",slug:"webpack的代码分包",normalizedTitle:"webpack的代码分包",charIndex:11},{level:2,title:"Vue中实现异步组件",slug:"vue中实现异步组件",normalizedTitle:"vue中实现异步组件",charIndex:307},{level:3,title:"工厂函数写法",slug:"工厂函数写法",normalizedTitle:"工厂函数写法",charIndex:505},{level:3,title:"对象写法",slug:"对象写法",normalizedTitle:"对象写法",charIndex:783},{level:2,title:"异步组件和Suspense",slug:"异步组件和suspense",normalizedTitle:"异步组件和suspense",charIndex:1838}],headersStr:"Webpack的代码分包 Vue中实现异步组件 工厂函数写法 对象写法 异步组件和Suspense",content:"# 异步组件\n\n\n# Webpack的代码分包\n\n默认的打包过程:\n\n * 默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组 件模块打包到一起(比如一个app.js文件中);\n\n * 这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢;\n\n打包时，代码的分包:\n\n * 所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js;\n * 这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容;\n\nwebpack中如何可以对代码进行分包呢?\n\n\n\n\n# Vue中实现异步组件\n\n如果我们的项目过大了，对于某些组件我们希望通过异步的方式来进行加载(目的是可以对其进行分包处理)，那么Vue中给我们提供了一个函数:defineAsyncComponent。\n\ndefineAsyncComponent接受两种类型的参数:\n\n * 类型一：工厂函数，该工厂函数需要返回一个Promise对象;\n * 类型二:接受一个对象类型，对异步函数进行配置;\n\n\n# 工厂函数写法\n\n<script>\n    import { defineAsyncComponent } from 'vue';\n\n    const AsyncCategory = defineAsyncComponent(() => import(\"./AsyncCategory.vue\"))\n\n    export default {\n        components: {\n            AsyncCategory,\n        }\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象写法\n\n<script>\n    import { defineAsyncComponent } from 'vue';\n    import Loading from './Loading';    \n    import Error from './Error';\n\n    const AsyncCategory = defineAsyncComponent({\n        // 工厂函数\n        loader: () => import(\"./AsyncCategory.vue\"),\n        \n        // 加载过程中显示的组件\n        loadingComponent: Loading,\n        \n        // 加载失败时显示的组件\n        errorComponent: Error,\n        \n        // 在显示loadingComponent组件之前, 等待多长时间，默认值：200，单位ms\n        delay: 2000,\n        \n        // 如果提供了timeout，并且加载组件的时间超过了该值，将显示错误组件。默认值 Infinity (即永不超时，单位ms)\n        // timeout: 0,\n        /**\n     \t * err: 错误信息,\n     \t * retry: 函数, 调用retry尝试重新加载\n     \t * attempts: 记录尝试的次数\n     \t */\n        onError: function(err, retry, fail, attempts) {\n\n    \t}\n    \t// 定义组件是否可挂起，默认值 true\n    \tsuspensible: true,\n    })\n\n    export default {\n        components: {\n            AsyncCategory,\n            Loading,\n            Error,\n        }\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 异步组件和Suspense\n\n目前(2021-06-08)Suspense显示的是一个实验性的特性，API随时可能会修改\n\nSuspense是一个内置的全局组件，该组件有两个插槽:\n\n * default:如果default可以显示，那么显示default的内容;\n * fallback:如果default无法显示，那么会显示fallback插槽的内容;\n\n<suspense>\n    <template #default>\n\t\t<async-category></async-category>\n    </template>\n    <template #fallback>\n\t\t<loading></loading>\n    </template>\n</suspense>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",normalizedContent:"# 异步组件\n\n\n# webpack的代码分包\n\n默认的打包过程:\n\n * 默认情况下，在构建整个组件树的过程中，因为组件和组件之间是通过模块化直接依赖的，那么webpack在打包时就会将组 件模块打包到一起(比如一个app.js文件中);\n\n * 这个时候随着项目的不断庞大，app.js文件的内容过大，会造成首屏的渲染速度变慢;\n\n打包时，代码的分包:\n\n * 所以，对于一些不需要立即使用的组件，我们可以单独对它们进行拆分，拆分成一些小的代码块chunk.js;\n * 这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容;\n\nwebpack中如何可以对代码进行分包呢?\n\n\n\n\n# vue中实现异步组件\n\n如果我们的项目过大了，对于某些组件我们希望通过异步的方式来进行加载(目的是可以对其进行分包处理)，那么vue中给我们提供了一个函数:defineasynccomponent。\n\ndefineasynccomponent接受两种类型的参数:\n\n * 类型一：工厂函数，该工厂函数需要返回一个promise对象;\n * 类型二:接受一个对象类型，对异步函数进行配置;\n\n\n# 工厂函数写法\n\n<script>\n    import { defineasynccomponent } from 'vue';\n\n    const asynccategory = defineasynccomponent(() => import(\"./asynccategory.vue\"))\n\n    export default {\n        components: {\n            asynccategory,\n        }\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\n\n# 对象写法\n\n<script>\n    import { defineasynccomponent } from 'vue';\n    import loading from './loading';    \n    import error from './error';\n\n    const asynccategory = defineasynccomponent({\n        // 工厂函数\n        loader: () => import(\"./asynccategory.vue\"),\n        \n        // 加载过程中显示的组件\n        loadingcomponent: loading,\n        \n        // 加载失败时显示的组件\n        errorcomponent: error,\n        \n        // 在显示loadingcomponent组件之前, 等待多长时间，默认值：200，单位ms\n        delay: 2000,\n        \n        // 如果提供了timeout，并且加载组件的时间超过了该值，将显示错误组件。默认值 infinity (即永不超时，单位ms)\n        // timeout: 0,\n        /**\n     \t * err: 错误信息,\n     \t * retry: 函数, 调用retry尝试重新加载\n     \t * attempts: 记录尝试的次数\n     \t */\n        onerror: function(err, retry, fail, attempts) {\n\n    \t}\n    \t// 定义组件是否可挂起，默认值 true\n    \tsuspensible: true,\n    })\n\n    export default {\n        components: {\n            asynccategory,\n            loading,\n            error,\n        }\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n\n\n\n# 异步组件和suspense\n\n目前(2021-06-08)suspense显示的是一个实验性的特性，api随时可能会修改\n\nsuspense是一个内置的全局组件，该组件有两个插槽:\n\n * default:如果default可以显示，那么显示default的内容;\n * fallback:如果default无法显示，那么会显示fallback插槽的内容;\n\n<suspense>\n    <template #default>\n\t\t<async-category></async-category>\n    </template>\n    <template #fallback>\n\t\t<loading></loading>\n    </template>\n</suspense>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"生命周期",frontmatter:{title:"生命周期",date:"2022-01-31T01:47:22.000Z",permalink:"/pages/85ff80/",categories:["x","组件"],tags:[null]},regularPath:"/1403.Vue3.x/200.%E7%BB%84%E4%BB%B6/206.%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",relativePath:"1403.Vue3.x/200.组件/206.生命周期.md",key:"v-b041636c",path:"/pages/85ff80/",headers:[{level:2,title:"生命周期函数",slug:"生命周期函数",normalizedTitle:"生命周期函数",charIndex:11}],headersStr:"生命周期函数",content:"# 生命周期\n\n\n# 生命周期函数\n\n * 注意 Vue2 的 destroy 等已被 unmount 等取代\n\n * 动态组件可以使用 activated 和 deactivated 这两个生命周期钩子函数来监听\n\n<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"UTF-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>Hello World</title>\n  </head>\n  <body>\n    <div id=\"root\">\n      <div>{{counter}}</div>\n    </div>\n\n    <script src=\"https://unpkg.com/vue@next\"><\/script>\n    <script>\n      // 生命周期函数：在某一刻会自动执行的函数\n      // 执行完 Vue.createApp 并且 mount 后开始进行生命周期函数\n\n      let options = {\n        data() {\n          return {\n            counter: 1,\n          }\n        },\n        beforeCreate() {\n          console.log(\n            '[beforeCreate]: after init events & lifecycle。事件绑定、生命周期函数等。即 Vue 应用生成之前，Vue.createApp',\n            '。root innerHTML: ',\n            document.getElementById('root').innerHTML // 空\n          )\n        },\n        created() {\n          console.log(\n            '[created]: after init injections & reactivity。依赖注入、响应式（数据双向绑定）等。即 Vue 应用生成之后，Vue.createApp',\n            '。root innerHTML: ',\n            document.getElementById('root').innerHTML // 空\n          )\n        },\n        // 组件中有 template 则编译为 render 函数，没有则使用 mount 挂载的 el DOM 元素作为 template 进行编译\n        beforeMount() {\n          console.log(\n            '[beforeMount]: template（或 el） 的 innerHtml 被编译成render函数后。或称为组件被渲染到页面前。app.mount()',\n            '。root innerHTML: ',\n            document.getElementById('root').innerHTML // 空，此时没有任何内容！\n          )\n        },\n        mounted() {\n          console.log(\n            '[mounted]: after Create app.$el and replace \"el\" with it。 组件被渲染到页面后。此时页面的所有数据都可以正常展示！！！app.mount()',\n            '。root innerHTML: ',\n            document.getElementById('root').innerHTML // <div>1</div>\n          )\n        },\n        beforeUpdate() {\n          // 执行 vm.counter ++ 改变了 data 中数据即可\n          console.log(\n            '[beforeUpdate]: when data change, before Virtual DOM re-rendered and patch。即 data 变化，且页面重新渲染前执行',\n            '。root innerHTML: ',\n            document.getElementById('root').innerHTML // <div>1</div>\n          )\n        },\n        updated() {\n          // 执行 vm.counter ++ 改变了 data 中数据即可\n          console.log(\n            '[updated]: when data change, after Virtual DOM re-rendered and patch。即 data 变化，且页面重新渲染后执行',\n            '。root innerHTML: ',\n\n            document.getElementById('root').innerHTML // <div>2</div>\n          )\n        },\n        beforeUnmount() {\n          console.log(\n            '[beforeUnmount]: when app.unmount() is called。即 Vue 应用失效时，类比 beforeMount',\n            '。root innerHTML: ',\n            document.getElementById('root').innerHTML // <div>2</div>\n          )\n        },\n        unmounted() {\n          console.log(\n            '[unmounted]: when app.unmount() is called。即 Vue 应用失效，且 DOM 完全销毁之后，类比 mounted',\n            '。root innerHTML: ',\n            document.getElementById('root').innerHTML // 空\n          )\n        },\n      }\n\n      // Vue.createApp 创建 Vue 应用\n      // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      const app = Vue.createApp(options)\n      const vm = app.mount('#root')\n\n      // vm.$data.counter = 2\n      vm.counter = 2\n      // app.unmount()\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n\n\n",normalizedContent:"# 生命周期\n\n\n# 生命周期函数\n\n * 注意 vue2 的 destroy 等已被 unmount 等取代\n\n * 动态组件可以使用 activated 和 deactivated 这两个生命周期钩子函数来监听\n\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" />\n    <title>hello world</title>\n  </head>\n  <body>\n    <div id=\"root\">\n      <div>{{counter}}</div>\n    </div>\n\n    <script src=\"https://unpkg.com/vue@next\"><\/script>\n    <script>\n      // 生命周期函数：在某一刻会自动执行的函数\n      // 执行完 vue.createapp 并且 mount 后开始进行生命周期函数\n\n      let options = {\n        data() {\n          return {\n            counter: 1,\n          }\n        },\n        beforecreate() {\n          console.log(\n            '[beforecreate]: after init events & lifecycle。事件绑定、生命周期函数等。即 vue 应用生成之前，vue.createapp',\n            '。root innerhtml: ',\n            document.getelementbyid('root').innerhtml // 空\n          )\n        },\n        created() {\n          console.log(\n            '[created]: after init injections & reactivity。依赖注入、响应式（数据双向绑定）等。即 vue 应用生成之后，vue.createapp',\n            '。root innerhtml: ',\n            document.getelementbyid('root').innerhtml // 空\n          )\n        },\n        // 组件中有 template 则编译为 render 函数，没有则使用 mount 挂载的 el dom 元素作为 template 进行编译\n        beforemount() {\n          console.log(\n            '[beforemount]: template（或 el） 的 innerhtml 被编译成render函数后。或称为组件被渲染到页面前。app.mount()',\n            '。root innerhtml: ',\n            document.getelementbyid('root').innerhtml // 空，此时没有任何内容！\n          )\n        },\n        mounted() {\n          console.log(\n            '[mounted]: after create app.$el and replace \"el\" with it。 组件被渲染到页面后。此时页面的所有数据都可以正常展示！！！app.mount()',\n            '。root innerhtml: ',\n            document.getelementbyid('root').innerhtml // <div>1</div>\n          )\n        },\n        beforeupdate() {\n          // 执行 vm.counter ++ 改变了 data 中数据即可\n          console.log(\n            '[beforeupdate]: when data change, before virtual dom re-rendered and patch。即 data 变化，且页面重新渲染前执行',\n            '。root innerhtml: ',\n            document.getelementbyid('root').innerhtml // <div>1</div>\n          )\n        },\n        updated() {\n          // 执行 vm.counter ++ 改变了 data 中数据即可\n          console.log(\n            '[updated]: when data change, after virtual dom re-rendered and patch。即 data 变化，且页面重新渲染后执行',\n            '。root innerhtml: ',\n\n            document.getelementbyid('root').innerhtml // <div>2</div>\n          )\n        },\n        beforeunmount() {\n          console.log(\n            '[beforeunmount]: when app.unmount() is called。即 vue 应用失效时，类比 beforemount',\n            '。root innerhtml: ',\n            document.getelementbyid('root').innerhtml // <div>2</div>\n          )\n        },\n        unmounted() {\n          console.log(\n            '[unmounted]: when app.unmount() is called。即 vue 应用失效，且 dom 完全销毁之后，类比 mounted',\n            '。root innerhtml: ',\n            document.getelementbyid('root').innerhtml // 空\n          )\n        },\n      }\n\n      // vue.createapp 创建 vue 应用\n      // mount 装载到哪里，即在 id = root 的 html 中使用 vue\n      const app = vue.createapp(options)\n      const vm = app.mount('#root')\n\n      // vm.$data.counter = 2\n      vm.counter = 2\n      // app.unmount()\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n\n\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"组件的v-model",frontmatter:{title:"组件的v-model",date:"2022-01-31T02:12:05.000Z",permalink:"/pages/fcbaec/",categories:["x","组件"],tags:[null]},regularPath:"/1403.Vue3.x/200.%E7%BB%84%E4%BB%B6/207.%E7%BB%84%E4%BB%B6%E7%9A%84v-model.html",relativePath:"1403.Vue3.x/200.组件/207.组件的v-model.md",key:"v-31e4b958",path:"/pages/fcbaec/",headers:[{level:2,title:"推荐 🔥",slug:"推荐-🔥",normalizedTitle:"推荐 🔥",charIndex:20},{level:2,title:"使用 🔥",slug:"使用-🔥",normalizedTitle:"使用 🔥",charIndex:58},{level:2,title:"绑定多个值 🔥",slug:"绑定多个值-🔥",normalizedTitle:"绑定多个值 🔥",charIndex:1952},{level:2,title:"注意—绑定对象 🔥",slug:"注意-绑定对象-🔥",normalizedTitle:"注意—绑定对象 🔥",charIndex:3179},{level:3,title:"方式一",slug:"方式一",normalizedTitle:"方式一",charIndex:3260},{level:3,title:"方式二",slug:"方式二",normalizedTitle:"方式二",charIndex:3663}],headersStr:"推荐 🔥 使用 🔥 绑定多个值 🔥 注意—绑定对象 🔥 方式一 方式二",content:'# 组件的v-model 🔥\n\n\n# 推荐 🔥\n\n * 只推荐绑定单个值！\n * 绑定对象推荐自己写！\n\n\n# 使用 🔥\n\n前面我们在input中可以使用v-model来完成双向绑定，这个时候往往会非常方便，因为v-model默认帮助我们完成了两件事：\n\n * v-bind:value的数据绑定\n * @input的事件监听\n\n<input v-model="message">\n<input :value="message" @input="message = $event.target.value">\n\n\n1\n2\n\n\n如果我们现在封装了一个组件，其他地方在使用这个组件时，是否也可以使用v-model来同时完成这两个功能呢? 也是可以的，vue也支持在组件上使用v-model。类似Vue2的.sync\n\n当我们在组件上使用的时候，等价于如下的操作：\n\n<template>\n    \x3c!-- 组件上使用v-model --\x3e\n    <hy-input v-model="message"></hy-input>\n    \x3c!-- 等价于如下 --\x3e\n\t<hy-input :modelValue="message" @update:model-value="message = $event"></hy-input>\n\n    <h2>{{ message }}</h2>\n</template>\n\n<script>\n    import HyInput from \'./HyInput.vue\'\n\n    export default {\n        components: {\n            HyInput,\n        },\n        data() {\n            return {\n                message: \'Hello World\',\n            }\n        },\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n所以 hy-input 组件中也应该提供 modelValue prop 和 update:model-value emit\n\n<template>\n  <div>\n    \x3c!-- 1.默认绑定和事件处理。事件还得button触发，不优雅 --\x3e\n    \x3c!-- <button @click="btnClick">hyinput按钮</button>\n    <h2>HyInput的message: {{modelValue}}</h2> --\x3e\n\n    \x3c!-- 2.通过input，也不是很优雅 --\x3e\n    \x3c!-- <input :value="modelValue" @input="btnClick"> --\x3e\n\n    \x3c!-- 3.绑定到props中是不对的，单向数据流，不应该修改props中的值 --\x3e\n    \x3c!-- <input v-model="modelValue"> --\x3e\n\n    \x3c!-- 4.利用计算属性！！！推荐！！！--\x3e\n    <input v-model="value">\n\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      modelValue: String\n    },\n    emits: ["update:modelValue"],\n    computed: {\n      value: {\n        set(value) {\n          this.$emit("update:modelValue", value);\n        },\n        get() {\n          return this.modelValue;\n        }\n      }\n    },\n    methods: {\n      btnClick(event) {\n        this.$emit("update:modelValue", event.target.value);\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 绑定多个值 🔥\n\n<template>\n\t\x3c!-- 绑定两个v-model，更多的一样！ --\x3e\n    <hy-input v-model="message" v-model:title="title"></hy-input>\n\n    <h2>{{ message }}</h2>\n    <h2>{{ title }}</h2>\n</template>\n\n<script>\n    import HyInput from \'./HyInput.vue\'\n\n    export default {\n        components: {\n            HyInput,\n        },\n        data() {\n            return {\n                message: \'Hello World\',\n                title: \'哈哈哈\',\n            }\n        },\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<template>\n  <div>\n    <input v-model="value">\n    <input v-model="titleData">\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      modelValue: String,\n      title: String \n    },\n    emits: ["update:modelValue", "update:title"],\n    computed: {\n      value: {\n        set(value) {\n          this.$emit("update:modelValue", value);\n        },\n        get() {\n          return this.modelValue;\n        }\n      },\n      titleData: {\n        set(title) {\n          this.$emit("update:title", title);\n        },\n        get() {\n          return this.title;\n        }\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 注意—绑定对象 🔥\n\n上述只能绑定1个值，不能绑定对象！否则对象属性改变不能触发set方法。详细见项目！\n\n改成下面绑定对象写法还是有问题，解决方式：\n\n\n# 方式一\n\n直接修改父组件formData，但是浅拷贝里对象的修改不会触发\n\n可以在父组件中不直接修改props的formData，而是修改formData中的属性！\n\n// 父组件修改属性 formData.value.xxx = xxx\n\n// 子组件\nconst formData = ref({...props.modelValue})\nwatch(\n    formData,\n    (newValue) => {\n        console.log(newValue)\n        emit(\'update:modelValue\', newValue)\n    },\n    {\n        deep: true\n    }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n不能使用computed来替代ref，配合watch会产生无限递归！\n\n\n# 方式二\n\n不适用v-model双向绑定语法糖，而是自定义！\n\n子组件\n\n<template>\n\t<el-input\n          :model-value="modelValue[`${item.field}`]"\n          @update:modelValue="handleValueChange($event, item.field)"\n          />\n</template>\n\n<script lang="ts" setup >\n    const props = defineProps({\n        modelValue: {\n            type: Object,\n            required: true,\n        }\n    })\n    \n    const emit = defineEmits([\'update:modelValue\'])\n    \n    const handleValueChange = (value: any, field: string) => {\n      emit(\'update:modelValue\', { ...props.modelValue, [field]: value })\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n父组件直接修改 formData.value 都可以！',normalizedContent:'# 组件的v-model 🔥\n\n\n# 推荐 🔥\n\n * 只推荐绑定单个值！\n * 绑定对象推荐自己写！\n\n\n# 使用 🔥\n\n前面我们在input中可以使用v-model来完成双向绑定，这个时候往往会非常方便，因为v-model默认帮助我们完成了两件事：\n\n * v-bind:value的数据绑定\n * @input的事件监听\n\n<input v-model="message">\n<input :value="message" @input="message = $event.target.value">\n\n\n1\n2\n\n\n如果我们现在封装了一个组件，其他地方在使用这个组件时，是否也可以使用v-model来同时完成这两个功能呢? 也是可以的，vue也支持在组件上使用v-model。类似vue2的.sync\n\n当我们在组件上使用的时候，等价于如下的操作：\n\n<template>\n    \x3c!-- 组件上使用v-model --\x3e\n    <hy-input v-model="message"></hy-input>\n    \x3c!-- 等价于如下 --\x3e\n\t<hy-input :modelvalue="message" @update:model-value="message = $event"></hy-input>\n\n    <h2>{{ message }}</h2>\n</template>\n\n<script>\n    import hyinput from \'./hyinput.vue\'\n\n    export default {\n        components: {\n            hyinput,\n        },\n        data() {\n            return {\n                message: \'hello world\',\n            }\n        },\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n所以 hy-input 组件中也应该提供 modelvalue prop 和 update:model-value emit\n\n<template>\n  <div>\n    \x3c!-- 1.默认绑定和事件处理。事件还得button触发，不优雅 --\x3e\n    \x3c!-- <button @click="btnclick">hyinput按钮</button>\n    <h2>hyinput的message: {{modelvalue}}</h2> --\x3e\n\n    \x3c!-- 2.通过input，也不是很优雅 --\x3e\n    \x3c!-- <input :value="modelvalue" @input="btnclick"> --\x3e\n\n    \x3c!-- 3.绑定到props中是不对的，单向数据流，不应该修改props中的值 --\x3e\n    \x3c!-- <input v-model="modelvalue"> --\x3e\n\n    \x3c!-- 4.利用计算属性！！！推荐！！！--\x3e\n    <input v-model="value">\n\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      modelvalue: string\n    },\n    emits: ["update:modelvalue"],\n    computed: {\n      value: {\n        set(value) {\n          this.$emit("update:modelvalue", value);\n        },\n        get() {\n          return this.modelvalue;\n        }\n      }\n    },\n    methods: {\n      btnclick(event) {\n        this.$emit("update:modelvalue", event.target.value);\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n\n# 绑定多个值 🔥\n\n<template>\n\t\x3c!-- 绑定两个v-model，更多的一样！ --\x3e\n    <hy-input v-model="message" v-model:title="title"></hy-input>\n\n    <h2>{{ message }}</h2>\n    <h2>{{ title }}</h2>\n</template>\n\n<script>\n    import hyinput from \'./hyinput.vue\'\n\n    export default {\n        components: {\n            hyinput,\n        },\n        data() {\n            return {\n                message: \'hello world\',\n                title: \'哈哈哈\',\n            }\n        },\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<template>\n  <div>\n    <input v-model="value">\n    <input v-model="titledata">\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      modelvalue: string,\n      title: string \n    },\n    emits: ["update:modelvalue", "update:title"],\n    computed: {\n      value: {\n        set(value) {\n          this.$emit("update:modelvalue", value);\n        },\n        get() {\n          return this.modelvalue;\n        }\n      },\n      titledata: {\n        set(title) {\n          this.$emit("update:title", title);\n        },\n        get() {\n          return this.title;\n        }\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n\n\n\n# 注意—绑定对象 🔥\n\n上述只能绑定1个值，不能绑定对象！否则对象属性改变不能触发set方法。详细见项目！\n\n改成下面绑定对象写法还是有问题，解决方式：\n\n\n# 方式一\n\n直接修改父组件formdata，但是浅拷贝里对象的修改不会触发\n\n可以在父组件中不直接修改props的formdata，而是修改formdata中的属性！\n\n// 父组件修改属性 formdata.value.xxx = xxx\n\n// 子组件\nconst formdata = ref({...props.modelvalue})\nwatch(\n    formdata,\n    (newvalue) => {\n        console.log(newvalue)\n        emit(\'update:modelvalue\', newvalue)\n    },\n    {\n        deep: true\n    }\n)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n不能使用computed来替代ref，配合watch会产生无限递归！\n\n\n# 方式二\n\n不适用v-model双向绑定语法糖，而是自定义！\n\n子组件\n\n<template>\n\t<el-input\n          :model-value="modelvalue[`${item.field}`]"\n          @update:modelvalue="handlevaluechange($event, item.field)"\n          />\n</template>\n\n<script lang="ts" setup >\n    const props = defineprops({\n        modelvalue: {\n            type: object,\n            required: true,\n        }\n    })\n    \n    const emit = defineemits([\'update:modelvalue\'])\n    \n    const handlevaluechange = (value: any, field: string) => {\n      emit(\'update:modelvalue\', { ...props.modelvalue, [field]: value })\n    }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n父组件直接修改 formdata.value 都可以！',charsets:{cjk:!0},lastUpdated:"2022/04/30, 01:54:50",lastUpdatedTimestamp:165128369e4},{title:"Vue 动画",frontmatter:{title:"Vue 动画",date:"2022-02-01T21:52:12.000Z",permalink:"/pages/5570af/",categories:["x","动画"],tags:[null]},regularPath:"/1403.Vue3.x/300.%E5%8A%A8%E7%94%BB/301.Vue%E5%8A%A8%E7%94%BB.html",relativePath:"1403.Vue3.x/300.动画/301.Vue动画.md",key:"v-442b5a91",path:"/pages/5570af/",headers:[{level:2,title:"认识动画",slug:"认识动画",normalizedTitle:"认识动画",charIndex:13},{level:2,title:"Vue 的 transition 组件",slug:"vue-的-transition-组件",normalizedTitle:"vue 的 transition 组件",charIndex:290},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:314},{level:3,title:"原理",slug:"原理",normalizedTitle:"原理",charIndex:427},{level:2,title:"过渡—transition",slug:"过渡-transition",normalizedTitle:"过渡—transition",charIndex:637},{level:3,title:"过渡 class",slug:"过渡-class",normalizedTitle:"过渡 class",charIndex:655},{level:3,title:"class 添加的时机和命名规则",slug:"class-添加的时机和命名规则",normalizedTitle:"class 添加的时机和命名规则",charIndex:1132},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:1297},{level:2,title:"动画—animation",slug:"动画-animation",normalizedTitle:"动画—animation",charIndex:1916},{level:3,title:"示例",slug:"示例-2",normalizedTitle:"示例",charIndex:1297},{level:2,title:"未完待续 ...",slug:"未完待续",normalizedTitle:"未完待续 ...",charIndex:2817}],headersStr:"认识动画 Vue 的 transition 组件 介绍 原理 过渡—transition 过渡 class class 添加的时机和命名规则 示例 动画—animation 示例 未完待续 ...",content:'# Vue 动画\n\n\n# 认识动画\n\n在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验:\n\n * React框架本身并没有提供任何动画相关的API，所以在React中使用过渡动画我们需要使用一个第三方库 react-transition-group;\n\n * Vue中为我们提供一些内置组件和对应的API来完成动画，利用它们我们可以方便的实现过渡动画效果;\n\n隐藏 / 显示案例\n\n * 没有动画的情况下，整个内容的显示和隐藏会非常的生硬\n * 如果我们希望给单元素或者组件实现过渡动画，可以使用 transition 内置组件来完成动画\n\n\n# Vue 的 transition 组件\n\n\n# 介绍\n\nVue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡：\n\n * 条件渲染 (使用 v-if)条件展示 (使用 v-show)\n * 动态组件\n * 组件根节点\n\n\n# 原理\n\n当插入或删除包含在 transition 组件中的元素时，Vue 将会做以下处理：\n\n * 自动嗅探目标元素是否应用了CSS过渡或者动画，如果有，那么在恰当的时机添加/删除 CSS类名\n * 如果 transition 组件提供了JavaScript钩子函数，这些钩子函数将在恰当的时机被调用\n * 如果没有找到JavaScript钩子并且也没有检测到CSS过渡/动画，DOM插入、删除操作将会立即执行\n\n\n# 过渡—transition\n\n\n# 过渡 class\n\n * v-enter-from：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。\n * v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动 画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。\n * v-enter-to：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡/ 动画完成之后移除。\n * v-leave-from：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。\n * v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。\n * v-leave-to：离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被删除)，在过渡/ 动画完成之后移除。\n\n\n# class 添加的时机和命名规则\n\n\n\nclass的name命名规则如下\n\n * 如果我们使用的是一个没有 name 的 transition，那么所有的class是以v-作为默认前缀\n * 如果我们添加了一个 name 属性，比如 <transtion name="why">，那么所有的 class 会以why-开头\n\n\n# 示例\n\n<template>\n  <div>\n    <button @click="isShow = !isShow">显示/隐藏</button>\n\n    <transition name="why">\n      <h2 v-if="isShow">Hello World</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        isShow: true\n      }\n    }\n  }\n<\/script>\n\n<style scoped>\n  .why-enter-from,\n  .why-leave-to {\n    opacity: 0;\n  }\n\n  .why-enter-to, \n  .why-leave-from {\n    opacity: 1;\n  }\n\n  .why-enter-active,\n  .why-leave-active {\n    transition: opacity 2s ease;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 动画—animation\n\n\n# 示例\n\n<template>\n  <div class="app">\n    <div><button @click="isShow = !isShow">显示/隐藏</button></div>\n\n    <transition name="why">\n      <h2 class="title" v-if="isShow">Hello World</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        isShow: true\n      }\n    }\n  }\n<\/script>\n\n<style scoped>\n  .app {\n    width: 200px;\n    margin: 0 auto;\n  }\n\n  .title {\n    display: inline-block;\n  }\n\n  .why-enter-active {\n    animation: bounce 1s ease;\n  }\n\n  .why-leave-active {\n    animation: bounce 1s ease reverse;\n  }\n\n  @keyframes bounce {\n    0% {\n      transform: scale(0)\n    }\n\n    50% {\n      transform: scale(1.2);\n    }\n\n    100% {\n      transform: scale(1);\n    }\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 未完待续 ...',normalizedContent:'# vue 动画\n\n\n# 认识动画\n\n在开发中，我们想要给一个组件的显示和消失添加某种过渡动画，可以很好的增加用户体验:\n\n * react框架本身并没有提供任何动画相关的api，所以在react中使用过渡动画我们需要使用一个第三方库 react-transition-group;\n\n * vue中为我们提供一些内置组件和对应的api来完成动画，利用它们我们可以方便的实现过渡动画效果;\n\n隐藏 / 显示案例\n\n * 没有动画的情况下，整个内容的显示和隐藏会非常的生硬\n * 如果我们希望给单元素或者组件实现过渡动画，可以使用 transition 内置组件来完成动画\n\n\n# vue 的 transition 组件\n\n\n# 介绍\n\nvue 提供了 transition 的封装组件，在下列情形中，可以给任何元素和组件添加进入/离开过渡：\n\n * 条件渲染 (使用 v-if)条件展示 (使用 v-show)\n * 动态组件\n * 组件根节点\n\n\n# 原理\n\n当插入或删除包含在 transition 组件中的元素时，vue 将会做以下处理：\n\n * 自动嗅探目标元素是否应用了css过渡或者动画，如果有，那么在恰当的时机添加/删除 css类名\n * 如果 transition 组件提供了javascript钩子函数，这些钩子函数将在恰当的时机被调用\n * 如果没有找到javascript钩子并且也没有检测到css过渡/动画，dom插入、删除操作将会立即执行\n\n\n# 过渡—transition\n\n\n# 过渡 class\n\n * v-enter-from：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。\n * v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动 画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。\n * v-enter-to：定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter-from 被移除)，在过渡/ 动画完成之后移除。\n * v-leave-from：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。\n * v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。\n * v-leave-to：离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave-from 被删除)，在过渡/ 动画完成之后移除。\n\n\n# class 添加的时机和命名规则\n\n\n\nclass的name命名规则如下\n\n * 如果我们使用的是一个没有 name 的 transition，那么所有的class是以v-作为默认前缀\n * 如果我们添加了一个 name 属性，比如 <transtion name="why">，那么所有的 class 会以why-开头\n\n\n# 示例\n\n<template>\n  <div>\n    <button @click="isshow = !isshow">显示/隐藏</button>\n\n    <transition name="why">\n      <h2 v-if="isshow">hello world</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        isshow: true\n      }\n    }\n  }\n<\/script>\n\n<style scoped>\n  .why-enter-from,\n  .why-leave-to {\n    opacity: 0;\n  }\n\n  .why-enter-to, \n  .why-leave-from {\n    opacity: 1;\n  }\n\n  .why-enter-active,\n  .why-leave-active {\n    transition: opacity 2s ease;\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 动画—animation\n\n\n# 示例\n\n<template>\n  <div class="app">\n    <div><button @click="isshow = !isshow">显示/隐藏</button></div>\n\n    <transition name="why">\n      <h2 class="title" v-if="isshow">hello world</h2>\n    </transition>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        isshow: true\n      }\n    }\n  }\n<\/script>\n\n<style scoped>\n  .app {\n    width: 200px;\n    margin: 0 auto;\n  }\n\n  .title {\n    display: inline-block;\n  }\n\n  .why-enter-active {\n    animation: bounce 1s ease;\n  }\n\n  .why-leave-active {\n    animation: bounce 1s ease reverse;\n  }\n\n  @keyframes bounce {\n    0% {\n      transform: scale(0)\n    }\n\n    50% {\n      transform: scale(1.2);\n    }\n\n    100% {\n      transform: scale(1);\n    }\n  }\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n\n# 未完待续 ...',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"旧解决方案",frontmatter:{title:"旧解决方案",date:"2022-02-03T21:52:17.000Z",permalink:"/pages/958e61/",categories:["x","Composition Api"],tags:[null]},regularPath:"/1403.Vue3.x/400.Composition%20Api/401.%E6%97%A7%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html",relativePath:"1403.Vue3.x/400.Composition Api/401.旧解决方案.md",key:"v-ee4028c4",path:"/pages/958e61/",headers:[{level:2,title:"Mixin",slug:"mixin",normalizedTitle:"mixin",charIndex:12},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:22},{level:3,title:"使用",slug:"使用",normalizedTitle:"使用",charIndex:31},{level:3,title:"Mixin的合并规则",slug:"mixin的合并规则",normalizedTitle:"mixin的合并规则",charIndex:935},{level:3,title:"全局混入Mixin",slug:"全局混入mixin",normalizedTitle:"全局混入mixin",charIndex:1260},{level:2,title:"extends—使用更少",slug:"extends-使用更少",normalizedTitle:"extends—使用更少",charIndex:1384},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:2139}],headersStr:"Mixin 介绍 使用 Mixin的合并规则 全局混入Mixin extends—使用更少 总结",content:'# 旧解决方案\n\n\n# Mixin\n\n\n# 介绍\n\n目前我们是使用组件化的方式在开发整个Vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。\n\n在Vue2和Vue3中都支持的一种方式就是使用Mixin来完成:\n\n * Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能;\n * 一个Mixin对象可以包含任何组件 Options 选项;\n * 当组件使用Mixin对象时，所有Mixin对象的选项将被混合进入该组件本身的选项中;\n\n\n# 使用\n\ndemoMixin.js\n\nexport const demoMixin = {\n  data() {\n    return {\n      message: "Hello DemoMixin"\n    }\n  },\n  methods: {\n    foo() {\n      console.log("demo mixin foo");\n    }\n  },\n  created() {\n    console.log("执行了demo mixin created");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n01_mixin基本使用.vue\n\n<template>\n  <div>\n    <h2>{{message}}</h2>\n    <button @click="foo">按钮</button>\n  </div>\n</template>\n\n<script>\n  import { demoMixin } from \'./mixins/demoMixin\';\n\n  export default {\n    mixins: [demoMixin],\n    data() {\n      return {\n        title: "Hello World"\n      }\n    },\n    methods: {\n\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# Mixin的合并规则\n\n**如果Mixin对象中的选项和组件对象中的选项发生了冲突，那么Vue会如何操作呢?**这里分成不同的情况来进行处理：\n\n * 如果是data函数的返回值对象\n   * 返回值对象默认情况下会进行合并;\n   * 如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据\n * 如果是生命周期钩子函数\n   * 生命周期的钩子函数会被合并到数组中，都会被调用\n * 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象\n   * 比如都有methods选项，并且都定义了方法，那么它们都会生效\n   * 但是如果对象的key相同，那么会取组件对象的键值对\n\n\n# 全局混入Mixin\n\n如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用全局的mixin\n\n * 全局的Mixin可以使用应用app的方法 mixin 来完成注册\n * 一旦注册，那么全局混入的选项将会影响每一个组件\n\n\n# extends—使用更少\n\n允许声明扩展另外一个组件，类似于Mixins。只能 extends Options Api 的东西！！！\n\nBasePage.vue\n\n<template>\n  <div>\n    <h2>哈哈哈哈啊</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        title: "Hello Page"\n      }\n    },\n    methods: {\n      bar() {\n        console.log("base page bar");\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nHome.vue\n\n<template>\n  <div>\n    Home Page\n    <h2>{{title}}</h2>\n    <button @click="bar">按钮</button>\n  </div>\n</template>\n\n<script>\n  import BasePage from \'./BasePage.vue\';\n\n  export default {\n    extends: [BasePage],\n    data() {\n      return {\n        content: "Hello Home"\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 总结\n\n在开发中extends用的非常少，在Vue2中比较推荐大家使用Mixin，而在Vue3中推荐使用Composition API',normalizedContent:'# 旧解决方案\n\n\n# mixin\n\n\n# 介绍\n\n目前我们是使用组件化的方式在开发整个vue的应用程序，但是组件和组件之间有时候会存在相同的代码逻辑，我们希望对相同的代码逻辑进行抽取。\n\n在vue2和vue3中都支持的一种方式就是使用mixin来完成:\n\n * mixin提供了一种非常灵活的方式，来分发vue组件中的可复用功能;\n * 一个mixin对象可以包含任何组件 options 选项;\n * 当组件使用mixin对象时，所有mixin对象的选项将被混合进入该组件本身的选项中;\n\n\n# 使用\n\ndemomixin.js\n\nexport const demomixin = {\n  data() {\n    return {\n      message: "hello demomixin"\n    }\n  },\n  methods: {\n    foo() {\n      console.log("demo mixin foo");\n    }\n  },\n  created() {\n    console.log("执行了demo mixin created");\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n01_mixin基本使用.vue\n\n<template>\n  <div>\n    <h2>{{message}}</h2>\n    <button @click="foo">按钮</button>\n  </div>\n</template>\n\n<script>\n  import { demomixin } from \'./mixins/demomixin\';\n\n  export default {\n    mixins: [demomixin],\n    data() {\n      return {\n        title: "hello world"\n      }\n    },\n    methods: {\n\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n\n# mixin的合并规则\n\n**如果mixin对象中的选项和组件对象中的选项发生了冲突，那么vue会如何操作呢?**这里分成不同的情况来进行处理：\n\n * 如果是data函数的返回值对象\n   * 返回值对象默认情况下会进行合并;\n   * 如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据\n * 如果是生命周期钩子函数\n   * 生命周期的钩子函数会被合并到数组中，都会被调用\n * 值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象\n   * 比如都有methods选项，并且都定义了方法，那么它们都会生效\n   * 但是如果对象的key相同，那么会取组件对象的键值对\n\n\n# 全局混入mixin\n\n如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用全局的mixin\n\n * 全局的mixin可以使用应用app的方法 mixin 来完成注册\n * 一旦注册，那么全局混入的选项将会影响每一个组件\n\n\n# extends—使用更少\n\n允许声明扩展另外一个组件，类似于mixins。只能 extends options api 的东西！！！\n\nbasepage.vue\n\n<template>\n  <div>\n    <h2>哈哈哈哈啊</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    data() {\n      return {\n        title: "hello page"\n      }\n    },\n    methods: {\n      bar() {\n        console.log("base page bar");\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nhome.vue\n\n<template>\n  <div>\n    home page\n    <h2>{{title}}</h2>\n    <button @click="bar">按钮</button>\n  </div>\n</template>\n\n<script>\n  import basepage from \'./basepage.vue\';\n\n  export default {\n    extends: [basepage],\n    data() {\n      return {\n        content: "hello home"\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\n\n# 总结\n\n在开发中extends用的非常少，在vue2中比较推荐大家使用mixin，而在vue3中推荐使用composition api',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"响应式Api",frontmatter:{title:"响应式Api",date:"2022-02-03T22:14:41.000Z",permalink:"/pages/52c08c/",categories:["x","Composition Api"],tags:[null]},regularPath:"/1403.Vue3.x/400.Composition%20Api/402.%E5%93%8D%E5%BA%94%E5%BC%8FApi.html",relativePath:"1403.Vue3.x/400.Composition Api/402.响应式Api.md",key:"v-5c4c5168",path:"/pages/52c08c/",headers:[{level:2,title:"Options Api 的弊端",slug:"options-api-的弊端",normalizedTitle:"options api 的弊端",charIndex:13},{level:2,title:"setup 函数 🔥",slug:"setup-函数-🔥",normalizedTitle:"setup 函数 🔥",charIndex:376},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:392},{level:3,title:"参数",slug:"参数",normalizedTitle:"参数",charIndex:563},{level:3,title:"返回值",slug:"返回值",normalizedTitle:"返回值",charIndex:1149},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:1298},{level:2,title:"ref Api 🔥",slug:"ref-api-🔥",normalizedTitle:"ref api 🔥",charIndex:2120},{level:3,title:"ref 🔥",slug:"ref-🔥",normalizedTitle:"ref 🔥",charIndex:2135},{level:3,title:"unref 🔥",slug:"unref-🔥",normalizedTitle:"unref 🔥",charIndex:3945},{level:3,title:"isRef",slug:"isref",normalizedTitle:"isref",charIndex:4031},{level:3,title:"shallowRef—浅层",slug:"shallowref-浅层",normalizedTitle:"shallowref—浅层",charIndex:4099},{level:3,title:"triggerRef",slug:"triggerref",normalizedTitle:"triggerref",charIndex:4134},{level:3,title:"customRef",slug:"customref",normalizedTitle:"customref",charIndex:4851},{level:3,title:"setup中获取元素的el 🔥",slug:"setup中获取元素的el-🔥",normalizedTitle:"setup中获取元素的el 🔥",charIndex:5849},{level:2,title:"reactive Api 🔥",slug:"reactive-api-🔥",normalizedTitle:"reactive api 🔥",charIndex:6758},{level:3,title:"reactive 🔥",slug:"reactive-🔥",normalizedTitle:"reactive 🔥",charIndex:6778},{level:3,title:"toRefs、toRef—解构reactive 🔥",slug:"torefs、toref-解构reactive-🔥",normalizedTitle:"torefs、toref—解构reactive 🔥",charIndex:7173},{level:3,title:"shallowReactive—浅层",slug:"shallowreactive-浅层",normalizedTitle:"shallowreactive—浅层",charIndex:8255},{level:2,title:"readonly 🔥",slug:"readonly-🔥",normalizedTitle:"readonly 🔥",charIndex:8341},{level:3,title:"readonly 🔥",slug:"readonly-🔥-2",normalizedTitle:"readonly 🔥",charIndex:8341},{level:3,title:"shallowReadonly",slug:"shallowreadonly",normalizedTitle:"shallowreadonly",charIndex:9434},{level:2,title:"reactive、readonly 其他 API",slug:"reactive、readonly-其他-api",normalizedTitle:"reactive、readonly 其他 api",charIndex:9516},{level:3,title:"isProxy",slug:"isproxy",normalizedTitle:"isproxy",charIndex:9545},{level:3,title:"isReactive",slug:"isreactive",normalizedTitle:"isreactive",charIndex:9601},{level:3,title:"isReadonly",slug:"isreadonly",normalizedTitle:"isreadonly",charIndex:9849},{level:3,title:"toRaw—谨慎使用",slug:"toraw-谨慎使用",normalizedTitle:"toraw—谨慎使用",charIndex:9894}],headersStr:"Options Api 的弊端 setup 函数 🔥 介绍 参数 返回值 示例 ref Api 🔥 ref 🔥 unref 🔥 isRef shallowRef—浅层 triggerRef customRef setup中获取元素的el 🔥 reactive Api 🔥 reactive 🔥 toRefs、toRef—解构reactive 🔥 shallowReactive—浅层 readonly 🔥 readonly 🔥 shallowReadonly reactive、readonly 其他 API isProxy isReactive isReadonly toRaw—谨慎使用",content:'# 响应式Api\n\n\n# Options Api 的弊端\n\n在Vue2中，我们编写组件的方式是Options API:\n\n * Options API的一大特点就是在对应的属性中编写对应的功能模块;\n\n * 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子\n\n但是这种代码有一个很大的弊端:\n\n * 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中，如data、method 等;\n * 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散;\n * 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的(阅读组件的其他人);\n\n改进：将同一个逻辑关注点相关的代码收集在一起会更好。\n\n\n# setup 函数 🔥\n\n\n# 介绍\n\n * setup 函数就是 composition api 编写的地方！\n * 它也是组件中的另一个选项（option），只不过可以替代之前的 options\n * setup 是围绕 beforeCreate 和 created 生命周期钩子运行的。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写\n\n\n# 参数\n\nsetup(props, context)\n\nprops就是父组件传递过来的属性会被放到props对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取:\n\n * 对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义；或者definedProps中\n * 并且在template中依然是可以正常去使用props中的属性，比如message;\n * 如果我们在setup函数中想要使用props，那么不可以通过 this 去获取(后面我会讲到为什么);\n * 因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可;\n\ncontext，我们也称之为是一个SetupContext，它里面包含三个属性\n\n * attrs：所有的非prop的attribute;\n * slots：父组件传递过来的插槽(这个在以渲染函数返回时会有作用，后面会讲到);\n * emit：当我们组件内部需要发出事件时会用到emit(因为我们不能访问this，所以不可以通过 this.$emit发出事件)\n\n官方关于this有这样一段描述\n\n * this并没有指向当前组件实例\n * setup调用发生在data、computed、methods等被解析之前\n * 所以他们无法在setup中获取！\n\n\n# 返回值\n\nsetup既然是一个函数，那么它也可以有返回值，它的返回值用来做什么呢?\n\n * setup的返回值可以在模板template中被使用;\n\n * 也就是说我们可以通过setup的返回值来替代data选项;\n\n * 甚至是我们可以返回一个执行函数来代替在methods中定义的方法\n\n\n# 示例\n\n<template>\n  <div>\n    Home Page\n    <h2>{{message}}</h2>\n\n    <h2>{{title}}</h2>\n    <h2>当前计数: {{counter}}</h2>\n    <button @click="increment">+1</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      message: {\n        type: String,\n        required: true\n      }\n    },\n    data() {\n      return {\n        counter: 100\n      }\n    },\n    setup(props, {attrs, slots, emit}) {\n      console.log(props.message);\n      console.log(attrs.id, attrs.class);\n      console.log(slots);\n      console.log(emit);\n\n      return {\n        title: "Hello Home",\n        counter: 100\n      }\n    },\n    methods: {\n      btnClick() {\n        this.$emit("")\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# ref Api 🔥\n\n\n# ref 🔥\n\n[reference] 的意思\n\n * ref 会返回一个可变的响应式对象，该对象作为一个 响应式的引用 维护着它内部的值，这就是ref名称的来源;\n * 它内部的值是在ref的 value 属性中被维护的。值可以是所有数据类型！如基本数据类型、数组、对象等\n\nconst message = ref(\'hello\')\n\n\n1\n\n\n注意：\n\n * 在模板中引入ref的值时，Vue会自动帮助我们进行解包操作，所以我们并不需要在模板中通过 ref.value 的方式来使用\n * 但是在 setup 函数内部，它依然是一个 ref引用， 所以对其进行操作时，我们依然需要使用ref.value的方式\n\nref 解包注意：\n\n * 模板中的解包是浅层的解包，如果我们的代码是下面的方式\n\n * 如果我们将ref放到一个reactive的属性当中，那么在模板中使用时，它会自动解包\n   \n   <template>\n     <div>\n       Home Page\n       <h2>{{message}}</h2>\n       \x3c!-- 当我们在template模板中使用ref对象, 它会自动进行解包 --\x3e\n       <h2>当前计数: {{counter}}</h2>\n       \x3c!-- ref的解包只能是一个浅层解包(info是一个普通的JavaScript对象)，此时就必须使用.value!!! --\x3e\n       <h2>当前计数: {{info.counter.value}}</h2>\n       \x3c!-- 当如果最外层包裹的是一个reactive可响应式对象, 那么内容的ref可以解包 --\x3e\n       <h2>当前计数: {{reactiveInfo.counter}}</h2>\n       <button @click="increment">+1</button>\n     </div>\n   </template>\n   \n   <script>\n     import { ref, reactive } from \'vue\';\n   \n     export default {\n       props: {\n         message: {\n           type: String,\n           required: true\n         }\n       },\n       setup() {\n         let counter = ref(100);\n   \n         const info = {\n           counter\n         }\n   \n         const reactiveInfo = reactive({\n           counter\n         })\n   \n         // 局部函数\n         const increment = () => {\n           counter.value++;\n           console.log(counter.value);\n         }\n   \n         return {\n           counter,\n           info,\n           reactiveInfo,\n           increment\n         }\n       }\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   \n\n\n# unref 🔥\n\n * 获取一个ref引用中的value，那么也可以通过unref方法。如果参数是一个 ref，则返回内部值，否则返回参数本身\n\n * 这是 val = isRef(val) ? val.value : val 的语法糖函数\n\n\n# isRef\n\n * 判断值是否是一个ref对象\n\n\n# shallowRef—浅层\n\n * 创建一个浅层的ref对象\n\n\n# triggerRef\n\n * 手动触发和 shallowRef 相关联的副作用\n   \n   <template>\n     <div>\n       <h2>{{info}}</h2>\n       <button @click="changeInfo">修改Info</button>\n     </div>\n   </template>\n   \n   <script>\n     import { ref, shallowRef, triggerRef } from \'vue\';\n   \n     export default {\n       setup() {\n         const info = shallowRef({name: "why"})\n   \n         const changeInfo = () => {\n           info.value.name = "james";\n           triggerRef(info);\n         }\n   \n         return {\n           info,\n           changeInfo\n         }\n       }\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n\n# customRef\n\n创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制:\n\n * 它需要一个工厂函数，该函数接受 track 和 trigger 函数作为参数;\n * 并且应该返回一个带有 get 和 set 的对象;\n\n示例：对双向绑定的属性进行**debounce(节流)**的操作\n\nApp.vue\n\n<template>\n  <div>\n    <input v-model="message"/>\n    <h2>{{message}}</h2>\n  </div>\n</template>\n\n<script>\n  import debounceRef from \'./hook/useDebounceRef\';\n\n  export default {\n    setup() {\n      const message = debounceRef("Hello World");\n\n      return {\n        message\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nuseDebounceRef.js\n\nimport { customRef } from \'vue\';\n\n// 自定义ref\nexport default function(value, delay = 300) {\n  let timer = null;\n  return customRef((track, trigger) => {\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        clearTimeout(timer);\n        timer = setTimeout(() => {\n          value = newValue;\n          trigger();\n        }, delay);\n      }\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# setup中获取元素的el 🔥\n\n在options api中获取元素的el，只需要在模板中声明ref=\'tableRef\'，调用时执行this.$refs.tableRef即可\n\n但是在setup中不能这样使用了！\n\n<template>\n  <div>\n    <h2 ref="title">哈哈哈</h2>\n\n    <h2 v-for="item of 3" :key="item" :ref="setH2Refs">{{ item }}</h2>\n  </div>\n</template>\n\n<script>\nimport { ref, watchEffect, onBeforeUpdate } from \'vue\'\n\nexport default {\n  setup() {\n    // 单个 ref\n    const title = ref(null)\n\n    watchEffect(\n      () => {\n        console.log(title.value)\n        console.log(h2Refs)\n      },\n      {\n        flush: \'post\',\n      }\n    )\n\n    // v-for 中 ref\n    let h2Refs = []\n    // DOM 被更新之前被调用\n    onBeforeUpdate(() => {\n      h2Refs = []\n    })\n    const setH2Refs = (el) => {\n      if (el) h2Refs.push(el)\n    }\n\n    return {\n      title,\n      setH2Refs,\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# reactive Api 🔥\n\n\n# reactive 🔥\n\n如果想为在setup中定义的数据提供响应式的特性，那么我们可以使用reactive的函数\n\n * 这是因为当我们使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集;\n * 当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作(比如更新界面);\n * 事实上，我们编写的data选项，也是在内部交给了reactive函数将其编程响应式对象的;\n\nconst state = reactive({\n    name: \'conanan\',\n    counter: 100,\n})\n\n\n1\n2\n3\n4\n\n\n注意：reactive API对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型。如果我们传入一个基本数据类型(String、Number、Boolean)会报一个警告。可以使用上面介绍的 Ref api\n\n\n# toRefs、toRef—解构reactive 🔥\n\n如果我们使用ES6的解构语法，对reactive返回的对象进行解构获取值，那么之后\n\n * 无论是修改结构后的变量\n * 还是修改reactive返回的state对象，\n\n数据都不再是响应式的。那么有没有办法让我们解构出来的属性是响应式的呢？\n\n * Vue为我们提供了一个toRefs的函数，可以将reactive返回的对象中的属性都转成ref\n\n * 那么我们再次进行结构出来的 name 和 age 本身都是 ref的\n   \n   // 返回2个ref对象！\n   const { name, age } = toRefs(state);\n   \n   \n   1\n   2\n   \n\n * 这种做法相当于已经在state.name和ref.value之间建立了链接，任何一个修改都会引起另外一个变化\n\n<template>\n  <div>\n    <h2>{{name}}-{{age}}</h2>\n    <button @click="changeAge">修改age</button>\n  </div>\n</template>\n\n<script>\n  import { reactive, toRefs, toRef } from \'vue\';\n\n  export default {\n    setup() {\n      const info = reactive({name: "why", age: 18});\n      // 1.toRefs: 将reactive对象中的所有属性都转成ref, 建立链接\n      // let { name, age } = toRefs(info);\n      // 2.toRef: 对其中一个属性进行转换ref, 建立链接\n      let { name } = info;\n      let age = toRef(info, "age");\n\n      const changeAge = () => {\n        age.value++;\n      }\n\n      return {\n        name,\n        age,\n        changeAge\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# shallowReactive—浅层\n\n * 创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换（深层还是原生对象）。\n\n\n# readonly 🔥\n\n\n# readonly 🔥\n\n我们通过reactive或者ref可以获取到一个响应式的对象，但是某些情况下，我们传入给其他地方(组件)的这个响应式对象希望在另外一个地方(组件)被使用，但是不能被修改\n\n * Vue3为我们提供了readonly的方法;\n\n * readonly会返回原生对象的只读代理（也就是它依然是一个Proxy，这是一个proxy的set方法被劫持，并且不能对其进行修改）；\n\n在开发中常见的readonly方法会传入三个类型的参数：\n\n * 普通对象\n * reactive返回的对象。传递给组件时\n * ref的对象。传递给组件时\n\n<template>\n  <div>\n    <button @click="updateState">修改状态</button>\n  </div>\n</template>\n\n<script>\n  import { reactive, ref, readonly } from \'vue\';\n\n  export default {\n    setup() {\n      // 1.普通对象\n      const info1 = {name: "why"};\n      const readonlyInfo1 = readonly(info1);\n\n      // 2.响应式的对象reactive\n      const info2 = reactive({\n        name: "why"\n      })\n      const readonlyInfo2 = readonly(info2);\n\n      // 3.响应式的对象ref\n      const info3 = ref("why");\n      const readonlyInfo3 = readonly(info3);\n\n      const updateState = () => {\n        // readonlyInfo3.value = "coderwhy"\n        info3.value = "coderwhy";\n      }\n\n      return {\n        updateState,\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# shallowReadonly\n\n * 创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）\n\n\n# reactive、readonly 其他 API\n\n\n# isProxy\n\n * 检查对象是否是由 reactive 或 readonly 创建的 Proxy。\n\n\n# isReactive\n\n * 检查对象是否是由 reactive创建的响应式代理:\n\n * 如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true;\n   \n   const info1 = readonly({name: \'conanan\'}) // false\n   const info2 = readonly(reactive({name: \'conanan\'})) // true\n   \n   \n   1\n   2\n   \n\n\n# isReadonly\n\n * 检查对象是否是由 readonly 创建的只读代理\n\n\n# toRaw—谨慎使用\n\n * 返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）',normalizedContent:'# 响应式api\n\n\n# options api 的弊端\n\n在vue2中，我们编写组件的方式是options api:\n\n * options api的一大特点就是在对应的属性中编写对应的功能模块;\n\n * 比如data定义数据、methods中定义方法、computed中定义计算属性、watch中监听属性改变，也包括生命 周期钩子\n\n但是这种代码有一个很大的弊端:\n\n * 当我们实现某一个功能时，这个功能对应的代码逻辑会被拆分到各个属性中，如data、method 等;\n * 当我们组件变得更大、更复杂时，逻辑关注点的列表就会增长，那么同一个功能的逻辑就会被拆分的很分散;\n * 尤其对于那些一开始没有编写这些组件的人来说，这个组件的代码是难以阅读和理解的(阅读组件的其他人);\n\n改进：将同一个逻辑关注点相关的代码收集在一起会更好。\n\n\n# setup 函数 🔥\n\n\n# 介绍\n\n * setup 函数就是 composition api 编写的地方！\n * 它也是组件中的另一个选项（option），只不过可以替代之前的 options\n * setup 是围绕 beforecreate 和 created 生命周期钩子运行的。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写\n\n\n# 参数\n\nsetup(props, context)\n\nprops就是父组件传递过来的属性会被放到props对象中，我们在setup中如果需要使用，那么就可以直接通过props参数获取:\n\n * 对于定义props的类型，我们还是和之前的规则是一样的，在props选项中定义；或者definedprops中\n * 并且在template中依然是可以正常去使用props中的属性，比如message;\n * 如果我们在setup函数中想要使用props，那么不可以通过 this 去获取(后面我会讲到为什么);\n * 因为props有直接作为参数传递到setup函数中，所以我们可以直接通过参数来使用即可;\n\ncontext，我们也称之为是一个setupcontext，它里面包含三个属性\n\n * attrs：所有的非prop的attribute;\n * slots：父组件传递过来的插槽(这个在以渲染函数返回时会有作用，后面会讲到);\n * emit：当我们组件内部需要发出事件时会用到emit(因为我们不能访问this，所以不可以通过 this.$emit发出事件)\n\n官方关于this有这样一段描述\n\n * this并没有指向当前组件实例\n * setup调用发生在data、computed、methods等被解析之前\n * 所以他们无法在setup中获取！\n\n\n# 返回值\n\nsetup既然是一个函数，那么它也可以有返回值，它的返回值用来做什么呢?\n\n * setup的返回值可以在模板template中被使用;\n\n * 也就是说我们可以通过setup的返回值来替代data选项;\n\n * 甚至是我们可以返回一个执行函数来代替在methods中定义的方法\n\n\n# 示例\n\n<template>\n  <div>\n    home page\n    <h2>{{message}}</h2>\n\n    <h2>{{title}}</h2>\n    <h2>当前计数: {{counter}}</h2>\n    <button @click="increment">+1</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    props: {\n      message: {\n        type: string,\n        required: true\n      }\n    },\n    data() {\n      return {\n        counter: 100\n      }\n    },\n    setup(props, {attrs, slots, emit}) {\n      console.log(props.message);\n      console.log(attrs.id, attrs.class);\n      console.log(slots);\n      console.log(emit);\n\n      return {\n        title: "hello home",\n        counter: 100\n      }\n    },\n    methods: {\n      btnclick() {\n        this.$emit("")\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# ref api 🔥\n\n\n# ref 🔥\n\n[reference] 的意思\n\n * ref 会返回一个可变的响应式对象，该对象作为一个 响应式的引用 维护着它内部的值，这就是ref名称的来源;\n * 它内部的值是在ref的 value 属性中被维护的。值可以是所有数据类型！如基本数据类型、数组、对象等\n\nconst message = ref(\'hello\')\n\n\n1\n\n\n注意：\n\n * 在模板中引入ref的值时，vue会自动帮助我们进行解包操作，所以我们并不需要在模板中通过 ref.value 的方式来使用\n * 但是在 setup 函数内部，它依然是一个 ref引用， 所以对其进行操作时，我们依然需要使用ref.value的方式\n\nref 解包注意：\n\n * 模板中的解包是浅层的解包，如果我们的代码是下面的方式\n\n * 如果我们将ref放到一个reactive的属性当中，那么在模板中使用时，它会自动解包\n   \n   <template>\n     <div>\n       home page\n       <h2>{{message}}</h2>\n       \x3c!-- 当我们在template模板中使用ref对象, 它会自动进行解包 --\x3e\n       <h2>当前计数: {{counter}}</h2>\n       \x3c!-- ref的解包只能是一个浅层解包(info是一个普通的javascript对象)，此时就必须使用.value!!! --\x3e\n       <h2>当前计数: {{info.counter.value}}</h2>\n       \x3c!-- 当如果最外层包裹的是一个reactive可响应式对象, 那么内容的ref可以解包 --\x3e\n       <h2>当前计数: {{reactiveinfo.counter}}</h2>\n       <button @click="increment">+1</button>\n     </div>\n   </template>\n   \n   <script>\n     import { ref, reactive } from \'vue\';\n   \n     export default {\n       props: {\n         message: {\n           type: string,\n           required: true\n         }\n       },\n       setup() {\n         let counter = ref(100);\n   \n         const info = {\n           counter\n         }\n   \n         const reactiveinfo = reactive({\n           counter\n         })\n   \n         // 局部函数\n         const increment = () => {\n           counter.value++;\n           console.log(counter.value);\n         }\n   \n         return {\n           counter,\n           info,\n           reactiveinfo,\n           increment\n         }\n       }\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   27\n   28\n   29\n   30\n   31\n   32\n   33\n   34\n   35\n   36\n   37\n   38\n   39\n   40\n   41\n   42\n   43\n   44\n   45\n   46\n   47\n   48\n   49\n   50\n   \n\n\n# unref 🔥\n\n * 获取一个ref引用中的value，那么也可以通过unref方法。如果参数是一个 ref，则返回内部值，否则返回参数本身\n\n * 这是 val = isref(val) ? val.value : val 的语法糖函数\n\n\n# isref\n\n * 判断值是否是一个ref对象\n\n\n# shallowref—浅层\n\n * 创建一个浅层的ref对象\n\n\n# triggerref\n\n * 手动触发和 shallowref 相关联的副作用\n   \n   <template>\n     <div>\n       <h2>{{info}}</h2>\n       <button @click="changeinfo">修改info</button>\n     </div>\n   </template>\n   \n   <script>\n     import { ref, shallowref, triggerref } from \'vue\';\n   \n     export default {\n       setup() {\n         const info = shallowref({name: "why"})\n   \n         const changeinfo = () => {\n           info.value.name = "james";\n           triggerref(info);\n         }\n   \n         return {\n           info,\n           changeinfo\n         }\n       }\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   14\n   15\n   16\n   17\n   18\n   19\n   20\n   21\n   22\n   23\n   24\n   25\n   26\n   \n\n\n# customref\n\n创建一个自定义的ref，并对其依赖项跟踪和更新触发进行显示控制:\n\n * 它需要一个工厂函数，该函数接受 track 和 trigger 函数作为参数;\n * 并且应该返回一个带有 get 和 set 的对象;\n\n示例：对双向绑定的属性进行**debounce(节流)**的操作\n\napp.vue\n\n<template>\n  <div>\n    <input v-model="message"/>\n    <h2>{{message}}</h2>\n  </div>\n</template>\n\n<script>\n  import debounceref from \'./hook/usedebounceref\';\n\n  export default {\n    setup() {\n      const message = debounceref("hello world");\n\n      return {\n        message\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nusedebounceref.js\n\nimport { customref } from \'vue\';\n\n// 自定义ref\nexport default function(value, delay = 300) {\n  let timer = null;\n  return customref((track, trigger) => {\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newvalue) {\n        cleartimeout(timer);\n        timer = settimeout(() => {\n          value = newvalue;\n          trigger();\n        }, delay);\n      }\n    }\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# setup中获取元素的el 🔥\n\n在options api中获取元素的el，只需要在模板中声明ref=\'tableref\'，调用时执行this.$refs.tableref即可\n\n但是在setup中不能这样使用了！\n\n<template>\n  <div>\n    <h2 ref="title">哈哈哈</h2>\n\n    <h2 v-for="item of 3" :key="item" :ref="seth2refs">{{ item }}</h2>\n  </div>\n</template>\n\n<script>\nimport { ref, watcheffect, onbeforeupdate } from \'vue\'\n\nexport default {\n  setup() {\n    // 单个 ref\n    const title = ref(null)\n\n    watcheffect(\n      () => {\n        console.log(title.value)\n        console.log(h2refs)\n      },\n      {\n        flush: \'post\',\n      }\n    )\n\n    // v-for 中 ref\n    let h2refs = []\n    // dom 被更新之前被调用\n    onbeforeupdate(() => {\n      h2refs = []\n    })\n    const seth2refs = (el) => {\n      if (el) h2refs.push(el)\n    }\n\n    return {\n      title,\n      seth2refs,\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n\n\n\n# reactive api 🔥\n\n\n# reactive 🔥\n\n如果想为在setup中定义的数据提供响应式的特性，那么我们可以使用reactive的函数\n\n * 这是因为当我们使用reactive函数处理我们的数据之后，数据再次被使用时就会进行依赖收集;\n * 当数据发生改变时，所有收集到的依赖都是进行对应的响应式操作(比如更新界面);\n * 事实上，我们编写的data选项，也是在内部交给了reactive函数将其编程响应式对象的;\n\nconst state = reactive({\n    name: \'conanan\',\n    counter: 100,\n})\n\n\n1\n2\n3\n4\n\n\n注意：reactive api对传入的类型是有限制的，它要求我们必须传入的是一个对象或者数组类型。如果我们传入一个基本数据类型(string、number、boolean)会报一个警告。可以使用上面介绍的 ref api\n\n\n# torefs、toref—解构reactive 🔥\n\n如果我们使用es6的解构语法，对reactive返回的对象进行解构获取值，那么之后\n\n * 无论是修改结构后的变量\n * 还是修改reactive返回的state对象，\n\n数据都不再是响应式的。那么有没有办法让我们解构出来的属性是响应式的呢？\n\n * vue为我们提供了一个torefs的函数，可以将reactive返回的对象中的属性都转成ref\n\n * 那么我们再次进行结构出来的 name 和 age 本身都是 ref的\n   \n   // 返回2个ref对象！\n   const { name, age } = torefs(state);\n   \n   \n   1\n   2\n   \n\n * 这种做法相当于已经在state.name和ref.value之间建立了链接，任何一个修改都会引起另外一个变化\n\n<template>\n  <div>\n    <h2>{{name}}-{{age}}</h2>\n    <button @click="changeage">修改age</button>\n  </div>\n</template>\n\n<script>\n  import { reactive, torefs, toref } from \'vue\';\n\n  export default {\n    setup() {\n      const info = reactive({name: "why", age: 18});\n      // 1.torefs: 将reactive对象中的所有属性都转成ref, 建立链接\n      // let { name, age } = torefs(info);\n      // 2.toref: 对其中一个属性进行转换ref, 建立链接\n      let { name } = info;\n      let age = toref(info, "age");\n\n      const changeage = () => {\n        age.value++;\n      }\n\n      return {\n        name,\n        age,\n        changeage\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# shallowreactive—浅层\n\n * 创建一个响应式代理，它跟踪其自身 property 的响应性，但不执行嵌套对象的深层响应式转换（深层还是原生对象）。\n\n\n# readonly 🔥\n\n\n# readonly 🔥\n\n我们通过reactive或者ref可以获取到一个响应式的对象，但是某些情况下，我们传入给其他地方(组件)的这个响应式对象希望在另外一个地方(组件)被使用，但是不能被修改\n\n * vue3为我们提供了readonly的方法;\n\n * readonly会返回原生对象的只读代理（也就是它依然是一个proxy，这是一个proxy的set方法被劫持，并且不能对其进行修改）；\n\n在开发中常见的readonly方法会传入三个类型的参数：\n\n * 普通对象\n * reactive返回的对象。传递给组件时\n * ref的对象。传递给组件时\n\n<template>\n  <div>\n    <button @click="updatestate">修改状态</button>\n  </div>\n</template>\n\n<script>\n  import { reactive, ref, readonly } from \'vue\';\n\n  export default {\n    setup() {\n      // 1.普通对象\n      const info1 = {name: "why"};\n      const readonlyinfo1 = readonly(info1);\n\n      // 2.响应式的对象reactive\n      const info2 = reactive({\n        name: "why"\n      })\n      const readonlyinfo2 = readonly(info2);\n\n      // 3.响应式的对象ref\n      const info3 = ref("why");\n      const readonlyinfo3 = readonly(info3);\n\n      const updatestate = () => {\n        // readonlyinfo3.value = "coderwhy"\n        info3.value = "coderwhy";\n      }\n\n      return {\n        updatestate,\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# shallowreadonly\n\n * 创建一个 proxy，使其自身的 property 为只读，但不执行嵌套对象的深度只读转换（深层还是可读、可写的）\n\n\n# reactive、readonly 其他 api\n\n\n# isproxy\n\n * 检查对象是否是由 reactive 或 readonly 创建的 proxy。\n\n\n# isreactive\n\n * 检查对象是否是由 reactive创建的响应式代理:\n\n * 如果该代理是 readonly 建的，但包裹了由 reactive 创建的另一个代理，它也会返回 true;\n   \n   const info1 = readonly({name: \'conanan\'}) // false\n   const info2 = readonly(reactive({name: \'conanan\'})) // true\n   \n   \n   1\n   2\n   \n\n\n# isreadonly\n\n * 检查对象是否是由 readonly 创建的只读代理\n\n\n# toraw—谨慎使用\n\n * 返回 reactive 或 readonly 代理的原始对象（不建议保留对原始对象的持久引用。请谨慎使用）',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"计算属性&侦听器",frontmatter:{title:"计算属性&侦听器",date:"2022-02-04T01:11:54.000Z",permalink:"/pages/4f74c8/",categories:["x","Composition Api"],tags:[null]},regularPath:"/1403.Vue3.x/400.Composition%20Api/403.%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7&%E4%BE%A6%E5%90%AC%E5%99%A8.html",relativePath:"1403.Vue3.x/400.Composition Api/403.计算属性&侦听器.md",key:"v-19d39f68",path:"/pages/4f74c8/",headers:[{level:2,title:"computed 🔥",slug:"computed-🔥",normalizedTitle:"computed 🔥",charIndex:15},{level:2,title:"watchEffect—立即&自动收集响应式数据的依赖 🔥",slug:"watcheffect-立即-自动收集响应式数据的依赖-🔥",normalizedTitle:"watcheffect—立即&amp;自动收集响应式数据的依赖 🔥",charIndex:null},{level:3,title:"介绍 🔥",slug:"介绍-🔥",normalizedTitle:"介绍 🔥",charIndex:1284},{level:3,title:"停止侦听 🔥",slug:"停止侦听-🔥",normalizedTitle:"停止侦听 🔥",charIndex:2133},{level:3,title:"清除副作用—onInvalidate 🔥",slug:"清除副作用-oninvalidate-🔥",normalizedTitle:"清除副作用—oninvalidate 🔥",charIndex:3043},{level:3,title:"执行时机—flush 🔥",slug:"执行时机-flush-🔥",normalizedTitle:"执行时机—flush 🔥",charIndex:4516},{level:3,title:"watchPostEffect",slug:"watchposteffect",normalizedTitle:"watchposteffect",charIndex:4779},{level:3,title:"watchSyncEffect",slug:"watchsynceffect",normalizedTitle:"watchsynceffect",charIndex:4795},{level:2,title:"watch—惰性&手动指定侦听的数据源",slug:"watch-惰性-手动指定侦听的数据源",normalizedTitle:"watch—惰性&amp;手动指定侦听的数据源",charIndex:null},{level:3,title:"介绍 🔥",slug:"介绍-🔥-2",normalizedTitle:"介绍 🔥",charIndex:1284},{level:3,title:"侦听单个数据源 🔥",slug:"侦听单个数据源-🔥",normalizedTitle:"侦听单个数据源 🔥",charIndex:5827},{level:3,title:"侦听多个数据源 🔥",slug:"侦听多个数据源-🔥",normalizedTitle:"侦听多个数据源 🔥",charIndex:7422},{level:3,title:"源码—查看侦听类型 🔥",slug:"源码-查看侦听类型-🔥",normalizedTitle:"源码—查看侦听类型 🔥",charIndex:8196},{level:3,title:"深层的侦听—deep 🔥",slug:"深层的侦听-deep-🔥",normalizedTitle:"深层的侦听—deep 🔥",charIndex:10001},{level:3,title:"立即执行—immediate 🔥",slug:"立即执行-immediate-🔥",normalizedTitle:"立即执行—immediate 🔥",charIndex:10163}],headersStr:"computed 🔥 watchEffect—立即&自动收集响应式数据的依赖 🔥 介绍 🔥 停止侦听 🔥 清除副作用—onInvalidate 🔥 执行时机—flush 🔥 watchPostEffect watchSyncEffect watch—惰性&手动指定侦听的数据源 介绍 🔥 侦听单个数据源 🔥 侦听多个数据源 🔥 源码—查看侦听类型 🔥 深层的侦听—deep 🔥 立即执行—immediate 🔥",content:'# 计算属性&侦听器\n\n\n# computed 🔥\n\n * 在Composition API中，我们可以在 setup 函数中使用 computed 方法来编写一个计算属性\n   * 接收一个getter函数，并为 getter 函数返回的值，返回一个不变的 ref 对象\n   * 接收一个具有 get 和 set 的对象，返回一个可变的(可读写)ref 对象\n\n<template>\n  <div>\n    <h2>{{ fullName }}</h2>\n    <button @click="changeName">修改firstName</button>\n  </div>\n</template>\n\n<script>\nimport { ref, computed } from \'vue\'\n\nexport default {\n  setup() {\n    const firstName = ref(\'Kobe\')\n    const lastName = ref(\'Bryant\')\n\n    // 1.用法一: 传入一个getter函数\n    // computed的返回值是一个ref对象\n    // const fullName = computed(() => firstName.value + \' \' + lastName.value)\n    // const fullName2 = computed(() => firstName.value + \' @ \' + lastName.value)\n\n    // 2.用法二: 传入一个对象, 对象包含getter/setter\n    const fullName = computed({\n      get: () => firstName.value + \' \' + lastName.value,\n      set(newValue) {\n        const names = newValue.split(\' \')\n        firstName.value = names[0]\n        lastName.value = names[1]\n      },\n    })\n\n    const changeName = () => {\n      // firstName.value = \'James\'\n      fullName.value = \'coder why\'\n    }\n\n    return {\n      fullName,\n      changeName,\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# watchEffect—立即&自动收集响应式数据的依赖 🔥\n\n\n# 介绍 🔥\n\n侦听data或者props的数据变化\n\n * watchEffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖\n * 只有收集的依赖发生变化时，watchEffect传入的函数才会再次执行\n\n<template>\n  <div>\n    <h2>{{name}}-{{age}}</h2>\n    <button @click="changeName">修改name</button>\n    <button @click="changeAge">修改age</button>\n  </div>\n</template>\n\n<script>\n  import { ref, watchEffect } from \'vue\';\n\n  export default {\n    setup() {\n      // watchEffect: 自动收集响应式的依赖\n      const name = ref("why");\n      const age = ref(18);\n\n      const changeName = () => name.value = "kobe"\n      const changeAge = () => age.value++\n\n      watchEffect(() => {\n        console.log("name:", name.value, "age:", age.value);\n      });\n\n      return {\n        name,\n        age,\n        changeName,\n        changeAge\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 停止侦听 🔥\n\n如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watchEffect的返回值函数，调用该函数即可\n\n<template>\n  <div>\n    <h2>{{name}}-{{age}}</h2>\n    <button @click="changeName">修改name</button>\n    <button @click="changeAge">修改age</button>\n  </div>\n</template>\n\n<script>\n  import { ref, watchEffect } from \'vue\';\n\n  export default {\n    setup() {\n      // watchEffect: 自动收集响应式的依赖\n      const name = ref("why");\n      const age = ref(18);\n\n      const stop = watchEffect(() => {\n        console.log("name:", name.value, "age:", age.value);\n      });\n\n      const changeName = () => name.value = "kobe"\n      const changeAge = () => {\n        age.value++;\n        if (age.value > 25) {\n          stop();\n        }\n      }\n\n      return {\n        name,\n        age,\n        changeName,\n        changeAge\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 清除副作用—onInvalidate 🔥\n\n什么是清除副作用呢？\n\n * 比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器，或者侦听器侦听函数被再次执行了。\n * 那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用;\n\n在我们给watchEffect传入的函数被回调时，其实可以获取到一个参数onInvalidate，这个失效回调会被触发：\n\n * 副作用即将重新执行时（每次依赖的数据变化时）\n * 侦听器被停止 (如果在 setup() 或生命周期钩子函数中使用了 watchEffect，则在组件卸载时)\n\n<template>\n  <div>\n    <h2>{{name}}-{{age}}</h2>\n    <button @click="changeName">修改name</button>\n    <button @click="changeAge">修改age</button>\n  </div>\n</template>\n\n<script>\n  import { ref, watchEffect } from \'vue\';\n\n  export default {\n    setup() {\n      // watchEffect: 自动收集响应式的依赖\n      const name = ref("why");\n      const age = ref(18);\n\n      const stop = watchEffect((onInvalidate) => {\n        const timer = setTimeout(() => {\n          console.log("网络请求成功~");\n        }, 2000)\n\n        // 根据name和age两个变量发送网络请求\n        onInvalidate(() => {\n          // 在这个函数中清除额外的副作用\n          // request.cancel()\n          clearTimeout(timer);\n          console.log("onInvalidate");\n        })\n        console.log("name:", name.value, "age:", age.value);\n      });\n\n      const changeName = () => name.value = "kobe"\n      const changeAge = () => {\n        age.value++;\n        if (age.value > 25) {\n          stop();\n        }\n      }\n\n      return {\n        name,\n        age,\n        changeName,\n        changeAge\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 执行时机—flush 🔥\n\n如果需要在组件更新（例如：当与模板引用一起）后重新运行侦听器副作用，我们可以传递带有 flush 选项的附加 options 对象 (默认为 \'pre\')：\n\nflush?: \'pre\' | \'post\' | \'sync\' // 默认：\'pre\'\n\n\n1\n\n\n * pre：在组件更新后触发，这样你就可以访问更新的 DOM。这也将推迟副作用的初始运行，直到组件的首次渲染完成\n\n * post：默认\n\n * sync：强制效果始终同步触发。然而，这是低效的，应该很少需要。\n\n3.2+，推荐使用 watchPostEffect、watchSyncEffect\n\n<template>\n  <div>\n    <h2 ref="title">哈哈哈</h2>\n  </div>\n</template>\n\n<script>\nimport { ref, watchEffect } from \'vue\'\n\nexport default {\n  setup() {\n    // 单个 ref\n    const title = ref(null)\n\n    watchEffect(\n      () => {\n        console.log(title.value)\n      },\n      {\n        // 当没有该配置，或者为默认值 pre，则上面log打印2次，第一次为null，第二次为el\n        // 这是因为setup函数在执行时就会立即执行传入的副作用函数，这个时候DOM并没有挂载，所以打印为null\n        // 而当DOM挂载时，会给title的ref对象赋值新的值，副作用函数会再次执行，打印出来对应的元素\n        flush: \'post\',\n      }\n    )\n\n    return {\n      title,\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# watchPostEffect\n\n3.2+。watchEffect 的别名，带有 flush: \'post\' 选项。\n\n\n# watchSyncEffect\n\n3.2+。watchEffect 的别名，带有 flush: \'sync\' 选项。\n\n\n# watch—惰性&手动指定侦听的数据源\n\n\n# 介绍 🔥\n\n侦听data或者props的数据变化\n\nwatch的API完全等同于组件watch选项的Property:\n\n * watch需要侦听特定的数据源，并在回调函数中执行副作用;\n * 默认情况下它是惰性的，只有当被侦听的源发生变化时才会执行回调;\n\n与watchEffect的比较，watch允许我们:\n\n * 懒执行副作用(第一次不会直接执行);\n * 更具体的说明当哪些状态发生变化时，触发侦听器的执行;\n * 访问侦听状态变化前后的值;\n\n\n# 侦听单个数据源 🔥\n\nwatch侦听函数的数据源有两种类型:\n\n * 一个getter函数，但是该getter函数必须引用可响应式的对象(比如reactive或者ref);\n * 直接写入一个可响应式的对象，reactive或者ref（比较常用的是ref，reactive类型需要进行某些转换）;\n\n<template>\n  <div>\n    <h2 ref="title">{{ info.name }}</h2>\n    <button @click="changeData">修改数据</button>\n  </div>\n</template>\n\n<script>\nimport { ref, reactive, watch } from \'vue\'\n\nexport default {\n  setup() {\n    const info = reactive({ name: \'why\', age: 18 })\n\n    // 1.侦听watch时,传入一个getter函数\n    watch(\n      () => info.name,\n      (newValue, oldValue) => {\n        console.log(\'newValue:\', newValue, \'oldValue:\', oldValue)\n      }\n    )\n\n    // 2.传入一个可响应式对象: reactive对象\n    // 2.1 情况一: reactive对象获取到的newValue和oldValue本身都是reactive对象。所以new、old值为reactive，且相同！\n    // watch(info, (newValue, oldValue) => {\n    //   console.log("newValue:", newValue, "oldValue:", oldValue);\n    // })\n    // 2.2 情况二：如果希望newValue和oldValue是一个普通的对象，需解构！！！\n    watch(\n      () => {\n        return { ...info }\n      },\n      (newValue, oldValue) => {\n        console.log(\'newValue:\', newValue, \'oldValue:\', oldValue)\n      }\n    )\n      \n    // 3.传入一个可响应式对象: ref对象\n    // ref对象获取newValue和oldValue是value值的本身，所以new、old不同\n    // const name = ref("why");\n    // watch(name, (newValue, oldValue) => {\n    //   console.log("newValue:", newValue, "oldValue:", oldValue);\n    // })\n\n    const changeData = () => {\n      info.name = \'kobe\'\n    }\n\n    return {\n      changeData,\n      info,\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 侦听多个数据源 🔥\n\n就是数组包含侦听单个数据源的方式！！！详见单个数据源！\n\n<template>\n  <div>\n    <h2 ref="title">{{info.name}}</h2>\n    <button @click="changeData">修改数据</button>\n  </div>\n</template>\n\n<script>\n  import { ref, reactive, watch } from \'vue\';\n\n  export default {\n    setup() {\n      // 1.定义可响应式的对象\n      const info = reactive({name: "why", age: 18});\n      const name = ref("why");\n\n      // 2.侦听器watch\n      watch([() => ({...info}), name], ([newInfo, newName], [oldInfo, oldName]) => {\n        console.log(newInfo, newName, oldInfo, oldName);\n      })\n\n      const changeData = () => {\n        info.name = "kobe";\n      }\n\n      return {\n        changeData,\n        info\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 源码—查看侦听类型 🔥\n\n/packages/runtime-core/src/apiWatch.ts#doWatch\n\nconst instance = currentInstance\nlet getter: () => any\nlet forceTrigger = false\nlet isMultiSource = false\n\nif (isRef(source)) {\n    getter = () => source.value\n    forceTrigger = !!source._shallow\n} else if (isReactive(source)) {\n    getter = () => source\n    deep = true\n} else if (isArray(source)) {\n    isMultiSource = true\n    forceTrigger = source.some(isReactive)\n    getter = () =>\n    source.map(s => {\n        if (isRef(s)) {\n            return s.value\n        } else if (isReactive(s)) {\n            return traverse(s)\n        } else if (isFunction(s)) {\n            return callWithErrorHandling(s, instance, ErrorCodes.WATCH_GETTER)\n        } else {\n            __DEV__ && warnInvalidSource(s)\n        }\n    })\n} else if (isFunction(source)) {\n    if (cb) {\n        // getter with cb\n        getter = () =>\n        callWithErrorHandling(source, instance, ErrorCodes.WATCH_GETTER)\n    } else {\n        // no cb -> simple effect\n        getter = () => {\n            if (instance && instance.isUnmounted) {\n                return\n            }\n            if (cleanup) {\n                cleanup()\n            }\n            return callWithAsyncErrorHandling(\n                source,\n                instance,\n                ErrorCodes.WATCH_CALLBACK,\n                [onInvalidate]\n            )\n        }\n    }\n} else {\n    getter = NOOP\n    __DEV__ && warnInvalidSource(source)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n可以看出，总共支持监听4中类型：\n\n * ref：getter 取的是ref的value，是普通数据类型，所以new、old值不同！\n * reactive：getter取的是原reactive的Proxy对象，所以new、old值同为最新的reactive的Proxy对象！\n * function（即getter）\n * array：即监听多个数据源，处理方式还是按照map后单个处理！！！\n\n\n# 深层的侦听—deep 🔥\n\n * 查看上面源码，注意 reactive 对象默认 deep 为 true！！！但是该方式 getter 直接取 reactive 对象，若需要返回普通对象，则需要侦听器传入解构对象。且若需要深度侦听，则需手动指定 deep 为 true\n * 其他类型根据需要设置 deep 的值\n\n\n# 立即执行—immediate 🔥\n\n默认情况下，watch第一次不会执行，必须侦听的值改变了！',normalizedContent:'# 计算属性&侦听器\n\n\n# computed 🔥\n\n * 在composition api中，我们可以在 setup 函数中使用 computed 方法来编写一个计算属性\n   * 接收一个getter函数，并为 getter 函数返回的值，返回一个不变的 ref 对象\n   * 接收一个具有 get 和 set 的对象，返回一个可变的(可读写)ref 对象\n\n<template>\n  <div>\n    <h2>{{ fullname }}</h2>\n    <button @click="changename">修改firstname</button>\n  </div>\n</template>\n\n<script>\nimport { ref, computed } from \'vue\'\n\nexport default {\n  setup() {\n    const firstname = ref(\'kobe\')\n    const lastname = ref(\'bryant\')\n\n    // 1.用法一: 传入一个getter函数\n    // computed的返回值是一个ref对象\n    // const fullname = computed(() => firstname.value + \' \' + lastname.value)\n    // const fullname2 = computed(() => firstname.value + \' @ \' + lastname.value)\n\n    // 2.用法二: 传入一个对象, 对象包含getter/setter\n    const fullname = computed({\n      get: () => firstname.value + \' \' + lastname.value,\n      set(newvalue) {\n        const names = newvalue.split(\' \')\n        firstname.value = names[0]\n        lastname.value = names[1]\n      },\n    })\n\n    const changename = () => {\n      // firstname.value = \'james\'\n      fullname.value = \'coder why\'\n    }\n\n    return {\n      fullname,\n      changename,\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n\n# watcheffect—立即&自动收集响应式数据的依赖 🔥\n\n\n# 介绍 🔥\n\n侦听data或者props的数据变化\n\n * watcheffect传入的函数会被立即执行一次，并且在执行的过程中会收集依赖\n * 只有收集的依赖发生变化时，watcheffect传入的函数才会再次执行\n\n<template>\n  <div>\n    <h2>{{name}}-{{age}}</h2>\n    <button @click="changename">修改name</button>\n    <button @click="changeage">修改age</button>\n  </div>\n</template>\n\n<script>\n  import { ref, watcheffect } from \'vue\';\n\n  export default {\n    setup() {\n      // watcheffect: 自动收集响应式的依赖\n      const name = ref("why");\n      const age = ref(18);\n\n      const changename = () => name.value = "kobe"\n      const changeage = () => age.value++\n\n      watcheffect(() => {\n        console.log("name:", name.value, "age:", age.value);\n      });\n\n      return {\n        name,\n        age,\n        changename,\n        changeage\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n\n# 停止侦听 🔥\n\n如果在发生某些情况下，我们希望停止侦听，这个时候我们可以获取watcheffect的返回值函数，调用该函数即可\n\n<template>\n  <div>\n    <h2>{{name}}-{{age}}</h2>\n    <button @click="changename">修改name</button>\n    <button @click="changeage">修改age</button>\n  </div>\n</template>\n\n<script>\n  import { ref, watcheffect } from \'vue\';\n\n  export default {\n    setup() {\n      // watcheffect: 自动收集响应式的依赖\n      const name = ref("why");\n      const age = ref(18);\n\n      const stop = watcheffect(() => {\n        console.log("name:", name.value, "age:", age.value);\n      });\n\n      const changename = () => name.value = "kobe"\n      const changeage = () => {\n        age.value++;\n        if (age.value > 25) {\n          stop();\n        }\n      }\n\n      return {\n        name,\n        age,\n        changename,\n        changeage\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n\n\n\n# 清除副作用—oninvalidate 🔥\n\n什么是清除副作用呢？\n\n * 比如在开发中我们需要在侦听函数中执行网络请求，但是在网络请求还没有达到的时候，我们停止了侦听器，或者侦听器侦听函数被再次执行了。\n * 那么上一次的网络请求应该被取消掉，这个时候我们就可以清除上一次的副作用;\n\n在我们给watcheffect传入的函数被回调时，其实可以获取到一个参数oninvalidate，这个失效回调会被触发：\n\n * 副作用即将重新执行时（每次依赖的数据变化时）\n * 侦听器被停止 (如果在 setup() 或生命周期钩子函数中使用了 watcheffect，则在组件卸载时)\n\n<template>\n  <div>\n    <h2>{{name}}-{{age}}</h2>\n    <button @click="changename">修改name</button>\n    <button @click="changeage">修改age</button>\n  </div>\n</template>\n\n<script>\n  import { ref, watcheffect } from \'vue\';\n\n  export default {\n    setup() {\n      // watcheffect: 自动收集响应式的依赖\n      const name = ref("why");\n      const age = ref(18);\n\n      const stop = watcheffect((oninvalidate) => {\n        const timer = settimeout(() => {\n          console.log("网络请求成功~");\n        }, 2000)\n\n        // 根据name和age两个变量发送网络请求\n        oninvalidate(() => {\n          // 在这个函数中清除额外的副作用\n          // request.cancel()\n          cleartimeout(timer);\n          console.log("oninvalidate");\n        })\n        console.log("name:", name.value, "age:", age.value);\n      });\n\n      const changename = () => name.value = "kobe"\n      const changeage = () => {\n        age.value++;\n        if (age.value > 25) {\n          stop();\n        }\n      }\n\n      return {\n        name,\n        age,\n        changename,\n        changeage\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n\n\n\n# 执行时机—flush 🔥\n\n如果需要在组件更新（例如：当与模板引用一起）后重新运行侦听器副作用，我们可以传递带有 flush 选项的附加 options 对象 (默认为 \'pre\')：\n\nflush?: \'pre\' | \'post\' | \'sync\' // 默认：\'pre\'\n\n\n1\n\n\n * pre：在组件更新后触发，这样你就可以访问更新的 dom。这也将推迟副作用的初始运行，直到组件的首次渲染完成\n\n * post：默认\n\n * sync：强制效果始终同步触发。然而，这是低效的，应该很少需要。\n\n3.2+，推荐使用 watchposteffect、watchsynceffect\n\n<template>\n  <div>\n    <h2 ref="title">哈哈哈</h2>\n  </div>\n</template>\n\n<script>\nimport { ref, watcheffect } from \'vue\'\n\nexport default {\n  setup() {\n    // 单个 ref\n    const title = ref(null)\n\n    watcheffect(\n      () => {\n        console.log(title.value)\n      },\n      {\n        // 当没有该配置，或者为默认值 pre，则上面log打印2次，第一次为null，第二次为el\n        // 这是因为setup函数在执行时就会立即执行传入的副作用函数，这个时候dom并没有挂载，所以打印为null\n        // 而当dom挂载时，会给title的ref对象赋值新的值，副作用函数会再次执行，打印出来对应的元素\n        flush: \'post\',\n      }\n    )\n\n    return {\n      title,\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# watchposteffect\n\n3.2+。watcheffect 的别名，带有 flush: \'post\' 选项。\n\n\n# watchsynceffect\n\n3.2+。watcheffect 的别名，带有 flush: \'sync\' 选项。\n\n\n# watch—惰性&手动指定侦听的数据源\n\n\n# 介绍 🔥\n\n侦听data或者props的数据变化\n\nwatch的api完全等同于组件watch选项的property:\n\n * watch需要侦听特定的数据源，并在回调函数中执行副作用;\n * 默认情况下它是惰性的，只有当被侦听的源发生变化时才会执行回调;\n\n与watcheffect的比较，watch允许我们:\n\n * 懒执行副作用(第一次不会直接执行);\n * 更具体的说明当哪些状态发生变化时，触发侦听器的执行;\n * 访问侦听状态变化前后的值;\n\n\n# 侦听单个数据源 🔥\n\nwatch侦听函数的数据源有两种类型:\n\n * 一个getter函数，但是该getter函数必须引用可响应式的对象(比如reactive或者ref);\n * 直接写入一个可响应式的对象，reactive或者ref（比较常用的是ref，reactive类型需要进行某些转换）;\n\n<template>\n  <div>\n    <h2 ref="title">{{ info.name }}</h2>\n    <button @click="changedata">修改数据</button>\n  </div>\n</template>\n\n<script>\nimport { ref, reactive, watch } from \'vue\'\n\nexport default {\n  setup() {\n    const info = reactive({ name: \'why\', age: 18 })\n\n    // 1.侦听watch时,传入一个getter函数\n    watch(\n      () => info.name,\n      (newvalue, oldvalue) => {\n        console.log(\'newvalue:\', newvalue, \'oldvalue:\', oldvalue)\n      }\n    )\n\n    // 2.传入一个可响应式对象: reactive对象\n    // 2.1 情况一: reactive对象获取到的newvalue和oldvalue本身都是reactive对象。所以new、old值为reactive，且相同！\n    // watch(info, (newvalue, oldvalue) => {\n    //   console.log("newvalue:", newvalue, "oldvalue:", oldvalue);\n    // })\n    // 2.2 情况二：如果希望newvalue和oldvalue是一个普通的对象，需解构！！！\n    watch(\n      () => {\n        return { ...info }\n      },\n      (newvalue, oldvalue) => {\n        console.log(\'newvalue:\', newvalue, \'oldvalue:\', oldvalue)\n      }\n    )\n      \n    // 3.传入一个可响应式对象: ref对象\n    // ref对象获取newvalue和oldvalue是value值的本身，所以new、old不同\n    // const name = ref("why");\n    // watch(name, (newvalue, oldvalue) => {\n    //   console.log("newvalue:", newvalue, "oldvalue:", oldvalue);\n    // })\n\n    const changedata = () => {\n      info.name = \'kobe\'\n    }\n\n    return {\n      changedata,\n      info,\n    }\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n\n\n\n# 侦听多个数据源 🔥\n\n就是数组包含侦听单个数据源的方式！！！详见单个数据源！\n\n<template>\n  <div>\n    <h2 ref="title">{{info.name}}</h2>\n    <button @click="changedata">修改数据</button>\n  </div>\n</template>\n\n<script>\n  import { ref, reactive, watch } from \'vue\';\n\n  export default {\n    setup() {\n      // 1.定义可响应式的对象\n      const info = reactive({name: "why", age: 18});\n      const name = ref("why");\n\n      // 2.侦听器watch\n      watch([() => ({...info}), name], ([newinfo, newname], [oldinfo, oldname]) => {\n        console.log(newinfo, newname, oldinfo, oldname);\n      })\n\n      const changedata = () => {\n        info.name = "kobe";\n      }\n\n      return {\n        changedata,\n        info\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n\n# 源码—查看侦听类型 🔥\n\n/packages/runtime-core/src/apiwatch.ts#dowatch\n\nconst instance = currentinstance\nlet getter: () => any\nlet forcetrigger = false\nlet ismultisource = false\n\nif (isref(source)) {\n    getter = () => source.value\n    forcetrigger = !!source._shallow\n} else if (isreactive(source)) {\n    getter = () => source\n    deep = true\n} else if (isarray(source)) {\n    ismultisource = true\n    forcetrigger = source.some(isreactive)\n    getter = () =>\n    source.map(s => {\n        if (isref(s)) {\n            return s.value\n        } else if (isreactive(s)) {\n            return traverse(s)\n        } else if (isfunction(s)) {\n            return callwitherrorhandling(s, instance, errorcodes.watch_getter)\n        } else {\n            __dev__ && warninvalidsource(s)\n        }\n    })\n} else if (isfunction(source)) {\n    if (cb) {\n        // getter with cb\n        getter = () =>\n        callwitherrorhandling(source, instance, errorcodes.watch_getter)\n    } else {\n        // no cb -> simple effect\n        getter = () => {\n            if (instance && instance.isunmounted) {\n                return\n            }\n            if (cleanup) {\n                cleanup()\n            }\n            return callwithasyncerrorhandling(\n                source,\n                instance,\n                errorcodes.watch_callback,\n                [oninvalidate]\n            )\n        }\n    }\n} else {\n    getter = noop\n    __dev__ && warninvalidsource(source)\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n\n\n可以看出，总共支持监听4中类型：\n\n * ref：getter 取的是ref的value，是普通数据类型，所以new、old值不同！\n * reactive：getter取的是原reactive的proxy对象，所以new、old值同为最新的reactive的proxy对象！\n * function（即getter）\n * array：即监听多个数据源，处理方式还是按照map后单个处理！！！\n\n\n# 深层的侦听—deep 🔥\n\n * 查看上面源码，注意 reactive 对象默认 deep 为 true！！！但是该方式 getter 直接取 reactive 对象，若需要返回普通对象，则需要侦听器传入解构对象。且若需要深度侦听，则需手动指定 deep 为 true\n * 其他类型根据需要设置 deep 的值\n\n\n# 立即执行—immediate 🔥\n\n默认情况下，watch第一次不会执行，必须侦听的值改变了！',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"其他",frontmatter:{title:"其他",date:"2022-02-04T17:23:43.000Z",permalink:"/pages/563ede/",categories:["x","Composition Api"],tags:[null]},regularPath:"/1403.Vue3.x/400.Composition%20Api/404.%E5%85%B6%E4%BB%96.html",relativePath:"1403.Vue3.x/400.Composition Api/404.其他.md",key:"v-60be060a",path:"/pages/563ede/",headers:[{level:2,title:"生命周期钩子 🔥",slug:"生命周期钩子-🔥",normalizedTitle:"生命周期钩子 🔥",charIndex:9},{level:2,title:"Provide & Inject 函数—不推荐",slug:"provide-inject-函数-不推荐",normalizedTitle:"provide &amp; inject 函数—不推荐",charIndex:null},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:2156},{level:3,title:"useCounter.js",slug:"usecounter-js",normalizedTitle:"usecounter.js",charIndex:2163},{level:3,title:"useTitle.js",slug:"usetitle-js",normalizedTitle:"usetitle.js",charIndex:2544},{level:3,title:"useScrollPosition.js",slug:"usescrollposition-js",normalizedTitle:"usescrollposition.js",charIndex:2824},{level:3,title:"useMousePosition.js",slug:"usemouseposition-js",normalizedTitle:"usemouseposition.js",charIndex:3168},{level:3,title:"useLocalStorage.js",slug:"uselocalstorage-js",normalizedTitle:"uselocalstorage.js",charIndex:3505},{level:3,title:"index.js",slug:"index-js",normalizedTitle:"index.js",charIndex:4166},{level:2,title:"setup script 🔥",slug:"setup-script-🔥",normalizedTitle:"setup script 🔥",charIndex:4537}],headersStr:"生命周期钩子 🔥 Provide & Inject 函数—不推荐 示例 useCounter.js useTitle.js useScrollPosition.js useMousePosition.js useLocalStorage.js index.js setup script 🔥",content:"# 其他\n\n\n# 生命周期钩子 🔥\n\nsetup中如何使用生命周期函数呢？可以使用直接导入的 onX 函数注册生命周期钩子：\n\n * 可以每个使用多次！\n\n下表包含如何在setup()内部调用生命周期钩子：\n\n选项式 API           HOOK INSIDE SETUP\nbeforeCreate      Not needed*\ncreated           Not needed*\nbeforeMount       onBeforeMount\nmounted           onMounted\nbeforeUpdate      onBeforeUpdate\nupdated           onUpdated\nbeforeUnmount     onBeforeUnmount\nunmounted         onUnmounted\nerrorCaptured     onErrorCaptured\nrenderTracked     onRenderTracked\nrenderTriggered   onRenderTriggered\nactivated         onActivated\ndeactivated       onDeactivated\n\n因为 setup 是围绕 beforeCreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写。\n\n\n# Provide & Inject 函数—不推荐\n\n事实上我们之前还学习过Provide和Inject，Composition API也可以替代之前的 Provide 和 Inject 的选项\n\n我们可以通过 provide来提供数据:\n\n * 可以通过 provide 方法来定义每个 Property;\n * provide可以传入两个参数:\n   * name:提供的属性名称;\n   * value:提供的属性值;\n\n在 后代组件 中可以通过 inject 来注入需要的属性和对应的值：\n\n * inject可以传入两个参数:\n   * 要 inject 的 property 的 name;\n   * 默认值;\n\n<template>\n  <div>\n    <home/>\n    <h2>App Counter: {{counter}}</h2>\n    <button @click=\"increment\">App中的+1</button>\n  </div>\n</template>\n\n<script>\n  import { provide, ref, readonly } from 'vue';\n\n  import Home from './Home.vue';\n\n  export default {\n    components: {\n      Home\n    },\n    setup() {\n      const name = ref(\"coderwhy\");\n      let counter = ref(100);\n\n      provide(\"name\", readonly(name));\n      provide(\"counter\", readonly(counter));\n\n      const increment = () => counter.value++;\n\n      return {\n        increment,\n        counter\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n<template>\n  <div>\n    <h2>{{name}}</h2>\n    <h2>{{counter}}</h2>\n\n    <button @click=\"homeIncrement\">home+1</button>\n  </div>\n</template>\n\n<script>\n  import { inject } from 'vue';\n\n  export default {\n    setup() {\n      const name = inject(\"name\");\n      const counter = inject(\"counter\");\n\n      const homeIncrement = () => counter.value++\n\n      return {\n        name,\n        counter,\n        homeIncrement\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 示例\n\n\n# useCounter.js\n\nimport { ref, computed } from 'vue';\n\nexport default function() {\n  const counter = ref(0);\n  const doubleCounter = computed(() => counter.value * 2);\n\n  const increment = () => counter.value++;\n  const decrement = () => counter.value--;\n\n  return {\n    counter, \n    doubleCounter, \n    increment, \n    decrement\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# useTitle.js\n\nimport { ref, watch } from 'vue';\n\nexport default function(title = \"默认的title\") {\n  const titleRef = ref(title);\n\n  watch(titleRef, (newValue) => {\n    document.title = newValue\n  }, {\n    immediate: true\n  })\n\n  return titleRef\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# useScrollPosition.js\n\nimport { ref } from 'vue';\n\nexport default function() {\n  const scrollX = ref(0);\n  const scrollY = ref(0);\n\n  document.addEventListener(\"scroll\", () => {\n    scrollX.value = window.scrollX;\n    scrollY.value = window.scrollY;\n  });\n\n  return {\n    scrollX,\n    scrollY\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# useMousePosition.js\n\nimport { ref } from 'vue';\n\nexport default function() {\n  const mouseX = ref(0);\n  const mouseY = ref(0);\n\n  window.addEventListener(\"mousemove\", (event) => {\n    mouseX.value = event.pageX;\n    mouseY.value = event.pageY;\n  });\n\n  return {\n    mouseX,\n    mouseY\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# useLocalStorage.js\n\n我们来完成一个使用 localStorage 存储和获取数据的Hook\n\nimport { ref, watch } from 'vue';\n\nexport default function(key, value) {\n  const data = ref(value);\n\n  if (value) {\n    window.localStorage.setItem(key, JSON.stringify(value));\n  } else {\n    data.value = JSON.parse(window.localStorage.getItem(key));\n  }\n\n  watch(data, (newValue) => {\n    window.localStorage.setItem(key, JSON.stringify(newValue));\n  })\n\n  return data;\n}\n\n// 一个参数: 取值\n// const data = useLocalStorage(\"name\");\n\n// 二个参数: 保存值\n// const data = useLocalStorage(\"name\", \"coderwhy\");\n\n// 自动修改值\n// data.value = \"kobe\";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# index.js\n\nimport useCounter from './useCounter';\nimport useTitle from './useTitle';\nimport useScrollPosition from './useScrollPosition';\nimport useMousePosition from './useMousePosition';\nimport useLocalStorage from './useLocalStorage';\n\nexport {\n  useCounter,\n  useTitle,\n  useScrollPosition,\n  useMousePosition,\n  useLocalStorage\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# setup script 🔥\n\n<script setup> 是在单文件组件 (SFC) 中使用组合式 API 的编译时语法糖。相比于普通的<script> 语法，它具有更多优势：\n\n * 更少的样板内容，更简洁的代码。\n * 能够使用纯 Typescript 声明 props 和抛出事件。\n * 更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。\n * 更好的 IDE 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。\n\nApp.vue\n\n<template>\n  <div>\n    <h2>当前计数: {{ counter }}</h2>\n    <button @click=\"increment\">+1</button>\n\n    <hello-world message=\"呵呵呵\" @increment=\"getCounter\"></hello-world>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport HelloWorld from './HelloWorld.vue'\n\nconst counter = ref(0)\nconst increment = () => counter.value++\n\nconst getCounter = (payload) => {\n  console.log(payload)\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nHelloWorld.vue\n\n<template>\n  <div>\n    <h2>Hello World</h2>\n    <h2>{{ message }}</h2>\n    <button @click=\"emitEvent\">发射事件</button>\n  </div>\n</template>\n\n<script setup>\nimport { defineProps, defineEmits } from 'vue'\n\nconst props = defineProps({\n  message: {\n    type: String,\n    default: '哈哈哈',\n  },\n})\n\nconst emit = defineEmits(['increment', 'decrement'])\n\nconst emitEvent = () => {\n  emit('increment', '100000')\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",normalizedContent:"# 其他\n\n\n# 生命周期钩子 🔥\n\nsetup中如何使用生命周期函数呢？可以使用直接导入的 onx 函数注册生命周期钩子：\n\n * 可以每个使用多次！\n\n下表包含如何在setup()内部调用生命周期钩子：\n\n选项式 api           hook inside setup\nbeforecreate      not needed*\ncreated           not needed*\nbeforemount       onbeforemount\nmounted           onmounted\nbeforeupdate      onbeforeupdate\nupdated           onupdated\nbeforeunmount     onbeforeunmount\nunmounted         onunmounted\nerrorcaptured     onerrorcaptured\nrendertracked     onrendertracked\nrendertriggered   onrendertriggered\nactivated         onactivated\ndeactivated       ondeactivated\n\n因为 setup 是围绕 beforecreate 和 created 生命周期钩子运行的，所以不需要显式地定义它们。换句话说，在这些钩子中编写的任何代码都应该直接在 setup 函数中编写。\n\n\n# provide & inject 函数—不推荐\n\n事实上我们之前还学习过provide和inject，composition api也可以替代之前的 provide 和 inject 的选项\n\n我们可以通过 provide来提供数据:\n\n * 可以通过 provide 方法来定义每个 property;\n * provide可以传入两个参数:\n   * name:提供的属性名称;\n   * value:提供的属性值;\n\n在 后代组件 中可以通过 inject 来注入需要的属性和对应的值：\n\n * inject可以传入两个参数:\n   * 要 inject 的 property 的 name;\n   * 默认值;\n\n<template>\n  <div>\n    <home/>\n    <h2>app counter: {{counter}}</h2>\n    <button @click=\"increment\">app中的+1</button>\n  </div>\n</template>\n\n<script>\n  import { provide, ref, readonly } from 'vue';\n\n  import home from './home.vue';\n\n  export default {\n    components: {\n      home\n    },\n    setup() {\n      const name = ref(\"coderwhy\");\n      let counter = ref(100);\n\n      provide(\"name\", readonly(name));\n      provide(\"counter\", readonly(counter));\n\n      const increment = () => counter.value++;\n\n      return {\n        increment,\n        counter\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n\n\n<template>\n  <div>\n    <h2>{{name}}</h2>\n    <h2>{{counter}}</h2>\n\n    <button @click=\"homeincrement\">home+1</button>\n  </div>\n</template>\n\n<script>\n  import { inject } from 'vue';\n\n  export default {\n    setup() {\n      const name = inject(\"name\");\n      const counter = inject(\"counter\");\n\n      const homeincrement = () => counter.value++\n\n      return {\n        name,\n        counter,\n        homeincrement\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# 示例\n\n\n# usecounter.js\n\nimport { ref, computed } from 'vue';\n\nexport default function() {\n  const counter = ref(0);\n  const doublecounter = computed(() => counter.value * 2);\n\n  const increment = () => counter.value++;\n  const decrement = () => counter.value--;\n\n  return {\n    counter, \n    doublecounter, \n    increment, \n    decrement\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# usetitle.js\n\nimport { ref, watch } from 'vue';\n\nexport default function(title = \"默认的title\") {\n  const titleref = ref(title);\n\n  watch(titleref, (newvalue) => {\n    document.title = newvalue\n  }, {\n    immediate: true\n  })\n\n  return titleref\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# usescrollposition.js\n\nimport { ref } from 'vue';\n\nexport default function() {\n  const scrollx = ref(0);\n  const scrolly = ref(0);\n\n  document.addeventlistener(\"scroll\", () => {\n    scrollx.value = window.scrollx;\n    scrolly.value = window.scrolly;\n  });\n\n  return {\n    scrollx,\n    scrolly\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# usemouseposition.js\n\nimport { ref } from 'vue';\n\nexport default function() {\n  const mousex = ref(0);\n  const mousey = ref(0);\n\n  window.addeventlistener(\"mousemove\", (event) => {\n    mousex.value = event.pagex;\n    mousey.value = event.pagey;\n  });\n\n  return {\n    mousex,\n    mousey\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n\n\n\n# uselocalstorage.js\n\n我们来完成一个使用 localstorage 存储和获取数据的hook\n\nimport { ref, watch } from 'vue';\n\nexport default function(key, value) {\n  const data = ref(value);\n\n  if (value) {\n    window.localstorage.setitem(key, json.stringify(value));\n  } else {\n    data.value = json.parse(window.localstorage.getitem(key));\n  }\n\n  watch(data, (newvalue) => {\n    window.localstorage.setitem(key, json.stringify(newvalue));\n  })\n\n  return data;\n}\n\n// 一个参数: 取值\n// const data = uselocalstorage(\"name\");\n\n// 二个参数: 保存值\n// const data = uselocalstorage(\"name\", \"coderwhy\");\n\n// 自动修改值\n// data.value = \"kobe\";\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# index.js\n\nimport usecounter from './usecounter';\nimport usetitle from './usetitle';\nimport usescrollposition from './usescrollposition';\nimport usemouseposition from './usemouseposition';\nimport uselocalstorage from './uselocalstorage';\n\nexport {\n  usecounter,\n  usetitle,\n  usescrollposition,\n  usemouseposition,\n  uselocalstorage\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# setup script 🔥\n\n<script setup> 是在单文件组件 (sfc) 中使用组合式 api 的编译时语法糖。相比于普通的<script> 语法，它具有更多优势：\n\n * 更少的样板内容，更简洁的代码。\n * 能够使用纯 typescript 声明 props 和抛出事件。\n * 更好的运行时性能 (其模板会被编译成与其同一作用域的渲染函数，没有任何的中间代理)。\n * 更好的 ide 类型推断性能 (减少语言服务器从代码中抽离类型的工作)。\n\napp.vue\n\n<template>\n  <div>\n    <h2>当前计数: {{ counter }}</h2>\n    <button @click=\"increment\">+1</button>\n\n    <hello-world message=\"呵呵呵\" @increment=\"getcounter\"></hello-world>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nimport helloworld from './helloworld.vue'\n\nconst counter = ref(0)\nconst increment = () => counter.value++\n\nconst getcounter = (payload) => {\n  console.log(payload)\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n\n\nhelloworld.vue\n\n<template>\n  <div>\n    <h2>hello world</h2>\n    <h2>{{ message }}</h2>\n    <button @click=\"emitevent\">发射事件</button>\n  </div>\n</template>\n\n<script setup>\nimport { defineprops, defineemits } from 'vue'\n\nconst props = defineprops({\n  message: {\n    type: string,\n    default: '哈哈哈',\n  },\n})\n\nconst emit = defineemits(['increment', 'decrement'])\n\nconst emitevent = () => {\n  emit('increment', '100000')\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"h 函数 & JSX",frontmatter:{title:"h 函数 & JSX",date:"2022-02-04T19:15:00.000Z",permalink:"/pages/2b61b7/",categories:["x","Composition Api"],tags:[null]},regularPath:"/1403.Vue3.x/500.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/501.h%20%E5%87%BD%E6%95%B0%20&%20JSX.html",relativePath:"1403.Vue3.x/500.高级语法/501.h 函数 & JSX.md",key:"v-3b93b6c4",path:"/pages/2b61b7/",headers:[{level:2,title:"h 函数 🔥",slug:"h-函数-🔥",normalizedTitle:"h 函数 🔥",charIndex:17},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:29},{level:3,title:"参数 🔥",slug:"参数-🔥",normalizedTitle:"参数 🔥",charIndex:594},{level:4,title:"type",slug:"type",normalizedTitle:"type",charIndex:608},{level:4,title:"props",slug:"props",normalizedTitle:"props",charIndex:613},{level:4,title:"children",slug:"children",normalizedTitle:"children",charIndex:621},{level:3,title:"h 函数的基本使用",slug:"h-函数的基本使用",normalizedTitle:"h 函数的基本使用",charIndex:1126},{level:3,title:"render 函数实现计数器",slug:"render-函数实现计数器",normalizedTitle:"render 函数实现计数器",charIndex:1696},{level:3,title:"setup 函数实现计数器",slug:"setup-函数实现计数器",normalizedTitle:"setup 函数实现计数器",charIndex:2203},{level:3,title:"组件和插槽的使用",slug:"组件和插槽的使用",normalizedTitle:"组件和插槽的使用",charIndex:2718},{level:2,title:"JSX 🔥",slug:"jsx-🔥",normalizedTitle:"jsx 🔥",charIndex:3533},{level:3,title:"入门",slug:"入门",normalizedTitle:"入门",charIndex:3544},{level:3,title:"JSX 计数器案例",slug:"jsx-计数器案例",normalizedTitle:"jsx 计数器案例",charIndex:3882}],headersStr:"h 函数 🔥 介绍 参数 🔥 type props children h 函数的基本使用 render 函数实现计数器 setup 函数实现计数器 组件和插槽的使用 JSX 🔥 入门 JSX 计数器案例",content:"# h 函数 & JSX\n\n\n# h 函数 🔥\n\n\n# 介绍\n\n返回一个”虚拟节点“，通常缩写为 VNode：一个普通对象，其中包含向 Vue 描述它应在页面上渲染哪种节点的信息，包括所有子节点的描述。它的目的是用于手动编写的渲染函数：\n\nVue推荐在绝大数情况下使用模板来创建你的HTML，然后一些特殊的场景，你真的需要JavaScript的完全编程的能力，这个时候你可以使用 h 渲染函数 ，它比模板更接近编译器;\n\n * 前面我们讲解过VNode和VDOM的改变：Vue在生成真实的DOM之前，会将我们的节点转换成VNode，而VNode组合在一起形成一颗树结构，就是虚拟DOM(VDOM);\n\n * 事实上，我们之前编写的 template 中的HTML 最终也是使用渲染函数生成对应的VNode;\n\n * 那么，如果你想充分的利用JavaScript的编程能力，我们可以自己来编写 createVNode 函数，生成对应的VNode;\n\n那么我们应该怎么来做呢?使用 h()函数:\n\n * h() 函数是一个用于创建 VNode 的一个函数;\n * 其实更准备的命名是 createVNode() 函数，但是为了简便在Vue将之简化为 h() 函数;\n\nrender() {\n  return h('h1', {}, 'Some title')\n}\n\n\n1\n2\n3\n\n\n\n# 参数 🔥\n\n接收三个参数：type，props 和 children\n\n# type\n\n * 类型：String | Object | Function\n\n * 详细：\n   \n   HTML 标签名、组件、异步组件或函数式组件。使用返回 null 的函数将渲染一个注释。此参数是必需的。\n\n# props\n\n * 类型：Object\n\n * 详细：\n   \n   一个对象，与我们将在模板中使用的 attribute、prop 和事件相对应。可选。\n\n# children\n\n * 类型：String | Array | Object\n\n * 详细：\n   \n   子代 VNode，使用 h() 生成，或者使用字符串来获取“文本 VNode”，或带有插槽的对象。可选。\n   \n   h('div', {}, [\n     'Some text comes first.',\n     h('h1', 'A headline'),\n     h(MyComponent, {\n       someProp: 'foobar'\n     })\n   ])\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n\n# h 函数的基本使用\n\nh函数可以在两个地方使用:\n\n * render函数选项中;\n   \n   <script>\n     import { h } from 'vue';\n   \n     export default {\n       render() {\n         return h(\"h2\", {class: \"title\"}, \"Hello Render\")\n       }\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * setup函数选项中(setup本身需要是一个函数类型，函数再返回h函数创建的VNode);\n   \n   <script>\n     import { h } from 'vue';\n   \n     export default {\n       setup() {\n         return () => h(\"h2\", {class: \"title\"}, \"Hello Render\")\n       }\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# render 函数实现计数器\n\n<script>\n  import { h } from 'vue';\n\n  export default {\n    data() {\n      return {\n        counter: 0\n      }\n    },\n    render() {\n      return h(\"div\", {class: \"app\"}, [\n        h(\"h2\", null, `当前计数: ${this.counter}`),\n        h(\"button\", {\n          onClick: () => this.counter++\n        }, \"+1\"),\n        h(\"button\", {\n          onClick: () => this.counter--\n        }, \"-1\"),\n      ])\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n太麻烦了，可以使用JSX替代。\n\n\n# setup 函数实现计数器\n\n<script>\n  import { ref, h } from 'vue';\n\n  export default {\n    setup() {\n      const counter = ref(0);\n      \n      return () => {\n        return h(\"div\", {class: \"app\"}, [\n          h(\"h2\", null, `当前计数: ${counter.value}`),\n          h(\"button\", {\n            onClick: () => counter.value++\n          }, \"+1\"),\n          h(\"button\", {\n            onClick: () => counter.value--\n          }, \"-1\"),\n        ])\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 组件和插槽的使用\n\nApp.vue\n\n<script>\nimport { h } from 'vue'\nimport HelloWorld from './HelloWorld.vue'\n\nexport default {\n  render() {\n    return h('div', null, [\n      h(HelloWorld, null, {\n        // default 插槽；作用域插槽\n        default: (props) =>\n          h('span', null, `app传入到HelloWorld中的内容: ${props.name}`),\n      }),\n    ])\n  },\n}\n<\/script>\n\n<style scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nHelloWorld.vue\n\n<script>\nimport { h } from 'vue'\n\nexport default {\n  render() {\n    return h('div', null, [\n      h('h2', null, 'Hello World'),\n      // default 插槽；\n      this.$slots.default\n        ? this.$slots.default({ name: 'coderwhy' })\n        : h('span', null, '我是HelloWorld的插槽默认值'),\n    ])\n  },\n}\n<\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# JSX 🔥\n\n\n# 入门\n\n如果我们希望在项目中使用jsx，那么我们需要添加对jsx的支持:\n\n * jsx我们通常会通过Babel来进行转换（React编写的jsx就是通过babel转换的）;\n * 对于Vue来说，我们只需要在Babel中配置对应的插件即可（当前版本无需配置）;\n\n（根据是否需要配置）安装Babel支持Vue的jsx插件：\n\n npm install @vue/babel-plugin-jsx -D\n\n\n1\n\n\n（根据是否需要配置）在babel.config.js配置文件中配置插件\n\nmodule.exports = {\n  presets: [\n    '@vue/cli-plugin-babel/preset'\n  ]\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# JSX 计数器案例\n\nApp.vue\n\n<script>\n  import HelloWorld from './HelloWorld.vue';\n\n  export default {\n    data() {\n      return {\n        counter: 0\n      }\n    },\n\n    render() {\n      const increment = () => this.counter++;\n      const decrement = () => this.counter--;\n\n      return (\n        <div>\n          <h2>当前计数: {this.counter}</h2>\n          <button onClick={increment}>+1</button>\n          <button onClick={decrement}>-1</button>\n          <HelloWorld>\n          </HelloWorld>\n        </div>\n      )\n    }\n  }\n<\/script>\n\n<style lang=\"scss\" scoped>\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nHelloWorld.vue\n\n<script>\n  export default {\n    render() {\n      return (\n        <div>\n          <h2>HelloWorld</h2>\n          {this.$slots.default ? this.$slots.default(): <span>哈哈哈</span>}\n        </div>\n      )\n    }\n  }\n<\/script>\n\n<style scoped>\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",normalizedContent:"# h 函数 & jsx\n\n\n# h 函数 🔥\n\n\n# 介绍\n\n返回一个”虚拟节点“，通常缩写为 vnode：一个普通对象，其中包含向 vue 描述它应在页面上渲染哪种节点的信息，包括所有子节点的描述。它的目的是用于手动编写的渲染函数：\n\nvue推荐在绝大数情况下使用模板来创建你的html，然后一些特殊的场景，你真的需要javascript的完全编程的能力，这个时候你可以使用 h 渲染函数 ，它比模板更接近编译器;\n\n * 前面我们讲解过vnode和vdom的改变：vue在生成真实的dom之前，会将我们的节点转换成vnode，而vnode组合在一起形成一颗树结构，就是虚拟dom(vdom);\n\n * 事实上，我们之前编写的 template 中的html 最终也是使用渲染函数生成对应的vnode;\n\n * 那么，如果你想充分的利用javascript的编程能力，我们可以自己来编写 createvnode 函数，生成对应的vnode;\n\n那么我们应该怎么来做呢?使用 h()函数:\n\n * h() 函数是一个用于创建 vnode 的一个函数;\n * 其实更准备的命名是 createvnode() 函数，但是为了简便在vue将之简化为 h() 函数;\n\nrender() {\n  return h('h1', {}, 'some title')\n}\n\n\n1\n2\n3\n\n\n\n# 参数 🔥\n\n接收三个参数：type，props 和 children\n\n# type\n\n * 类型：string | object | function\n\n * 详细：\n   \n   html 标签名、组件、异步组件或函数式组件。使用返回 null 的函数将渲染一个注释。此参数是必需的。\n\n# props\n\n * 类型：object\n\n * 详细：\n   \n   一个对象，与我们将在模板中使用的 attribute、prop 和事件相对应。可选。\n\n# children\n\n * 类型：string | array | object\n\n * 详细：\n   \n   子代 vnode，使用 h() 生成，或者使用字符串来获取“文本 vnode”，或带有插槽的对象。可选。\n   \n   h('div', {}, [\n     'some text comes first.',\n     h('h1', 'a headline'),\n     h(mycomponent, {\n       someprop: 'foobar'\n     })\n   ])\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   \n\n\n# h 函数的基本使用\n\nh函数可以在两个地方使用:\n\n * render函数选项中;\n   \n   <script>\n     import { h } from 'vue';\n   \n     export default {\n       render() {\n         return h(\"h2\", {class: \"title\"}, \"hello render\")\n       }\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n * setup函数选项中(setup本身需要是一个函数类型，函数再返回h函数创建的vnode);\n   \n   <script>\n     import { h } from 'vue';\n   \n     export default {\n       setup() {\n         return () => h(\"h2\", {class: \"title\"}, \"hello render\")\n       }\n     }\n   <\/script>\n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   \n\n\n# render 函数实现计数器\n\n<script>\n  import { h } from 'vue';\n\n  export default {\n    data() {\n      return {\n        counter: 0\n      }\n    },\n    render() {\n      return h(\"div\", {class: \"app\"}, [\n        h(\"h2\", null, `当前计数: ${this.counter}`),\n        h(\"button\", {\n          onclick: () => this.counter++\n        }, \"+1\"),\n        h(\"button\", {\n          onclick: () => this.counter--\n        }, \"-1\"),\n      ])\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n\n\n太麻烦了，可以使用jsx替代。\n\n\n# setup 函数实现计数器\n\n<script>\n  import { ref, h } from 'vue';\n\n  export default {\n    setup() {\n      const counter = ref(0);\n      \n      return () => {\n        return h(\"div\", {class: \"app\"}, [\n          h(\"h2\", null, `当前计数: ${counter.value}`),\n          h(\"button\", {\n            onclick: () => counter.value++\n          }, \"+1\"),\n          h(\"button\", {\n            onclick: () => counter.value--\n          }, \"-1\"),\n        ])\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n\n# 组件和插槽的使用\n\napp.vue\n\n<script>\nimport { h } from 'vue'\nimport helloworld from './helloworld.vue'\n\nexport default {\n  render() {\n    return h('div', null, [\n      h(helloworld, null, {\n        // default 插槽；作用域插槽\n        default: (props) =>\n          h('span', null, `app传入到helloworld中的内容: ${props.name}`),\n      }),\n    ])\n  },\n}\n<\/script>\n\n<style scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\nhelloworld.vue\n\n<script>\nimport { h } from 'vue'\n\nexport default {\n  render() {\n    return h('div', null, [\n      h('h2', null, 'hello world'),\n      // default 插槽；\n      this.$slots.default\n        ? this.$slots.default({ name: 'coderwhy' })\n        : h('span', null, '我是helloworld的插槽默认值'),\n    ])\n  },\n}\n<\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n\n\n\n# jsx 🔥\n\n\n# 入门\n\n如果我们希望在项目中使用jsx，那么我们需要添加对jsx的支持:\n\n * jsx我们通常会通过babel来进行转换（react编写的jsx就是通过babel转换的）;\n * 对于vue来说，我们只需要在babel中配置对应的插件即可（当前版本无需配置）;\n\n（根据是否需要配置）安装babel支持vue的jsx插件：\n\n npm install @vue/babel-plugin-jsx -d\n\n\n1\n\n\n（根据是否需要配置）在babel.config.js配置文件中配置插件\n\nmodule.exports = {\n  presets: [\n    '@vue/cli-plugin-babel/preset'\n  ]\n}\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n# jsx 计数器案例\n\napp.vue\n\n<script>\n  import helloworld from './helloworld.vue';\n\n  export default {\n    data() {\n      return {\n        counter: 0\n      }\n    },\n\n    render() {\n      const increment = () => this.counter++;\n      const decrement = () => this.counter--;\n\n      return (\n        <div>\n          <h2>当前计数: {this.counter}</h2>\n          <button onclick={increment}>+1</button>\n          <button onclick={decrement}>-1</button>\n          <helloworld>\n          </helloworld>\n        </div>\n      )\n    }\n  }\n<\/script>\n\n<style lang=\"scss\" scoped>\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\nhelloworld.vue\n\n<script>\n  export default {\n    render() {\n      return (\n        <div>\n          <h2>helloworld</h2>\n          {this.$slots.default ? this.$slots.default(): <span>哈哈哈</span>}\n        </div>\n      )\n    }\n  }\n<\/script>\n\n<style scoped>\n\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n",charsets:{cjk:!0},lastUpdated:"2022/03/24, 16:45:21",lastUpdatedTimestamp:1648140321e3},{title:"自定义指令",frontmatter:{title:"自定义指令",date:"2022-03-24T22:19:20.000Z",permalink:"/pages/aa7419/",categories:["x","高级语法"],tags:[null]},regularPath:"/1403.Vue3.x/500.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/502.%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4.html",relativePath:"1403.Vue3.x/500.高级语法/502.自定义指令.md",key:"v-3edfb5c9",path:"/pages/aa7419/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:12},{level:2,title:"默认的实现方式",slug:"默认的实现方式",normalizedTitle:"默认的实现方式",charIndex:318},{level:2,title:"局部自定义指令",slug:"局部自定义指令",normalizedTitle:"局部自定义指令",charIndex:779},{level:2,title:"全局自定义指令 🔥",slug:"全局自定义指令-🔥",normalizedTitle:"全局自定义指令 🔥",charIndex:1261},{level:2,title:"指令的生命周期、参数、修饰符 🔥",slug:"指令的生命周期、参数、修饰符-🔥",normalizedTitle:"指令的生命周期、参数、修饰符 🔥",charIndex:1549},{level:2,title:"时间戳格式化指令 🔥🔥🔥",slug:"时间戳格式化指令-🔥🔥🔥",normalizedTitle:"时间戳格式化指令 🔥🔥🔥",charIndex:3210}],headersStr:"介绍 默认的实现方式 局部自定义指令 全局自定义指令 🔥 指令的生命周期、参数、修饰符 🔥 时间戳格式化指令 🔥🔥🔥",content:'# 自定义指令\n\n\n# 介绍\n\n在Vue的模板语法中我们学习过各种各样的指令：v-show、v-for、v-model等等，除了使用这些指令之外，Vue 也允许我们来自定义自己的指令。\n\n * 注意:在Vue中，代码的复用和抽象主要还是通过组件;\n * 通常在某些情况下，你需要对DOM元素进行底层操作，这个时候就会用到自定义指令;\n\n自定义指令分为两种 :\n\n * 自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用;\n * 自定义全局指令：app的 directive 方法，可以在任意组件中被使用;\n\n比如我们来做一个非常简单的案例:当某个元素挂载完成后可以自定获取焦点\n\n * 实现方式一:如果我们使用默认的实现方式;\n * 实现方式二:自定义一个 v-focus 的局部指令;\n * 实现方式三:自定义一个 v-focus 的全局指令;\n\n\n# 默认的实现方式\n\n<template>\n  <div>\n    <input type="text" ref="input">\n  </div>\n</template>\n\n<script>\n  import { ref, onMounted } from "vue";\n\n  export default {\n    setup() {\n      const input = ref(null);\n\n      onMounted(() => {\n        input.value.focus();\n      })\n\n      return {\n        input\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 局部自定义指令\n\n * 在组件 options 选项中使用 directives 即可\n * 它是一个对象，在对象中编写我们自定义指令的名称（注意:这里不需要加v-）\n * 自定义指令有一个生命周期，是在组件挂载后调用的 mounted，我们可以在其中完成操作\n\n<template>\n  <div>\n    <input type="text" v-focus>\n  </div>\n</template>\n\n<script>\n  export default {\n    // 局部指令\n    directives: {\n      focus: {\n        mounted(el, bindings, vnode, preVnode) {\n          console.log("focus mounted");\n          el.focus();\n        }\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 全局自定义指令 🔥\n\n上面的局部自定义指令修改：\n\nmain.js\n\nimport { createApp } from \'vue\'\n\nconst app = createApp(App)\n\napp.directive("focus", {\n  mounted(el, bindings, vnode, preVnode) {\n    console.log("focus mounted");\n    el.focus();\n  }\n})\n\napp.mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n然后直接使用即可！！！\n\n\n# 指令的生命周期、参数、修饰符 🔥\n\n一个指令定义的对象，Vue提供了如下的几个钩子函数：\n\n * created：在绑定元素的 attribute 或事件监听器被应用之前调用;\n * beforeMount：当指令第一次绑定到元素并且在挂载父组件之前调用;\n * mounted：在绑定元素的父组件被挂载后调用;\n * beforeUpdate：在更新包含组件的 VNode 之前调用;\n * updated：在包含组件的 VNode 及其子组件的 VNode 更新后调用;\n * beforeUnmount：在卸载绑定元素的父组件之前调用;\n * unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次;\n\n在我们的生命周期中，我们可以通过 bindings 获取到对应的参数（value）和修饰符对象（modifiers）\n\n<template>\n  <div>\n    <button v-if="counter < 2" v-why.aaaa.bbbb="\'coderwhy\'" @click="increment">当前计数: {{counter}}</button>\n  </div>\n</template>\n\n<script>\n  import { ref } from "vue";\n\n  export default {\n    // 局部指令\n    directives: {\n      why: {\n        // preVnode 在 updated 节点会有值\n        created(el, bindings, vnode, preVnode) {\n          console.log("why created", el, bindings, vnode, preVnode);\n          console.log(bindings.value);// 字符串\n          console.log(bindings.modifiers);// 是个对象\n        },\n        beforeMount() {\n          console.log("why beforeMount");\n        },\n        mounted() {\n          console.log("why mounted");\n        },\n        beforeUpdate() {\n          console.log("why beforeUpdate");\n        },\n        updated() {\n          console.log("why updated");\n        },\n        beforeUnmount() {\n          console.log("why beforeUnmount");\n        },\n        unmounted() {\n          console.log("why unmounted");\n        }\n      }\n    },\n    setup() {\n      const counter = ref(0);\n      const increment = () => counter.value++;\n\n      return {\n        counter,\n        increment\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 时间戳格式化指令 🔥🔥🔥\n\n开发要求：\n\n * 在开发中，大多数情况下从服务器获取到的都是时间戳;\n * 我们需要将时间戳转换成具体格式化的时间来展示;\n * 在Vue2中我们可以通过过滤器来完成;\n * 在Vue3中我们可以通过 计算属性(computed) 或者 自定义一个方法(methods) 来完成;\n * 其实我们还可以通过一个自定义的指令来完成;\n\n实现一个可以自动对时间格式化的指令v-format-time\n\n/src/directives/index.js\n\nimport registerFormatTime from \'./format-time\';\n\nexport default function registerDirectives(app) {\n  registerFormatTime(app);\n}\n\n\n1\n2\n3\n4\n5\n\n\n/src/directives/format-time.js\n\nimport dayjs from \'dayjs\'\n\nexport default function (app) {\n  app.directive(\'format-time\', {\n    created(el, bindings) {\n      bindings.formatString = \'YYYY-MM-DD HH:mm:ss\'\n      if (bindings.value) {\n        bindings.formatString = bindings.value\n      }\n    },\n    // 都放入 mounted 也一样！\n    mounted(el, bindings) {\n      const textContent = el.textContent\n      let timestamp = parseInt(textContent)\n      if (textContent.length === 10) {\n        timestamp = timestamp * 1000\n      }\n      el.textContent = dayjs(timestamp).format(bindings.formatString)\n    },\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n/src/main.js\n\nimport registerDirectives from \'./directives\'\nregisterDirectives(app)\n\n\n1\n2\n',normalizedContent:'# 自定义指令\n\n\n# 介绍\n\n在vue的模板语法中我们学习过各种各样的指令：v-show、v-for、v-model等等，除了使用这些指令之外，vue 也允许我们来自定义自己的指令。\n\n * 注意:在vue中，代码的复用和抽象主要还是通过组件;\n * 通常在某些情况下，你需要对dom元素进行底层操作，这个时候就会用到自定义指令;\n\n自定义指令分为两种 :\n\n * 自定义局部指令：组件中通过 directives 选项，只能在当前组件中使用;\n * 自定义全局指令：app的 directive 方法，可以在任意组件中被使用;\n\n比如我们来做一个非常简单的案例:当某个元素挂载完成后可以自定获取焦点\n\n * 实现方式一:如果我们使用默认的实现方式;\n * 实现方式二:自定义一个 v-focus 的局部指令;\n * 实现方式三:自定义一个 v-focus 的全局指令;\n\n\n# 默认的实现方式\n\n<template>\n  <div>\n    <input type="text" ref="input">\n  </div>\n</template>\n\n<script>\n  import { ref, onmounted } from "vue";\n\n  export default {\n    setup() {\n      const input = ref(null);\n\n      onmounted(() => {\n        input.value.focus();\n      })\n\n      return {\n        input\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 局部自定义指令\n\n * 在组件 options 选项中使用 directives 即可\n * 它是一个对象，在对象中编写我们自定义指令的名称（注意:这里不需要加v-）\n * 自定义指令有一个生命周期，是在组件挂载后调用的 mounted，我们可以在其中完成操作\n\n<template>\n  <div>\n    <input type="text" v-focus>\n  </div>\n</template>\n\n<script>\n  export default {\n    // 局部指令\n    directives: {\n      focus: {\n        mounted(el, bindings, vnode, prevnode) {\n          console.log("focus mounted");\n          el.focus();\n        }\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 全局自定义指令 🔥\n\n上面的局部自定义指令修改：\n\nmain.js\n\nimport { createapp } from \'vue\'\n\nconst app = createapp(app)\n\napp.directive("focus", {\n  mounted(el, bindings, vnode, prevnode) {\n    console.log("focus mounted");\n    el.focus();\n  }\n})\n\napp.mount(\'#app\')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n然后直接使用即可！！！\n\n\n# 指令的生命周期、参数、修饰符 🔥\n\n一个指令定义的对象，vue提供了如下的几个钩子函数：\n\n * created：在绑定元素的 attribute 或事件监听器被应用之前调用;\n * beforemount：当指令第一次绑定到元素并且在挂载父组件之前调用;\n * mounted：在绑定元素的父组件被挂载后调用;\n * beforeupdate：在更新包含组件的 vnode 之前调用;\n * updated：在包含组件的 vnode 及其子组件的 vnode 更新后调用;\n * beforeunmount：在卸载绑定元素的父组件之前调用;\n * unmounted：当指令与元素解除绑定且父组件已卸载时，只调用一次;\n\n在我们的生命周期中，我们可以通过 bindings 获取到对应的参数（value）和修饰符对象（modifiers）\n\n<template>\n  <div>\n    <button v-if="counter < 2" v-why.aaaa.bbbb="\'coderwhy\'" @click="increment">当前计数: {{counter}}</button>\n  </div>\n</template>\n\n<script>\n  import { ref } from "vue";\n\n  export default {\n    // 局部指令\n    directives: {\n      why: {\n        // prevnode 在 updated 节点会有值\n        created(el, bindings, vnode, prevnode) {\n          console.log("why created", el, bindings, vnode, prevnode);\n          console.log(bindings.value);// 字符串\n          console.log(bindings.modifiers);// 是个对象\n        },\n        beforemount() {\n          console.log("why beforemount");\n        },\n        mounted() {\n          console.log("why mounted");\n        },\n        beforeupdate() {\n          console.log("why beforeupdate");\n        },\n        updated() {\n          console.log("why updated");\n        },\n        beforeunmount() {\n          console.log("why beforeunmount");\n        },\n        unmounted() {\n          console.log("why unmounted");\n        }\n      }\n    },\n    setup() {\n      const counter = ref(0);\n      const increment = () => counter.value++;\n\n      return {\n        counter,\n        increment\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n\n\n\n# 时间戳格式化指令 🔥🔥🔥\n\n开发要求：\n\n * 在开发中，大多数情况下从服务器获取到的都是时间戳;\n * 我们需要将时间戳转换成具体格式化的时间来展示;\n * 在vue2中我们可以通过过滤器来完成;\n * 在vue3中我们可以通过 计算属性(computed) 或者 自定义一个方法(methods) 来完成;\n * 其实我们还可以通过一个自定义的指令来完成;\n\n实现一个可以自动对时间格式化的指令v-format-time\n\n/src/directives/index.js\n\nimport registerformattime from \'./format-time\';\n\nexport default function registerdirectives(app) {\n  registerformattime(app);\n}\n\n\n1\n2\n3\n4\n5\n\n\n/src/directives/format-time.js\n\nimport dayjs from \'dayjs\'\n\nexport default function (app) {\n  app.directive(\'format-time\', {\n    created(el, bindings) {\n      bindings.formatstring = \'yyyy-mm-dd hh:mm:ss\'\n      if (bindings.value) {\n        bindings.formatstring = bindings.value\n      }\n    },\n    // 都放入 mounted 也一样！\n    mounted(el, bindings) {\n      const textcontent = el.textcontent\n      let timestamp = parseint(textcontent)\n      if (textcontent.length === 10) {\n        timestamp = timestamp * 1000\n      }\n      el.textcontent = dayjs(timestamp).format(bindings.formatstring)\n    },\n  })\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n/src/main.js\n\nimport registerdirectives from \'./directives\'\nregisterdirectives(app)\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/03/24, 16:45:21",lastUpdatedTimestamp:1648140321e3},{title:"Teleport",frontmatter:{title:"Teleport",date:"2022-03-24T22:20:33.000Z",permalink:"/pages/847cf9/",categories:["x","高级语法"],tags:[null]},regularPath:"/1403.Vue3.x/500.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/503.Teleport.html",relativePath:"1403.Vue3.x/500.高级语法/503.Teleport.md",key:"v-ca2df650",path:"/pages/847cf9/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:20},{level:3,title:"Teleport是什么呢?",slug:"teleport是什么呢",normalizedTitle:"teleport是什么呢?",charIndex:247}],headersStr:"介绍 Teleport是什么呢?",content:'# Teleport—Vue3\n\n\n# 介绍\n\n在组件化开发中，我们封装一个组件A，在另外一个组件B中使用:\n\n * 那么组件A中template的元素，会被挂载到组件B中template的某个位置;\n * 最终我们的应用程序会形成一颗DOM树结构;\n\n但是某些情况下，我们希望组件不是挂载在这个组件树上的，可能是移动到Vue app之外的其他位置:\n\n * 比如移动到body元素上，或者我们有其他的div#app之外的元素上;\n * 这个时候我们就可以通过teleport来完成;\n\n\n# Teleport是什么呢?\n\n * 它是一个Vue提供的内置组件，类似于react的 Portals;\n * teleport翻译过来是心灵传输、远距离运输的意思;\n * 它有两个属性:\n   * to：指定将其中的内容移动到的目标元素，可以使用选择器;\n   * disabled：是否禁用 teleport 的功能;\n * 如果我们将多个teleport应用到同一个目标上(to的值相同)，那么这些目标会进行合并\n\n可能会想到 element 的类似this.showMessage()弹窗功能，但其实不是使用该方式实现的！\n\n/public/index.html\n\n<!DOCTYPE html>\n<html lang="">\n  <head>\n    <meta charset="utf-8">\n    <meta http-equiv="X-UA-Compatible" content="IE=edge">\n    <meta name="viewport" content="width=device-width,initial-scale=1.0">\n    <link rel="icon" href="<%= BASE_URL %>favicon.ico">\n    <title><%= htmlWebpackPlugin.options.title %></title>\n  </head>\n  <body>\n    <noscript>\n      <strong>We\'re sorry but <%= htmlWebpackPlugin.options.title %> doesn\'t work properly without JavaScript enabled. Please enable it to continue.</strong>\n    </noscript>\n    <div id="app"></div>\n    \n    <div id="why"></div>\n    \x3c!-- built files will be auto injected --\x3e\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nHelloWorld.vue\n\n<template>\n  <div>\n    <h2>Hello World</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\nApp.vue\n\n<template>\n  <div class="app">\n    <teleport to="#why">\n      <h2>当前计数</h2>\n      <button>+1</button>\n      <hello-world></hello-world>\n    </teleport>\n\n    <teleport to="#why">\n      <span>呵呵呵呵</span>\n    </teleport>\n  </div>\n</template>\n\n<script>\n  import { getCurrentInstance } from "vue";\n\n  import HelloWorld from \'./HelloWorld.vue\';\n\n  export default {\n    components: {\n      HelloWorld\n    },\n    setup() {\n      const instance = getCurrentInstance();\n      console.log(instance.appContext.config.globalProperties.$name);\n    },\n    mounted() {\n      console.log(this.$name);\n    },\n    methods: {\n      foo() {\n        console.log(this.$name);\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',normalizedContent:'# teleport—vue3\n\n\n# 介绍\n\n在组件化开发中，我们封装一个组件a，在另外一个组件b中使用:\n\n * 那么组件a中template的元素，会被挂载到组件b中template的某个位置;\n * 最终我们的应用程序会形成一颗dom树结构;\n\n但是某些情况下，我们希望组件不是挂载在这个组件树上的，可能是移动到vue app之外的其他位置:\n\n * 比如移动到body元素上，或者我们有其他的div#app之外的元素上;\n * 这个时候我们就可以通过teleport来完成;\n\n\n# teleport是什么呢?\n\n * 它是一个vue提供的内置组件，类似于react的 portals;\n * teleport翻译过来是心灵传输、远距离运输的意思;\n * 它有两个属性:\n   * to：指定将其中的内容移动到的目标元素，可以使用选择器;\n   * disabled：是否禁用 teleport 的功能;\n * 如果我们将多个teleport应用到同一个目标上(to的值相同)，那么这些目标会进行合并\n\n可能会想到 element 的类似this.showmessage()弹窗功能，但其实不是使用该方式实现的！\n\n/public/index.html\n\n<!doctype html>\n<html lang="">\n  <head>\n    <meta charset="utf-8">\n    <meta http-equiv="x-ua-compatible" content="ie=edge">\n    <meta name="viewport" content="width=device-width,initial-scale=1.0">\n    <link rel="icon" href="<%= base_url %>favicon.ico">\n    <title><%= htmlwebpackplugin.options.title %></title>\n  </head>\n  <body>\n    <noscript>\n      <strong>we\'re sorry but <%= htmlwebpackplugin.options.title %> doesn\'t work properly without javascript enabled. please enable it to continue.</strong>\n    </noscript>\n    <div id="app"></div>\n    \n    <div id="why"></div>\n    \x3c!-- built files will be auto injected --\x3e\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\nhelloworld.vue\n\n<template>\n  <div>\n    <h2>hello world</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    \n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n\n\napp.vue\n\n<template>\n  <div class="app">\n    <teleport to="#why">\n      <h2>当前计数</h2>\n      <button>+1</button>\n      <hello-world></hello-world>\n    </teleport>\n\n    <teleport to="#why">\n      <span>呵呵呵呵</span>\n    </teleport>\n  </div>\n</template>\n\n<script>\n  import { getcurrentinstance } from "vue";\n\n  import helloworld from \'./helloworld.vue\';\n\n  export default {\n    components: {\n      helloworld\n    },\n    setup() {\n      const instance = getcurrentinstance();\n      console.log(instance.appcontext.config.globalproperties.$name);\n    },\n    mounted() {\n      console.log(this.$name);\n    },\n    methods: {\n      foo() {\n        console.log(this.$name);\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n',charsets:{cjk:!0},lastUpdated:"2022/03/24, 16:45:21",lastUpdatedTimestamp:1648140321e3},{title:"插件",frontmatter:{title:"插件",date:"2022-03-24T22:21:21.000Z",permalink:"/pages/73db51/",categories:["x","高级语法"],tags:[null]},regularPath:"/1403.Vue3.x/500.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/504.%E6%8F%92%E4%BB%B6.html",relativePath:"1403.Vue3.x/500.高级语法/504.插件.md",key:"v-65a89695",path:"/pages/73db51/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:9},{level:2,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:310}],headersStr:"介绍 示例",content:"# 插件\n\n\n# 介绍\n\n通常我们向Vue全局添加一些功能时，会采用插件的模式，它有两种编写方式:\n\n * 对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行;\n * 函数类型：一个function，这个函数会在安装插件时自动执行;\n\n插件可以完成的功能没有限制，比如下面的几种都是可以的：\n\n * 添加全局方法或者 property，通过把它们添加到 config.globalProperties 上实现;\n * 添加全局资源:指令/过滤器/过渡等;\n * 通过全局 mixin 来添加一些组件选项;\n * 一个库，提供自己的 API，同时提供上面提到的一个或多个功能;\n\n\n# 示例\n\n/src/plugins/plugins_object.js\n\nexport default {\n  install(app) {\n    app.config.globalProperties.$name = \"coderwhy\"\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n/src/plugins/plugins_function.js\n\nexport default function(app) {\n  console.log(app);\n}\n\n\n1\n2\n3\n\n\n/src/main.js\n\nimport { createApp } from 'vue'\n\nimport pluginObject from './plugins/plugins_object'\nimport pluginFunction from './plugins/plugins_function'\n\nconst app = createApp(App)\n\n// 这里底层自动执行 plugin.install(app)\napp.use(pluginObject)\napp.use(pluginFunction)\n\napp.mount('#app')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n使用该属性\n\n<template>\n</template>\n\n<script>\n  import { getCurrentInstance } from \"vue\";\n\n  export default {\n    // setup 只能通过该方式获取。其他的正常使用 this 即可\n    setup() {\n      const instance = getCurrentInstance();\n      console.log(instance.appContext.config.globalProperties.$name);\n    },\n    mounted() {\n      console.log(this.$name);\n    },\n    methods: {\n      foo() {\n        console.log(this.$name);\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",normalizedContent:"# 插件\n\n\n# 介绍\n\n通常我们向vue全局添加一些功能时，会采用插件的模式，它有两种编写方式:\n\n * 对象类型：一个对象，但是必须包含一个 install 的函数，该函数会在安装插件时执行;\n * 函数类型：一个function，这个函数会在安装插件时自动执行;\n\n插件可以完成的功能没有限制，比如下面的几种都是可以的：\n\n * 添加全局方法或者 property，通过把它们添加到 config.globalproperties 上实现;\n * 添加全局资源:指令/过滤器/过渡等;\n * 通过全局 mixin 来添加一些组件选项;\n * 一个库，提供自己的 api，同时提供上面提到的一个或多个功能;\n\n\n# 示例\n\n/src/plugins/plugins_object.js\n\nexport default {\n  install(app) {\n    app.config.globalproperties.$name = \"coderwhy\"\n  }\n}\n\n\n1\n2\n3\n4\n5\n\n\n/src/plugins/plugins_function.js\n\nexport default function(app) {\n  console.log(app);\n}\n\n\n1\n2\n3\n\n\n/src/main.js\n\nimport { createapp } from 'vue'\n\nimport pluginobject from './plugins/plugins_object'\nimport pluginfunction from './plugins/plugins_function'\n\nconst app = createapp(app)\n\n// 这里底层自动执行 plugin.install(app)\napp.use(pluginobject)\napp.use(pluginfunction)\n\napp.mount('#app')\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n\n\n使用该属性\n\n<template>\n</template>\n\n<script>\n  import { getcurrentinstance } from \"vue\";\n\n  export default {\n    // setup 只能通过该方式获取。其他的正常使用 this 即可\n    setup() {\n      const instance = getcurrentinstance();\n      console.log(instance.appcontext.config.globalproperties.$name);\n    },\n    mounted() {\n      console.log(this.$name);\n    },\n    methods: {\n      foo() {\n        console.log(this.$name);\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n",charsets:{cjk:!0},lastUpdated:"2022/03/24, 16:45:21",lastUpdatedTimestamp:1648140321e3},{title:"nextTick与eventloop",frontmatter:{title:"nextTick与eventloop",date:"2022-03-24T22:24:31.000Z",permalink:"/pages/e0a730/",categories:["x","高级语法"],tags:[null]},regularPath:"/1403.Vue3.x/500.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/505.nextTick%E4%B8%8Eeventloop.html",relativePath:"1403.Vue3.x/500.高级语法/505.nextTick与eventloop.md",key:"v-7be5c8d6",path:"/pages/e0a730/",headers:[{level:2,title:"nextTick",slug:"nexttick",normalizedTitle:"nexttick",charIndex:2},{level:2,title:"eventloop、任务队列",slug:"eventloop、任务队列",normalizedTitle:"eventloop、任务队列",charIndex:279}],headersStr:"nextTick eventloop、任务队列",content:"# nextTick与eventloop\n\n\n# nextTick\n\n官方解释：将回调推迟到下一个 DOM 更新周期之后执行。在更改了一些数据以等待 DOM 更新后立即使用它\n\n比如我们有下面的需求:\n\n * 点击一个按钮，我们会修改在h2中显示的message;\n * message被修改后，获取h2的高度;\n\n实现上面的案例我们有三种方式:\n\n * 方式一:在点击按钮后立即获取到h2的高度(错误的做法)\n * 方式二:在updated生命周期函数中获取h2的高度(但是其他数据更新，也会执行该操作)\n * 方式三:使用nexttick函数;\n\n\n# eventloop、任务队列\n\nDOM事件、setTimeout等会被放入任务队列，任务队列又分为2种：\n\n * 微任务队列（优先级高）：Promise.resolve().then(回调函数)\n * 宏任务队列（优先级低）：DOM事件、setTimeout\n\nVue中的：\n\n * watch(,回调函数)：preQueue\n * 组件更新 update：jobQueue\n * 生命周期回调：postQueue\n\nnextTick 会将其中回调放入微任务队列最后！",normalizedContent:"# nexttick与eventloop\n\n\n# nexttick\n\n官方解释：将回调推迟到下一个 dom 更新周期之后执行。在更改了一些数据以等待 dom 更新后立即使用它\n\n比如我们有下面的需求:\n\n * 点击一个按钮，我们会修改在h2中显示的message;\n * message被修改后，获取h2的高度;\n\n实现上面的案例我们有三种方式:\n\n * 方式一:在点击按钮后立即获取到h2的高度(错误的做法)\n * 方式二:在updated生命周期函数中获取h2的高度(但是其他数据更新，也会执行该操作)\n * 方式三:使用nexttick函数;\n\n\n# eventloop、任务队列\n\ndom事件、settimeout等会被放入任务队列，任务队列又分为2种：\n\n * 微任务队列（优先级高）：promise.resolve().then(回调函数)\n * 宏任务队列（优先级低）：dom事件、settimeout\n\nvue中的：\n\n * watch(,回调函数)：prequeue\n * 组件更新 update：jobqueue\n * 生命周期回调：postqueue\n\nnexttick 会将其中回调放入微任务队列最后！",charsets:{cjk:!0},lastUpdated:"2022/03/24, 16:45:21",lastUpdatedTimestamp:1648140321e3},{title:"historyApiFallback",frontmatter:{title:"historyApiFallback",date:"2022-03-24T22:51:29.000Z",permalink:"/pages/d4f613/",categories:["x","高级语法"],tags:[null]},regularPath:"/1403.Vue3.x/500.%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95/506.historyApiFallback.html",relativePath:"1403.Vue3.x/500.高级语法/506.historyApiFallback.md",key:"v-501ae650",path:"/pages/d4f613/",headersStr:null,content:"# historyApiFallback\n\n前端路由：\n\n\n\n * historyApiFallback是开发中一个非常常见的属性，它主要的作用是解决SPA页面在路由跳转之后，进行页面刷新时，返回404的错误。\n\n * boolean值:默认是false。如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容;\n\n * object类型的值，可以配置rewrites属性。可以配置from来匹配路径，决定要跳转到哪一个页面;\n\n * 事实上devServer中实现historyApiFallback功能是通过connect-history-api-fallback库的。可以查看connect-history-api-fallback 文档\n\n * Nginx 配置\n   \n   ",normalizedContent:"# historyapifallback\n\n前端路由：\n\n\n\n * historyapifallback是开发中一个非常常见的属性，它主要的作用是解决spa页面在路由跳转之后，进行页面刷新时，返回404的错误。\n\n * boolean值:默认是false。如果设置为true，那么在刷新时，返回404错误时，会自动返回 index.html 的内容;\n\n * object类型的值，可以配置rewrites属性。可以配置from来匹配路径，决定要跳转到哪一个页面;\n\n * 事实上devserver中实现historyapifallback功能是通过connect-history-api-fallback库的。可以查看connect-history-api-fallback 文档\n\n * nginx 配置\n   \n   ",charsets:{cjk:!0},lastUpdated:"2022/03/24, 16:45:21",lastUpdatedTimestamp:1648140321e3},{title:"源码",frontmatter:{title:"源码",date:"2022-01-13T19:16:38.000Z",permalink:"/pages/2e2905/",categories:["x","基础"],tags:[null]},regularPath:"/1403.Vue3.x/600.Vue%E6%BA%90%E7%A0%81/601.%E6%BA%90%E7%A0%81.html",relativePath:"1403.Vue3.x/600.Vue源码/601.源码.md",key:"v-f262342e",path:"/pages/2e2905/",headers:[{level:2,title:"源码 clone 🔥",slug:"源码-clone-🔥",normalizedTitle:"源码 clone 🔥",charIndex:9},{level:2,title:"源码之 createApp",slug:"源码之-createapp",normalizedTitle:"源码之 createapp",charIndex:1794},{level:2,title:"源码阅读之挂载根组件",slug:"源码阅读之挂载根组件",normalizedTitle:"源码阅读之挂载根组件",charIndex:1814},{level:2,title:"组件化的初始化",slug:"组件化的初始化",normalizedTitle:"组件化的初始化",charIndex:1831},{level:2,title:"template中数据的使用顺序",slug:"template中数据的使用顺序",normalizedTitle:"template中数据的使用顺序",charIndex:1845}],headersStr:"源码 clone 🔥 源码之 createApp 源码阅读之挂载根组件 组件化的初始化 template中数据的使用顺序",content:'# 源码\n\n\n# 源码 clone 🔥\n\n步骤：\n\n 1. git clone git@github.com:vuejs/vue-next.git\n\n 2. git checkout -b conangan-v3.2.9 v3.2.9切换并创建分支。可以使用git tag查看 tag\n\n 3. yarn安装依赖\n\n 4. 在 package.json 中的 dev 选项后面加上 --sourcemap，就可以在debug时看到独立的文件而不是打包后的文件\n\n 5. 执行yarn dev命令，会自动打包文件，并会生成packages/vue/dist/vue.global.js和*.map文件\n\n 6. 创建packages/vue/examples/conanan这个目录，用于自己写demo\n    \n    <!DOCTYPE html>\n    <html lang="en">\n      <head>\n        <meta charset="UTF-8" />\n        <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>Document</title>\n      </head>\n      <body>\n        <div id="app"></div>\n    \n        <template id="temp">\n          <button @click="decrement">-</button>\n          <span>{{counter}}</span>\n          <button @click="increment">+</button>\n        </template>\n    \n        <script src="../../dist/vue.global.js"><\/script>\n    \n        <script>\n          const options = {\n            template: \'#temp\', //\n            data() {\n              return {\n                counter: 0\n              }\n            },\n            methods: {\n              decrement() {\n                this.counter--\n              },\n              increment() {\n                this.counter++\n              }\n            }\n          }\n          // debugger\n          const vm = Vue.createApp(options).mount(\'#app\')\n        <\/script>\n      </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    \n    \n    debug会发现createApp进入的是index.ts文件，而不是上面生成的vue.global.js\n\n\n# 源码之 createApp\n\n\n\n\n# 源码阅读之挂载根组件\n\n\n\n\n# 组件化的初始化\n\n\n\n\n# template中数据的使用顺序\n\n// data / props / ctx\n// This getter gets called for every property access on the render context\n// during render and is a major hotspot. The most expensive part of this\n// is the multiple hasOwn() calls. It\'s much faster to do a simple property\n// access on a plain object, so we use an accessCache object (with null\n// prototype) to memoize what access type a key corresponds to.\nlet normalizedProps\nif (key[0] !== \'$\') {\n    const n = accessCache![key]\n    if (n !== undefined) {\n        switch (n) {\n            case AccessTypes.SETUP:\n                return setupState[key]\n            case AccessTypes.DATA:\n                return data[key]\n            case AccessTypes.CONTEXT:\n                return ctx[key]\n            case AccessTypes.PROPS:\n                return props![key]\n                // default: just fallthrough\n        }\n    } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {\n        accessCache![key] = AccessTypes.SETUP\n        return setupState[key]\n    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {\n        accessCache![key] = AccessTypes.DATA\n        return data[key]\n    } else if (\n        // only cache other properties when instance has declared (thus stable)\n        // props\n        (normalizedProps = instance.propsOptions[0]) &&\n        hasOwn(normalizedProps, key)\n    ) {\n        accessCache![key] = AccessTypes.PROPS\n        return props![key]\n    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {\n        accessCache![key] = AccessTypes.CONTEXT\n        return ctx[key]\n    } else if (!__FEATURE_OPTIONS_API__ || shouldCacheAccess) {\n        accessCache![key] = AccessTypes.OTHER\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n由源码可知：setup——data——props——ctx（methods、computed）',normalizedContent:'# 源码\n\n\n# 源码 clone 🔥\n\n步骤：\n\n 1. git clone git@github.com:vuejs/vue-next.git\n\n 2. git checkout -b conangan-v3.2.9 v3.2.9切换并创建分支。可以使用git tag查看 tag\n\n 3. yarn安装依赖\n\n 4. 在 package.json 中的 dev 选项后面加上 --sourcemap，就可以在debug时看到独立的文件而不是打包后的文件\n\n 5. 执行yarn dev命令，会自动打包文件，并会生成packages/vue/dist/vue.global.js和*.map文件\n\n 6. 创建packages/vue/examples/conanan这个目录，用于自己写demo\n    \n    <!doctype html>\n    <html lang="en">\n      <head>\n        <meta charset="utf-8" />\n        <meta http-equiv="x-ua-compatible" content="ie=edge" />\n        <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n        <title>document</title>\n      </head>\n      <body>\n        <div id="app"></div>\n    \n        <template id="temp">\n          <button @click="decrement">-</button>\n          <span>{{counter}}</span>\n          <button @click="increment">+</button>\n        </template>\n    \n        <script src="../../dist/vue.global.js"><\/script>\n    \n        <script>\n          const options = {\n            template: \'#temp\', //\n            data() {\n              return {\n                counter: 0\n              }\n            },\n            methods: {\n              decrement() {\n                this.counter--\n              },\n              increment() {\n                this.counter++\n              }\n            }\n          }\n          // debugger\n          const vm = vue.createapp(options).mount(\'#app\')\n        <\/script>\n      </body>\n    </html>\n    \n    \n    1\n    2\n    3\n    4\n    5\n    6\n    7\n    8\n    9\n    10\n    11\n    12\n    13\n    14\n    15\n    16\n    17\n    18\n    19\n    20\n    21\n    22\n    23\n    24\n    25\n    26\n    27\n    28\n    29\n    30\n    31\n    32\n    33\n    34\n    35\n    36\n    37\n    38\n    39\n    40\n    41\n    \n    \n    debug会发现createapp进入的是index.ts文件，而不是上面生成的vue.global.js\n\n\n# 源码之 createapp\n\n\n\n\n# 源码阅读之挂载根组件\n\n\n\n\n# 组件化的初始化\n\n\n\n\n# template中数据的使用顺序\n\n// data / props / ctx\n// this getter gets called for every property access on the render context\n// during render and is a major hotspot. the most expensive part of this\n// is the multiple hasown() calls. it\'s much faster to do a simple property\n// access on a plain object, so we use an accesscache object (with null\n// prototype) to memoize what access type a key corresponds to.\nlet normalizedprops\nif (key[0] !== \'$\') {\n    const n = accesscache![key]\n    if (n !== undefined) {\n        switch (n) {\n            case accesstypes.setup:\n                return setupstate[key]\n            case accesstypes.data:\n                return data[key]\n            case accesstypes.context:\n                return ctx[key]\n            case accesstypes.props:\n                return props![key]\n                // default: just fallthrough\n        }\n    } else if (setupstate !== empty_obj && hasown(setupstate, key)) {\n        accesscache![key] = accesstypes.setup\n        return setupstate[key]\n    } else if (data !== empty_obj && hasown(data, key)) {\n        accesscache![key] = accesstypes.data\n        return data[key]\n    } else if (\n        // only cache other properties when instance has declared (thus stable)\n        // props\n        (normalizedprops = instance.propsoptions[0]) &&\n        hasown(normalizedprops, key)\n    ) {\n        accesscache![key] = accesstypes.props\n        return props![key]\n    } else if (ctx !== empty_obj && hasown(ctx, key)) {\n        accesscache![key] = accesstypes.context\n        return ctx[key]\n    } else if (!__feature_options_api__ || shouldcacheaccess) {\n        accesscache![key] = accesstypes.other\n    }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n\n\n由源码可知：setup——data——props——ctx（methods、computed）',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"MiniVue",frontmatter:{title:"MiniVue",date:"2022-02-07T22:56:15.000Z",permalink:"/pages/6f4bd5/",categories:["x","Vue源码"],tags:[null]},regularPath:"/1403.Vue3.x/600.Vue%E6%BA%90%E7%A0%81/611.MiniVue.html",relativePath:"1403.Vue3.x/600.Vue源码/611.MiniVue.md",key:"v-189a620b",path:"/pages/6f4bd5/",headers:[{level:2,title:"渲染系统实现",slug:"渲染系统实现",normalizedTitle:"渲染系统实现",charIndex:87},{level:2,title:"响应式系统 Vue2 实现",slug:"响应式系统-vue2-实现",normalizedTitle:"响应式系统 vue2 实现",charIndex:4897},{level:2,title:"响应式系统 Vue3 实现",slug:"响应式系统-vue3-实现",normalizedTitle:"响应式系统 vue3 实现",charIndex:7044},{level:3,title:"为什么Vue3选择Proxy呢",slug:"为什么vue3选择proxy呢",normalizedTitle:"为什么vue3选择proxy呢",charIndex:9013},{level:2,title:"入口函数",slug:"入口函数",normalizedTitle:"入口函数",charIndex:9461}],headersStr:"渲染系统实现 响应式系统 Vue2 实现 响应式系统 Vue3 实现 为什么Vue3选择Proxy呢 入口函数",content:'# MiniVue\n\n这里我们实现一个简洁版的Mini-Vue框架，该Vue包括三个模块:\n\n * 渲染系统模块;\n * 响应式系统模块;\n * 应用程序入口模块;\n\n\n# 渲染系统实现\n\n渲染系统，该模块主要包含三个功能:\n\n * 功能一:h函数，用于返回一个VNode对象;\n * 功能二:mount函数，用于将VNode挂载到DOM上;\n * 功能三:patch函数，用于对两个VNode进行对比，决定如何处理新的VNode\n\nconst h = (tag, props, children) => {\n  // vnode -> javascript对象 -> {}\n  return {\n    tag,\n    props,\n    children,\n  }\n}\n\nconst mount = (vnode, container) => {\n  // vnode -> element\n  // 1.创建出真实的原生, 并且在vnode上保留el\n  const el = (vnode.el = document.createElement(vnode.tag))\n\n  // 2.处理props\n  if (vnode.props) {\n    for (const key in vnode.props) {\n      const value = vnode.props[key]\n\n      if (key.startsWith(\'on\')) {\n        // 对事件监听的判断\n        el.addEventListener(key.slice(2).toLowerCase(), value)\n      } else {\n        el.setAttribute(key, value)\n      }\n    }\n  }\n\n  // 3.处理children\n  if (vnode.children) {\n    if (typeof vnode.children === \'string\') {\n      el.textContent = vnode.children\n    } else {\n      vnode.children.forEach((item) => {\n        mount(item, el)\n      })\n    }\n  }\n\n  // 4.将el挂载到container上\n  container.appendChild(el)\n}\n\nconst patch = (n1, n2) => {\n  if (n1.tag !== n2.tag) {\n    const n1ElParent = n1.el.parentElement\n    n1ElParent.removeChild(n1.el)\n    mount(n2, n1ElParent)\n  } else {\n    // 1.取出element对象, 并且在n2中进行保存\n    const el = (n2.el = n1.el)\n\n    // 2.处理props\n    const oldProps = n1.props || {}\n    const newProps = n2.props || {}\n    // 2.1.获取所有的newProps添加到el\n    for (const key in newProps) {\n      const oldValue = oldProps[key]\n      const newValue = newProps[key]\n      if (newValue !== oldValue) {\n        if (key.startsWith(\'on\')) {\n          // 对事件监听的判断\n          el.addEventListener(key.slice(2).toLowerCase(), newValue)\n        } else {\n          el.setAttribute(key, newValue)\n        }\n      }\n    }\n\n    // 2.2.删除旧的props\n    for (const key in oldProps) {\n      if (key.startsWith(\'on\')) {\n        // 对事件监听的判断，每次移除所有旧的事件，否则在添加props时会重复（事件函数newValue !== oldValue为 true）\n        const value = oldProps[key]\n        el.removeEventListener(key.slice(2).toLowerCase(), value)\n      }\n      if (!(key in newProps)) {\n        el.removeAttribute(key)\n      }\n    }\n\n    // 3.处理children\n    const oldChildren = n1.children || []\n    const newChidlren = n2.children || []\n\n    if (typeof newChidlren === \'string\') {\n      // 情况一: newChildren本身是一个string\n      // 边界情况 (edge case)\n      if (typeof oldChildren === \'string\') {\n        if (newChidlren !== oldChildren) {\n          el.textContent = newChidlren\n        }\n      } else {\n        el.innerHTML = newChidlren\n      }\n    } else {\n      // 情况二: newChildren本身是一个数组\n      if (typeof oldChildren === \'string\') {\n        el.innerHTML = \'\'\n        newChidlren.forEach((item) => {\n          mount(item, el)\n        })\n      } else {\n        // oldChildren: [v1, v2, v3, v8, v9]\n        // newChildren: [v1, v5, v6]\n        // 1.前面有相同节点的原生进行patch操作\n        const commonLength = Math.min(oldChildren.length, newChidlren.length)\n        for (let i = 0; i < commonLength; i++) {\n          patch(oldChildren[i], newChidlren[i])\n        }\n\n        // 2.newChildren.length > oldChildren.length\n        if (newChidlren.length > oldChildren.length) {\n          newChidlren.slice(oldChildren.length).forEach((item) => {\n            mount(item, el)\n          })\n        }\n\n        // 3.newChildren.length < oldChildren.length\n        if (newChidlren.length < oldChildren.length) {\n          oldChildren.slice(newChidlren.length).forEach((item) => {\n            el.removeChild(item.el)\n          })\n        }\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  \n  <div id="app"></div>\n\n  <script src="./renderer.js"><\/script>\n  <script>\n\n    // 1.通过h函数来创建一个vnode\n    const vnode = h(\'div\', {class: "why", id: "aaa"}, [\n      h("h2", null, "当前计数: 100"),\n      h("button", {onClick: function() {}}, "+1")\n    ]); // vdom\n\n    // 2.通过mount函数, 将vnode挂载到div#app上\n    mount(vnode, document.querySelector("#app"))\n\n    // 3.创建新的vnode\n    setTimeout(() => {\n      const vnode1 = h(\'div\', {class: "coderwhy", id: "aaa"}, [\n        h("h2", null, "呵呵呵"),\n        h("button", {onClick: function() {}}, "-1")\n      ]); \n      patch(vnode, vnode1);\n    }, 2000)\n\n  <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 响应式系统 Vue2 实现\n\nclass Dep {\n  constructor() {\n    this.subscribers = new Set()\n  }\n\n  depend() {\n    if (activeEffect) {\n      this.subscribers.add(activeEffect)\n    }\n  }\n\n  notify() {\n    this.subscribers.forEach((effect) => {\n      effect()\n    })\n  }\n}\n\nlet activeEffect = null\nfunction watchEffect(effect) {\n  activeEffect = effect\n  effect()\n  activeEffect = null\n}\n\n// Map({key: value}): key是一个字符串\n// WeakMap({key(对象): value}): key是一个对象, 弱引用\nconst targetMap = new WeakMap()\nfunction getDep(target, key) {\n  // 1.根据对象(target)取出对应的Map对象\n  let depsMap = targetMap.get(target)\n  if (!depsMap) {\n    depsMap = new Map()\n    targetMap.set(target, depsMap)\n  }\n\n  // 2.取出具体的dep对象\n  let dep = depsMap.get(key)\n  if (!dep) {\n    dep = new Dep()\n    depsMap.set(key, dep)\n  }\n  return dep\n}\n\n// vue2对raw进行数据劫持\nfunction reactive(raw) {\n  Object.keys(raw).forEach((key) => {\n    const dep = getDep(raw, key)\n    let value = raw[key]\n\n    Object.defineProperty(raw, key, {\n      get() {\n        dep.depend()\n        return value\n      },\n      set(newValue) {\n        if (value !== newValue) {\n          value = newValue\n          dep.notify()\n        }\n      },\n    })\n  })\n\n  return raw\n}\n\n// 测试代码\n// 先defineProperty劫持对象属性，不会调用其get、set方法\nconst info = reactive({ counter: 100, name: \'why\' })\nconst foo = reactive({ height: 1.88 })\n\n// 调用 watchEffect，确定当前 activeEffect，自动执行该 effect，\n// 此时.调用会执行get方法，dep.depend()会将该effect加入该key的Dep中\n// watchEffect1\nwatchEffect(function () {\n  console.log(\'effect1:\', info.counter * 2, info.name)\n})\n\n// watchEffect2\nwatchEffect(function () {\n  console.log(\'effect2:\', info.counter * info.counter)\n})\n\n// watchEffect3\nwatchEffect(function () {\n  console.log(\'effect3:\', info.counter + 10, info.name)\n})\n\nwatchEffect(function () {\n  console.log(\'effect4:\', foo.height)\n})\n\n// info.counter++;\n// info.name = "why";\n\nfoo.height = 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n\n# 响应式系统 Vue3 实现\n\nclass Dep {\n  constructor() {\n    this.subscribers = new Set()\n  }\n\n  depend() {\n    if (activeEffect) {\n      this.subscribers.add(activeEffect)\n    }\n  }\n\n  notify() {\n    this.subscribers.forEach((effect) => {\n      effect()\n    })\n  }\n}\n\nlet activeEffect = null\nfunction watchEffect(effect) {\n  activeEffect = effect\n  effect()\n  activeEffect = null\n}\n\n// Map({key: value}): key是一个字符串\n// WeakMap({key(对象): value}): key是一个对象, 弱引用\nconst targetMap = new WeakMap()\nfunction getDep(target, key) {\n  // 1.根据对象(target)取出对应的Map对象\n  let depsMap = targetMap.get(target)\n  if (!depsMap) {\n    depsMap = new Map()\n    targetMap.set(target, depsMap)\n  }\n\n  // 2.取出具体的dep对象\n  let dep = depsMap.get(key)\n  if (!dep) {\n    dep = new Dep()\n    depsMap.set(key, dep)\n  }\n  return dep\n}\n\n// vue3对raw进行数据劫持\nfunction reactive(raw) {\n  return new Proxy(raw, {\n    get(target, key) {\n      const dep = getDep(target, key)\n      dep.depend()\n      return target[key]\n    },\n    set(target, key, newValue) {\n      const dep = getDep(target, key)\n      target[key] = newValue\n      dep.notify()\n    },\n  })\n}\n\n// const proxy = reactive({name: "123"})\n// proxy.name = "321";\n\n// 测试代码\nconst info = reactive({ counter: 100, name: \'why\' })\nconst foo = reactive({ height: 1.88 })\n\n// watchEffect1\nwatchEffect(function () {\n  console.log(\'effect1:\', info.counter * 2, info.name)\n})\n\n// watchEffect2\nwatchEffect(function () {\n  console.log(\'effect2:\', info.counter * info.counter)\n})\n\n// watchEffect3\nwatchEffect(function () {\n  console.log(\'effect3:\', info.counter + 10, info.name)\n})\n\nwatchEffect(function () {\n  console.log(\'effect4:\', foo.height)\n})\n\n// info.counter++;\n// info.name = "why";\n\nfoo.height = 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n\n# 为什么Vue3选择Proxy呢\n\n * 劫持目标\n   \n   * Object.definedProperty 是劫持对象的属性时，如果新增元素，那么Vue2需要再次 调用definedProperty，\n   * Proxy 劫持的是整个对象，不需要做特殊处理;\n\n * 修改对象的不同:\n   \n   * 使用 defineProperty 时，我们修改原来的 obj 对象就可以触发拦截;\n   * 而使用 proxy，就必须修改代理对象，即 Proxy 的实例才可以触发拦截;\n\n * Proxy 能观察的类型比 defineProperty 更丰富\n   \n   * has:in操作符的捕获器;\n   * deleteProperty:delete 操作符的捕捉器;\n   * 等等其他操作;\n\n * Proxy 作为新标准将受到浏览器厂商重点持续的性能优化;\n\n * 缺点:Proxy 不兼容IE，也没有 polyfill, defineProperty 能支持到IE9\n\n\n# 入口函数\n\nfunction createApp(rootComponent) {\n  return {\n    mount(selector) {\n      const container = document.querySelector(selector)\n      let isMounted = false\n      let oldVNode = null\n\n      watchEffect(function () {\n        if (!isMounted) {\n          // 第一次进入需要 mount 挂载\n          oldVNode = rootComponent.render()\n          mount(oldVNode, container)\n          isMounted = true\n        } else {\n          // 非第一次进入需要 patch 更新\n          const newVNode = rootComponent.render()\n          patch(oldVNode, newVNode)\n          oldVNode = newVNode\n        }\n      })\n    },\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  \n  <div id="app"></div>\n  <script src="../02_渲染器实现/renderer.js"><\/script>\n  <script src="../03_响应式系统/reactive.js"><\/script>\n  <script src="./index.js"><\/script>\n\n  <script>\n    // 1.创建根组件\n    const App = {\n      data: reactive({\n        counter: 0\n      }),\n      render() {\n        return h("div", null, [\n          h("h2", null, `当前计数: ${this.data.counter}`),\n          h("button", {\n            onClick: () => {\n              this.data.counter++\n              console.log(this.data.counter);\n            }\n          }, "+1")\n        ])\n      }\n    }\n\n    // 2.挂载根组件\n    const app = createApp(App);\n    app.mount("#app");\n  <\/script>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n',normalizedContent:'# minivue\n\n这里我们实现一个简洁版的mini-vue框架，该vue包括三个模块:\n\n * 渲染系统模块;\n * 响应式系统模块;\n * 应用程序入口模块;\n\n\n# 渲染系统实现\n\n渲染系统，该模块主要包含三个功能:\n\n * 功能一:h函数，用于返回一个vnode对象;\n * 功能二:mount函数，用于将vnode挂载到dom上;\n * 功能三:patch函数，用于对两个vnode进行对比，决定如何处理新的vnode\n\nconst h = (tag, props, children) => {\n  // vnode -> javascript对象 -> {}\n  return {\n    tag,\n    props,\n    children,\n  }\n}\n\nconst mount = (vnode, container) => {\n  // vnode -> element\n  // 1.创建出真实的原生, 并且在vnode上保留el\n  const el = (vnode.el = document.createelement(vnode.tag))\n\n  // 2.处理props\n  if (vnode.props) {\n    for (const key in vnode.props) {\n      const value = vnode.props[key]\n\n      if (key.startswith(\'on\')) {\n        // 对事件监听的判断\n        el.addeventlistener(key.slice(2).tolowercase(), value)\n      } else {\n        el.setattribute(key, value)\n      }\n    }\n  }\n\n  // 3.处理children\n  if (vnode.children) {\n    if (typeof vnode.children === \'string\') {\n      el.textcontent = vnode.children\n    } else {\n      vnode.children.foreach((item) => {\n        mount(item, el)\n      })\n    }\n  }\n\n  // 4.将el挂载到container上\n  container.appendchild(el)\n}\n\nconst patch = (n1, n2) => {\n  if (n1.tag !== n2.tag) {\n    const n1elparent = n1.el.parentelement\n    n1elparent.removechild(n1.el)\n    mount(n2, n1elparent)\n  } else {\n    // 1.取出element对象, 并且在n2中进行保存\n    const el = (n2.el = n1.el)\n\n    // 2.处理props\n    const oldprops = n1.props || {}\n    const newprops = n2.props || {}\n    // 2.1.获取所有的newprops添加到el\n    for (const key in newprops) {\n      const oldvalue = oldprops[key]\n      const newvalue = newprops[key]\n      if (newvalue !== oldvalue) {\n        if (key.startswith(\'on\')) {\n          // 对事件监听的判断\n          el.addeventlistener(key.slice(2).tolowercase(), newvalue)\n        } else {\n          el.setattribute(key, newvalue)\n        }\n      }\n    }\n\n    // 2.2.删除旧的props\n    for (const key in oldprops) {\n      if (key.startswith(\'on\')) {\n        // 对事件监听的判断，每次移除所有旧的事件，否则在添加props时会重复（事件函数newvalue !== oldvalue为 true）\n        const value = oldprops[key]\n        el.removeeventlistener(key.slice(2).tolowercase(), value)\n      }\n      if (!(key in newprops)) {\n        el.removeattribute(key)\n      }\n    }\n\n    // 3.处理children\n    const oldchildren = n1.children || []\n    const newchidlren = n2.children || []\n\n    if (typeof newchidlren === \'string\') {\n      // 情况一: newchildren本身是一个string\n      // 边界情况 (edge case)\n      if (typeof oldchildren === \'string\') {\n        if (newchidlren !== oldchildren) {\n          el.textcontent = newchidlren\n        }\n      } else {\n        el.innerhtml = newchidlren\n      }\n    } else {\n      // 情况二: newchildren本身是一个数组\n      if (typeof oldchildren === \'string\') {\n        el.innerhtml = \'\'\n        newchidlren.foreach((item) => {\n          mount(item, el)\n        })\n      } else {\n        // oldchildren: [v1, v2, v3, v8, v9]\n        // newchildren: [v1, v5, v6]\n        // 1.前面有相同节点的原生进行patch操作\n        const commonlength = math.min(oldchildren.length, newchidlren.length)\n        for (let i = 0; i < commonlength; i++) {\n          patch(oldchildren[i], newchidlren[i])\n        }\n\n        // 2.newchildren.length > oldchildren.length\n        if (newchidlren.length > oldchildren.length) {\n          newchidlren.slice(oldchildren.length).foreach((item) => {\n            mount(item, el)\n          })\n        }\n\n        // 3.newchildren.length < oldchildren.length\n        if (newchidlren.length < oldchildren.length) {\n          oldchildren.slice(newchidlren.length).foreach((item) => {\n            el.removechild(item.el)\n          })\n        }\n      }\n    }\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n\n\n<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <meta http-equiv="x-ua-compatible" content="ie=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>document</title>\n</head>\n<body>\n  \n  <div id="app"></div>\n\n  <script src="./renderer.js"><\/script>\n  <script>\n\n    // 1.通过h函数来创建一个vnode\n    const vnode = h(\'div\', {class: "why", id: "aaa"}, [\n      h("h2", null, "当前计数: 100"),\n      h("button", {onclick: function() {}}, "+1")\n    ]); // vdom\n\n    // 2.通过mount函数, 将vnode挂载到div#app上\n    mount(vnode, document.queryselector("#app"))\n\n    // 3.创建新的vnode\n    settimeout(() => {\n      const vnode1 = h(\'div\', {class: "coderwhy", id: "aaa"}, [\n        h("h2", null, "呵呵呵"),\n        h("button", {onclick: function() {}}, "-1")\n      ]); \n      patch(vnode, vnode1);\n    }, 2000)\n\n  <\/script>\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n\n\n\n# 响应式系统 vue2 实现\n\nclass dep {\n  constructor() {\n    this.subscribers = new set()\n  }\n\n  depend() {\n    if (activeeffect) {\n      this.subscribers.add(activeeffect)\n    }\n  }\n\n  notify() {\n    this.subscribers.foreach((effect) => {\n      effect()\n    })\n  }\n}\n\nlet activeeffect = null\nfunction watcheffect(effect) {\n  activeeffect = effect\n  effect()\n  activeeffect = null\n}\n\n// map({key: value}): key是一个字符串\n// weakmap({key(对象): value}): key是一个对象, 弱引用\nconst targetmap = new weakmap()\nfunction getdep(target, key) {\n  // 1.根据对象(target)取出对应的map对象\n  let depsmap = targetmap.get(target)\n  if (!depsmap) {\n    depsmap = new map()\n    targetmap.set(target, depsmap)\n  }\n\n  // 2.取出具体的dep对象\n  let dep = depsmap.get(key)\n  if (!dep) {\n    dep = new dep()\n    depsmap.set(key, dep)\n  }\n  return dep\n}\n\n// vue2对raw进行数据劫持\nfunction reactive(raw) {\n  object.keys(raw).foreach((key) => {\n    const dep = getdep(raw, key)\n    let value = raw[key]\n\n    object.defineproperty(raw, key, {\n      get() {\n        dep.depend()\n        return value\n      },\n      set(newvalue) {\n        if (value !== newvalue) {\n          value = newvalue\n          dep.notify()\n        }\n      },\n    })\n  })\n\n  return raw\n}\n\n// 测试代码\n// 先defineproperty劫持对象属性，不会调用其get、set方法\nconst info = reactive({ counter: 100, name: \'why\' })\nconst foo = reactive({ height: 1.88 })\n\n// 调用 watcheffect，确定当前 activeeffect，自动执行该 effect，\n// 此时.调用会执行get方法，dep.depend()会将该effect加入该key的dep中\n// watcheffect1\nwatcheffect(function () {\n  console.log(\'effect1:\', info.counter * 2, info.name)\n})\n\n// watcheffect2\nwatcheffect(function () {\n  console.log(\'effect2:\', info.counter * info.counter)\n})\n\n// watcheffect3\nwatcheffect(function () {\n  console.log(\'effect3:\', info.counter + 10, info.name)\n})\n\nwatcheffect(function () {\n  console.log(\'effect4:\', foo.height)\n})\n\n// info.counter++;\n// info.name = "why";\n\nfoo.height = 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n\n\n\n# 响应式系统 vue3 实现\n\nclass dep {\n  constructor() {\n    this.subscribers = new set()\n  }\n\n  depend() {\n    if (activeeffect) {\n      this.subscribers.add(activeeffect)\n    }\n  }\n\n  notify() {\n    this.subscribers.foreach((effect) => {\n      effect()\n    })\n  }\n}\n\nlet activeeffect = null\nfunction watcheffect(effect) {\n  activeeffect = effect\n  effect()\n  activeeffect = null\n}\n\n// map({key: value}): key是一个字符串\n// weakmap({key(对象): value}): key是一个对象, 弱引用\nconst targetmap = new weakmap()\nfunction getdep(target, key) {\n  // 1.根据对象(target)取出对应的map对象\n  let depsmap = targetmap.get(target)\n  if (!depsmap) {\n    depsmap = new map()\n    targetmap.set(target, depsmap)\n  }\n\n  // 2.取出具体的dep对象\n  let dep = depsmap.get(key)\n  if (!dep) {\n    dep = new dep()\n    depsmap.set(key, dep)\n  }\n  return dep\n}\n\n// vue3对raw进行数据劫持\nfunction reactive(raw) {\n  return new proxy(raw, {\n    get(target, key) {\n      const dep = getdep(target, key)\n      dep.depend()\n      return target[key]\n    },\n    set(target, key, newvalue) {\n      const dep = getdep(target, key)\n      target[key] = newvalue\n      dep.notify()\n    },\n  })\n}\n\n// const proxy = reactive({name: "123"})\n// proxy.name = "321";\n\n// 测试代码\nconst info = reactive({ counter: 100, name: \'why\' })\nconst foo = reactive({ height: 1.88 })\n\n// watcheffect1\nwatcheffect(function () {\n  console.log(\'effect1:\', info.counter * 2, info.name)\n})\n\n// watcheffect2\nwatcheffect(function () {\n  console.log(\'effect2:\', info.counter * info.counter)\n})\n\n// watcheffect3\nwatcheffect(function () {\n  console.log(\'effect3:\', info.counter + 10, info.name)\n})\n\nwatcheffect(function () {\n  console.log(\'effect4:\', foo.height)\n})\n\n// info.counter++;\n// info.name = "why";\n\nfoo.height = 2\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n\n\n\n# 为什么vue3选择proxy呢\n\n * 劫持目标\n   \n   * object.definedproperty 是劫持对象的属性时，如果新增元素，那么vue2需要再次 调用definedproperty，\n   * proxy 劫持的是整个对象，不需要做特殊处理;\n\n * 修改对象的不同:\n   \n   * 使用 defineproperty 时，我们修改原来的 obj 对象就可以触发拦截;\n   * 而使用 proxy，就必须修改代理对象，即 proxy 的实例才可以触发拦截;\n\n * proxy 能观察的类型比 defineproperty 更丰富\n   \n   * has:in操作符的捕获器;\n   * deleteproperty:delete 操作符的捕捉器;\n   * 等等其他操作;\n\n * proxy 作为新标准将受到浏览器厂商重点持续的性能优化;\n\n * 缺点:proxy 不兼容ie，也没有 polyfill, defineproperty 能支持到ie9\n\n\n# 入口函数\n\nfunction createapp(rootcomponent) {\n  return {\n    mount(selector) {\n      const container = document.queryselector(selector)\n      let ismounted = false\n      let oldvnode = null\n\n      watcheffect(function () {\n        if (!ismounted) {\n          // 第一次进入需要 mount 挂载\n          oldvnode = rootcomponent.render()\n          mount(oldvnode, container)\n          ismounted = true\n        } else {\n          // 非第一次进入需要 patch 更新\n          const newvnode = rootcomponent.render()\n          patch(oldvnode, newvnode)\n          oldvnode = newvnode\n        }\n      })\n    },\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <meta http-equiv="x-ua-compatible" content="ie=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>document</title>\n</head>\n<body>\n  \n  <div id="app"></div>\n  <script src="../02_渲染器实现/renderer.js"><\/script>\n  <script src="../03_响应式系统/reactive.js"><\/script>\n  <script src="./index.js"><\/script>\n\n  <script>\n    // 1.创建根组件\n    const app = {\n      data: reactive({\n        counter: 0\n      }),\n      render() {\n        return h("div", null, [\n          h("h2", null, `当前计数: ${this.data.counter}`),\n          h("button", {\n            onclick: () => {\n              this.data.counter++\n              console.log(this.data.counter);\n            }\n          }, "+1")\n        ])\n      }\n    }\n\n    // 2.挂载根组件\n    const app = createapp(app);\n    app.mount("#app");\n  <\/script>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"VueCLI",frontmatter:{title:"VueCLI",date:"2022-01-28T01:26:52.000Z",permalink:"/pages/af8fd5/",categories:["x","VueCLI&Vite"],tags:[null]},regularPath:"/1403.Vue3.x/700.VueCLI&Vite/100.VueCLI.html",relativePath:"1403.Vue3.x/700.VueCLI&Vite/100.VueCLI.md",key:"v-7593113f",path:"/pages/af8fd5/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:13},{level:2,title:"CLI 原理",slug:"cli-原理",normalizedTitle:"cli 原理",charIndex:129}],headersStr:"安装 CLI 原理",content:'# VueCLI\n\n\n# 安装\n\n全局安装\n\n npm install @vue/cli -g\n\n\n1\n\n\n升级\n\n npm update @vue/cli -g\n\n\n1\n\n\n通过Vue的命令来创建项目\n\nvue create [项目名]\n\n\n1\n\n\n\n# CLI 原理\n\n查看package.json\n\n"scripts": {\n    "serve": "vue-cli-service serve",\n    "build": "vue-cli-service build",\n},\n\n\n1\n2\n3\n4\n\n\n在/node_modules/.bin/vue-cli-service可以看到该命令，但是里面有段代码\n\nconst Service = require(\'../lib/Service\')\n\n\n1\n\n\n.bin下没有该目录，仔细查看可以发现 vue-cli-service 是一个软连接。连接到/node_modules/@vue/cli-service。\n\n其他的自己看！！！\n\n',normalizedContent:'# vuecli\n\n\n# 安装\n\n全局安装\n\n npm install @vue/cli -g\n\n\n1\n\n\n升级\n\n npm update @vue/cli -g\n\n\n1\n\n\n通过vue的命令来创建项目\n\nvue create [项目名]\n\n\n1\n\n\n\n# cli 原理\n\n查看package.json\n\n"scripts": {\n    "serve": "vue-cli-service serve",\n    "build": "vue-cli-service build",\n},\n\n\n1\n2\n3\n4\n\n\n在/node_modules/.bin/vue-cli-service可以看到该命令，但是里面有段代码\n\nconst service = require(\'../lib/service\')\n\n\n1\n\n\n.bin下没有该目录，仔细查看可以发现 vue-cli-service 是一个软连接。连接到/node_modules/@vue/cli-service。\n\n其他的自己看！！！\n\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"Vite",frontmatter:{title:"Vite",date:"2022-01-29T22:10:10.000Z",permalink:"/pages/fe7980/",categories:["x","VueCLI&Vite"],tags:[null]},regularPath:"/1403.Vue3.x/700.VueCLI&Vite/200.Vite.html",relativePath:"1403.Vue3.x/700.VueCLI&Vite/200.Vite.md",key:"v-7d33582d",path:"/pages/fe7980/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:11},{level:2,title:"构造",slug:"构造",normalizedTitle:"构造",charIndex:423},{level:2,title:"浏览器原生支持模块化",slug:"浏览器原生支持模块化",normalizedTitle:"浏览器原生支持模块化",charIndex:792},{level:2,title:"安装和使用",slug:"安装和使用",normalizedTitle:"安装和使用",charIndex:980},{level:2,title:"Vite对css的支持",slug:"vite对css的支持",normalizedTitle:"vite对css的支持",charIndex:1084},{level:2,title:"Vite对TypeScript的支持",slug:"vite对typescript的支持",normalizedTitle:"vite对typescript的支持",charIndex:1506},{level:2,title:"Vite对vue的支持",slug:"vite对vue的支持",normalizedTitle:"vite对vue的支持",charIndex:1722},{level:2,title:"Vite打包项目",slug:"vite打包项目",normalizedTitle:"vite打包项目",charIndex:2057},{level:2,title:"ESBuild 解析",slug:"esbuild-解析",normalizedTitle:"esbuild 解析",charIndex:2317},{level:3,title:"ESBuild 特点",slug:"esbuild-特点",normalizedTitle:"esbuild 特点",charIndex:2332},{level:3,title:"ESBuild的构建速度",slug:"esbuild的构建速度",normalizedTitle:"esbuild的构建速度",charIndex:2514},{level:2,title:"Vite 脚手架工具",slug:"vite-脚手架工具",normalizedTitle:"vite 脚手架工具",charIndex:2711}],headersStr:"介绍 构造 浏览器原生支持模块化 安装和使用 Vite对css的支持 Vite对TypeScript的支持 Vite对vue的支持 Vite打包项目 ESBuild 解析 ESBuild 特点 ESBuild的构建速度 Vite 脚手架工具",content:'# Vite\n\n\n# 介绍\n\nWebpack是目前整个前端使用最多的构建工具，但是除了webpack之后也有其他的一些构建工具：如rollup、parcel、gulp、vite等\n\nvite官方的定位:下一代前端开发与构建工具\n\n如何定义下一代开发和构建工具呢？\n\n * 我们知道在实际开发中，我们编写的代码往往是不能被浏览器直接识别的，比如ES6、TypeScript、Vue文件等 等;\n * 所以我们必须通过构建工具来对代码进行转换、编译，类似的工具有webpack、rollup、parcel;\n * 但是随着项目越来越大，需要处理的JavaScript呈指数级增长，模块越来越多;\n * 构建工具需要很长的时间才能开启服务器，HMR也需要几秒钟才能在浏览器反应出来;\n * 所以也有这样的说法：天下苦webpack久矣;\n\nVite (法语意为 "快速的"，发音 /vit/) 是一种新型前端构建工具，能够显著提升前端开发体验\n\n\n# 构造\n\n它主要由两部分组成:\n\n * 一个开发服务器，它基于原生ES模块提供了丰富的内建功能，HMR的速度非常快速;\n * 一套构建指令，它使用rollup打开我们的代码，并且它是预配置的，可以输出生成环境的优化过的静态资源\n\n目前是否要大力学习vite?vite的未来是怎么样的?\n\n * 我个人非常看好vite的未来，也希望它可以有更好的发展;\n * 但是，目前vite虽然已经更新到2.0，依然并不算非常的稳定，并且比较少大型项目(或框架)使用vite来进行 构建;\n * vite的整个社区插件等支持也还不够完善;\n * 包括vue脚手架本身，目前也还没有打算迁移到vite，而依然使用webpack(虽然后期一定是有这个打算的);\n * 所以vite看起来非常的火热，在面试也可能会问到，但是实际项目中应用的还比较少;\n\n\n# 浏览器原生支持模块化\n\n\n\n但是如果我们不借助于其他工具，直接使用ES Module来开发有什么问题呢?\n\n * 首先，我们会发现在使用loadash时，加载了上百个模块的js代码，对于浏览器发送请求是巨大的消耗;\n * 其次，我们的代码中如果有TypeScript、less、vue等代码时，浏览器并不能直接识别;\n\n事实上，vite就帮助我们解决了上面的所有问题\n\n\n# 安装和使用\n\n npm install vite –g # 全局安装 \n npm install vite –D # 局部安装\n\n\n1\n2\n\n\n通过vite来启动项目\n\n npx vite\n\n\n1\n\n\n\n# Vite对css的支持\n\n * vite可以直接支持css的处理，直接js中导入css即可\n\n * vite可以直接支持css预处理器，比如less，js中直接导入less\n   \n   安装less编译器\n   \n    npm install less -D\n   \n   \n   1\n   \n\n * vite直接支持postcss的转换\n   \n   只需要安装postcss，并且配置 postcss.config.js 的配置文件即可\n   \n    npm install postcss postcss-preset-env -D\n   \n   \n   1\n   \n   \n   module.exports = {\n     plugins: [\n       require("postcss-preset-env")\n     ]\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# Vite对TypeScript的支持\n\nvite对TypeScript是原生支持的，它会直接使用ESBuild来完成编译。只需要直接导入即可\n\n如果我们查看浏览器中的请求，会发现请求的依然是ts的代码\n\n * 这是因为vite中的服务器Connect会对我们的请求进行转发\n * 获取ts编译后的代码，给浏览器返回，浏览器可以直接进行解析\n\n注意:在vite2中，已经不再使用Koa了，而是使用Connect来搭建的服务器\n\n\n# Vite对vue的支持\n\nvite对vue提供第一优先级支持:\n\n * Vue 3 单文件组件支持:@vitejs/plugin-vue\n * Vue 3 JSX 支持:@vitejs/plugin-vue-jsx\n * Vue 2 支持:underfin/vite-plugin-vue2\n\n安装支持vue的插件\n\n  npm install @vitejs/plugin-vue -D\n\n\n1\n\n\n在vite.config.js中配置插件\n\nconst vue = require(\'@vitejs/plugin-vue\')\n\nmodule.exports = {\n  plugins: [\n    vue()\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# Vite打包项目\n\n我们可以直接通过vite build来完成对当前项目的打包工具\n\n npx vite build\n\n\n1\n\n\n\n\n我们可以通过preview的方式，开启一个本地服务来预览打包后的效果：\n\n npx vite preview\n\n\n1\n\n\n在package.json 中配置\n\n"scripts": {\n    "serve": "vite",\n    "build": "vite build",\n    "preview": "vite preview"\n  },\n\n\n1\n2\n3\n4\n5\n\n\n\n# ESBuild 解析\n\n\n# ESBuild 特点\n\n * 超快的构建速度，并且不需要缓存;\n * 支持ES6和CommonJS的模块化;\n * 支持ES6的Tree Shaking（删除未使用的代码）;\n * 支持Go、JavaScript的API;\n * 支持TypeScript、JSX等语法编译;\n * 支持SourceMap;\n * 支持代码压缩;\n * 支持扩展其他插件;\n\n\n# ESBuild的构建速度\n\nESBuild的构建速度和其他构建工具速度对比:\n\n\n\nESBuild为什么这么快呢?\n\n * 使用Go语言编写的，可以直接转换成机器代码，而无需经过字节码;\n * ESBuild可以充分利用CPU的多内核，尽可能让它们饱和运行;\n * ESBuild的所有内容都是从零开始编写的，而不是使用第三方，所以从一开始就可以考虑各种性能问题;\n * 等等....\n\n\n# Vite 脚手架工具\n\n在开发中，我们不可能所有的项目都使用vite从零去搭建，比如一个react项目、Vue项目; 这个时候vite还给我们提供了对应的脚手架工具\n\n所以Vite实际上是有两个工具的:\n\n * vite:相当于是一个构件工具，类似于webpack、rollup;\n * @vitejs/create-app:类似vue-cli、create-react-app;\n\n如果使用脚手架工具呢?\n\n #  如下2种方式都可以，官方文档是第1个\n npm create vite@latest\n \n # npm init @vitejs/app\n\n\n1\n2\n3\n4\n\n\n第一种做法相当于省略了安装脚手架的过程:\n\nnpm install @create-vite@latest\ncreate-app\n\n\n1\n2\n\n\n第二种做法相当于省略了安装脚手架的过程:\n\nnpm install @vitejs/create-app -g\ncreate-app\n\n\n1\n2\n',normalizedContent:'# vite\n\n\n# 介绍\n\nwebpack是目前整个前端使用最多的构建工具，但是除了webpack之后也有其他的一些构建工具：如rollup、parcel、gulp、vite等\n\nvite官方的定位:下一代前端开发与构建工具\n\n如何定义下一代开发和构建工具呢？\n\n * 我们知道在实际开发中，我们编写的代码往往是不能被浏览器直接识别的，比如es6、typescript、vue文件等 等;\n * 所以我们必须通过构建工具来对代码进行转换、编译，类似的工具有webpack、rollup、parcel;\n * 但是随着项目越来越大，需要处理的javascript呈指数级增长，模块越来越多;\n * 构建工具需要很长的时间才能开启服务器，hmr也需要几秒钟才能在浏览器反应出来;\n * 所以也有这样的说法：天下苦webpack久矣;\n\nvite (法语意为 "快速的"，发音 /vit/) 是一种新型前端构建工具，能够显著提升前端开发体验\n\n\n# 构造\n\n它主要由两部分组成:\n\n * 一个开发服务器，它基于原生es模块提供了丰富的内建功能，hmr的速度非常快速;\n * 一套构建指令，它使用rollup打开我们的代码，并且它是预配置的，可以输出生成环境的优化过的静态资源\n\n目前是否要大力学习vite?vite的未来是怎么样的?\n\n * 我个人非常看好vite的未来，也希望它可以有更好的发展;\n * 但是，目前vite虽然已经更新到2.0，依然并不算非常的稳定，并且比较少大型项目(或框架)使用vite来进行 构建;\n * vite的整个社区插件等支持也还不够完善;\n * 包括vue脚手架本身，目前也还没有打算迁移到vite，而依然使用webpack(虽然后期一定是有这个打算的);\n * 所以vite看起来非常的火热，在面试也可能会问到，但是实际项目中应用的还比较少;\n\n\n# 浏览器原生支持模块化\n\n\n\n但是如果我们不借助于其他工具，直接使用es module来开发有什么问题呢?\n\n * 首先，我们会发现在使用loadash时，加载了上百个模块的js代码，对于浏览器发送请求是巨大的消耗;\n * 其次，我们的代码中如果有typescript、less、vue等代码时，浏览器并不能直接识别;\n\n事实上，vite就帮助我们解决了上面的所有问题\n\n\n# 安装和使用\n\n npm install vite –g # 全局安装 \n npm install vite –d # 局部安装\n\n\n1\n2\n\n\n通过vite来启动项目\n\n npx vite\n\n\n1\n\n\n\n# vite对css的支持\n\n * vite可以直接支持css的处理，直接js中导入css即可\n\n * vite可以直接支持css预处理器，比如less，js中直接导入less\n   \n   安装less编译器\n   \n    npm install less -d\n   \n   \n   1\n   \n\n * vite直接支持postcss的转换\n   \n   只需要安装postcss，并且配置 postcss.config.js 的配置文件即可\n   \n    npm install postcss postcss-preset-env -d\n   \n   \n   1\n   \n   \n   module.exports = {\n     plugins: [\n       require("postcss-preset-env")\n     ]\n   }\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n\n# vite对typescript的支持\n\nvite对typescript是原生支持的，它会直接使用esbuild来完成编译。只需要直接导入即可\n\n如果我们查看浏览器中的请求，会发现请求的依然是ts的代码\n\n * 这是因为vite中的服务器connect会对我们的请求进行转发\n * 获取ts编译后的代码，给浏览器返回，浏览器可以直接进行解析\n\n注意:在vite2中，已经不再使用koa了，而是使用connect来搭建的服务器\n\n\n# vite对vue的支持\n\nvite对vue提供第一优先级支持:\n\n * vue 3 单文件组件支持:@vitejs/plugin-vue\n * vue 3 jsx 支持:@vitejs/plugin-vue-jsx\n * vue 2 支持:underfin/vite-plugin-vue2\n\n安装支持vue的插件\n\n  npm install @vitejs/plugin-vue -d\n\n\n1\n\n\n在vite.config.js中配置插件\n\nconst vue = require(\'@vitejs/plugin-vue\')\n\nmodule.exports = {\n  plugins: [\n    vue()\n  ]\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# vite打包项目\n\n我们可以直接通过vite build来完成对当前项目的打包工具\n\n npx vite build\n\n\n1\n\n\n\n\n我们可以通过preview的方式，开启一个本地服务来预览打包后的效果：\n\n npx vite preview\n\n\n1\n\n\n在package.json 中配置\n\n"scripts": {\n    "serve": "vite",\n    "build": "vite build",\n    "preview": "vite preview"\n  },\n\n\n1\n2\n3\n4\n5\n\n\n\n# esbuild 解析\n\n\n# esbuild 特点\n\n * 超快的构建速度，并且不需要缓存;\n * 支持es6和commonjs的模块化;\n * 支持es6的tree shaking（删除未使用的代码）;\n * 支持go、javascript的api;\n * 支持typescript、jsx等语法编译;\n * 支持sourcemap;\n * 支持代码压缩;\n * 支持扩展其他插件;\n\n\n# esbuild的构建速度\n\nesbuild的构建速度和其他构建工具速度对比:\n\n\n\nesbuild为什么这么快呢?\n\n * 使用go语言编写的，可以直接转换成机器代码，而无需经过字节码;\n * esbuild可以充分利用cpu的多内核，尽可能让它们饱和运行;\n * esbuild的所有内容都是从零开始编写的，而不是使用第三方，所以从一开始就可以考虑各种性能问题;\n * 等等....\n\n\n# vite 脚手架工具\n\n在开发中，我们不可能所有的项目都使用vite从零去搭建，比如一个react项目、vue项目; 这个时候vite还给我们提供了对应的脚手架工具\n\n所以vite实际上是有两个工具的:\n\n * vite:相当于是一个构件工具，类似于webpack、rollup;\n * @vitejs/create-app:类似vue-cli、create-react-app;\n\n如果使用脚手架工具呢?\n\n #  如下2种方式都可以，官方文档是第1个\n npm create vite@latest\n \n # npm init @vitejs/app\n\n\n1\n2\n3\n4\n\n\n第一种做法相当于省略了安装脚手架的过程:\n\nnpm install @create-vite@latest\ncreate-app\n\n\n1\n2\n\n\n第二种做法相当于省略了安装脚手架的过程:\n\nnpm install @vitejs/create-app -g\ncreate-app\n\n\n1\n2\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"路由",frontmatter:{title:"路由",date:"2022-02-08T17:52:40.000Z",permalink:"/pages/39a5b4/",categories:["x","VueRouter"],tags:[null]},regularPath:"/1403.Vue3.x/800.VueRouter/801.%E8%B7%AF%E7%94%B1.html",relativePath:"1403.Vue3.x/800.VueRouter/801.路由.md",key:"v-5e159a9e",path:"/pages/39a5b4/",headers:[{level:2,title:"路由简介",slug:"路由简介",normalizedTitle:"路由简介",charIndex:9},{level:2,title:"历史 🔥",slug:"历史-🔥",normalizedTitle:"历史 🔥",charIndex:150},{level:2,title:"URL 的 hash & HTML5 的 history 🔥",slug:"url-的-hash-html5-的-history-🔥",normalizedTitle:"url 的 hash &amp; html5 的 history 🔥",charIndex:null},{level:3,title:"hash—URL",slug:"hash-url",normalizedTitle:"hash—url",charIndex:874},{level:3,title:"history—HTML5",slug:"history-html5",normalizedTitle:"history—html5",charIndex:1973}],headersStr:"路由简介 历史 🔥 URL 的 hash & HTML5 的 history 🔥 hash—URL history—HTML5",content:'# 路由\n\n\n# 路由简介\n\n * 路由就是通过互联的网络把信息从源地址传送到目的地的活动，网络工程术语\n * 路由提供了两种机制：路由和传送\n   * 路由是决定数据包从来源到目的地的路径\n   * 转送就是将数据转移\n * 路由表\n   * 路由表本质就是一个映射表，决定了数据包的指向\n\n\n# 历史 🔥\n\n 1. 后端渲染，服务端渲染（后端路由）阶段：前端请求一个 URL 后，由例如 Java 如 SpringMVC 中 @RequestMapping 来映射到 Java 代码中，并通过 Servlet 和 JSP 技术编写 HTML 页面（JS+CSS）并填充数据，最后返回给前端完整的 HTML，前端直接渲染展示即可。这种由后端处理 URL 和页面映射关系的称为后端路由。\n\n 2. 前后端分离阶段（Gmail 的 Ajax 大量使用） ：前端请求一个 URL 后，可能先从静态资源服务器获取一套 HTML+CSS+JS（服务器中有多套），之后再由 JS 发送 Ajax 请求到后端，由后端返回如 JSON 数据交给前端，前端使用 JS 进行数据填充，渲染 DOM。每次 URL 改变都会请求后端服务器拿静态资源和数据。\n\n 3. 单页面富应用（SPA 页面），前后端分离加上前端路由阶段： 前端第一次请求 URL 后，会从如静态资源服务器获取一套完整的 HTML+CSS+JS（只有一个 HTML，其他 JS 或 CSS 可能会懒加载），之后的 URL 改变不会向后端服务器发送请求，页面不进行整体刷新，而是由其不同的 URL 页面自己发送 Ajax 请求获取数据并由 JS 进行数据填充，渲染 DOM。这种由前端处理 URL 和页面的映射关系称为前端路由。\n    \n    那么如何在 URL 改变后页面还不进行整体刷新呢？且看下面介绍。\n\n\n# URL 的 hash & HTML5 的 history 🔥\n\n提示\n\nVue CLI 初始化项目时推荐选择 history 模式。URL 看起来更友好，没有#这玩意\n\n\n# hash—URL\n\nURL 的 hash 是改变锚点#，其本质上改变的是 window.location.hash 属性，不是 href 属性\n\nlocation.hash = \'/user/10000\'\nhttp://localhost:8082/#/user/10000\n\nlocation.hash = \'/role/1\'\nhttp://localhost:8082/#/role/1\n\n\n1\n2\n3\n4\n5\n\n\n原理\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n  <meta charset="UTF-8">\n  <meta http-equiv="X-UA-Compatible" content="IE=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>Document</title>\n</head>\n<body>\n  \n  <div id="app">\n    <a href="#/home">home</a>\n    <a href="#/about">about</a>\n\n    <div class="content">Default</div>\n  </div>\n\n  <script>\n    const contentEl = document.querySelector(\'.content\');\n    window.addEventListener("hashchange", () => {\n      switch(location.hash) {\n        case "#/home":\n          contentEl.innerHTML = "Home";\n          break;\n        case "#/about":\n          contentEl.innerHTML = "About";\n          break;\n        default:\n          contentEl.innerHTML = "Default";\n      }\n    })\n  <\/script>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# history—HTML5\n\nHTML5 的 history。是一个栈结构\n\nhistory.pushState(\'\',\'\',\'/user/100001\')\nhttp://localhost:8082/user/100001\n\nhistory.pushState(\'\',\'\',\'/role/1\')\nhttp://localhost:8082/role/1\n\nhistory.back()\nhttp://localhost:8082/user/100001\n\nhistory.forward()\nhttp://localhost:8082/role/1\n\nhistory.replaceState(\'\',\'\',\'/permission/100\')\nhttp://localhost:8082/permission/100\n# 此时将上面的 http://localhost:8082/role/1 替换掉了，之后无法 back 回去，只能 back 到 http://localhost:8082/user/100001\n\n# go 可以更灵活控制，相比 back，forward\nhistory.go(-1)\nhistory.go(1)\nhistory.go(-2)\nhistory.go(2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nVue Router 就是将组件和 URL 映射\n\n原理\n\n<!DOCTYPE html>\n<html lang="en">\n  <head>\n    <meta charset="UTF-8" />\n    <meta http-equiv="X-UA-Compatible" content="IE=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>Document</title>\n  </head>\n  <body>\n    <div id="app">\n      <a href="/home">home</a>\n      <a href="/about">about</a>\n\n      <div class="content">Default</div>\n    </div>\n\n    <script>\n      const contentEl = document.querySelector(\'.content\')\n\n      const changeContent = () => {\n        console.log(\'-----\')\n        switch (location.pathname) {\n          case \'/home\':\n            contentEl.innerHTML = \'Home\'\n            break\n          case \'/about\':\n            contentEl.innerHTML = \'About\'\n            break\n          default:\n            contentEl.innerHTML = \'Default\'\n        }\n      }\n\n      const aEls = document.getElementsByTagName(\'a\')\n      for (let aEl of aEls) {\n        aEl.addEventListener(\'click\', (e) => {\n          // 取消a标签的默认行为\n          e.preventDefault()\n\n          const href = aEl.getAttribute(\'href\')\n          // 压栈操作，可back\n          // history.pushState({}, "", href);\n          // 替换操作，无法back\n          history.replaceState({}, \'\', href)\n\n          changeContent()\n        })\n      }\n\n      window.addEventListener(\'popstate\', changeContent)\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',normalizedContent:'# 路由\n\n\n# 路由简介\n\n * 路由就是通过互联的网络把信息从源地址传送到目的地的活动，网络工程术语\n * 路由提供了两种机制：路由和传送\n   * 路由是决定数据包从来源到目的地的路径\n   * 转送就是将数据转移\n * 路由表\n   * 路由表本质就是一个映射表，决定了数据包的指向\n\n\n# 历史 🔥\n\n 1. 后端渲染，服务端渲染（后端路由）阶段：前端请求一个 url 后，由例如 java 如 springmvc 中 @requestmapping 来映射到 java 代码中，并通过 servlet 和 jsp 技术编写 html 页面（js+css）并填充数据，最后返回给前端完整的 html，前端直接渲染展示即可。这种由后端处理 url 和页面映射关系的称为后端路由。\n\n 2. 前后端分离阶段（gmail 的 ajax 大量使用） ：前端请求一个 url 后，可能先从静态资源服务器获取一套 html+css+js（服务器中有多套），之后再由 js 发送 ajax 请求到后端，由后端返回如 json 数据交给前端，前端使用 js 进行数据填充，渲染 dom。每次 url 改变都会请求后端服务器拿静态资源和数据。\n\n 3. 单页面富应用（spa 页面），前后端分离加上前端路由阶段： 前端第一次请求 url 后，会从如静态资源服务器获取一套完整的 html+css+js（只有一个 html，其他 js 或 css 可能会懒加载），之后的 url 改变不会向后端服务器发送请求，页面不进行整体刷新，而是由其不同的 url 页面自己发送 ajax 请求获取数据并由 js 进行数据填充，渲染 dom。这种由前端处理 url 和页面的映射关系称为前端路由。\n    \n    那么如何在 url 改变后页面还不进行整体刷新呢？且看下面介绍。\n\n\n# url 的 hash & html5 的 history 🔥\n\n提示\n\nvue cli 初始化项目时推荐选择 history 模式。url 看起来更友好，没有#这玩意\n\n\n# hash—url\n\nurl 的 hash 是改变锚点#，其本质上改变的是 window.location.hash 属性，不是 href 属性\n\nlocation.hash = \'/user/10000\'\nhttp://localhost:8082/#/user/10000\n\nlocation.hash = \'/role/1\'\nhttp://localhost:8082/#/role/1\n\n\n1\n2\n3\n4\n5\n\n\n原理\n\n<!doctype html>\n<html lang="en">\n<head>\n  <meta charset="utf-8">\n  <meta http-equiv="x-ua-compatible" content="ie=edge">\n  <meta name="viewport" content="width=device-width, initial-scale=1.0">\n  <title>document</title>\n</head>\n<body>\n  \n  <div id="app">\n    <a href="#/home">home</a>\n    <a href="#/about">about</a>\n\n    <div class="content">default</div>\n  </div>\n\n  <script>\n    const contentel = document.queryselector(\'.content\');\n    window.addeventlistener("hashchange", () => {\n      switch(location.hash) {\n        case "#/home":\n          contentel.innerhtml = "home";\n          break;\n        case "#/about":\n          contentel.innerhtml = "about";\n          break;\n        default:\n          contentel.innerhtml = "default";\n      }\n    })\n  <\/script>\n\n</body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# history—html5\n\nhtml5 的 history。是一个栈结构\n\nhistory.pushstate(\'\',\'\',\'/user/100001\')\nhttp://localhost:8082/user/100001\n\nhistory.pushstate(\'\',\'\',\'/role/1\')\nhttp://localhost:8082/role/1\n\nhistory.back()\nhttp://localhost:8082/user/100001\n\nhistory.forward()\nhttp://localhost:8082/role/1\n\nhistory.replacestate(\'\',\'\',\'/permission/100\')\nhttp://localhost:8082/permission/100\n# 此时将上面的 http://localhost:8082/role/1 替换掉了，之后无法 back 回去，只能 back 到 http://localhost:8082/user/100001\n\n# go 可以更灵活控制，相比 back，forward\nhistory.go(-1)\nhistory.go(1)\nhistory.go(-2)\nhistory.go(2)\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\nvue router 就是将组件和 url 映射\n\n原理\n\n<!doctype html>\n<html lang="en">\n  <head>\n    <meta charset="utf-8" />\n    <meta http-equiv="x-ua-compatible" content="ie=edge" />\n    <meta name="viewport" content="width=device-width, initial-scale=1.0" />\n    <title>document</title>\n  </head>\n  <body>\n    <div id="app">\n      <a href="/home">home</a>\n      <a href="/about">about</a>\n\n      <div class="content">default</div>\n    </div>\n\n    <script>\n      const contentel = document.queryselector(\'.content\')\n\n      const changecontent = () => {\n        console.log(\'-----\')\n        switch (location.pathname) {\n          case \'/home\':\n            contentel.innerhtml = \'home\'\n            break\n          case \'/about\':\n            contentel.innerhtml = \'about\'\n            break\n          default:\n            contentel.innerhtml = \'default\'\n        }\n      }\n\n      const aels = document.getelementsbytagname(\'a\')\n      for (let ael of aels) {\n        ael.addeventlistener(\'click\', (e) => {\n          // 取消a标签的默认行为\n          e.preventdefault()\n\n          const href = ael.getattribute(\'href\')\n          // 压栈操作，可back\n          // history.pushstate({}, "", href);\n          // 替换操作，无法back\n          history.replacestate({}, \'\', href)\n\n          changecontent()\n        })\n      }\n\n      window.addeventlistener(\'popstate\', changecontent)\n    <\/script>\n  </body>\n</html>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"VueRouter",frontmatter:{title:"VueRouter",date:"2022-02-08T18:29:59.000Z",permalink:"/pages/1c8fc2/",categories:["x","VueRouter"],tags:[null]},regularPath:"/1403.Vue3.x/800.VueRouter/802.VueRouter.html",relativePath:"1403.Vue3.x/800.VueRouter/802.VueRouter.md",key:"v-3f3a9c6d",path:"/pages/1c8fc2/",headers:[{level:2,title:"认识",slug:"认识",normalizedTitle:"认识",charIndex:16},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:197},{level:2,title:"标签路由使用步骤",slug:"标签路由使用步骤",normalizedTitle:"标签路由使用步骤",charIndex:255},{level:3,title:"创建路由组件的组件",slug:"创建路由组件的组件",normalizedTitle:"创建路由组件的组件",charIndex:268},{level:3,title:"配置路由映射",slug:"配置路由映射",normalizedTitle:"配置路由映射",charIndex:562},{level:3,title:"<router-link>和<router-view>",slug:"router-link-和-router-view",normalizedTitle:"<router-link>和<router-view>",charIndex:1291},{level:3,title:"router-link 配置",slug:"router-link-配置",normalizedTitle:"router-link 配置",charIndex:1622},{level:3,title:"router-link 和 router-view 的 v-slot 🔥",slug:"router-link-和-router-view-的-v-slot-🔥",normalizedTitle:"router-link 和 router-view 的 v-slot 🔥",charIndex:1916},{level:2,title:"路由懒加载 🔥",slug:"路由懒加载-🔥",normalizedTitle:"路由懒加载 🔥",charIndex:3629},{level:2,title:"动态路由 🔥",slug:"动态路由-🔥",normalizedTitle:"动态路由 🔥",charIndex:4633},{level:2,title:"NotFound 🔥",slug:"notfound-🔥",normalizedTitle:"notfound 🔥",charIndex:5790},{level:2,title:"路由的嵌套 🔥",slug:"路由的嵌套-🔥",normalizedTitle:"路由的嵌套 🔥",charIndex:6528},{level:2,title:"代码路由 🔥",slug:"代码路由-🔥",normalizedTitle:"代码路由 🔥",charIndex:7937},{level:2,title:"动态添加、删除路由—权限 🔥",slug:"动态添加、删除路由-权限-🔥",normalizedTitle:"动态添加、删除路由—权限 🔥",charIndex:9131},{level:3,title:"添加路由",slug:"添加路由",normalizedTitle:"添加路由",charIndex:9151},{level:3,title:"删除路由",slug:"删除路由",normalizedTitle:"删除路由",charIndex:9136},{level:3,title:"其他方法",slug:"其他方法",normalizedTitle:"其他方法",charIndex:8614},{level:2,title:"路由导航守卫—拦截 🔥",slug:"路由导航守卫-拦截-🔥",normalizedTitle:"路由导航守卫—拦截 🔥",charIndex:9901},{level:3,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:8620},{level:3,title:"登录守卫功能",slug:"登录守卫功能",normalizedTitle:"登录守卫功能",charIndex:10941},{level:3,title:"其他导航守卫",slug:"其他导航守卫",normalizedTitle:"其他导航守卫",charIndex:11671}],headersStr:"认识 安装 标签路由使用步骤 创建路由组件的组件 配置路由映射 <router-link>和<router-view> router-link 配置 router-link 和 router-view 的 v-slot 🔥 路由懒加载 🔥 动态路由 🔥 NotFound 🔥 路由的嵌套 🔥 代码路由 🔥 动态添加、删除路由—权限 🔥 添加路由 删除路由 其他方法 路由导航守卫—拦截 🔥 介绍 登录守卫功能 其他导航守卫",content:"# VueRouter\n\n\n# 认识\n\n目前前端流行的三大框架, 都有自己的路由实现:\n\n * Angular的ngRouter\n * React的ReactRouter\n * Vue的vue-router\n\nvue-router是基于路由和组件的\n\n * 路由用于设定访问路径, 将路径和组件映射起来.\n * 在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.\n\n\n# 安装\n\n目前Vue路由最新的版本是4.x版本\n\nnpm install vue-router@4\n\n\n1\n\n\n\n# 标签路由使用步骤\n\n\n# 创建路由组件的组件\n\n/src/pages/Home.vue\n\n<template>\n  <h2>Home</h2>\n</template>\n\n<script setup><\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/src/pages/About.vue\n\n<template>\n  <h2>About</h2>\n</template>\n\n<script setup><\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 配置路由映射\n\n组件和路径映射关系的routes数组;\n\n通过createRouter创建路由对象，并且传入routes和history模式;\n\n/src/router/index.js\n\nimport { createRouter, createWebHistory } from 'vue-router'\nimport Home from '../views/Home.vue'\nimport About from '../views/About.vue'\n\nconst routes = [\n  {\n    path: '/',\n    redirect: '/home',\n  },\n  {\n    path: '/home',\n    component: Home,\n  },\n  {\n    path: '/about',\n    component: About,\n  },\n]\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes,\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n/src/main.js\n\nimport { createApp } from 'vue'\nimport App from './App.vue'\nimport router from './router'\n\ncreateApp(App).use(router).mount('#app')\n\n\n1\n2\n3\n4\n5\n\n\n\n# <router-link>和<router-view>\n\n通过<router-link>和<router-view>，使用路由:\n\n/src/App.vue\n\n<template>\n  <div>\n    <router-link to=\"/home\">Home</router-link> |\n    <router-link to=\"/about\">About</router-link>\n    <router-view />\n  </div>\n</template>\n\n<style>\n.router-link-active {\n  color: red;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# router-link 配置\n\n * to属性:\n   \n   是一个字符串，或者是一个对象\n\n * replace属性:\n   \n   设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push();\n\n * active-class属性:\n   \n   设置激活a元素后应用的class，默认是router-link-active\n\n * exact-active-class属性:\n   \n   嵌套路由，链接精准激活时，应用于渲染的 <a> 的 class，默认是router-link-exact-active;\n\n\n# router-link 和 router-view 的 v-slot 🔥\n\n在vue-router3.x的时候，router-link有一个tag属性，可以决定router-link到底渲染成什么元素，但是在vue-router4.x开始，该属性被移除了；而给我们提供了更加具有灵活性的v-slot的方式来定制渲染的内容;\n\n * 首先，我们需要使用 custom 表示我们整个元素要自定义；如果不写，那么自定义的内容会被包裹在一个 a 元素中;\n\n * 其次，我们使用v-slot来作用域插槽来获取内部传给我们的值:\n   \n   * href:解析后的 URL;\n   * route:解析后的规范化的route对象;\n   * navigate:触发导航的函数;\n   * isActive:是否匹配的状态;\n   * isExactActive:是否是精准匹配的状态;\n\nrouter-view也提供给我们一个插槽，可以用于 <transition> 和 <keep-alive>组件来包裹你的路由组件:\n\n * Component:要渲染的组件;\n * route:解析出的标准化路由对象;\n\n<template>\n  <div>\n    \x3c!-- props: href 跳转的链接 --\x3e\n    \x3c!-- props: route对象 --\x3e\n    \x3c!-- props: navigate导航函数 --\x3e\n    \x3c!-- props: isActive 是否当前处于活跃的状态 --\x3e\n    \x3c!-- props: isExactActive 是否当前处于精确的活跃状态 --\x3e\n    <router-link to=\"/home\" v-slot=\"props\" custom>\n      <button @click=\"props.navigate\">{{ props.href }}</button>\n      <button @click=\"props.navigate\">哈哈哈</button>\n      <span :class=\"{ active: props.isActive }\">{{ props.isActive }}</span>\n      <span :class=\"{ active: props.isExactActive }\">{{\n        props.isExactActive\n      }}</span>\n      \x3c!-- <p>{{props.route}}</p> --\x3e\n    </router-link>\n    <br />\n\n    <router-view v-slot=\"props\">\n      <transition name=\"why\">\n        <keep-alive>\n          <component :is=\"props.Component\"></component>\n        </keep-alive>\n      </transition>\n    </router-view>\n    \x3c!-- <router-view /> --\x3e\n  </div>\n</template>\n\n<script setup>\n\n<\/script>\n\n<style>\n.router-link-active {\n  color: red;\n}\n\n.why-enter-from,\n.why-leave-to {\n  opacity: 0;\n}\n\n.why-enter-active,\n.why-leave-active {\n  transition: opacity 1s ease;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 路由懒加载 🔥\n\n当打包构建应用时，JavaScript 包会变得非常大，影响页面加载:\n\n * 如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，会更加高效;\n * 也可以提高首屏的渲染效率;\n\n其实这里还是我们前面讲到过的webpack的分包知识，而Vue Router默认就支持动态来导入组件:\n\n * 这是因为component可以传入一个组件，也可以接收一个函数，该函数 需要放回一个Promise;\n * 而import函数就是返回一个Promise;\n\n修改 /src/router/index.js\n\nimport { createRouter, createWebHistory } from 'vue-router'\n\nconst routes = [\n  {\n    path: '/',\n    redirect: '/home',\n  },\n  {\n    path: '/home',\n    name: 'home', // 名称\n    component: () =>\n      // webpackChunkName 打包起名，必须这样写！webpack的功能\n      import(/* webpackChunkName: 'home-chunk' */ '../views/Home.vue'), // 动态路由。import返回Promise\n    // 元数据\n    meta: {\n      name: 'conanan',\n    },\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: () => import('../views/About.vue'),\n  },\n]\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes,\n})\n\nexport default router\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n执行打包命令\n\nnpm run build\n\n\n1\n\n\n可以看出\n\n\n\n\n# 动态路由 🔥\n\n修改 /src/router/index.js\n\nconst routes = [\n  {\n    // 动态路由，必须完整匹配！如下'/'分割的4个参数一个不能少，也不能多\n    path: '/user/:username/id/:id',\n    name: 'user',\n    component: () => import('../views/User.vue'),\n  },\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n/src/App.vue\n\n<template>\n  <div>\n    <router-link to=\"/user/conanan/id/10086\">User</router-link>\n    <router-view />\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n/src/pages/User.vue\n\n<template>\n  <h2>User: {{ route.params.username }} - {{ route.params.id }}</h2>\n</template>\n\n<script setup>\nimport { useRouter, useRoute } from 'vue-router'\n\nconst router = useRouter()\nconsole.log('router', router)\n\nconst route = useRoute()\nconst params = route.params\nconsole.log('params', params)\n\nconst query = route.query\nconsole.log('query', query)\n\n// 这种方法获取到是 undefiend，很尴尬。不知道原因在哪\n// import { getCurrentInstance } from 'vue'\n// const { ctx } = getCurrentInstance()\n// console.log(ctx.$router)\n// console.log(ctx.$route)\n\n// 在 options api 中直接调用如下：\n// this.$route.params 即可\n// this.$route.query 即可\n// this.$router\n<\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# NotFound 🔥\n\n对于哪些没有匹配到的路由，我们通常会匹配到固定的某个页\n\n修改 /src/router/index.js\n\nconst routes = [\n  {\n    path: '/:pathMatch(.*)',\n    // path: '/:pathMatch(.*)*', // 多个*，会将path根据'/'分割转为数组\n    component: () => import('../views/NotFound.vue'),\n  },\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/src/App.vue\n\n<template>\n  <div>\n    <router-link to=\"/notfound/aa/bb/cc\">NotFound</router-link> |\n    <router-view />\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n/src/pages/NotFound.vue\n\n<template>\n  <div>\n    <h2>Page Not Found</h2>\n    <p>您打开的路径页面不存在, 请不要使用我们家的应用程序了~</p>\n    <h1>{{ route.params.pathMatch }}</h1>\n  </div>\n</template>\n\n<script setup>\nimport { useRoute } from 'vue-router'\nconst route = useRoute()\n<\/script>\n\n<style scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 路由的嵌套 🔥\n\n什么是路由的嵌套呢?\n\n * 目前我们匹配的Home、About、User等都属于底层路由，我们在它们之间可以来回进行切换;\n * 但是呢，我们Home页面本身，也可能会在多个组件之间来回切换：比如Home中包括Product、Message，它们可以在Home内部来回切换;\n * 这个时候我们就需要使用嵌套路由，在Home中也使用 router-view 来占位之后需要渲染的组件\n\n修改 /src/router/index.js\n\nconst routes = [\n  {\n    path: '/home',\n    name: 'home', // 名称\n    component: () =>\n      // webpackChunkName 打包起名，必须这样写！webpack的功能\n      import(/* webpackChunkName: 'home-chunk' */ '../views/Home.vue'), // 动态路由。import返回Promise\n    // 元数据\n    meta: {\n      name: 'conanan',\n    },\n    children: [\n      {\n        // 这里path必须为空\n        path: '',\n        // 这里必须写全路径\n        redirect: '/home/message',\n      },\n      {\n        // 这里的path不用拼接父route的path，并且不可以已'/'开头！！！\n        path: 'message',\n        name: 'message',\n        component: () => import('../views/HomeMessage.vue'),\n      },\n      {\n        path: 'shops',\n        name: 'shops',\n        component: () => import('../views/HomeShops.vue'),\n      },\n    ],\n  },\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n/src/Home.vue\n\n<template>\n  <div>\n    <h2>Home</h2>\n\n    <router-view />\n\n    <router-link to=\"/home/message\">消息</router-link> |\n    <router-link to=\"/home/shops\">商品</router-link> |\n    <router-link to=\"/home/moment\">动态</router-link>\n  </div>\n</template>\n\n<script setup><\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n其他组件略\n\n\n# 代码路由 🔥\n\n修改/src/App.vue\n\n<template>\n  <div>\n    <router-link to=\"/home\">Home</router-link> |\n    <router-link to=\"/about\">About</router-link> |\n    <router-link to=\"/user/conanan/id/10086\">User</router-link> |\n    <router-link to=\"/notfound/aa/bb/cc\">NotFound</router-link> |\n    <button @click=\"jumpToAbout\">查看我！</button>\n    <button @click=\"back\">←</button>\n    <button @click=\"forword\">→</button>\n    <router-view />\n  </div>\n</template>\n\n<script setup>\nimport { useRouter } from 'vue-router'\nconst router = useRouter()\n\nconst jumpToAbout = () => {\n  router.push({\n    path: '/about',\n    query: {\n      q1: 'qa1',\n    },\n  })\n}\n\nconst forword = () => {\n  router.go(1)\n  // 其他方法就不介绍了\n}\n\nconst back = () => {\n  router.go(-1)\n}\n<\/script>\n\n<style>\n.router-link-active {\n  color: red;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n修改/src/pages/About.vue\n\n<template>\n  <div>\n    <h2>About</h2>\n    <div>{{ route.query.q1 }}</div>\n  </div>\n</template>\n\n<script setup>\nimport { useRoute } from 'vue-router'\nconst route = useRoute()\n<\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 动态添加、删除路由—权限 🔥\n\n\n# 添加路由\n\n某些情况下我们可能需要动态的来添加路由:\n\n * 比如根据用户不同的权限，注册不同的路由;\n * 这个时候我们可以使用一个方法 addRoute;\n\n如果我们是为route添加一个children路由，那么可以传入对应的name\n\n修改 /src/router/index.js\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes,\n})\n\n// 动态添加路由\nconst categoryRoute = {\n  path: '/category',\n  component: () => import('../views/Category.vue'),\n}\n\n// 添加顶级路由对象\nrouter.addRoute(categoryRoute)\n\n// 添加二级路由对象，第一个参数为路由的名称name\nrouter.addRoute('home', {\n  path: 'moment',\n  component: () => import('../views/HomeMoment.vue'),\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 删除路由\n\n不常用，删除路由有以下三种方式:\n\n * 方式一：添加一个name相同的路由;\n * 方式二：通过removeRoute方法，传入路由的名称;\n * 方式三：通过addRoute方法的返回值回调;\n\n\n\n\n# 其他方法\n\n * router.hasRoute()：检查路由是否存在。\n * router.getRoutes()：获取一个包含所有路由记录的数组\n\n\n# 路由导航守卫—拦截 🔥\n\n\n# 介绍\n\n * vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。\n\n * 全局的前置守卫beforeEach是在导航触发时会被回调的\n   \n   它有两个参数:\n   \n   * to:即将进入的路由Route对象;\n   * from:即将离开的路由Route对象;\n\n * 它有返回值:\n   \n   * false:取消当前导航;\n   * 不返回或者undefined:进行默认导航;\n   * 返回一个路由地址:\n     * 可以是一个string类型的路径;\n     * 可以是一个对象，对象中包含path、query、params等信息;\n\n * 可选的第三个参数:next\n   \n   * 在Vue2中我们是通过next函数来决定如何进行跳转的;\n   * 但是在Vue3中我们是通过返回值来控制的，不再推荐使用next函数，这是因为开发中很容易调用多次next;\n\n修改 /src/router/index.js\n\n// 导航守卫beforeEach\nlet counter = 0\n// to: Route对象, 即将跳转到的Route对象\n// from: Route对象,\n/**\n * 返回值问题:\n *    1.false: 不进行导航\n *    2.undefined或者不写返回值: 进行默认导航\n *    3.字符串: 路径, 跳转到对应的路径中\n *    4.对象: 类似于 router.push({path: \"/login\", query: ....})\n */\nrouter.beforeEach((to, from) => {\n  console.log(`进行了${++counter}路由跳转`)\n  // if (to.path.indexOf(\"/home\") !== -1) {\n  //   return \"/login\"\n  // }\n  if (to.path !== '/login') {\n    const token = window.localStorage.getItem('token')\n    if (!token) {\n      return '/login'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 登录守卫功能\n\n/src/Login.vue\n\n<template>\n  <div>\n    <button @click=\"loginClick\">登录</button>\n  </div>\n</template>\n\n<script setup>\nimport { useRouter } from 'vue-router'\n\nconst router = useRouter()\n\nconst loginClick = () => {\n  window.localStorage.setItem('token', 'why')\n\n  router.push({\n    path: '/home',\n  })\n}\n<\/script>\n\n<style scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n注册路由\n\n{\n  path: '/login',\n  component: () => import('../views/Login.vue'),\n},\n\n\n1\n2\n3\n4\n\n\n修改 /src/router/index.js\n\n// 导航守卫beforeEach\nrouter.beforeEach((to, from) => {\n  if (to.path !== '/login') {\n    const token = window.localStorage.getItem('token')\n    if (!token) {\n      return '/login'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 其他导航守卫\n\nVue还提供了很多的其他守卫函数，目的都是在某一个时刻给予我们回调，让我们可以更好的控制程序的流程或者功能\n\n完整的导航解析流程:\n\n * 导航被触发。\n * 在失活的组件里调用 beforeRouteLeave 守卫。\n * 调用全局的 beforeEach 守卫。\n * 在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。\n * 在路由配置里调用 beforeEnter。\n * 解析异步路由组件。\n * 在被激活的组件里调用 beforeRouteEnter。\n * 调用全局的 beforeResolve 守卫(2.5+)。\n * 导航被确认。\n * 调用全局的 afterEach 钩子。\n * 触发 DOM 更新。\n * 调用 beforeRouteEnter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。",normalizedContent:"# vuerouter\n\n\n# 认识\n\n目前前端流行的三大框架, 都有自己的路由实现:\n\n * angular的ngrouter\n * react的reactrouter\n * vue的vue-router\n\nvue-router是基于路由和组件的\n\n * 路由用于设定访问路径, 将路径和组件映射起来.\n * 在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.\n\n\n# 安装\n\n目前vue路由最新的版本是4.x版本\n\nnpm install vue-router@4\n\n\n1\n\n\n\n# 标签路由使用步骤\n\n\n# 创建路由组件的组件\n\n/src/pages/home.vue\n\n<template>\n  <h2>home</h2>\n</template>\n\n<script setup><\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/src/pages/about.vue\n\n<template>\n  <h2>about</h2>\n</template>\n\n<script setup><\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n\n# 配置路由映射\n\n组件和路径映射关系的routes数组;\n\n通过createrouter创建路由对象，并且传入routes和history模式;\n\n/src/router/index.js\n\nimport { createrouter, createwebhistory } from 'vue-router'\nimport home from '../views/home.vue'\nimport about from '../views/about.vue'\n\nconst routes = [\n  {\n    path: '/',\n    redirect: '/home',\n  },\n  {\n    path: '/home',\n    component: home,\n  },\n  {\n    path: '/about',\n    component: about,\n  },\n]\n\nconst router = createrouter({\n  history: createwebhistory(),\n  routes,\n})\n\nexport default router\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n/src/main.js\n\nimport { createapp } from 'vue'\nimport app from './app.vue'\nimport router from './router'\n\ncreateapp(app).use(router).mount('#app')\n\n\n1\n2\n3\n4\n5\n\n\n\n# <router-link>和<router-view>\n\n通过<router-link>和<router-view>，使用路由:\n\n/src/app.vue\n\n<template>\n  <div>\n    <router-link to=\"/home\">home</router-link> |\n    <router-link to=\"/about\">about</router-link>\n    <router-view />\n  </div>\n</template>\n\n<style>\n.router-link-active {\n  color: red;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# router-link 配置\n\n * to属性:\n   \n   是一个字符串，或者是一个对象\n\n * replace属性:\n   \n   设置 replace 属性的话，当点击时，会调用 router.replace()，而不是 router.push();\n\n * active-class属性:\n   \n   设置激活a元素后应用的class，默认是router-link-active\n\n * exact-active-class属性:\n   \n   嵌套路由，链接精准激活时，应用于渲染的 <a> 的 class，默认是router-link-exact-active;\n\n\n# router-link 和 router-view 的 v-slot 🔥\n\n在vue-router3.x的时候，router-link有一个tag属性，可以决定router-link到底渲染成什么元素，但是在vue-router4.x开始，该属性被移除了；而给我们提供了更加具有灵活性的v-slot的方式来定制渲染的内容;\n\n * 首先，我们需要使用 custom 表示我们整个元素要自定义；如果不写，那么自定义的内容会被包裹在一个 a 元素中;\n\n * 其次，我们使用v-slot来作用域插槽来获取内部传给我们的值:\n   \n   * href:解析后的 url;\n   * route:解析后的规范化的route对象;\n   * navigate:触发导航的函数;\n   * isactive:是否匹配的状态;\n   * isexactactive:是否是精准匹配的状态;\n\nrouter-view也提供给我们一个插槽，可以用于 <transition> 和 <keep-alive>组件来包裹你的路由组件:\n\n * component:要渲染的组件;\n * route:解析出的标准化路由对象;\n\n<template>\n  <div>\n    \x3c!-- props: href 跳转的链接 --\x3e\n    \x3c!-- props: route对象 --\x3e\n    \x3c!-- props: navigate导航函数 --\x3e\n    \x3c!-- props: isactive 是否当前处于活跃的状态 --\x3e\n    \x3c!-- props: isexactactive 是否当前处于精确的活跃状态 --\x3e\n    <router-link to=\"/home\" v-slot=\"props\" custom>\n      <button @click=\"props.navigate\">{{ props.href }}</button>\n      <button @click=\"props.navigate\">哈哈哈</button>\n      <span :class=\"{ active: props.isactive }\">{{ props.isactive }}</span>\n      <span :class=\"{ active: props.isexactactive }\">{{\n        props.isexactactive\n      }}</span>\n      \x3c!-- <p>{{props.route}}</p> --\x3e\n    </router-link>\n    <br />\n\n    <router-view v-slot=\"props\">\n      <transition name=\"why\">\n        <keep-alive>\n          <component :is=\"props.component\"></component>\n        </keep-alive>\n      </transition>\n    </router-view>\n    \x3c!-- <router-view /> --\x3e\n  </div>\n</template>\n\n<script setup>\n\n<\/script>\n\n<style>\n.router-link-active {\n  color: red;\n}\n\n.why-enter-from,\n.why-leave-to {\n  opacity: 0;\n}\n\n.why-enter-active,\n.why-leave-active {\n  transition: opacity 1s ease;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# 路由懒加载 🔥\n\n当打包构建应用时，javascript 包会变得非常大，影响页面加载:\n\n * 如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，会更加高效;\n * 也可以提高首屏的渲染效率;\n\n其实这里还是我们前面讲到过的webpack的分包知识，而vue router默认就支持动态来导入组件:\n\n * 这是因为component可以传入一个组件，也可以接收一个函数，该函数 需要放回一个promise;\n * 而import函数就是返回一个promise;\n\n修改 /src/router/index.js\n\nimport { createrouter, createwebhistory } from 'vue-router'\n\nconst routes = [\n  {\n    path: '/',\n    redirect: '/home',\n  },\n  {\n    path: '/home',\n    name: 'home', // 名称\n    component: () =>\n      // webpackchunkname 打包起名，必须这样写！webpack的功能\n      import(/* webpackchunkname: 'home-chunk' */ '../views/home.vue'), // 动态路由。import返回promise\n    // 元数据\n    meta: {\n      name: 'conanan',\n    },\n  },\n  {\n    path: '/about',\n    name: 'about',\n    component: () => import('../views/about.vue'),\n  },\n]\n\nconst router = createrouter({\n  history: createwebhistory(),\n  routes,\n})\n\nexport default router\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n执行打包命令\n\nnpm run build\n\n\n1\n\n\n可以看出\n\n\n\n\n# 动态路由 🔥\n\n修改 /src/router/index.js\n\nconst routes = [\n  {\n    // 动态路由，必须完整匹配！如下'/'分割的4个参数一个不能少，也不能多\n    path: '/user/:username/id/:id',\n    name: 'user',\n    component: () => import('../views/user.vue'),\n  },\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n/src/app.vue\n\n<template>\n  <div>\n    <router-link to=\"/user/conanan/id/10086\">user</router-link>\n    <router-view />\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n/src/pages/user.vue\n\n<template>\n  <h2>user: {{ route.params.username }} - {{ route.params.id }}</h2>\n</template>\n\n<script setup>\nimport { userouter, useroute } from 'vue-router'\n\nconst router = userouter()\nconsole.log('router', router)\n\nconst route = useroute()\nconst params = route.params\nconsole.log('params', params)\n\nconst query = route.query\nconsole.log('query', query)\n\n// 这种方法获取到是 undefiend，很尴尬。不知道原因在哪\n// import { getcurrentinstance } from 'vue'\n// const { ctx } = getcurrentinstance()\n// console.log(ctx.$router)\n// console.log(ctx.$route)\n\n// 在 options api 中直接调用如下：\n// this.$route.params 即可\n// this.$route.query 即可\n// this.$router\n<\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# notfound 🔥\n\n对于哪些没有匹配到的路由，我们通常会匹配到固定的某个页\n\n修改 /src/router/index.js\n\nconst routes = [\n  {\n    path: '/:pathmatch(.*)',\n    // path: '/:pathmatch(.*)*', // 多个*，会将path根据'/'分割转为数组\n    component: () => import('../views/notfound.vue'),\n  },\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/src/app.vue\n\n<template>\n  <div>\n    <router-link to=\"/notfound/aa/bb/cc\">notfound</router-link> |\n    <router-view />\n  </div>\n</template>\n\n\n1\n2\n3\n4\n5\n6\n\n\n/src/pages/notfound.vue\n\n<template>\n  <div>\n    <h2>page not found</h2>\n    <p>您打开的路径页面不存在, 请不要使用我们家的应用程序了~</p>\n    <h1>{{ route.params.pathmatch }}</h1>\n  </div>\n</template>\n\n<script setup>\nimport { useroute } from 'vue-router'\nconst route = useroute()\n<\/script>\n\n<style scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n\n\n\n# 路由的嵌套 🔥\n\n什么是路由的嵌套呢?\n\n * 目前我们匹配的home、about、user等都属于底层路由，我们在它们之间可以来回进行切换;\n * 但是呢，我们home页面本身，也可能会在多个组件之间来回切换：比如home中包括product、message，它们可以在home内部来回切换;\n * 这个时候我们就需要使用嵌套路由，在home中也使用 router-view 来占位之后需要渲染的组件\n\n修改 /src/router/index.js\n\nconst routes = [\n  {\n    path: '/home',\n    name: 'home', // 名称\n    component: () =>\n      // webpackchunkname 打包起名，必须这样写！webpack的功能\n      import(/* webpackchunkname: 'home-chunk' */ '../views/home.vue'), // 动态路由。import返回promise\n    // 元数据\n    meta: {\n      name: 'conanan',\n    },\n    children: [\n      {\n        // 这里path必须为空\n        path: '',\n        // 这里必须写全路径\n        redirect: '/home/message',\n      },\n      {\n        // 这里的path不用拼接父route的path，并且不可以已'/'开头！！！\n        path: 'message',\n        name: 'message',\n        component: () => import('../views/homemessage.vue'),\n      },\n      {\n        path: 'shops',\n        name: 'shops',\n        component: () => import('../views/homeshops.vue'),\n      },\n    ],\n  },\n]\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n/src/home.vue\n\n<template>\n  <div>\n    <h2>home</h2>\n\n    <router-view />\n\n    <router-link to=\"/home/message\">消息</router-link> |\n    <router-link to=\"/home/shops\">商品</router-link> |\n    <router-link to=\"/home/moment\">动态</router-link>\n  </div>\n</template>\n\n<script setup><\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n\n\n其他组件略\n\n\n# 代码路由 🔥\n\n修改/src/app.vue\n\n<template>\n  <div>\n    <router-link to=\"/home\">home</router-link> |\n    <router-link to=\"/about\">about</router-link> |\n    <router-link to=\"/user/conanan/id/10086\">user</router-link> |\n    <router-link to=\"/notfound/aa/bb/cc\">notfound</router-link> |\n    <button @click=\"jumptoabout\">查看我！</button>\n    <button @click=\"back\">←</button>\n    <button @click=\"forword\">→</button>\n    <router-view />\n  </div>\n</template>\n\n<script setup>\nimport { userouter } from 'vue-router'\nconst router = userouter()\n\nconst jumptoabout = () => {\n  router.push({\n    path: '/about',\n    query: {\n      q1: 'qa1',\n    },\n  })\n}\n\nconst forword = () => {\n  router.go(1)\n  // 其他方法就不介绍了\n}\n\nconst back = () => {\n  router.go(-1)\n}\n<\/script>\n\n<style>\n.router-link-active {\n  color: red;\n}\n</style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n\n\n修改/src/pages/about.vue\n\n<template>\n  <div>\n    <h2>about</h2>\n    <div>{{ route.query.q1 }}</div>\n  </div>\n</template>\n\n<script setup>\nimport { useroute } from 'vue-router'\nconst route = useroute()\n<\/script>\n\n<style lang=\"scss\" scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# 动态添加、删除路由—权限 🔥\n\n\n# 添加路由\n\n某些情况下我们可能需要动态的来添加路由:\n\n * 比如根据用户不同的权限，注册不同的路由;\n * 这个时候我们可以使用一个方法 addroute;\n\n如果我们是为route添加一个children路由，那么可以传入对应的name\n\n修改 /src/router/index.js\n\nconst router = createrouter({\n  history: createwebhistory(),\n  routes,\n})\n\n// 动态添加路由\nconst categoryroute = {\n  path: '/category',\n  component: () => import('../views/category.vue'),\n}\n\n// 添加顶级路由对象\nrouter.addroute(categoryroute)\n\n// 添加二级路由对象，第一个参数为路由的名称name\nrouter.addroute('home', {\n  path: 'moment',\n  component: () => import('../views/homemoment.vue'),\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 删除路由\n\n不常用，删除路由有以下三种方式:\n\n * 方式一：添加一个name相同的路由;\n * 方式二：通过removeroute方法，传入路由的名称;\n * 方式三：通过addroute方法的返回值回调;\n\n\n\n\n# 其他方法\n\n * router.hasroute()：检查路由是否存在。\n * router.getroutes()：获取一个包含所有路由记录的数组\n\n\n# 路由导航守卫—拦截 🔥\n\n\n# 介绍\n\n * vue-router 提供的导航守卫主要用来通过跳转或取消的方式守卫导航。\n\n * 全局的前置守卫beforeeach是在导航触发时会被回调的\n   \n   它有两个参数:\n   \n   * to:即将进入的路由route对象;\n   * from:即将离开的路由route对象;\n\n * 它有返回值:\n   \n   * false:取消当前导航;\n   * 不返回或者undefined:进行默认导航;\n   * 返回一个路由地址:\n     * 可以是一个string类型的路径;\n     * 可以是一个对象，对象中包含path、query、params等信息;\n\n * 可选的第三个参数:next\n   \n   * 在vue2中我们是通过next函数来决定如何进行跳转的;\n   * 但是在vue3中我们是通过返回值来控制的，不再推荐使用next函数，这是因为开发中很容易调用多次next;\n\n修改 /src/router/index.js\n\n// 导航守卫beforeeach\nlet counter = 0\n// to: route对象, 即将跳转到的route对象\n// from: route对象,\n/**\n * 返回值问题:\n *    1.false: 不进行导航\n *    2.undefined或者不写返回值: 进行默认导航\n *    3.字符串: 路径, 跳转到对应的路径中\n *    4.对象: 类似于 router.push({path: \"/login\", query: ....})\n */\nrouter.beforeeach((to, from) => {\n  console.log(`进行了${++counter}路由跳转`)\n  // if (to.path.indexof(\"/home\") !== -1) {\n  //   return \"/login\"\n  // }\n  if (to.path !== '/login') {\n    const token = window.localstorage.getitem('token')\n    if (!token) {\n      return '/login'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n\n\n\n# 登录守卫功能\n\n/src/login.vue\n\n<template>\n  <div>\n    <button @click=\"loginclick\">登录</button>\n  </div>\n</template>\n\n<script setup>\nimport { userouter } from 'vue-router'\n\nconst router = userouter()\n\nconst loginclick = () => {\n  window.localstorage.setitem('token', 'why')\n\n  router.push({\n    path: '/home',\n  })\n}\n<\/script>\n\n<style scoped></style>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n\n\n注册路由\n\n{\n  path: '/login',\n  component: () => import('../views/login.vue'),\n},\n\n\n1\n2\n3\n4\n\n\n修改 /src/router/index.js\n\n// 导航守卫beforeeach\nrouter.beforeeach((to, from) => {\n  if (to.path !== '/login') {\n    const token = window.localstorage.getitem('token')\n    if (!token) {\n      return '/login'\n    }\n  }\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n\n# 其他导航守卫\n\nvue还提供了很多的其他守卫函数，目的都是在某一个时刻给予我们回调，让我们可以更好的控制程序的流程或者功能\n\n完整的导航解析流程:\n\n * 导航被触发。\n * 在失活的组件里调用 beforerouteleave 守卫。\n * 调用全局的 beforeeach 守卫。\n * 在重用的组件里调用 beforerouteupdate 守卫(2.2+)。\n * 在路由配置里调用 beforeenter。\n * 解析异步路由组件。\n * 在被激活的组件里调用 beforerouteenter。\n * 调用全局的 beforeresolve 守卫(2.5+)。\n * 导航被确认。\n * 调用全局的 aftereach 钩子。\n * 触发 dom 更新。\n * 调用 beforerouteenter 守卫中传给 next 的回调函数，创建好的组件实例会作为回调函数的参数传入。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"状态管理",frontmatter:{title:"状态管理",date:"2022-02-08T22:54:22.000Z",permalink:"/pages/47a190/",categories:["x","Vuex"],tags:[null]},regularPath:"/1403.Vue3.x/900.Vuex/901.%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86.html",relativePath:"1403.Vue3.x/900.Vuex/901.状态管理.md",key:"v-a7ae7326",path:"/pages/47a190/",headers:[{level:2,title:"什么是状态管理",slug:"什么是状态管理",normalizedTitle:"什么是状态管理",charIndex:11},{level:2,title:"复杂的状态管理",slug:"复杂的状态管理",normalizedTitle:"复杂的状态管理",charIndex:310}],headersStr:"什么是状态管理 复杂的状态管理",content:"# 状态管理\n\n\n# 什么是状态管理\n\n在开发中，我们会的应用程序需要处理各种各样的数据，这些 数据需要保存在我们应用程序中的某一个位置，对于这些数据 的管理我们就称之为是 状态管理。\n\n在前面我们是如何管理自己的状态呢?\n\n * 在Vue开发中，我们使用组件化的开发方式;\n\n * 而在组件中我们定义data或者在setup中返回使用的数据， 这些数据我们称之为state;\n\n * 在模块template中我们可以使用这些数据，模块最终会被 渲染成DOM，我们称之为View;\n\n * 在模块中我们会产生一些行为事件，处理这些行为事件时， 有可能会修改state，这些行为事件我们称之为actions;\n\n\n\n\n# 复杂的状态管理\n\nJavaScript开发的应用程序，已经变得越来越复杂了:\n\n * JavaScript需要管理的状态越来越多，越来越复杂;\n * 这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等;\n * 也包括一些UI的状态，比如某些元素是否被选中，是否显示加载动效，当前分页;\n\n当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏:\n\n * 多个视图依赖于同一状态;\n * 来自不同视图的行为需要变更同一状态;\n\n我们是否可以通过组件数据的传递来完成呢?\n\n * 对于一些简单的状态，确实可以通过props的传递或者Provide的方式来共享状态;\n\n * 但是对于复杂的状态管理来说，显然单纯通过传递和共享的方式是不足以解决问题的，比如兄弟组件如何共享数据呢?",normalizedContent:"# 状态管理\n\n\n# 什么是状态管理\n\n在开发中，我们会的应用程序需要处理各种各样的数据，这些 数据需要保存在我们应用程序中的某一个位置，对于这些数据 的管理我们就称之为是 状态管理。\n\n在前面我们是如何管理自己的状态呢?\n\n * 在vue开发中，我们使用组件化的开发方式;\n\n * 而在组件中我们定义data或者在setup中返回使用的数据， 这些数据我们称之为state;\n\n * 在模块template中我们可以使用这些数据，模块最终会被 渲染成dom，我们称之为view;\n\n * 在模块中我们会产生一些行为事件，处理这些行为事件时， 有可能会修改state，这些行为事件我们称之为actions;\n\n\n\n\n# 复杂的状态管理\n\njavascript开发的应用程序，已经变得越来越复杂了:\n\n * javascript需要管理的状态越来越多，越来越复杂;\n * 这些状态包括服务器返回的数据、缓存数据、用户操作产生的数据等等;\n * 也包括一些ui的状态，比如某些元素是否被选中，是否显示加载动效，当前分页;\n\n当我们的应用遇到多个组件共享状态时，单向数据流的简洁性很容易被破坏:\n\n * 多个视图依赖于同一状态;\n * 来自不同视图的行为需要变更同一状态;\n\n我们是否可以通过组件数据的传递来完成呢?\n\n * 对于一些简单的状态，确实可以通过props的传递或者provide的方式来共享状态;\n\n * 但是对于复杂的状态管理来说，显然单纯通过传递和共享的方式是不足以解决问题的，比如兄弟组件如何共享数据呢?",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"Vuex",frontmatter:{title:"Vuex",date:"2022-02-08T22:57:49.000Z",permalink:"/pages/fa4384/",categories:["x","Vuex"],tags:[null]},regularPath:"/1403.Vue3.x/900.Vuex/902.Vuex.html",relativePath:"1403.Vue3.x/900.Vuex/902.Vuex.md",key:"v-d73b99a6",path:"/pages/fa4384/",headers:[{level:2,title:"Vuex的状态管理",slug:"vuex的状态管理",normalizedTitle:"vuex的状态管理",charIndex:11},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:672},{level:2,title:"单一状态树 🔥",slug:"单一状态树-🔥",normalizedTitle:"单一状态树 🔥",charIndex:789},{level:2,title:"创建 store 🔥",slug:"创建-store-🔥",normalizedTitle:"创建 store 🔥",charIndex:1123},{level:2,title:"state & mapState 🔥",slug:"state-mapstate-🔥",normalizedTitle:"state &amp; mapstate 🔥",charIndex:null},{level:3,title:"options 中使用",slug:"options-中使用",normalizedTitle:"options 中使用",charIndex:2018},{level:3,title:"composition 中使用 🔥",slug:"composition-中使用-🔥",normalizedTitle:"composition 中使用 🔥",charIndex:2689},{level:2,title:"getters & mapGetters 封装 🔥",slug:"getters-mapgetters-封装-🔥",normalizedTitle:"getters &amp; mapgetters 封装 🔥",charIndex:null},{level:3,title:"options 中使用",slug:"options-中使用-2",normalizedTitle:"options 中使用",charIndex:2018},{level:3,title:"composition 中使用 🔥",slug:"composition-中使用-🔥-2",normalizedTitle:"composition 中使用 🔥",charIndex:2689},{level:2,title:"mutations & commit & mapMutations 🔥",slug:"mutations-commit-mapmutations-🔥",normalizedTitle:"mutations &amp; commit &amp; mapmutations 🔥",charIndex:null},{level:3,title:"注意：必须是同步函数",slug:"注意-必须是同步函数",normalizedTitle:"注意：必须是同步函数",charIndex:7988},{level:3,title:"mutations & commit",slug:"mutations-commit",normalizedTitle:"mutations &amp; commit",charIndex:null},{level:3,title:"options 中使用",slug:"options-中使用-3",normalizedTitle:"options 中使用",charIndex:2018},{level:3,title:"composition 中使用 🔥",slug:"composition-中使用-🔥-3",normalizedTitle:"composition 中使用 🔥",charIndex:2689},{level:2,title:"actions & dispatch & mapActions 🔥",slug:"actions-dispatch-mapactions-🔥",normalizedTitle:"actions &amp; dispatch &amp; mapactions 🔥",charIndex:null},{level:3,title:"注意：可以包含异步操作",slug:"注意-可以包含异步操作",normalizedTitle:"注意：可以包含异步操作",charIndex:13740},{level:3,title:"context 🔥",slug:"context-🔥",normalizedTitle:"context 🔥",charIndex:13809},{level:3,title:"actions 返回值 🔥",slug:"actions-返回值-🔥",normalizedTitle:"actions 返回值 🔥",charIndex:14016},{level:3,title:"options 中使用",slug:"options-中使用-4",normalizedTitle:"options 中使用",charIndex:2018},{level:3,title:"composition 中使用 🔥",slug:"composition-中使用-🔥-4",normalizedTitle:"composition 中使用 🔥",charIndex:2689},{level:2,title:"module 🔥",slug:"module-🔥",normalizedTitle:"module 🔥",charIndex:15921},{level:3,title:"什么是Module",slug:"什么是module",normalizedTitle:"什么是module",charIndex:15935},{level:3,title:"store",slug:"store",normalizedTitle:"store",charIndex:408},{level:3,title:"state 使用",slug:"state-使用",normalizedTitle:"state 使用",charIndex:17646},{level:3,title:"module的局部状态",slug:"module的局部状态",normalizedTitle:"module的局部状态",charIndex:18262},{level:3,title:"module的命名空间 🔥",slug:"module的命名空间-🔥",normalizedTitle:"module的命名空间 🔥",charIndex:18324},{level:3,title:"module修改或派发根组件",slug:"module修改或派发根组件",normalizedTitle:"module修改或派发根组件",charIndex:19343},{level:3,title:"module的辅助函数 🔥",slug:"module的辅助函数-🔥",normalizedTitle:"module的辅助函数 🔥",charIndex:19703},{level:2,title:"Vuex 封装",slug:"vuex-封装",normalizedTitle:"vuex 封装",charIndex:21990},{level:3,title:"mapState & mapGetters 封装 ①",slug:"mapstate-mapgetters-封装-1",normalizedTitle:"mapstate &amp; mapgetters 封装 ①",charIndex:null},{level:3,title:"没有模块封装 🔥",slug:"没有模块封装-🔥",normalizedTitle:"没有模块封装 🔥",charIndex:23112},{level:3,title:"最终 🔥",slug:"最终-🔥",normalizedTitle:"最终 🔥",charIndex:24134},{level:2,title:"注意 🔥",slug:"注意-🔥",normalizedTitle:"注意 🔥",charIndex:25965}],headersStr:"Vuex的状态管理 安装 单一状态树 🔥 创建 store 🔥 state & mapState 🔥 options 中使用 composition 中使用 🔥 getters & mapGetters 封装 🔥 options 中使用 composition 中使用 🔥 mutations & commit & mapMutations 🔥 注意：必须是同步函数 mutations & commit options 中使用 composition 中使用 🔥 actions & dispatch & mapActions 🔥 注意：可以包含异步操作 context 🔥 actions 返回值 🔥 options 中使用 composition 中使用 🔥 module 🔥 什么是Module store state 使用 module的局部状态 module的命名空间 🔥 module修改或派发根组件 module的辅助函数 🔥 Vuex 封装 mapState & mapGetters 封装 ① 没有模块封装 🔥 最终 🔥 注意 🔥",content:"# Vuex\n\n\n# Vuex的状态管理\n\n管理不断变化的state本身是非常困难的:\n\n * 状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，View页面也有可能会引起状态的变化;\n\n * 当应用程序复杂时，state在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控制和追踪;\n\n因此，我们是否可以考虑将组件的内部状态抽离出来，以一个全局单例的方式来管理呢?\n\n * 在这种模式下，我们的组件树构成了一个巨大的 “视图View”;\n\n * 不管在树的哪个位置，任何组件都能获取状态或者触发行为;\n\n * 通过定义和隔离状态管理中的各个概念，并通过强制性的规则来维护视图和状态间的独立性，我们的代码边会变得更加结构化和易于维护、跟踪;\n\n这就是Vuex背后的基本思想，它借鉴了Flux、Redux、Elm（纯函数语言，redux有借鉴它的思想）\n\n每一个Vuex应用的核心就是store(仓库)：store本质上是一个容器，它包含着你的应用中大部分的状态(state)\n\n\n\nVuex和单纯的全局对象有什么区别呢？\n\n * Vuex的状态存储是响应式的。当Vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会被更新\n * 你不能直接改变store中的状态。\n   * 改变store中的状态的唯一途径就显示提交 (commit) mutation;\n   * 这样使得我们可以方便的跟踪每一个状态的变化，从而让我们能够通过一些工具帮助我们更好的管理应用的状态\n\n\n# 安装\n\n这里使用的是vuex4.x，安装的时候需要添加 next 指定版本（实际根据当前版本决定添加next与否）\n\n npm install vuex@next\n\n\n1\n\n\n安装 Vue DevTools 浏览器插件 🔥\n\n\n# 单一状态树 🔥\n\nVuex 使用单一状态树:\n\n * 用一个对象就包含了全部的应用层级状（store只有一个，但是可以分模块）\n * 采用的是SSOT，Single Source of Truth，也可以翻译成单一数据源;\n * 这也意味着，每个应用将仅仅包含一个 store 实例;\n * 单状态树和模块化并不冲突，后面我们会讲到module的概念;\n\n单一状态树的优势:\n\n * 如果你的状态信息是保存到多个Store对象中的，那么之后的管理和维护等等都会变得特别困难;\n * 所以Vuex也使用了单一状态树来管理应用层级的全部状态;\n * 单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护;\n\n\n# 创建 store 🔥\n\n使用步骤:\n\n * 创建Store对象，/src/store/index.js\n   \n   import { createStore } from 'vuex'\n   \n   export default createStore({\n     state: {\n     },\n     mutations: {\n     },\n     actions: {\n     },\n     modules: {\n     }\n   })\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n * 在app中通过插件安装，/src/main.js\n   \n   import { createApp } from 'vue'\n   import App from './App.vue'\n   import store from './store'\n   \n   createApp(App).use(store).mount('#app')\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n在组件中使用store，我们按照如下的方式:\n\n * 在模板中使用;\n * 在options api中使用，比如computed;\n * 在setup中使用;\n\n\n# state & mapState 🔥\n\n/src/store/index.js\n\nimport { createStore } from 'vuex'\n\nexport default createStore({\n  state: {\n    counter: 100,\n    name: 'conanan',\n    age: 18,\n    height: 188,\n  },\n  mutations: {},\n  actions: {},\n  modules: {},\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# options 中使用\n\n<template>\n  <div>\n    <h2>Home:{{ $store.state.counter }}</h2>\n    <h2>Home:{{ sCounter }}</h2>\n    <h2>Home:{{ sName }}</h2>\n    \x3c!-- <h2>Home:{{ age }}</h2>\n    <h2>Home:{{ height }}</h2> --\x3e\n  </div>\n</template>\n\n<script>\nimport { mapState } from 'vuex'\n\nexport default {\n  computed: {\n    fullName() {\n      return 'Kobe Bryant'\n    },\n    // 其他的计算属性, 从state获取\n    // 1 数组\n    // ...mapState([\"counter\", \"name\", \"age\", \"height\"])\n    // 2 对象，可起别名\n    ...mapState({\n      sCounter: (state) => state.counter,\n      sName: (state) => state.name,\n    }),\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# composition 中使用 🔥\n\n<template>\n  <div>\n    <h2>Home:{{ $store.state.counter }}</h2>\n    <hr>\n    <h2>{{sCounter}}</h2>\n    <h2>{{counter}}</h2>\n    <h2>{{name}}</h2>\n    <h2>{{age}}</h2>\n    <h2>{{height}}</h2>\n    <hr>\n  </div>\n</template>\n\n<script>\n  import { mapState, useStore } from 'vuex'\n  import { computed } from 'vue'\n\n  export default {\n    computed: {\n      fullName: function() {\n        return \"1fdasfdasfad\"\n      },\n      ...mapState([\"name\", \"age\"])\n    },\n\n    setup() {\n      const store = useStore()\n      const sCounter = computed(() => store.state.counter)\n      // const sName = computed(() => store.state.name)\n      // const sAge = computed(() => store.state.age)\n\n      const storeStateFns = mapState([\"counter\", \"name\", \"age\", \"height\"])\n\n      // {name: function, age: function, height: function}\n      // {name: ref, age: ref, height: ref}\n      const storeState = {}\n      Object.keys(storeStateFns).forEach(fnKey => {\n        const fn = storeStateFns[fnKey].bind({$store: store})\n        storeState[fnKey] = computed(fn)\n      })\n\n      return {\n        sCounter,\n        ...storeState\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\nmapState返回的是值为function的对象，所以不能直接解构，需遍历并使用计算属性，封装后见 Vuex封装—最终\n\n使用\n\n<template>\n  <div>\n    <h2>Home:{{ $store.state.counter }}</h2>\n    <hr />\n    <h2>{{ counter }}</h2>\n    <h2>{{ name }}</h2>\n    <h2>{{ age }}</h2>\n    <h2>{{ height }}</h2>\n    <h2>{{ sCounter }}</h2>\n    <h2>{{ sName }}</h2>\n    <hr />\n  </div>\n</template>\n\n<script>\n// import { useState } from '../hooks/useVuex'\n\n// export default {\n//   setup() {\n//     const storeState = useState(['counter', 'name', 'age', 'height'])\n//     const storeState2 = useState({\n//       sCounter: (state) => state.counter,\n//       sName: (state) => state.name,\n//     })\n\n//     return {\n//       ...storeState,\n//       ...storeState2,\n//     }\n//   },\n// }\n//\n<\/script>\n\n<script setup>\nimport { useState } from '../hooks/useVuex'\n\nconst { counter, name, age, height } = useState([\n  'counter',\n  'name',\n  'age',\n  'height',\n])\nconst { sCounter, sName } = useState({\n  sCounter: (state) => state.counter,\n  sName: (state) => state.name,\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# getters & mapGetters 封装 🔥\n\n某些属性我们可能需要经过变化（运算）后来使用，这个时候可以使用getters\n\n/src/store/index.js，要展示如下books的总价格等等\n\nimport { createStore } from 'vuex'\n\nexport default createStore({\n  state: {\n    counter: 100,\n    name: 'conanan',\n    age: 18,\n    height: 188,\n    books: [\n      { name: '深入Vuejs', price: 200, count: 3 },\n      { name: '深入Webpack', price: 240, count: 5 },\n      { name: '深入React', price: 130, count: 1 },\n      { name: '深入Node', price: 220, count: 2 },\n    ],\n  },\n  mutations: {},\n  actions: {},\n  modules: {},\n  getters: {\n    // 调用其他 getter\n    totalPrice(state, getters) {\n      let totalPrice = 0\n      for (const book of state.books) {\n        totalPrice += book.count * book.price\n      }\n      return totalPrice * getters.currentDiscount\n    },\n    currentDiscount(state) {\n      return state.discount * 0.9\n    },\n    // 传递参数\n    totalPriceCountGreaterN(state, getters) {\n      return function (n) {\n        let totalPrice = 0\n        for (const book of state.books) {\n          if (book.count > n) {\n            totalPrice += book.count * book.price\n          }\n        }\n        return totalPrice * getters.currentDiscount\n      }\n    },\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# options 中使用\n\n<template>\n  <div>\n    <h2>总价值: {{ $store.getters.totalPrice }}</h2>\n    <h2>总价值: {{ $store.getters.totalPriceCountGreaterN(1) }}</h2>\n    <hr />\n    <h2>{{ sNameInfo }}</h2>\n    <h2>{{ sAgeInfo }}</h2>\n    <h2>{{ ageInfo }}</h2>\n    <h2>{{ heightInfo }}</h2>\n    <hr />\n  </div>\n</template>\n\n<script>\nimport { mapGetters } from 'vuex'\n\nexport default {\n  computed: {\n    ...mapGetters(['nameInfo', 'ageInfo', 'heightInfo']),\n    ...mapGetters({\n      sNameInfo: 'nameInfo',\n      sAgeInfo: 'ageInfo',\n    }),\n  },\n  setup() {},\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# composition 中使用 🔥\n\n同样的 mapGetters 返回的是值为function的对象，所以不能直接解构，需遍历并使用计算属性，封装后见 Vuex封装—最终\n\n使用\n\n<template>\n  <div>\n    <h2>总价值: {{ $store.getters.totalPrice }}</h2>\n    <h2>总价值: {{ $store.getters.totalPriceCountGreaterN(1) }}</h2>\n    <hr />\n    <h2>{{ nameInfo }}</h2>\n    <h2>{{ ageInfo }}</h2>\n    <h2>{{ heightInfo }}</h2>\n    <hr />\n  </div>\n</template>\n\n<script>\n// import { useGetters } from '../hooks/useVuex'\n\n// export default {\n//   computed: {},\n//   setup() {\n//     const storeGetters = useGetters(['nameInfo', 'ageInfo', 'heightInfo'])\n//     return {\n//       ...storeGetters,\n//     }\n//   },\n// }\n<\/script>\n\n<script setup>\nimport { useGetters } from '../hooks/useVuex'\n\nconst { nameInfo, ageInfo, heightInfo } = useGetters([\n  'nameInfo',\n  'ageInfo',\n  'heightInfo',\n])\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# mutations & commit & mapMutations 🔥\n\n\n# 注意：必须是同步函数\n\n * mutation 必须是同步函数\n * 这是因为devtool工具会记录mutation的日记，每一条mutation被记录，devtools都需要捕捉到前一状态和后一状态的快照。但是在mutation中执行异步操作，就无法追踪到数据的变化，所以Vuex的重要原则中要求 mutation必须是同步函数\n\n\n# mutations & commit\n\n/src/store/index.js\n\nimport { createStore } from 'vuex'\nimport { INCREMENT_N } from './mutation-types'\n\nexport default createStore({\n  state: {\n    counter: 100,\n    name: 'conanan',\n    age: 18,\n    height: 188,\n    books: [\n      { name: '深入Vuejs', price: 200, count: 3 },\n      { name: '深入Webpack', price: 240, count: 5 },\n      { name: '深入React', price: 130, count: 1 },\n      { name: '深入Node', price: 220, count: 2 },\n    ],\n    discount: 0.6,\n  },\n  mutations: {\n    increment(state) {\n      state.counter++\n    },\n    decrement(state) {\n      state.counter--\n    },\n    // 10 -> payload\n    // {n: 10, name: \"why\", age: 18} -> payload\n    [INCREMENT_N](state, payload) {\n      console.log(payload)\n      state.counter += payload.n\n    },\n  },\n  actions: {},\n  modules: {},\n  getters: {\n    \n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n/src/sotre/mutation-types.js\n\nexport const INCREMENT_N = \"increment_n\"\n\n\n1\n\n\ncommit 使用\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr>\n      <button @click=\"$store.commit('increment')\">+1</button>\n      <button @click=\"$store.commit('decrement')\">-1</button>\n      <button @click=\"addTen\">+10</button>\n    <hr>\n  </div>\n</template>\n\n<script>\n  import { INCREMENT_N } from '../store/mutation-types'\n\n  export default {\n    methods: {\n      addTen() {\n        // this.$store.commit('incrementN', 10)\n        // this.$store.commit('incrementN', {n: 10, name: \"why\", age: 18})\n        // 另外一种提交风格\n        this.$store.commit({\n          type: INCREMENT_N,\n          n: 10, \n          name: \"why\", \n          age: 18\n        })\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# options 中使用\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr />\n    <button @click=\"increment\">+1</button>\n    <button @click=\"add\">+1</button>\n    <button @click=\"decrement\">-1</button>\n    <button @click=\"increment_n({ n: 10 })\">+10</button>\n    <hr />\n  </div>\n</template>\n\n<script>\nimport { mapMutations } from 'vuex'\n\nimport { INCREMENT_N } from '../store/mutation-types'\n\nexport default {\n  methods: {\n    ...mapMutations(['increment', 'decrement', INCREMENT_N]),\n    ...mapMutations({\n      add: 'increment',\n    }),\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# composition 中使用 🔥\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr />\n    <button @click=\"increment\">+1</button>\n    <button @click=\"add\">+1</button>\n    <button @click=\"decrement\">-1</button>\n    <button @click=\"increment_n({ n: 10 })\">+10</button>\n    <hr />\n  </div>\n</template>\n\n<script>\n// import { useMutations } from '../hooks/useVuex'\n// import { INCREMENT_N } from '../store/mutation-types'\n\n// export default {\n//   setup() {\n//     console.log('11')\n//     const mutations1 = useMutations(['increment', 'decrement', INCREMENT_N])\n//     const mutations2 = useMutations({\n//       add: 'increment',\n//     })\n//     return {\n//       ...mutations1,\n//       ...mutations2,\n//     }\n//   },\n// }\n<\/script>\n\n<script setup>\nimport { useMutations } from '../hooks/useVuex'\nimport { INCREMENT_N } from '../store/mutation-types'\n\n// 这里的解构只能用 increment_n 表示了，暂时没有其他办法\nconst { increment, decrement, increment_n } = useMutations([\n  'increment',\n  'decrement',\n  INCREMENT_N,\n])\nconst { add } = useMutations({\n  add: 'increment',\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# actions & dispatch & mapActions 🔥\n\n/src/store/index.js\n\nimport { createStore } from 'vuex'\nimport axios from 'axios'\nimport { INCREMENT_N } from './mutation-types'\n\nexport default createStore({\n  state: {\n    counter: 100,\n    name: 'conanan',\n    age: 18,\n    height: 188,\n    books: [\n      { name: '深入Vuejs', price: 200, count: 3 },\n      { name: '深入Webpack', price: 240, count: 5 },\n      { name: '深入React', price: 130, count: 1 },\n      { name: '深入Node', price: 220, count: 2 },\n    ],\n    discount: 0.6,\n    banners: [],\n  },\n  mutations: {\n    increment(state) {\n      state.counter++\n    },\n    decrement(state) {\n      state.counter--\n    },\n    // 10 -> payload\n    // {n: 10, name: \"why\", age: 18} -> payload\n    [INCREMENT_N](state, payload) {\n      console.log(payload)\n      state.counter += payload.n\n    },\n    addBannerData(state, payload) {\n      state.banners = payload\n    },\n  },\n  actions: {\n    // 放函数\n    // 1.参数问题\n    incrementAction(context, payload) {\n      console.log(payload)\n      setTimeout(() => {\n        context.commit('increment')\n      }, 1000)\n    },\n    // 2.context的其他属性\n    decrementAction({\n      commit,\n      dispatch,\n      state,\n      rootState,\n      getters,\n      rootGetters,\n    }) {\n      commit('decrement')\n    },\n    getHomeMultidata(context) {\n      return new Promise((resolve, reject) => {\n        axios\n          .get('http://123.207.32.32:8000/home/multidata')\n          .then((res) => {\n            context.commit('addBannerData', res.data.data.banner.list)\n            resolve({ name: 'coderwhy', age: 18 })\n          })\n          .catch((err) => {\n            reject(err)\n          })\n      })\n    },\n  },\n  modules: {},\n  getters: {\n    \n  },\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 注意：可以包含异步操作\n\n * Action提交的是mutation，而不是直接变更状态\n * Action可以包含任意异步操作\n\n\n# context 🔥\n\n * context是一个和store实例均有相同方法和属性的context对象;\n * 所以我们可以从其中获取到 commit 方法来提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当然还有其他参数。\n * 但是为什么它不是store对象呢?这个等到我们讲Modules时再具体来说;\n\n\n# actions 返回值 🔥\n\nAction 通常是异步的，那么如何知道 action 什么时候结束呢?\n\n * 我们可以通过让action返回Promise，在Promise的then中来处理完成后的操作;\n\n\n# options 中使用\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr />\n    <button @click=\"incrementAction\">+1</button>\n    <button @click=\"decrementAction\">-1</button>\n    <button @click=\"add\">+1</button>\n    <button @click=\"sub\">-1</button>\n    <hr />\n  </div>\n</template>\n\n<script>\nimport { mapActions } from 'vuex';\n\nexport default {\n  methods: {\n    ...mapActions([\"incrementAction\", \"decrementAction\"]),\n    ...mapActions({\n      add: \"incrementAction\",\n      sub: \"decrementAction\"\n    })\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# composition 中使用 🔥\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr />\n    <button @click=\"incrementAction\">+1</button>\n    <button @click=\"decrementAction\">-1</button>\n    <button @click=\"add\">+1</button>\n    <button @click=\"sub\">-1</button>\n    <hr />\n  </div>\n</template>\n\n<script>\n// import { mapActions } from 'vuex'\n// import { useActions } from '../hooks/useVuex'\n\n// export default {\n//   setup() {\n//     const actions = mapActions(['incrementAction', 'decrementAction'])\n//     const actions2 = mapActions({\n//       add: 'incrementAction',\n//       sub: 'decrementAction',\n//     })\n//     console.log('actions', actions)\n//     console.log('actions2', actions2)\n//     return {\n//       ...actions,\n//       ...actions2,\n//     }\n//   },\n// }\n<\/script>\n\n<script setup>\nimport { useActions } from '../hooks/useVuex'\n\nconst { incrementAction, decrementAction } = useActions([\n  'incrementAction',\n  'decrementAction',\n])\n\nconst { add, sub } = useActions({\n  add: 'incrementAction',\n  sub: 'decrementAction',\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# module 🔥\n\n\n# 什么是Module\n\n * 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用非常复杂时，store 就有可能变得相当臃肿;\n * 为了解决以上问题，Vuex 允许我们将 store 分割成模块(module);\n * 每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块;\n\n\n# store\n\n/src/store/index.js\n\nimport { createStore } from \"vuex\"\nimport home from './modules/home'\nimport user from './modules/user'\n\nconst store = createStore({\n  state() {\n    return {\n      rootCounter: 100\n    }\n  },\n  getters: {\n    doubleRootCounter(state) {\n      return state.rootCounter * 2\n    }\n  },\n  mutations: {\n    increment(state) {\n      state.rootCounter++\n    }\n  },\n  modules: {\n    home,\n    user\n  }\n});\n\nexport default store;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n/src/store/modules/home.js\n\nconst homeModule = {\n  namespaced: true,\n  state() {\n    return {\n      homeCounter: 100\n    }\n  },\n  getters: {\n    doubleHomeCounter(state, getters, rootState, rootGetters) {\n      return state.homeCounter * 2\n    },\n    otherGetter(state) {\n      return 100\n    }\n  },\n  mutations: {\n    increment(state) {\n      state.homeCounter++\n    }\n  },\n  actions: {\n    incrementAction({commit, dispatch, state, rootState, getters, rootGetters}) {\n      commit(\"increment\")\n      commit(\"increment\", null, {root: true})\n\n      // dispatch\n      // dispatch(\"incrementAction\", null, {root: true})\n    }\n  }\n}\n\nexport default homeModule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n/src/store/modules/user.js\n\nconst userModule = {\n  namespaced: true,\n  state() {\n    return {\n      userCounter: 10\n    }\n  },\n  getters: {\n\n  },\n  mutations: {\n\n  },\n  actions: {\n\n  }\n}\n\nexport default userModule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# state 使用\n\n<template>\n  <div>\n    <h2>{{ $store.state.rootCounter }}</h2>\n    <h2>{{ $store.state.home.homeCounter }}</h2>\n    <h2>{{ $store.state.user.userCounter }}</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    setup() {\n    }\n  }\n<\/script>\n\n<style scoped>\n\n</style><template>\n  <div>\n    <h2>{{ $store.state.rootCounter }}</h2>\n    <h2>{{ $store.state.home.homeCounter }}</h2>\n    <h2>{{ $store.state.user.userCounter }}</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    setup() {\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# module的局部状态\n\n对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象\n\n\n# module的命名空间 🔥\n\n默认情况下，模块内部的 action 和mutation 仍然是注册在全局的命名空间中的:\n\n * 这样使得多个模块能够对同一个 action 或 mutation 作出响应;\n * Getter 同样也默认注册在全局命名空间;\n\n如果我们希望模块具有更高的封装度和复用性，可以添加 namespaced: true 的方式使其成为带命名空间的模块:\n\n * 当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名\n\n<template>\n  <div>\n    <h2>root:{{ $store.state.rootCounter }}</h2>\n    <h2>home:{{ $store.state.home.homeCounter }}</h2>\n    <h2>user:{{ $store.state.user.userCounter }}</h2>\n\n    <hr>\n    <h2>{{ $store.getters[\"home/doubleHomeCounter\"] }}</h2>\n\n    <button @click=\"homeIncrement\">home+1</button>\n    <button @click=\"homeIncrementAction\">home+1</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    methods: {\n      homeIncrement() {\n        this.$store.commit(\"home/increment\")\n      },\n      homeIncrementAction() {\n        this.$store.dispatch(\"home/incrementAction\")\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 访问 state 时：$store.state.user.xxx\n * 访问其他3个：$store.commit(\"user/changeName\")\n\n\n\n\n# module修改或派发根组件\n\n如果我们希望在action中修改root中的state，那么有如下的方式\n\nactions: {\n    incrementAction({commit, dispatch, state, rootState, getters, rootGetters}) {\n      commit(\"increment\")\n      // null 是 payload\n      commit(\"increment\", null, {root: true})\n\n      // dispatch 同样\n      // dispatch(\"incrementAction\", null, {root: true})\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# module的辅助函数 🔥\n\n如果辅助函数有三种使用方法:\n\n * 方式一:通过完整的模块空间名称来查找;\n * 方式二:第一个参数传入模块空间名称，后面写上要使用的属性;\n * 方式三:通过 createNamespacedHelpers 生成一个模块的辅助函数;\n\n<template>\n  <div>\n    <hr>\n    <h2>{{ homeCounter }}</h2>\n    <h2>{{ doubleHomeCounter }}</h2>\n    \x3c!-- <h2>{{ doubleRootCounter }}</h2> --\x3e\n    <button @click=\"increment\">home+1</button>\n    <button @click=\"incrementAction\">home+1</button>\n    <hr>\n  </div>\n</template>\n\n<script>\n  import { createNamespacedHelpers, mapState, mapGetters, mapMutations, mapActions } from \"vuex\";\n\n  import { useState, useGetters } from '../hooks/index'\n\n  // const { mapState, mapGetters, mapMutations, mapActions } = createNamespacedHelpers(\"home\")\n\n  export default {\n    computed: {\n      // 1.写法一:\n      // ...mapState({\n      //   homeCounter: state => state.home.homeCounter\n      // }),\n      // ...mapGetters({\n      //   doubleHomeCounter: \"home/doubleHomeCounter\"\n      // })\n\n      // 2.写法二:\n      // ...mapState(\"home\", [\"homeCounter\"]),\n      // ...mapGetters(\"home\", [\"doubleHomeCounter\"])\n\n      // 3.写法三:\n      // ...mapState([\"homeCounter\"]),\n      // ...mapGetters([\"doubleHomeCounter\"])\n    },\n    methods: {\n      // 1.写法一:\n      // ...mapMutations({\n      //   increment: \"home/increment\"\n      // }),\n      // ...mapActions({\n      //   incrementAction: \"home/incrementAction\"\n      // }),\n\n      // 2.写法二\n      // ...mapMutations(\"home\", [\"increment\"]),\n      // ...mapActions(\"home\", [\"incrementAction\"]),\n      \n      // 3.写法三:\n      // ...mapMutations([\"increment\"]),\n      // ...mapActions([\"incrementAction\"]),\n    },\n\n    setup() {\n      // {homeCounter: function}\n      // const state = useState([\"rootCounter\"])\n      // const rootGetters = useGetters([\"doubleRootCounter\"])\n      // const getters = useGetters(\"home\", [\"doubleHomeCounter\"])\n\n      // const mutations = mapMutations([\"increment\"])\n      // const actions = mapActions([\"incrementAction\"])\n\n      return {\n        // ...state,\n        // ...getters,\n        // ...rootGetters\n        // ...mutations,\n        // ...actions\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# Vuex 封装\n\n\n# mapState & mapGetters 封装 ①\n\n封装不够彻底\n\n/src/hooks/index.js\n\nimport { useGetters } from './useGetters';\nimport { useState } from './useState';\n\nexport {\n  useGetters,\n  useState\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/src/hooks/useState.js\n\nimport { mapState } from 'vuex'\nimport { useMapper } from './useMapper'\n\nexport function useState(mapper) {\n  return useMapper(mapper, mapState)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n/src/hooks/useGetters.js\n\nimport { mapGetters } from 'vuex'\nimport { useMapper } from './useMapper'\n\nexport function useGetters(mapper) {\n  return useMapper(mapper, mapGetters)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n/src/hooks/useMapper.js\n\nimport { computed } from 'vue'\nimport { useStore } from 'vuex'\n\nexport function useMapper(mapper, mapFn) {\n  // 拿到store独享\n  const store = useStore()\n\n  // 获取到对应的对象的functions: {name: function, age: function}\n  const storeStateFns = mapFn(mapper)\n\n  // 对数据进行转换\n  const storeState = {}\n  Object.keys(storeStateFns).forEach(fnKey => {\n    const fn = storeStateFns[fnKey].bind({$store: store})\n    storeState[fnKey] = computed(fn)\n  })\n\n  return storeState\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 没有模块封装 🔥\n\n/src/hooks/useVuex.js\n\nimport { computed } from 'vue'\nimport { useStore, mapState, mapGetters, mapMutations, mapActions } from 'vuex'\n\nexport function useState(mapper) {\n  return useMapper(mapper, mapState, 'computed')\n}\n\nexport function useGetters(mapper) {\n  return useMapper(mapper, mapGetters, 'computed')\n}\n\nexport function useMutations(mapper) {\n  return useMapper(mapper, mapMutations, 'function')\n}\n\nexport function useActions(mapper) {\n  return useMapper(mapper, mapActions, 'function')\n}\n\nexport function useMapper(mapper, mapFn, type) {\n  // 拿到store独享\n  const store = useStore()\n\n  // 获取到对应的对象的functions: {name: function, age: function}\n  const storeFns = mapFn(mapper)\n\n  // 对数据进行转换\n  const storeInfo = {}\n  Object.keys(storeFns).forEach((fnKey) => {\n    const fn = storeFns[fnKey].bind({ $store: store })\n    storeInfo[fnKey] = type === 'computed' ? computed(fn) : fn\n  })\n\n  return storeInfo\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 最终 🔥\n\n/src/hooks/useVuex.js，但是没有传递module时，这里也没有从index中找啊？\n\nimport { computed } from 'vue'\nimport {\n  useStore,\n  mapState,\n  mapGetters,\n  mapMutations,\n  mapActions,\n  createNamespacedHelpers,\n} from 'vuex'\n\nexport function useState(moduleName, mapper) {\n  let mapperFn = mapState\n  if (typeof moduleName === 'string' && moduleName.length > 0) {\n    mapperFn = createNamespacedHelpers(moduleName).mapState\n  }\n  return useMapper(mapper, mapperFn, 'computed')\n}\n\nexport function useGetters(moduleName, mapper) {\n  let mapperFn = mapGetters\n  if (typeof moduleName === 'string' && moduleName.length > 0) {\n    mapperFn = createNamespacedHelpers(moduleName).mapGetters\n  }\n  return useMapper(mapper, mapperFn, 'computed')\n}\n\nexport function useMutations(moduleName, mapper) {\n  let mapperFn = mapMutations\n  if (typeof moduleName === 'string' && moduleName.length > 0) {\n    mapperFn = createNamespacedHelpers(moduleName).mapMutations\n  }\n  return useMapper(mapper, mapperFn, 'function')\n}\n\nexport function useActions(moduleName, mapper) {\n  let mapperFn = mapActions\n  if (typeof moduleName === 'string' && moduleName.length > 0) {\n    mapperFn = createNamespacedHelpers(moduleName).mapActions\n  }\n  return useMapper(mapper, mapperFn, 'function')\n}\n\nexport function useMapper(mapper, mapFn, type) {\n  // 拿到store独享\n  const store = useStore()\n\n  // 获取到对应的对象的functions: {name: function, age: function}\n  const storeFns = mapFn(mapper)\n\n  // 对数据进行转换\n  const storeInfo = {}\n  Object.keys(storeFns).forEach((fnKey) => {\n    const fn = storeFns[fnKey].bind({ $store: store })\n    storeInfo[fnKey] = type === 'computed' ? computed(fn) : fn\n  })\n\n  return storeInfo\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 注意 🔥\n\n上面示例中 setup() 和 setup script 不能共存，否则执行的是 setup script 代码",normalizedContent:"# vuex\n\n\n# vuex的状态管理\n\n管理不断变化的state本身是非常困难的:\n\n * 状态之间相互会存在依赖，一个状态的变化会引起另一个状态的变化，view页面也有可能会引起状态的变化;\n\n * 当应用程序复杂时，state在什么时候，因为什么原因而发生了变化，发生了怎么样的变化，会变得非常难以控制和追踪;\n\n因此，我们是否可以考虑将组件的内部状态抽离出来，以一个全局单例的方式来管理呢?\n\n * 在这种模式下，我们的组件树构成了一个巨大的 “视图view”;\n\n * 不管在树的哪个位置，任何组件都能获取状态或者触发行为;\n\n * 通过定义和隔离状态管理中的各个概念，并通过强制性的规则来维护视图和状态间的独立性，我们的代码边会变得更加结构化和易于维护、跟踪;\n\n这就是vuex背后的基本思想，它借鉴了flux、redux、elm（纯函数语言，redux有借鉴它的思想）\n\n每一个vuex应用的核心就是store(仓库)：store本质上是一个容器，它包含着你的应用中大部分的状态(state)\n\n\n\nvuex和单纯的全局对象有什么区别呢？\n\n * vuex的状态存储是响应式的。当vue组件从store中读取状态的时候，若store中的状态发生变化，那么相应的组件也会被更新\n * 你不能直接改变store中的状态。\n   * 改变store中的状态的唯一途径就显示提交 (commit) mutation;\n   * 这样使得我们可以方便的跟踪每一个状态的变化，从而让我们能够通过一些工具帮助我们更好的管理应用的状态\n\n\n# 安装\n\n这里使用的是vuex4.x，安装的时候需要添加 next 指定版本（实际根据当前版本决定添加next与否）\n\n npm install vuex@next\n\n\n1\n\n\n安装 vue devtools 浏览器插件 🔥\n\n\n# 单一状态树 🔥\n\nvuex 使用单一状态树:\n\n * 用一个对象就包含了全部的应用层级状（store只有一个，但是可以分模块）\n * 采用的是ssot，single source of truth，也可以翻译成单一数据源;\n * 这也意味着，每个应用将仅仅包含一个 store 实例;\n * 单状态树和模块化并不冲突，后面我们会讲到module的概念;\n\n单一状态树的优势:\n\n * 如果你的状态信息是保存到多个store对象中的，那么之后的管理和维护等等都会变得特别困难;\n * 所以vuex也使用了单一状态树来管理应用层级的全部状态;\n * 单一状态树能够让我们最直接的方式找到某个状态的片段，而且在之后的维护和调试过程中，也可以非常方便的管理和维护;\n\n\n# 创建 store 🔥\n\n使用步骤:\n\n * 创建store对象，/src/store/index.js\n   \n   import { createstore } from 'vuex'\n   \n   export default createstore({\n     state: {\n     },\n     mutations: {\n     },\n     actions: {\n     },\n     modules: {\n     }\n   })\n   \n   \n   \n   1\n   2\n   3\n   4\n   5\n   6\n   7\n   8\n   9\n   10\n   11\n   12\n   13\n   \n\n * 在app中通过插件安装，/src/main.js\n   \n   import { createapp } from 'vue'\n   import app from './app.vue'\n   import store from './store'\n   \n   createapp(app).use(store).mount('#app')\n   \n   \n   1\n   2\n   3\n   4\n   5\n   \n\n在组件中使用store，我们按照如下的方式:\n\n * 在模板中使用;\n * 在options api中使用，比如computed;\n * 在setup中使用;\n\n\n# state & mapstate 🔥\n\n/src/store/index.js\n\nimport { createstore } from 'vuex'\n\nexport default createstore({\n  state: {\n    counter: 100,\n    name: 'conanan',\n    age: 18,\n    height: 188,\n  },\n  mutations: {},\n  actions: {},\n  modules: {},\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n\n\n\n# options 中使用\n\n<template>\n  <div>\n    <h2>home:{{ $store.state.counter }}</h2>\n    <h2>home:{{ scounter }}</h2>\n    <h2>home:{{ sname }}</h2>\n    \x3c!-- <h2>home:{{ age }}</h2>\n    <h2>home:{{ height }}</h2> --\x3e\n  </div>\n</template>\n\n<script>\nimport { mapstate } from 'vuex'\n\nexport default {\n  computed: {\n    fullname() {\n      return 'kobe bryant'\n    },\n    // 其他的计算属性, 从state获取\n    // 1 数组\n    // ...mapstate([\"counter\", \"name\", \"age\", \"height\"])\n    // 2 对象，可起别名\n    ...mapstate({\n      scounter: (state) => state.counter,\n      sname: (state) => state.name,\n    }),\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n\n\n\n# composition 中使用 🔥\n\n<template>\n  <div>\n    <h2>home:{{ $store.state.counter }}</h2>\n    <hr>\n    <h2>{{scounter}}</h2>\n    <h2>{{counter}}</h2>\n    <h2>{{name}}</h2>\n    <h2>{{age}}</h2>\n    <h2>{{height}}</h2>\n    <hr>\n  </div>\n</template>\n\n<script>\n  import { mapstate, usestore } from 'vuex'\n  import { computed } from 'vue'\n\n  export default {\n    computed: {\n      fullname: function() {\n        return \"1fdasfdasfad\"\n      },\n      ...mapstate([\"name\", \"age\"])\n    },\n\n    setup() {\n      const store = usestore()\n      const scounter = computed(() => store.state.counter)\n      // const sname = computed(() => store.state.name)\n      // const sage = computed(() => store.state.age)\n\n      const storestatefns = mapstate([\"counter\", \"name\", \"age\", \"height\"])\n\n      // {name: function, age: function, height: function}\n      // {name: ref, age: ref, height: ref}\n      const storestate = {}\n      object.keys(storestatefns).foreach(fnkey => {\n        const fn = storestatefns[fnkey].bind({$store: store})\n        storestate[fnkey] = computed(fn)\n      })\n\n      return {\n        scounter,\n        ...storestate\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\nmapstate返回的是值为function的对象，所以不能直接解构，需遍历并使用计算属性，封装后见 vuex封装—最终\n\n使用\n\n<template>\n  <div>\n    <h2>home:{{ $store.state.counter }}</h2>\n    <hr />\n    <h2>{{ counter }}</h2>\n    <h2>{{ name }}</h2>\n    <h2>{{ age }}</h2>\n    <h2>{{ height }}</h2>\n    <h2>{{ scounter }}</h2>\n    <h2>{{ sname }}</h2>\n    <hr />\n  </div>\n</template>\n\n<script>\n// import { usestate } from '../hooks/usevuex'\n\n// export default {\n//   setup() {\n//     const storestate = usestate(['counter', 'name', 'age', 'height'])\n//     const storestate2 = usestate({\n//       scounter: (state) => state.counter,\n//       sname: (state) => state.name,\n//     })\n\n//     return {\n//       ...storestate,\n//       ...storestate2,\n//     }\n//   },\n// }\n//\n<\/script>\n\n<script setup>\nimport { usestate } from '../hooks/usevuex'\n\nconst { counter, name, age, height } = usestate([\n  'counter',\n  'name',\n  'age',\n  'height',\n])\nconst { scounter, sname } = usestate({\n  scounter: (state) => state.counter,\n  sname: (state) => state.name,\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n\n\n\n# getters & mapgetters 封装 🔥\n\n某些属性我们可能需要经过变化（运算）后来使用，这个时候可以使用getters\n\n/src/store/index.js，要展示如下books的总价格等等\n\nimport { createstore } from 'vuex'\n\nexport default createstore({\n  state: {\n    counter: 100,\n    name: 'conanan',\n    age: 18,\n    height: 188,\n    books: [\n      { name: '深入vuejs', price: 200, count: 3 },\n      { name: '深入webpack', price: 240, count: 5 },\n      { name: '深入react', price: 130, count: 1 },\n      { name: '深入node', price: 220, count: 2 },\n    ],\n  },\n  mutations: {},\n  actions: {},\n  modules: {},\n  getters: {\n    // 调用其他 getter\n    totalprice(state, getters) {\n      let totalprice = 0\n      for (const book of state.books) {\n        totalprice += book.count * book.price\n      }\n      return totalprice * getters.currentdiscount\n    },\n    currentdiscount(state) {\n      return state.discount * 0.9\n    },\n    // 传递参数\n    totalpricecountgreatern(state, getters) {\n      return function (n) {\n        let totalprice = 0\n        for (const book of state.books) {\n          if (book.count > n) {\n            totalprice += book.count * book.price\n          }\n        }\n        return totalprice * getters.currentdiscount\n      }\n    },\n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n\n\n\n# options 中使用\n\n<template>\n  <div>\n    <h2>总价值: {{ $store.getters.totalprice }}</h2>\n    <h2>总价值: {{ $store.getters.totalpricecountgreatern(1) }}</h2>\n    <hr />\n    <h2>{{ snameinfo }}</h2>\n    <h2>{{ sageinfo }}</h2>\n    <h2>{{ ageinfo }}</h2>\n    <h2>{{ heightinfo }}</h2>\n    <hr />\n  </div>\n</template>\n\n<script>\nimport { mapgetters } from 'vuex'\n\nexport default {\n  computed: {\n    ...mapgetters(['nameinfo', 'ageinfo', 'heightinfo']),\n    ...mapgetters({\n      snameinfo: 'nameinfo',\n      sageinfo: 'ageinfo',\n    }),\n  },\n  setup() {},\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n\n# composition 中使用 🔥\n\n同样的 mapgetters 返回的是值为function的对象，所以不能直接解构，需遍历并使用计算属性，封装后见 vuex封装—最终\n\n使用\n\n<template>\n  <div>\n    <h2>总价值: {{ $store.getters.totalprice }}</h2>\n    <h2>总价值: {{ $store.getters.totalpricecountgreatern(1) }}</h2>\n    <hr />\n    <h2>{{ nameinfo }}</h2>\n    <h2>{{ ageinfo }}</h2>\n    <h2>{{ heightinfo }}</h2>\n    <hr />\n  </div>\n</template>\n\n<script>\n// import { usegetters } from '../hooks/usevuex'\n\n// export default {\n//   computed: {},\n//   setup() {\n//     const storegetters = usegetters(['nameinfo', 'ageinfo', 'heightinfo'])\n//     return {\n//       ...storegetters,\n//     }\n//   },\n// }\n<\/script>\n\n<script setup>\nimport { usegetters } from '../hooks/usevuex'\n\nconst { nameinfo, ageinfo, heightinfo } = usegetters([\n  'nameinfo',\n  'ageinfo',\n  'heightinfo',\n])\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# mutations & commit & mapmutations 🔥\n\n\n# 注意：必须是同步函数\n\n * mutation 必须是同步函数\n * 这是因为devtool工具会记录mutation的日记，每一条mutation被记录，devtools都需要捕捉到前一状态和后一状态的快照。但是在mutation中执行异步操作，就无法追踪到数据的变化，所以vuex的重要原则中要求 mutation必须是同步函数\n\n\n# mutations & commit\n\n/src/store/index.js\n\nimport { createstore } from 'vuex'\nimport { increment_n } from './mutation-types'\n\nexport default createstore({\n  state: {\n    counter: 100,\n    name: 'conanan',\n    age: 18,\n    height: 188,\n    books: [\n      { name: '深入vuejs', price: 200, count: 3 },\n      { name: '深入webpack', price: 240, count: 5 },\n      { name: '深入react', price: 130, count: 1 },\n      { name: '深入node', price: 220, count: 2 },\n    ],\n    discount: 0.6,\n  },\n  mutations: {\n    increment(state) {\n      state.counter++\n    },\n    decrement(state) {\n      state.counter--\n    },\n    // 10 -> payload\n    // {n: 10, name: \"why\", age: 18} -> payload\n    [increment_n](state, payload) {\n      console.log(payload)\n      state.counter += payload.n\n    },\n  },\n  actions: {},\n  modules: {},\n  getters: {\n    \n  },\n})\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n\n\n/src/sotre/mutation-types.js\n\nexport const increment_n = \"increment_n\"\n\n\n1\n\n\ncommit 使用\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr>\n      <button @click=\"$store.commit('increment')\">+1</button>\n      <button @click=\"$store.commit('decrement')\">-1</button>\n      <button @click=\"addten\">+10</button>\n    <hr>\n  </div>\n</template>\n\n<script>\n  import { increment_n } from '../store/mutation-types'\n\n  export default {\n    methods: {\n      addten() {\n        // this.$store.commit('incrementn', 10)\n        // this.$store.commit('incrementn', {n: 10, name: \"why\", age: 18})\n        // 另外一种提交风格\n        this.$store.commit({\n          type: increment_n,\n          n: 10, \n          name: \"why\", \n          age: 18\n        })\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n\n\n\n# options 中使用\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr />\n    <button @click=\"increment\">+1</button>\n    <button @click=\"add\">+1</button>\n    <button @click=\"decrement\">-1</button>\n    <button @click=\"increment_n({ n: 10 })\">+10</button>\n    <hr />\n  </div>\n</template>\n\n<script>\nimport { mapmutations } from 'vuex'\n\nimport { increment_n } from '../store/mutation-types'\n\nexport default {\n  methods: {\n    ...mapmutations(['increment', 'decrement', increment_n]),\n    ...mapmutations({\n      add: 'increment',\n    }),\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n\n\n# composition 中使用 🔥\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr />\n    <button @click=\"increment\">+1</button>\n    <button @click=\"add\">+1</button>\n    <button @click=\"decrement\">-1</button>\n    <button @click=\"increment_n({ n: 10 })\">+10</button>\n    <hr />\n  </div>\n</template>\n\n<script>\n// import { usemutations } from '../hooks/usevuex'\n// import { increment_n } from '../store/mutation-types'\n\n// export default {\n//   setup() {\n//     console.log('11')\n//     const mutations1 = usemutations(['increment', 'decrement', increment_n])\n//     const mutations2 = usemutations({\n//       add: 'increment',\n//     })\n//     return {\n//       ...mutations1,\n//       ...mutations2,\n//     }\n//   },\n// }\n<\/script>\n\n<script setup>\nimport { usemutations } from '../hooks/usevuex'\nimport { increment_n } from '../store/mutation-types'\n\n// 这里的解构只能用 increment_n 表示了，暂时没有其他办法\nconst { increment, decrement, increment_n } = usemutations([\n  'increment',\n  'decrement',\n  increment_n,\n])\nconst { add } = usemutations({\n  add: 'increment',\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n\n\n\n# actions & dispatch & mapactions 🔥\n\n/src/store/index.js\n\nimport { createstore } from 'vuex'\nimport axios from 'axios'\nimport { increment_n } from './mutation-types'\n\nexport default createstore({\n  state: {\n    counter: 100,\n    name: 'conanan',\n    age: 18,\n    height: 188,\n    books: [\n      { name: '深入vuejs', price: 200, count: 3 },\n      { name: '深入webpack', price: 240, count: 5 },\n      { name: '深入react', price: 130, count: 1 },\n      { name: '深入node', price: 220, count: 2 },\n    ],\n    discount: 0.6,\n    banners: [],\n  },\n  mutations: {\n    increment(state) {\n      state.counter++\n    },\n    decrement(state) {\n      state.counter--\n    },\n    // 10 -> payload\n    // {n: 10, name: \"why\", age: 18} -> payload\n    [increment_n](state, payload) {\n      console.log(payload)\n      state.counter += payload.n\n    },\n    addbannerdata(state, payload) {\n      state.banners = payload\n    },\n  },\n  actions: {\n    // 放函数\n    // 1.参数问题\n    incrementaction(context, payload) {\n      console.log(payload)\n      settimeout(() => {\n        context.commit('increment')\n      }, 1000)\n    },\n    // 2.context的其他属性\n    decrementaction({\n      commit,\n      dispatch,\n      state,\n      rootstate,\n      getters,\n      rootgetters,\n    }) {\n      commit('decrement')\n    },\n    gethomemultidata(context) {\n      return new promise((resolve, reject) => {\n        axios\n          .get('http://123.207.32.32:8000/home/multidata')\n          .then((res) => {\n            context.commit('addbannerdata', res.data.data.banner.list)\n            resolve({ name: 'coderwhy', age: 18 })\n          })\n          .catch((err) => {\n            reject(err)\n          })\n      })\n    },\n  },\n  modules: {},\n  getters: {\n    \n  },\n})\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n\n\n\n# 注意：可以包含异步操作\n\n * action提交的是mutation，而不是直接变更状态\n * action可以包含任意异步操作\n\n\n# context 🔥\n\n * context是一个和store实例均有相同方法和属性的context对象;\n * 所以我们可以从其中获取到 commit 方法来提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当然还有其他参数。\n * 但是为什么它不是store对象呢?这个等到我们讲modules时再具体来说;\n\n\n# actions 返回值 🔥\n\naction 通常是异步的，那么如何知道 action 什么时候结束呢?\n\n * 我们可以通过让action返回promise，在promise的then中来处理完成后的操作;\n\n\n# options 中使用\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr />\n    <button @click=\"incrementaction\">+1</button>\n    <button @click=\"decrementaction\">-1</button>\n    <button @click=\"add\">+1</button>\n    <button @click=\"sub\">-1</button>\n    <hr />\n  </div>\n</template>\n\n<script>\nimport { mapactions } from 'vuex';\n\nexport default {\n  methods: {\n    ...mapactions([\"incrementaction\", \"decrementaction\"]),\n    ...mapactions({\n      add: \"incrementaction\",\n      sub: \"decrementaction\"\n    })\n  },\n}\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n\n\n\n# composition 中使用 🔥\n\n<template>\n  <div>\n    <h2>当前计数: {{ $store.state.counter }}</h2>\n    <hr />\n    <button @click=\"incrementaction\">+1</button>\n    <button @click=\"decrementaction\">-1</button>\n    <button @click=\"add\">+1</button>\n    <button @click=\"sub\">-1</button>\n    <hr />\n  </div>\n</template>\n\n<script>\n// import { mapactions } from 'vuex'\n// import { useactions } from '../hooks/usevuex'\n\n// export default {\n//   setup() {\n//     const actions = mapactions(['incrementaction', 'decrementaction'])\n//     const actions2 = mapactions({\n//       add: 'incrementaction',\n//       sub: 'decrementaction',\n//     })\n//     console.log('actions', actions)\n//     console.log('actions2', actions2)\n//     return {\n//       ...actions,\n//       ...actions2,\n//     }\n//   },\n// }\n<\/script>\n\n<script setup>\nimport { useactions } from '../hooks/usevuex'\n\nconst { incrementaction, decrementaction } = useactions([\n  'incrementaction',\n  'decrementaction',\n])\n\nconst { add, sub } = useactions({\n  add: 'incrementaction',\n  sub: 'decrementaction',\n})\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n\n\n\n# module 🔥\n\n\n# 什么是module\n\n * 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象，当应用非常复杂时，store 就有可能变得相当臃肿;\n * 为了解决以上问题，vuex 允许我们将 store 分割成模块(module);\n * 每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块;\n\n\n# store\n\n/src/store/index.js\n\nimport { createstore } from \"vuex\"\nimport home from './modules/home'\nimport user from './modules/user'\n\nconst store = createstore({\n  state() {\n    return {\n      rootcounter: 100\n    }\n  },\n  getters: {\n    doublerootcounter(state) {\n      return state.rootcounter * 2\n    }\n  },\n  mutations: {\n    increment(state) {\n      state.rootcounter++\n    }\n  },\n  modules: {\n    home,\n    user\n  }\n});\n\nexport default store;\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n\n\n/src/store/modules/home.js\n\nconst homemodule = {\n  namespaced: true,\n  state() {\n    return {\n      homecounter: 100\n    }\n  },\n  getters: {\n    doublehomecounter(state, getters, rootstate, rootgetters) {\n      return state.homecounter * 2\n    },\n    othergetter(state) {\n      return 100\n    }\n  },\n  mutations: {\n    increment(state) {\n      state.homecounter++\n    }\n  },\n  actions: {\n    incrementaction({commit, dispatch, state, rootstate, getters, rootgetters}) {\n      commit(\"increment\")\n      commit(\"increment\", null, {root: true})\n\n      // dispatch\n      // dispatch(\"incrementaction\", null, {root: true})\n    }\n  }\n}\n\nexport default homemodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n\n\n/src/store/modules/user.js\n\nconst usermodule = {\n  namespaced: true,\n  state() {\n    return {\n      usercounter: 10\n    }\n  },\n  getters: {\n\n  },\n  mutations: {\n\n  },\n  actions: {\n\n  }\n}\n\nexport default usermodule\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# state 使用\n\n<template>\n  <div>\n    <h2>{{ $store.state.rootcounter }}</h2>\n    <h2>{{ $store.state.home.homecounter }}</h2>\n    <h2>{{ $store.state.user.usercounter }}</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    setup() {\n    }\n  }\n<\/script>\n\n<style scoped>\n\n</style><template>\n  <div>\n    <h2>{{ $store.state.rootcounter }}</h2>\n    <h2>{{ $store.state.home.homecounter }}</h2>\n    <h2>{{ $store.state.user.usercounter }}</h2>\n  </div>\n</template>\n\n<script>\n  export default {\n    setup() {\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n\n\n\n# module的局部状态\n\n对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象\n\n\n# module的命名空间 🔥\n\n默认情况下，模块内部的 action 和mutation 仍然是注册在全局的命名空间中的:\n\n * 这样使得多个模块能够对同一个 action 或 mutation 作出响应;\n * getter 同样也默认注册在全局命名空间;\n\n如果我们希望模块具有更高的封装度和复用性，可以添加 namespaced: true 的方式使其成为带命名空间的模块:\n\n * 当模块被注册后，它的所有 getter、action 及 mutation 都会自动根据模块注册的路径调整命名\n\n<template>\n  <div>\n    <h2>root:{{ $store.state.rootcounter }}</h2>\n    <h2>home:{{ $store.state.home.homecounter }}</h2>\n    <h2>user:{{ $store.state.user.usercounter }}</h2>\n\n    <hr>\n    <h2>{{ $store.getters[\"home/doublehomecounter\"] }}</h2>\n\n    <button @click=\"homeincrement\">home+1</button>\n    <button @click=\"homeincrementaction\">home+1</button>\n  </div>\n</template>\n\n<script>\n  export default {\n    methods: {\n      homeincrement() {\n        this.$store.commit(\"home/increment\")\n      },\n      homeincrementaction() {\n        this.$store.dispatch(\"home/incrementaction\")\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n\n * 访问 state 时：$store.state.user.xxx\n * 访问其他3个：$store.commit(\"user/changename\")\n\n\n\n\n# module修改或派发根组件\n\n如果我们希望在action中修改root中的state，那么有如下的方式\n\nactions: {\n    incrementaction({commit, dispatch, state, rootstate, getters, rootgetters}) {\n      commit(\"increment\")\n      // null 是 payload\n      commit(\"increment\", null, {root: true})\n\n      // dispatch 同样\n      // dispatch(\"incrementaction\", null, {root: true})\n    }\n  }\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n\n# module的辅助函数 🔥\n\n如果辅助函数有三种使用方法:\n\n * 方式一:通过完整的模块空间名称来查找;\n * 方式二:第一个参数传入模块空间名称，后面写上要使用的属性;\n * 方式三:通过 createnamespacedhelpers 生成一个模块的辅助函数;\n\n<template>\n  <div>\n    <hr>\n    <h2>{{ homecounter }}</h2>\n    <h2>{{ doublehomecounter }}</h2>\n    \x3c!-- <h2>{{ doublerootcounter }}</h2> --\x3e\n    <button @click=\"increment\">home+1</button>\n    <button @click=\"incrementaction\">home+1</button>\n    <hr>\n  </div>\n</template>\n\n<script>\n  import { createnamespacedhelpers, mapstate, mapgetters, mapmutations, mapactions } from \"vuex\";\n\n  import { usestate, usegetters } from '../hooks/index'\n\n  // const { mapstate, mapgetters, mapmutations, mapactions } = createnamespacedhelpers(\"home\")\n\n  export default {\n    computed: {\n      // 1.写法一:\n      // ...mapstate({\n      //   homecounter: state => state.home.homecounter\n      // }),\n      // ...mapgetters({\n      //   doublehomecounter: \"home/doublehomecounter\"\n      // })\n\n      // 2.写法二:\n      // ...mapstate(\"home\", [\"homecounter\"]),\n      // ...mapgetters(\"home\", [\"doublehomecounter\"])\n\n      // 3.写法三:\n      // ...mapstate([\"homecounter\"]),\n      // ...mapgetters([\"doublehomecounter\"])\n    },\n    methods: {\n      // 1.写法一:\n      // ...mapmutations({\n      //   increment: \"home/increment\"\n      // }),\n      // ...mapactions({\n      //   incrementaction: \"home/incrementaction\"\n      // }),\n\n      // 2.写法二\n      // ...mapmutations(\"home\", [\"increment\"]),\n      // ...mapactions(\"home\", [\"incrementaction\"]),\n      \n      // 3.写法三:\n      // ...mapmutations([\"increment\"]),\n      // ...mapactions([\"incrementaction\"]),\n    },\n\n    setup() {\n      // {homecounter: function}\n      // const state = usestate([\"rootcounter\"])\n      // const rootgetters = usegetters([\"doublerootcounter\"])\n      // const getters = usegetters(\"home\", [\"doublehomecounter\"])\n\n      // const mutations = mapmutations([\"increment\"])\n      // const actions = mapactions([\"incrementaction\"])\n\n      return {\n        // ...state,\n        // ...getters,\n        // ...rootgetters\n        // ...mutations,\n        // ...actions\n      }\n    }\n  }\n<\/script>\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n\n\n\n# vuex 封装\n\n\n# mapstate & mapgetters 封装 ①\n\n封装不够彻底\n\n/src/hooks/index.js\n\nimport { usegetters } from './usegetters';\nimport { usestate } from './usestate';\n\nexport {\n  usegetters,\n  usestate\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n\n\n/src/hooks/usestate.js\n\nimport { mapstate } from 'vuex'\nimport { usemapper } from './usemapper'\n\nexport function usestate(mapper) {\n  return usemapper(mapper, mapstate)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n/src/hooks/usegetters.js\n\nimport { mapgetters } from 'vuex'\nimport { usemapper } from './usemapper'\n\nexport function usegetters(mapper) {\n  return usemapper(mapper, mapgetters)\n}\n\n\n1\n2\n3\n4\n5\n6\n\n\n/src/hooks/usemapper.js\n\nimport { computed } from 'vue'\nimport { usestore } from 'vuex'\n\nexport function usemapper(mapper, mapfn) {\n  // 拿到store独享\n  const store = usestore()\n\n  // 获取到对应的对象的functions: {name: function, age: function}\n  const storestatefns = mapfn(mapper)\n\n  // 对数据进行转换\n  const storestate = {}\n  object.keys(storestatefns).foreach(fnkey => {\n    const fn = storestatefns[fnkey].bind({$store: store})\n    storestate[fnkey] = computed(fn)\n  })\n\n  return storestate\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n\n\n\n# 没有模块封装 🔥\n\n/src/hooks/usevuex.js\n\nimport { computed } from 'vue'\nimport { usestore, mapstate, mapgetters, mapmutations, mapactions } from 'vuex'\n\nexport function usestate(mapper) {\n  return usemapper(mapper, mapstate, 'computed')\n}\n\nexport function usegetters(mapper) {\n  return usemapper(mapper, mapgetters, 'computed')\n}\n\nexport function usemutations(mapper) {\n  return usemapper(mapper, mapmutations, 'function')\n}\n\nexport function useactions(mapper) {\n  return usemapper(mapper, mapactions, 'function')\n}\n\nexport function usemapper(mapper, mapfn, type) {\n  // 拿到store独享\n  const store = usestore()\n\n  // 获取到对应的对象的functions: {name: function, age: function}\n  const storefns = mapfn(mapper)\n\n  // 对数据进行转换\n  const storeinfo = {}\n  object.keys(storefns).foreach((fnkey) => {\n    const fn = storefns[fnkey].bind({ $store: store })\n    storeinfo[fnkey] = type === 'computed' ? computed(fn) : fn\n  })\n\n  return storeinfo\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n\n\n\n# 最终 🔥\n\n/src/hooks/usevuex.js，但是没有传递module时，这里也没有从index中找啊？\n\nimport { computed } from 'vue'\nimport {\n  usestore,\n  mapstate,\n  mapgetters,\n  mapmutations,\n  mapactions,\n  createnamespacedhelpers,\n} from 'vuex'\n\nexport function usestate(modulename, mapper) {\n  let mapperfn = mapstate\n  if (typeof modulename === 'string' && modulename.length > 0) {\n    mapperfn = createnamespacedhelpers(modulename).mapstate\n  }\n  return usemapper(mapper, mapperfn, 'computed')\n}\n\nexport function usegetters(modulename, mapper) {\n  let mapperfn = mapgetters\n  if (typeof modulename === 'string' && modulename.length > 0) {\n    mapperfn = createnamespacedhelpers(modulename).mapgetters\n  }\n  return usemapper(mapper, mapperfn, 'computed')\n}\n\nexport function usemutations(modulename, mapper) {\n  let mapperfn = mapmutations\n  if (typeof modulename === 'string' && modulename.length > 0) {\n    mapperfn = createnamespacedhelpers(modulename).mapmutations\n  }\n  return usemapper(mapper, mapperfn, 'function')\n}\n\nexport function useactions(modulename, mapper) {\n  let mapperfn = mapactions\n  if (typeof modulename === 'string' && modulename.length > 0) {\n    mapperfn = createnamespacedhelpers(modulename).mapactions\n  }\n  return usemapper(mapper, mapperfn, 'function')\n}\n\nexport function usemapper(mapper, mapfn, type) {\n  // 拿到store独享\n  const store = usestore()\n\n  // 获取到对应的对象的functions: {name: function, age: function}\n  const storefns = mapfn(mapper)\n\n  // 对数据进行转换\n  const storeinfo = {}\n  object.keys(storefns).foreach((fnkey) => {\n    const fn = storefns[fnkey].bind({ $store: store })\n    storeinfo[fnkey] = type === 'computed' ? computed(fn) : fn\n  })\n\n  return storeinfo\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n\n\n\n# 注意 🔥\n\n上面示例中 setup() 和 setup script 不能共存，否则执行的是 setup script 代码",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"入门",frontmatter:{title:"入门",date:"2020-12-27T00:28:43.000Z",permalink:"/pages/00b1d8/",categories:["微信小程序"],tags:[null]},regularPath:"/1500.%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/101.%E5%85%A5%E9%97%A8.html",relativePath:"1500.微信小程序/101.入门.md",key:"v-f5a073a2",path:"/pages/00b1d8/",headers:[{level:2,title:"准备 🔥",slug:"准备-🔥",normalizedTitle:"准备 🔥",charIndex:12},{level:3,title:"开发前",slug:"开发前",normalizedTitle:"开发前",charIndex:22},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:60},{level:3,title:"使用 NPM 包",slug:"使用-npm-包",normalizedTitle:"使用 npm 包",charIndex:173},{level:3,title:"NPM semver 🔥",slug:"npm-semver-🔥",normalizedTitle:"npm semver 🔥",charIndex:365},{level:2,title:"数据单向绑定 & 简易的数据双向绑定",slug:"数据单向绑定-简易的数据双向绑定",normalizedTitle:"数据单向绑定 &amp; 简易的数据双向绑定",charIndex:null},{level:2,title:"回调地狱 & 解决 🔥",slug:"回调地狱-解决-🔥",normalizedTitle:"回调地狱 &amp; 解决 🔥",charIndex:null},{level:3,title:"callback",slug:"callback",normalizedTitle:"callback",charIndex:559},{level:3,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:694},{level:3,title:"async await",slug:"async-await",normalizedTitle:"async await",charIndex:719},{level:2,title:"JS 基础",slug:"js-基础",normalizedTitle:"js 基础",charIndex:925},{level:3,title:"ES6 模版字符串",slug:"es6-模版字符串",normalizedTitle:"es6 模版字符串",charIndex:935},{level:3,title:"普通函数 VS 箭头函数的 this 指向问题",slug:"普通函数-vs-箭头函数的-this-指向问题",normalizedTitle:"普通函数 vs 箭头函数的 this 指向问题",charIndex:949},{level:2,title:"前端分层 🔥",slug:"前端分层-🔥",normalizedTitle:"前端分层 🔥",charIndex:977},{level:2,title:"JS 面向对象 🔥",slug:"js-面向对象-🔥",normalizedTitle:"js 面向对象 🔥",charIndex:1095},{level:2,title:"组件设计通用原则 🔥",slug:"组件设计通用原则-🔥",normalizedTitle:"组件设计通用原则 🔥",charIndex:1161},{level:3,title:"组件目的",slug:"组件目的",normalizedTitle:"组件目的",charIndex:1177},{level:3,title:"灵活性和易用性取舍",slug:"灵活性和易用性取舍",normalizedTitle:"灵活性和易用性取舍",charIndex:1252},{level:3,title:"样式宽高的固定",slug:"样式宽高的固定",normalizedTitle:"样式宽高的固定",charIndex:1471},{level:2,title:"小程序自定义组件的坑",slug:"小程序自定义组件的坑",normalizedTitle:"小程序自定义组件的坑",charIndex:1618},{level:2,title:"HTTPS 证书",slug:"https-证书",normalizedTitle:"https 证书",charIndex:1737},{level:2,title:"首页请求数量",slug:"首页请求数量",normalizedTitle:"首页请求数量",charIndex:1776},{level:2,title:"WXS & JS",slug:"wxs-js",normalizedTitle:"wxs &amp; js",charIndex:null},{level:2,title:"Observer 监听器",slug:"observer-监听器",normalizedTitle:"observer 监听器",charIndex:1901},{level:2,title:"Hover 点击态",slug:"hover-点击态",normalizedTitle:"hover 点击态",charIndex:1918},{level:2,title:"scroll-view 的一些问题",slug:"scroll-view-的一些问题",normalizedTitle:"scroll-view 的一些问题",charIndex:1947},{level:2,title:"图片下面多出10rpx左右问题",slug:"图片下面多出10rpx左右问题",normalizedTitle:"图片下面多出10rpx左右问题",charIndex:2109},{level:2,title:"单行文字省略问题",slug:"单行文字省略问题",normalizedTitle:"单行文字省略问题",charIndex:2150},{level:2,title:"触摸区大小 width",slug:"触摸区大小-width",normalizedTitle:"触摸区大小 width",charIndex:2204},{level:2,title:"抽象节点 🔥",slug:"抽象节点-🔥",normalizedTitle:"抽象节点 🔥",charIndex:2239},{level:2,title:"不使用 setData",slug:"不使用-setdata",normalizedTitle:"不使用 setdata",charIndex:2258},{level:2,title:"rpx—机型",slug:"rpx-机型",normalizedTitle:"rpx—机型",charIndex:2310},{level:2,title:"上拉加载",slug:"上拉加载",normalizedTitle:"上拉加载",charIndex:2351},{level:3,title:"阈值修改",slug:"阈值修改",normalizedTitle:"阈值修改",charIndex:2360},{level:3,title:"状态",slug:"状态",normalizedTitle:"状态",charIndex:1135},{level:2,title:"图片 bind:load",slug:"图片-bind-load",normalizedTitle:"图片 bind:load",charIndex:2490},{level:2,title:"小程序的渲染层对对象的封装 🔥",slug:"小程序的渲染层对对象的封装-🔥",normalizedTitle:"小程序的渲染层对对象的封装 🔥",charIndex:2523},{level:2,title:"直接事件转发 🔥",slug:"直接事件转发-🔥",normalizedTitle:"直接事件转发 🔥",charIndex:2588},{level:2,title:"自定义分享按钮样式 🔥",slug:"自定义分享按钮样式-🔥",normalizedTitle:"自定义分享按钮样式 🔥",charIndex:2652},{level:2,title:"text 标签不要随便换行🔥",slug:"text-标签不要随便换行🔥",normalizedTitle:"text 标签不要随便换行🔥",charIndex:2757},{level:2,title:"LinUI 的 Tabs 标签页 & Segment 选项卡",slug:"linui-的-tabs-标签页-segment-选项卡",normalizedTitle:"linui 的 tabs 标签页 &amp; segment 选项卡",charIndex:null},{level:2,title:"屏幕宽高 🔥",slug:"屏幕宽高-🔥",normalizedTitle:"屏幕宽高 🔥",charIndex:2877},{level:2,title:"console.log 数字 & 字符串 🔥",slug:"console-log-数字-字符串-🔥",normalizedTitle:"console.log 数字 &amp; 字符串 🔥",charIndex:null},{level:2,title:"小程序长列表组件 🔥",slug:"小程序长列表组件-🔥",normalizedTitle:"小程序长列表组件 🔥",charIndex:3359}],headersStr:"准备 🔥 开发前 配置 使用 NPM 包 NPM semver 🔥 数据单向绑定 & 简易的数据双向绑定 回调地狱 & 解决 🔥 callback Promise async await JS 基础 ES6 模版字符串 普通函数 VS 箭头函数的 this 指向问题 前端分层 🔥 JS 面向对象 🔥 组件设计通用原则 🔥 组件目的 灵活性和易用性取舍 样式宽高的固定 小程序自定义组件的坑 HTTPS 证书 首页请求数量 WXS & JS Observer 监听器 Hover 点击态 scroll-view 的一些问题 图片下面多出10rpx左右问题 单行文字省略问题 触摸区大小 width 抽象节点 🔥 不使用 setData rpx—机型 上拉加载 阈值修改 状态 图片 bind:load 小程序的渲染层对对象的封装 🔥 直接事件转发 🔥 自定义分享按钮样式 🔥 text 标签不要随便换行🔥 LinUI 的 Tabs 标签页 & Segment 选项卡 屏幕宽高 🔥 console.log 数字 & 字符串 🔥 小程序长列表组件 🔥",content:'# 微信小程序\n\n\n# 准备 🔥\n\n\n# 开发前\n\n * 申请 appid。appsecret 在服务端有用\n\n\n# 配置\n\n * [x] ES6 转 ES5\n * [x] 增强编译。为了使用 async、await\n * [x] 使用 npm 模块\n * [ ] 开发阶段可以勾上"不校验合法域名"，方便开发阶段使用 HTTP 协议\n\n\n# 使用 NPM 包\n\nnpn init 后安装。之后可以在 node_modules 该 npm 包的 package.json 中 version查看真实安装的版本，_id不知是不是\n\n还需要安装后点击「工具」—「构建 npm」，构建完毕会自动创建 miniprogram_npm 目录，这个才是最终要引用的组件目录。此时 node_modules 就没有用了，除非再次构建\n\n\n# NPM semver 🔥\n\n版本号规则\n\n~0.6.2：只会安装0.6.x中第三位 latest 版本\n\n^0.6.2：会安装0.x.x中第二、三位 latest 版本\n\n\n# 数据单向绑定 & 简易的数据双向绑定\n\nVue 是双向数据绑定，可以绑定复杂的数据\n\n微信小程序支持简易的数据双向绑定，只有 input 的 value 支持！！！\n\n\n# 回调地狱 & 解决 🔥\n\n\n# callback\n\n由于微信小程序的 wx.request 为异步请求，且使用的是回调函数来获取返回值（回调地狱），使用不同函数来调用时为了不产生回调地狱，则必须使用 callback 来处理返回值，有多少层调用就会有多个 callback，很是难受。\n\n所以可以封装 Promise。\n\n\n# Promise\n\n\n# async await\n\n * ES8 语法，需要在小程序勾选增强编译\n\n * async 只是一个标识符，用于声明异步函数\n\n * 只有在函数（方法）有 return 返回值时，这个值才会被 Promise.resolve() 包装为 Promise 对象（可以无需手动 new）；否则还是同步执行的！\n\n * await 用于暂停执行异步函数后面的代码，等待 Promise 对象被 resolve\n\n\n# JS 基础\n\n\n# ES6 模版字符串\n\n\n# 普通函数 VS 箭头函数的 this 指向问题\n\n\n# 前端分层 🔥\n\n前端 view 层的 JS 是否应该写业务逻辑？\n\n * 一般 View 层应该仅做数据绑定\n\n抽取 model 层\n\n * 数据流转等操作应该放在 model 层，而最终的数据交由 view 层来绑定、渲染\n\n\n# JS 面向对象 🔥\n\n * 比较麻烦，因为没有类型约束！\n * 需要考虑对象的状态所在类（不要太扣细节！太过于求完美！）\n\n\n# 组件设计通用原则 🔥\n\n\n# 组件目的\n\n * 对骨架、样式、业务逻辑（行为）的封装\n   \n   业务逻辑这里可以使用计数器组件来说明。有时需要根据货物数量来限制增减等\n\n\n# 灵活性和易用性取舍\n\n * 易用性：可封装原有组件，来限制以获取易用性（提高稳定）\n\n * 灵活性（可提供如下方式实现）：\n   \n   * Slot 插槽\n   \n   * 外部样式类\n   \n   * 业务逻辑（其实没有灵活的，目前只能做到提供多种业务逻辑，通过对属性传参来决定。否则就是另一个组件了）\n     \n     可以提供 Behavior 行为来让使用者自定义\n\n * 可提供**默认值（样式、插槽）**来中和\n\n\n# 样式宽高的固定\n\n * 固定高宽，你必须要有理由，比如为了点击事件的区域更大。\n * 固定高宽，弊端就是版本更迭很繁琐。修改和维护不方便。\n * 固定高宽，数值难以确定。\n\n写样式时（特别是组件开发），width 指定 750rpx 则可以用 100% 替代，因为父容器的宽度不确定性\n\n\n# 小程序自定义组件的坑\n\n * 自定义组件添加 margin 无效解决：1.给原生组件加；2.view包裹；3.自定义外部样式类\n\n * 自定义组件无法使用 app.wxss 中定义的样式，需要自己写，然后 @import 导入！\n\n\n# HTTPS 证书\n\n * lets encrypt\n * caddy\n\n\n# 首页请求数量\n\n * HTTP 请求数量\n * 数据库查询次数，join\n * 接口灵活性、可维护性\n\n\n# WXS & JS\n\n * 逻辑层：JS\n * 视图层：要在小程序的 wxml 中写 js，只能使用 wxs（只支持 ES5！！！）\n\n\n# Observer 监听器\n\n\n# Hover 点击态\n\n * view 的动画使用\n\n\n# scroll-view 的一些问题\n\nenable-flex 为 true 的 scroll-view x 轴滚动时 y 轴留白问题，解决：\n\nalign-items: center;\n\n\n1\n\n\n也可以取消 scroll-view 的 enable-flex，采用内嵌 view，给该 view 来设置 flex\n\n\n# 图片下面多出10rpx左右问题\n\ndisplay: flex;\n\n\n1\n\n\n\n# 单行文字省略问题\n\n由于必须指定 width，所以有时可以使用 js 来截取，或者 wxs 来截取\n\n\n# 触摸区大小 width\n\n为了触摸区大点，来指定 width\n\n\n# 抽象节点 🔥\n\n类似 插槽\n\n\n# 不使用 setData\n\n有些数据无需渲染，使用 this.data.xxx = xxx 即可\n\n\n# rpx—机型\n\n只有在 iPhone 6 上才满足 2rpx = 1px\n\n\n# 上拉加载\n\n\n# 阈值修改\n\napp.json修改即可\n\nonReachBottomDistance\n\n\n1\n\n\n\n# 状态\n\n 1. 点击（下拉）加载（基本不会看到该状态！！）\n 2. 加载中；\n 3. 没有更多\n\n总之就是12123这样的循环，但是1基本不会出现！\n\n\n# 图片 bind:load\n\n使用该方式来动态指定图片长宽\n\n\n# 小程序的渲染层对对象的封装 🔥\n\n注意，经过小程序渲染层后，对象已经不再是原来的对象，无法根据引用类型特征，直接修改！\n\n\n# 直接事件转发 🔥\n\n自己封装开源组件为新的组件，那么该开源组件的事件可以直接在使用封装组件的地方调用，会自动转发！！\n\n\n# 自定义分享按钮样式 🔥\n\n没有 API ！！！必须使用原生 button！！！样式比较难修改！！！\n\n * 盖住原生 button。比较麻烦\n * 使用 lin-ui button。牛皮的很啊！🔥\n\n\n# text 标签不要随便换行🔥\n\n否则会有空行！\n\n\n# LinUI 的 Tabs 标签页 & Segment 选项卡\n\n * Tabs 标签页：标签 和 页面！是2个联动起来的\n * Segment 选项卡：只管理标签！方便使用\n\n\n# 屏幕宽高 🔥\n\nconst getSystemSize = async function () {\n  // const res = await promisic(wx.getSystemInfo)()\n  const res = await wxp.getSystemInfo()\n  return {\n    windowHeight: res.windowHeight, // 可使用窗口宽度，单位px\n    windowWidth:res.windowWidth, // 可使用窗口高度，单位px。除去原生配置的 tabbar，导航栏\n    screenWidth: res.screenWidth, // 屏幕宽度，单位px\n    screenHeight: res.screenHeight, // 屏幕高度，单位px\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n不同机型之间 rpx 和 px 比例可有上述计算\n\n\n# console.log 数字 & 字符串 🔥\n\n * 数字为蓝色表示！\n * 字符串为黑色！\n\n\n# 小程序长列表组件 🔥\n\n普通列表，追加时，setData 会造成全部都需要重新渲染，而小程序不允许渲染这么多，所以到后面的数据就不会显示了。\n\n推荐使用 recycle-view 长列表组件来实现！！！',normalizedContent:'# 微信小程序\n\n\n# 准备 🔥\n\n\n# 开发前\n\n * 申请 appid。appsecret 在服务端有用\n\n\n# 配置\n\n * [x] es6 转 es5\n * [x] 增强编译。为了使用 async、await\n * [x] 使用 npm 模块\n * [ ] 开发阶段可以勾上"不校验合法域名"，方便开发阶段使用 http 协议\n\n\n# 使用 npm 包\n\nnpn init 后安装。之后可以在 node_modules 该 npm 包的 package.json 中 version查看真实安装的版本，_id不知是不是\n\n还需要安装后点击「工具」—「构建 npm」，构建完毕会自动创建 miniprogram_npm 目录，这个才是最终要引用的组件目录。此时 node_modules 就没有用了，除非再次构建\n\n\n# npm semver 🔥\n\n版本号规则\n\n~0.6.2：只会安装0.6.x中第三位 latest 版本\n\n^0.6.2：会安装0.x.x中第二、三位 latest 版本\n\n\n# 数据单向绑定 & 简易的数据双向绑定\n\nvue 是双向数据绑定，可以绑定复杂的数据\n\n微信小程序支持简易的数据双向绑定，只有 input 的 value 支持！！！\n\n\n# 回调地狱 & 解决 🔥\n\n\n# callback\n\n由于微信小程序的 wx.request 为异步请求，且使用的是回调函数来获取返回值（回调地狱），使用不同函数来调用时为了不产生回调地狱，则必须使用 callback 来处理返回值，有多少层调用就会有多个 callback，很是难受。\n\n所以可以封装 promise。\n\n\n# promise\n\n\n# async await\n\n * es8 语法，需要在小程序勾选增强编译\n\n * async 只是一个标识符，用于声明异步函数\n\n * 只有在函数（方法）有 return 返回值时，这个值才会被 promise.resolve() 包装为 promise 对象（可以无需手动 new）；否则还是同步执行的！\n\n * await 用于暂停执行异步函数后面的代码，等待 promise 对象被 resolve\n\n\n# js 基础\n\n\n# es6 模版字符串\n\n\n# 普通函数 vs 箭头函数的 this 指向问题\n\n\n# 前端分层 🔥\n\n前端 view 层的 js 是否应该写业务逻辑？\n\n * 一般 view 层应该仅做数据绑定\n\n抽取 model 层\n\n * 数据流转等操作应该放在 model 层，而最终的数据交由 view 层来绑定、渲染\n\n\n# js 面向对象 🔥\n\n * 比较麻烦，因为没有类型约束！\n * 需要考虑对象的状态所在类（不要太扣细节！太过于求完美！）\n\n\n# 组件设计通用原则 🔥\n\n\n# 组件目的\n\n * 对骨架、样式、业务逻辑（行为）的封装\n   \n   业务逻辑这里可以使用计数器组件来说明。有时需要根据货物数量来限制增减等\n\n\n# 灵活性和易用性取舍\n\n * 易用性：可封装原有组件，来限制以获取易用性（提高稳定）\n\n * 灵活性（可提供如下方式实现）：\n   \n   * slot 插槽\n   \n   * 外部样式类\n   \n   * 业务逻辑（其实没有灵活的，目前只能做到提供多种业务逻辑，通过对属性传参来决定。否则就是另一个组件了）\n     \n     可以提供 behavior 行为来让使用者自定义\n\n * 可提供**默认值（样式、插槽）**来中和\n\n\n# 样式宽高的固定\n\n * 固定高宽，你必须要有理由，比如为了点击事件的区域更大。\n * 固定高宽，弊端就是版本更迭很繁琐。修改和维护不方便。\n * 固定高宽，数值难以确定。\n\n写样式时（特别是组件开发），width 指定 750rpx 则可以用 100% 替代，因为父容器的宽度不确定性\n\n\n# 小程序自定义组件的坑\n\n * 自定义组件添加 margin 无效解决：1.给原生组件加；2.view包裹；3.自定义外部样式类\n\n * 自定义组件无法使用 app.wxss 中定义的样式，需要自己写，然后 @import 导入！\n\n\n# https 证书\n\n * lets encrypt\n * caddy\n\n\n# 首页请求数量\n\n * http 请求数量\n * 数据库查询次数，join\n * 接口灵活性、可维护性\n\n\n# wxs & js\n\n * 逻辑层：js\n * 视图层：要在小程序的 wxml 中写 js，只能使用 wxs（只支持 es5！！！）\n\n\n# observer 监听器\n\n\n# hover 点击态\n\n * view 的动画使用\n\n\n# scroll-view 的一些问题\n\nenable-flex 为 true 的 scroll-view x 轴滚动时 y 轴留白问题，解决：\n\nalign-items: center;\n\n\n1\n\n\n也可以取消 scroll-view 的 enable-flex，采用内嵌 view，给该 view 来设置 flex\n\n\n# 图片下面多出10rpx左右问题\n\ndisplay: flex;\n\n\n1\n\n\n\n# 单行文字省略问题\n\n由于必须指定 width，所以有时可以使用 js 来截取，或者 wxs 来截取\n\n\n# 触摸区大小 width\n\n为了触摸区大点，来指定 width\n\n\n# 抽象节点 🔥\n\n类似 插槽\n\n\n# 不使用 setdata\n\n有些数据无需渲染，使用 this.data.xxx = xxx 即可\n\n\n# rpx—机型\n\n只有在 iphone 6 上才满足 2rpx = 1px\n\n\n# 上拉加载\n\n\n# 阈值修改\n\napp.json修改即可\n\nonreachbottomdistance\n\n\n1\n\n\n\n# 状态\n\n 1. 点击（下拉）加载（基本不会看到该状态！！）\n 2. 加载中；\n 3. 没有更多\n\n总之就是12123这样的循环，但是1基本不会出现！\n\n\n# 图片 bind:load\n\n使用该方式来动态指定图片长宽\n\n\n# 小程序的渲染层对对象的封装 🔥\n\n注意，经过小程序渲染层后，对象已经不再是原来的对象，无法根据引用类型特征，直接修改！\n\n\n# 直接事件转发 🔥\n\n自己封装开源组件为新的组件，那么该开源组件的事件可以直接在使用封装组件的地方调用，会自动转发！！\n\n\n# 自定义分享按钮样式 🔥\n\n没有 api ！！！必须使用原生 button！！！样式比较难修改！！！\n\n * 盖住原生 button。比较麻烦\n * 使用 lin-ui button。牛皮的很啊！🔥\n\n\n# text 标签不要随便换行🔥\n\n否则会有空行！\n\n\n# linui 的 tabs 标签页 & segment 选项卡\n\n * tabs 标签页：标签 和 页面！是2个联动起来的\n * segment 选项卡：只管理标签！方便使用\n\n\n# 屏幕宽高 🔥\n\nconst getsystemsize = async function () {\n  // const res = await promisic(wx.getsysteminfo)()\n  const res = await wxp.getsysteminfo()\n  return {\n    windowheight: res.windowheight, // 可使用窗口宽度，单位px\n    windowwidth:res.windowwidth, // 可使用窗口高度，单位px。除去原生配置的 tabbar，导航栏\n    screenwidth: res.screenwidth, // 屏幕宽度，单位px\n    screenheight: res.screenheight, // 屏幕高度，单位px\n  }\n}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n\n\n不同机型之间 rpx 和 px 比例可有上述计算\n\n\n# console.log 数字 & 字符串 🔥\n\n * 数字为蓝色表示！\n * 字符串为黑色！\n\n\n# 小程序长列表组件 🔥\n\n普通列表，追加时，setdata 会造成全部都需要重新渲染，而小程序不允许渲染这么多，所以到后面的数据就不会显示了。\n\n推荐使用 recycle-view 长列表组件来实现！！！',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"index",frontmatter:{title:"index",date:"2022-01-09T17:36:14.000Z",permalink:"/pages/d80ad7/",categories:["推荐"],tags:[null]},regularPath:"/9999.%E6%8E%A8%E8%8D%90/101.index.html",relativePath:"9999.推荐/101.index.md",key:"v-66c7385c",path:"/pages/d80ad7/",headers:[{level:2,title:"推荐的开源项目",slug:"推荐的开源项目",normalizedTitle:"推荐的开源项目",charIndex:2}],headersStr:"推荐的开源项目",content:"# 推荐的开源项目\n\n * PPTist\n   \n   基于 Vue3.x + TypeScript 的在线演示文稿（幻灯片）应用，还原了大部分 Office PowerPoint 常用功能，实现在线PPT的编辑、演示。支持导出PPT文件。\n\n * ",normalizedContent:"# 推荐的开源项目\n\n * pptist\n   \n   基于 vue3.x + typescript 的在线演示文稿（幻灯片）应用，还原了大部分 office powerpoint 常用功能，实现在线ppt的编辑、演示。支持导出ppt文件。\n\n * ",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-a64046a6",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-90d1f7e6",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-2ec62ba6",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"你知道的越多，不知道的也就越多",frontmatter:{title:"你知道的越多，不知道的也就越多",date:"2020-05-06T15:52:40.000Z",permalink:"/pages/f2e63f",sidebar:"auto",categories:["随笔"],tags:["学习","知识","鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E8%B6%8A%E5%A4%9A%EF%BC%8C%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%B9%9F%E5%B0%B1%E8%B6%8A%E5%A4%9A.html",relativePath:"_posts/随笔/你知道的越多，不知道的也就越多.md",key:"v-d9cccf82",path:"/pages/f2e63f/",excerpt:"<p>不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。</p>\n",headersStr:null,content:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。1\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤 1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤 2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",normalizedContent:"不知道大家有没有发现，我们身边经常有这样的人，他们越是有能力的，越是有知识的，越是低调，越是谦逊，因为他们深知，知道的越多，不知道的也就越多。\n\n你知道的越多，你不知道的也就越多，这是一句非常有哲理的话。1\n\n每个人的知识面都是有限的，你有可能在某个领域会有较深的研究，成为这个领域里的专家，等到你站在高处的时候，才会发现，自己是多么的渺小，才知道自己有多少没有涉及的领域。知道的越多，疑惑、问题就会越来越多，对已知的质疑、疑虑、困惑就会越来越多。\n\n即使如此，我们也应该努力，至少可以成为某个领域的佼佼者。\n\n鸡汤 1\n\n弱小的人，才习惯嘲讽与否定，而内心强大的人，从不吝啬赞美与鼓励。\n\n鸡汤 2\n\n当代青年人都应该摆脱冷气，只管向上走，不必听从自暴自弃者的流言。能做事的做事，能发声的发声。有一份热，发一份光，就像萤火一般，也可以在黑暗里发一点光，不必等候炬火。",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"我做了一个手写春联小网页，祝大家虎年暴富",frontmatter:{title:"我做了一个手写春联小网页，祝大家虎年暴富",date:"2022-01-28T14:59:51.000Z",permalink:"/pages/829589/",titleTag:"原创",sidebar:"auto",categories:["随笔"],tags:[null]},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%88%91%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E6%89%8B%E5%86%99%E6%98%A5%E8%81%94%E5%B0%8F%E7%BD%91%E9%A1%B5%EF%BC%8C%E7%A5%9D%E5%A4%A7%E5%AE%B6%E8%99%8E%E5%B9%B4%E6%9A%B4%E5%AF%8C.html",relativePath:"_posts/随笔/我做了一个手写春联小网页，祝大家虎年暴富.md",key:"v-191fb5de",path:"/pages/829589/",headers:[{level:3,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:33},{level:3,title:"产品构思",slug:"产品构思",normalizedTitle:"产品构思",charIndex:195},{level:3,title:"设计",slug:"设计",normalizedTitle:"设计",charIndex:478},{level:3,title:"开发",slug:"开发",normalizedTitle:"开发",charIndex:487}],excerpt:'<p>手写春联：<a href="https://cl.xugaoyi.com/" target="_blank" rel="noopener noreferrer">https://cl.xugaoyi.com/<OutboundLink/></a></p>\n<h3 id="前言"><a class="header-anchor" href="#前言">#</a> 前言</h3>\n<p>虎年春节快到了，首先祝大家新年快乐，轻松暴富。\n最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么UI特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）</p>\n',headersStr:"前言 产品构思 设计 开发",content:'手写春联：https://cl.xugaoyi.com/\n\n\n# 前言\n\n虎年春节快到了，首先祝大家新年快乐，轻松暴富。 最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么UI特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）\n\n\n\n\n# 产品构思\n\n包含手写春节和生成春联两大功能：\n\n * 手写春联\n   \n   * 模拟用笔写字的字迹\n   * 选择画笔颜色\n   * 调整画笔大小\n   * 清空画布\n   * 撤回笔画\n   * 切换上、下联、横批、福字\n   * 随机切换对联提示\n   * 预览图片和下载\n   * 贴春联海报和下载\n\n * 生成模式\n   \n   * 选择画笔颜色\n   * 挑选生成的对联\n   * 输入对联\n   * 随机切换对联\n   * 贴春联海报和下载\n\n * 其他\n   \n   * 快速切换模式按钮\n   * 可控制的背景音乐\n   * 微信分享网页\n\n\n# 设计\n\n\n\n\n# 开发\n\n * 技术栈\n   * vite (打包&构建)\n   * vue3 (页面开发)\n   * vant（ui）\n   * sass (css)\n   * smooth-signature.js (带笔锋手写库)\n\n<template>\n  <div class="wrap" :class="\'mode-\' + mode" @touchstart="handleTouchstart">\n    \x3c!-- 切换模式按钮 --\x3e\n    <div class="toggle-mode-btn" @click="toggleMode">\n      {{ mode === 1 ? \'手写\' : \'生成\' }}\n      <i class="iconfont icon-qiehuan"></i>\n    </div>\n\n    \x3c!-- 工具栏 --\x3e\n    <div\n      class="actions"\n      :style="{ borderTopRightRadius: colorListVisibility ? \'0\' : \'5px\' }"\n    >\n      \x3c!-- 手写模式显示 --\x3e\n      <template v-if="mode === 1">\n        \x3c!-- 调色板 --\x3e\n        <div class="palette btn-block">\n          <div\n            class="cur-color"\n            @click="togglePalette"\n            :style="{ background: colorList[curColorIndex] }"\n          ></div>\n          <ul class="colorList" v-show="colorListVisibility">\n            <li\n              v-for="(item, index) in colorList"\n              :key="item"\n              :style="{ background: item }"\n              @click="selectColor(index)"\n            ></li>\n          </ul>\n        </div>\n\n        \x3c!-- 滑块 --\x3e\n        <div class="slider-box btn-block">\n          <van-slider\n            v-model="progress"\n            vertical\n            @change="changeProgress"\n            bar-height="28"\n            active-color="transparent"\n            :min="50"\n            :max="150"\n          >\n            <template #button>\n              <div class="custom-button"></div>\n            </template>\n          </van-slider>\n        </div>\n\n        \x3c!-- 清空 --\x3e\n        <div class="btn" @click="handleClear">\n          <i class="iconfont icon-lajitong"></i>\n        </div>\n\n        \x3c!-- 撤销 --\x3e\n        <div class="btn" @click="handleUndo">\n          <i class="iconfont icon-fanhui"></i>\n        </div>\n\n        <div class="line"></div>\n\n        \x3c!-- 切换画布的按钮 --\x3e\n        <div\n          class="btn"\n          :class="{ \'cur-active\': curCanvasIndex === index }"\n          v-for="(item, index) in canvasList"\n          :key="item.name"\n          @click="changeCanvas(index)"\n        >\n          {{ item.name }}\n        </div>\n\n        <div class="line"></div>\n\n        <div class="btn prominent" @click="handlePreview">预览</div>\n        <div class="btn prominent" @click="openPosters">贴联</div>\n      </template>\n\n      \x3c!-- 生成模式显示 --\x3e\n      <template v-else>\n        \x3c!-- 选颜色 --\x3e\n        <div\n          class="color-list-quick"\n          :class="{ active: curColorIndex === index }"\n          v-for="(item, index) in colorList"\n          :key="item"\n          :style="{ background: item }"\n          @click="selectColor(index)"\n        ></div>\n        <div class="line"></div>\n        <div class="btn" @click="showPickBox = true">挑选</div>\n        <div class="btn" @click="showInputBox = true">输入</div>\n\n        \x3c!-- 挑选对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showPickBox" title="请挑选对联">\n          <ul class="duilian-list">\n            <li\n              v-for="(item, index) in duilianList"\n              :key="index"\n              @click="handlePickDuilian(item)"\n            >\n              <span>{{ item.shang }}</span\n              >， <span>{{ item.xia }}</span\n              >。\n              <span>{{ item.heng }}</span>\n            </li>\n          </ul>\n        </van-action-sheet>\n\n        \x3c!-- 输入对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showInputBox" title="请输入对联">\n          <van-form @submit="handleSubmitInput">\n            <van-cell-group inset>\n              <van-field\n                v-model="shanglian"\n                name="shang"\n                label="上联"\n                placeholder="上联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字上联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="xialian"\n                name="xia"\n                label="下联"\n                placeholder="下联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字下联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="hengpi"\n                name="heng"\n                label="横批"\n                placeholder="横批"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入4位汉字横批\',\n                    pattern: /^[\\u4e00-\\u9fa5]{4}$/\n                  }\n                ]"\n                clearable\n              />\n            </van-cell-group>\n            <div style="margin: 16px">\n              <van-button\n                round\n                block\n                type="primary"\n                native-type="submit"\n                color="linear-gradient(to right, #ff6034, #c33825)"\n              >\n                完成\n              </van-button>\n            </div>\n          </van-form>\n        </van-action-sheet>\n      </template>\n    </div>\n\n    \x3c!-- 模式1-春联画布 --\x3e\n    <div\n      v-show="mode === 1"\n      v-for="(item, index) in canvasList"\n      :key="item.name"\n    >\n      <canvas\n        class="canvas"\n        :class="item.className"\n        v-show="curCanvasIndex === index"\n        :style="{\n          marginTop:\n            item.height < clientHeight\n              ? `${(clientHeight - item.height) / 2}px`\n              : 0,\n          marginLeft:\n            item.width < clientWidth ? `${(clientWidth - item.width) / 2}px` : 0\n        }"\n      />\n    </div>\n\n    \x3c!-- 模式2-春联画布 --\x3e\n    <div v-show="mode === 2" class="canvas-mode-2">\n      <div class="row">\n        <canvas id="canvas-top" :width="200 * scale" :height="60 * scale" />\n      </div>\n      <div class="row">\n        <canvas id="canvas-left" :width="60 * scale" :height="364 * scale" />\n        <canvas id="canvas-right" :width="60 * scale" :height="364 * scale" />\n      </div>\n    </div>\n\n    \x3c!-- 贴春联按钮 --\x3e\n    <Button class="btn-posters" @click="openPosters" />\n\n    \x3c!-- footer-当前对联提示 --\x3e\n    <footer v-if="duilian.shang">\n      <div class="refresh-btn" @click="handleRefresh(true)">\n        <i class="iconfont icon-shuaxin" :class="{ rotate: isRotate }"></i>\n      </div>\n      <dl class="duilian">\n        <dt>对联</dt>\n        <dd>\n          <div>{{ duilian.shang }}</div>\n          <div>{{ duilian.xia }}</div>\n        </dd>\n      </dl>\n      <dl>\n        <dt>横批</dt>\n        <dd>{{ duilian.heng }}</dd>\n      </dl>\n    </footer>\n\n    \x3c!-- 分享按钮 --\x3e\n    <div class="share-btn" v-if="isShowShareBtn" @click="isShowShareTip = true">\n      <i class="iconfont icon-fenxiang"></i>\n    </div>\n    \x3c!-- 微信分享提示语 --\x3e\n    <div\n      class="share-tip"\n      v-if="isShowShareTip"\n      @click="isShowShareTip = false"\n    >\n      点击右上角把这个工具分享给朋友\n      <div class="hand">👆</div>\n    </div>\n\n    \x3c!-- 保存tip --\x3e\n    <p v-if="isShowTip" class="download-tip">*长按图片保存或转发</p>\n\n    \x3c!-- 版权 --\x3e\n    <div class="copyright">公众号「有趣研究社」 ©版权所有</div>\n\n    \x3c!-- 载入图片元素，用于快速贴图使用, 注意设置crossorigin="anonymous"解决跨域 --\x3e\n    <div v-if="isReadImages">\n      <img\n        crossorigin="anonymous"\n        v-for="(item, index) in bgList"\n        :src="item"\n        :key="item"\n        class="hide-img"\n        :id="`bg-img-` + index"\n      />\n      <img\n        crossorigin="anonymous"\n        class="hide-img"\n        id="qrcode"\n        src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/img/qrcode.zul0pldsuao.png"\n      />\n    </div>\n\n    \x3c!-- 背景音乐 --\x3e\n    <audio\n      src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/cjxq.mp3"\n      id="bgm"\n      ref="bgm"\n      loop\n    />\n    <div\n      class="play-btn"\n      :class="{ paused: !isPlay }"\n      ref="playBtn"\n      @click="handlePlay"\n    >\n      <i class="iconfont icon-yinle"></i>\n    </div>\n  </div>\n\n  <div class="body-bg-img"></div>\n</template>\n\n<script>\nimport { ImagePreview, Notify } from \'vant\'\nimport { isWX, isMobile } from \'@/utils\'\nimport Button from \'@/components/Button.vue\'\nimport dl from \'@/assets/img/yh/dl.jpeg\'\nimport hp from \'@/assets/img/yh/hp.jpeg\'\nimport fz from \'@/assets/img/yh/fz.png\'\n\n// 对联数据\nimport duilianList from \'@/mock/duilian\'\n\nconst PROPORTION = 0.37 // 图片缩小比例\nconst INSTANTIATE_NAME = \'signature\' // 实例名称\nconst MIN_WIDTH = 3 // 画笔最小宽\nconst MAX_WIDTH = 12 // 画笔最大宽\n\n// 海报背景图大小\nconst BG_WIDTH = 750\nconst BG_HEIGHT = 1448\n\n// 贴图定位和大小\nconst POSITION = [\n  { left: 57, top: 510, width: 90, height: 546 }, // 上联\n  { left: 600, top: 510, width: 90, height: 546 }, // 下联\n  { left: 225, top: 345, width: 300, height: 90 }, // 横幅\n  { left: 460, top: 450, width: 130, height: 130 }, // 福字\n]\n\nexport default {\n  name: "Home",\n  components: {\n    Button\n  },\n  data() {\n    return {\n      duilianList,\n      mode: Number(localStorage.getItem(\'mode\')) || 1, // 1 手写，2 生成\n      curCanvasIndex: 0, // 显示哪个画布\n      progress: 100, // 画笔大小的刻度\n      clientWidth: document.documentElement.clientWidth,\n      clientHeight: document.documentElement.clientHeight,\n      canvasList: [\n        {\n          name: \'上联\',\n          className: \'canvas-a\',\n          bgImage: dl,\n          width: 600 * PROPORTION,\n          height: 3640 * PROPORTION,\n        },\n        {\n          name: \'下联\',\n          className: \'canvas-b\',\n          bgImage: dl,\n          width: 600 * PROPORTION,\n          height: 3640 * PROPORTION,\n        },\n        {\n          name: \'横批\',\n          className: \'canvas-c\',\n          bgImage: hp,\n          width: 2000 * PROPORTION,\n          height: 600 * PROPORTION,\n        },\n        {\n          name: \'福字\',\n          className: \'canvas-d\',\n          bgImage: fz,\n          width: 366,\n          height: 366,\n        }\n      ],\n      colorList: [\'#000000\', \'#ffd800\', \'#e8bd48\', \'#ddc08c\',],\n      curColorIndex: 0,\n      colorListVisibility: false, // 画布颜色选择列表可见性\n      isShowTip: false, // 是否显示底部提示语\n      duilian: {}, // 当前对联文本对象\n      isRotate: false, // 刷新icon旋转\n      bgList: [\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/1.4j8qpdnq80i0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/4.4460an8ag5o0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/5.3axtl4xpvy00.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/6.2lnbphdqjaq0.jpeg\',\n      ],\n      isReadImages: false, // 延迟加载图片用\n      isShowShareBtn: false, // 是否显示分享按钮\n      isShowShareTip: false, // 是否显示分享提示语\n      isPlay: false, // 是否在播放\n\n      // 模式2\n      canvasTop: null, // 横批\n      canvasLeft: null, // 上联\n      canvasRight: null, // 下联\n      imgObj1: null, // 横批图片对象\n      imgObj2: null, // 上下联图片对象\n      scale: Math.max(window.devicePixelRatio || 1, 2), // 用于增加画布清晰度\n      showPickBox: false, // 挑选对联的弹框\n      showInputBox: false, // 输入对联的弹框\n      shanglian: \'\', // 输入的上联\n      xialian: \'\', // 输入的下联\n      hengpi: \'\', // 输入的横批\n    };\n  },\n  computed: {\n    // 模式1-当前画布实例\n    curCanvasInstantiate() {\n      return this[INSTANTIATE_NAME + this.curCanvasIndex]\n    }\n  },\n  created() {\n    // 微信浏览器显示分享按钮\n    this.isShowShareBtn = isWX()\n  },\n  mounted() {\n    if (!isMobile()) {\n      Notify({ type: \'warning\', message: \'请用移动端打开获得最佳体验\', duration: 6000, });\n    }\n\n    this.initMode1();\n\n    // 初始化对联提示\n    this.handleRefresh();\n\n    this.initMode2();\n\n    // 按钮添加激活时发光效果class\n    const btnEl = document.querySelectorAll(\'.btn,.btn-block\');\n    btnEl.forEach((item) => {\n      item.addEventListener(\'touchstart\', () => {\n        item.classList.add(\'btn-active\')\n      })\n      item.addEventListener(\'touchend\', () => {\n        setTimeout(() => {\n          item.classList.remove(\'btn-active\')\n        }, 100)\n      })\n    })\n\n    // 延迟加载贴图背景\n    setTimeout(() => {\n      this.isReadImages = true\n    }, 1000)\n  },\n\n  watch: {\n    // 切换画笔颜色\n    curColorIndex() {\n      this.curCanvasInstantiate.color = this.colorList[this.curColorIndex]\n      if (this.mode === 2) {\n        this.refreshDuilian()\n      }\n    },\n    // 切换画布时应用当前画笔颜色和大小\n    curCanvasIndex() {\n      this.curCanvasInstantiate.color = this.colorList[this.curColorIndex]\n      this.handleChangeSize()\n      window.scrollTo(0, 0)\n    }\n  },\n\n  methods: {\n    initMode1() {\n      const { colorList, curColorIndex } = this\n      this.canvasList.forEach((item, index) => {\n        const options = {\n          width: item.width,\n          height: item.height,\n          minWidth: MIN_WIDTH, // 画笔最小宽度(px)\n          maxWidth: MAX_WIDTH, // 画笔最大宽度\n          minSpeed: 1.8, // 画笔达到最小宽度所需最小速度(px/ms)，取值范围1.0-10.0\n          color: colorList[curColorIndex],\n          // 新增的配置\n          bgImage: item.bgImage,\n        };\n\n        this[INSTANTIATE_NAME + index] = new SmoothSignature(document.querySelector(\'.\' + item.className), options);\n      })\n    },\n\n    initMode2() {\n      this.canvasTop = document.getElementById(\'canvas-top\').getContext(\'2d\')\n      this.canvasLeft = document.getElementById(\'canvas-left\').getContext(\'2d\')\n      this.canvasRight = document.getElementById(\'canvas-right\').getContext(\'2d\')\n\n      // 设字体样式\n      const font = "36px xs, cursive"\n      this.canvasTop.font = font\n      this.canvasLeft.font = font\n      this.canvasRight.font = font\n\n      // 增强清晰度\n      const { scale } = this\n      this.canvasTop.scale(scale, scale);\n      this.canvasLeft.scale(scale, scale);\n      this.canvasRight.scale(scale, scale);\n\n      // 设背景图\n      this.imgObj1 = new Image()\n      this.imgObj2 = new Image()\n      this.imgObj1.src = hp\n      this.imgObj2.src = dl\n      this.imgObj1.onload = () => {\n        // 贴背景\n        this.canvasTop.drawImage(this.imgObj1, 0, 0, 200, 60)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handleTopFillText()\n        });\n      }\n      this.imgObj2.onload = () => {\n        // 贴背景\n        this.canvasLeft.drawImage(this.imgObj2, 0, 0, 60, 364)\n        this.canvasRight.drawImage(this.imgObj2, 0, 0, 60, 364)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handleLRFillText(this.canvasLeft, this.duilian.shang)\n          this.handleLRFillText(this.canvasRight, this.duilian.xia)\n        });\n      }\n    },\n\n    // 模式2-刷新对联\n    refreshDuilian() {\n      this.canvasTop.drawImage(this.imgObj1, 0, 0, 200, 60)\n      this.canvasLeft.drawImage(this.imgObj2, 0, 0, 60, 364)\n      this.canvasRight.drawImage(this.imgObj2, 0, 0, 60, 364)\n      this.handleTopFillText()\n      this.handleLRFillText(this.canvasLeft, this.duilian.shang)\n      this.handleLRFillText(this.canvasRight, this.duilian.xia)\n    },\n\n    // 模式2-贴横批\n    handleTopFillText() {\n      // 贴文本\n      this.canvasTop.fillStyle = this.colorList[this.curColorIndex]\n      if (this.duilian.heng) {\n        this.duilian.heng.split(\'\').forEach((item, index) => {\n          const left = 42 * (index + 1) - 22\n          this.canvasTop.fillText(item, left, 40)\n        })\n      }\n    },\n\n    // 模式2-贴上下联\n    handleLRFillText(ctx, text) {\n      ctx.fillStyle = this.colorList[this.curColorIndex]\n      if (text) {\n        text.split(\'\').forEach((item, index) => {\n          const top = 50 * (index + 1) - 8\n          ctx.fillText(item, 13, top)\n        })\n      }\n    },\n\n    // 切换模式\n    toggleMode() {\n      if (this.mode === 1) {\n        this.mode = 2\n        this.refreshDuilian()\n      } else {\n        this.mode = 1\n      }\n      localStorage.setItem(\'mode\', this.mode);\n    },\n\n    // 打开调色板\n    togglePalette() {\n      this.colorListVisibility = !this.colorListVisibility\n    },\n\n    // 关闭调色板\n    handleTouchstart(e) {\n      // 不是点击选择颜色时\n      if (e.path[1]?.classList?.value !== \'colorList\' && e.target.classList?.value !== \'cur-color\') {\n        this.colorListVisibility = false\n      }\n    },\n\n    // 选择颜色\n    selectColor(index) {\n      this.curColorIndex = index\n      this.colorListVisibility = false\n    },\n\n    // 切换画布\n    changeCanvas(index) {\n      this.curCanvasIndex = index\n    },\n\n    // 清空画布\n    handleClear() {\n      this.curCanvasInstantiate.clear();\n    },\n\n    // 撤销笔画\n    handleUndo() {\n      this.curCanvasInstantiate.undo();\n    },\n\n    // 预览\n    handlePreview() {\n      this.showTopTip();\n      this.isShowTip = true\n      const _this = this\n      ImagePreview({\n        images: this.getImageList(),\n        closeable: true,\n        startPosition: this.curCanvasIndex,\n        onClose() {\n          _this.isShowTip = false\n        },\n      });\n    },\n\n    // 打开海报预览\n    openPosters() {\n      // 创建画布\n      const canvas = document.createElement(\'canvas\');\n      canvas.width = BG_WIDTH\n      canvas.height = BG_HEIGHT\n      const ctx = canvas.getContext(\'2d\');\n      const resultImageList = [];\n\n      // 是否隐藏福字\n      const isHideFu = this[INSTANTIATE_NAME + 3].isEmpty()\n      this.bgList.forEach((item, index) => {\n        // 贴背景图\n        ctx.drawImage(document.getElementById(\'bg-img-\' + index), 0, 0, BG_WIDTH, BG_HEIGHT)\n\n        // 贴对联\n        if (this.mode === 1) {\n          this.canvasList.forEach((item, index) => {\n            if (index === 3 && isHideFu) return;\n            const dlCanvas = document.querySelector(\'.\' + item.className)\n            const { left, top, width, height } = POSITION[index]\n            ctx.drawImage(dlCanvas, left, top, width, height)\n          })\n        } else {\n          [\'canvas-left\', \'canvas-right\', \'canvas-top\'].forEach((item, index) => {\n            const dlCanvas = document.getElementById(item)\n            const { left, top, width, height } = POSITION[index]\n            ctx.drawImage(dlCanvas, left, top, width, height)\n          })\n        }\n\n        // 贴二维码\n        ctx.drawImage(document.getElementById("qrcode"), 40, 1280, 580, 136)\n\n        // 贴文本\n        ctx.font = "18px sans-serif"\n        ctx.fillStyle = "#666666"\n        ctx.fillText(\'©公众号「有趣研究社」\', 550, 1420)\n\n        // 导出图片\n        resultImageList.push(canvas.toDataURL(\'image/jpeg\', 0.8))\n      })\n\n      // 打开图片预览\n      this.isShowTip = true\n      const _this = this\n      ImagePreview({\n        images: resultImageList,\n        closeable: true,\n        onClose() {\n          _this.isShowTip = false\n        },\n      });\n      this.showTopTip();\n    },\n\n    // 弹出顶部提示语\n    showTopTip() {\n      if (!sessionStorage.getItem(\'showTip\')) {\n        sessionStorage.setItem(\'showTip\', \'true\');\n        Notify({\n          message: \'长按图片可保存到本地\',\n          color: \'#c33825\',\n          background: \'#eed3ae\',\n        });\n      }\n    },\n\n    // 获取对联图片列表\n    getImageList(type = \'image/png\') {\n      const imageList = []\n      this.canvasList.forEach((item, index) => {\n        if (index === 3) {\n          // `福`字必须是png格式\n          type = \'image/png\'\n        }\n        imageList.push(this[INSTANTIATE_NAME + index].toDataURL(type, 0.8))\n      })\n      return imageList\n    },\n\n    // 进度改变时\n    changeProgress(progress) {\n      this.progress = progress\n      this.handleChangeSize()\n    },\n\n    // 调整画笔大小\n    handleChangeSize() {\n      const { progress } = this\n      this.curCanvasInstantiate.minWidth = MIN_WIDTH * progress / 100\n      this.curCanvasInstantiate.maxWidth = MAX_WIDTH * progress / 100\n    },\n\n    // 刷新对联\n    handleRefresh(rotate) {\n      this.duilian = duilianList[Math.floor(Math.random() * duilianList.length)]\n\n      if (rotate) {\n        if (this.mode === 2) {\n          this.refreshDuilian()\n        }\n        // 使icon旋转\n        this.isRotate = true\n        setTimeout(() => {\n          this.isRotate = false\n        }, 300)\n      }\n    },\n\n    // 播放背景音乐\n    handlePlay() {\n      const { bgm } = this.$refs\n      if (bgm.paused) {\n        bgm.play()\n        this.isPlay = true\n      } else {\n        bgm.pause()\n        this.isPlay = false\n      }\n    },\n\n    // 完成输入对联\n    handleSubmitInput(values) {\n      this.duilian = values\n      this.showInputBox = false\n      this.refreshDuilian()\n    },\n\n    // 完成挑选对联\n    handlePickDuilian(item) {\n      this.duilian = item\n      this.showPickBox = false\n      this.refreshDuilian()\n    }\n  },\n};\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n\n\n更多有趣的小网页欢迎关注公众号有趣研究社:\n\n> 手写春联\n> FC在线模拟器\n> 爱国头像生成器\n> 到账语音生成器',normalizedContent:'手写春联：https://cl.xugaoyi.com/\n\n\n# 前言\n\n虎年春节快到了，首先祝大家新年快乐，轻松暴富。 最近在网上经常看到生成春联的文章，不过这些小demo要么功能简陋,要么ui特别‘程序员’，满足不了我挑剔的眼光。干脆我自己做一个吧，顺便简单体验一下vite+vue3。（因为页面相对简单，vue组件风格还是使用选项式api，重点还是想把产品快速做出来。）\n\n\n\n\n# 产品构思\n\n包含手写春节和生成春联两大功能：\n\n * 手写春联\n   \n   * 模拟用笔写字的字迹\n   * 选择画笔颜色\n   * 调整画笔大小\n   * 清空画布\n   * 撤回笔画\n   * 切换上、下联、横批、福字\n   * 随机切换对联提示\n   * 预览图片和下载\n   * 贴春联海报和下载\n\n * 生成模式\n   \n   * 选择画笔颜色\n   * 挑选生成的对联\n   * 输入对联\n   * 随机切换对联\n   * 贴春联海报和下载\n\n * 其他\n   \n   * 快速切换模式按钮\n   * 可控制的背景音乐\n   * 微信分享网页\n\n\n# 设计\n\n\n\n\n# 开发\n\n * 技术栈\n   * vite (打包&构建)\n   * vue3 (页面开发)\n   * vant（ui）\n   * sass (css)\n   * smooth-signature.js (带笔锋手写库)\n\n<template>\n  <div class="wrap" :class="\'mode-\' + mode" @touchstart="handletouchstart">\n    \x3c!-- 切换模式按钮 --\x3e\n    <div class="toggle-mode-btn" @click="togglemode">\n      {{ mode === 1 ? \'手写\' : \'生成\' }}\n      <i class="iconfont icon-qiehuan"></i>\n    </div>\n\n    \x3c!-- 工具栏 --\x3e\n    <div\n      class="actions"\n      :style="{ bordertoprightradius: colorlistvisibility ? \'0\' : \'5px\' }"\n    >\n      \x3c!-- 手写模式显示 --\x3e\n      <template v-if="mode === 1">\n        \x3c!-- 调色板 --\x3e\n        <div class="palette btn-block">\n          <div\n            class="cur-color"\n            @click="togglepalette"\n            :style="{ background: colorlist[curcolorindex] }"\n          ></div>\n          <ul class="colorlist" v-show="colorlistvisibility">\n            <li\n              v-for="(item, index) in colorlist"\n              :key="item"\n              :style="{ background: item }"\n              @click="selectcolor(index)"\n            ></li>\n          </ul>\n        </div>\n\n        \x3c!-- 滑块 --\x3e\n        <div class="slider-box btn-block">\n          <van-slider\n            v-model="progress"\n            vertical\n            @change="changeprogress"\n            bar-height="28"\n            active-color="transparent"\n            :min="50"\n            :max="150"\n          >\n            <template #button>\n              <div class="custom-button"></div>\n            </template>\n          </van-slider>\n        </div>\n\n        \x3c!-- 清空 --\x3e\n        <div class="btn" @click="handleclear">\n          <i class="iconfont icon-lajitong"></i>\n        </div>\n\n        \x3c!-- 撤销 --\x3e\n        <div class="btn" @click="handleundo">\n          <i class="iconfont icon-fanhui"></i>\n        </div>\n\n        <div class="line"></div>\n\n        \x3c!-- 切换画布的按钮 --\x3e\n        <div\n          class="btn"\n          :class="{ \'cur-active\': curcanvasindex === index }"\n          v-for="(item, index) in canvaslist"\n          :key="item.name"\n          @click="changecanvas(index)"\n        >\n          {{ item.name }}\n        </div>\n\n        <div class="line"></div>\n\n        <div class="btn prominent" @click="handlepreview">预览</div>\n        <div class="btn prominent" @click="openposters">贴联</div>\n      </template>\n\n      \x3c!-- 生成模式显示 --\x3e\n      <template v-else>\n        \x3c!-- 选颜色 --\x3e\n        <div\n          class="color-list-quick"\n          :class="{ active: curcolorindex === index }"\n          v-for="(item, index) in colorlist"\n          :key="item"\n          :style="{ background: item }"\n          @click="selectcolor(index)"\n        ></div>\n        <div class="line"></div>\n        <div class="btn" @click="showpickbox = true">挑选</div>\n        <div class="btn" @click="showinputbox = true">输入</div>\n\n        \x3c!-- 挑选对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showpickbox" title="请挑选对联">\n          <ul class="duilian-list">\n            <li\n              v-for="(item, index) in duilianlist"\n              :key="index"\n              @click="handlepickduilian(item)"\n            >\n              <span>{{ item.shang }}</span\n              >， <span>{{ item.xia }}</span\n              >。\n              <span>{{ item.heng }}</span>\n            </li>\n          </ul>\n        </van-action-sheet>\n\n        \x3c!-- 输入对联弹窗 --\x3e\n        <van-action-sheet v-model:show="showinputbox" title="请输入对联">\n          <van-form @submit="handlesubmitinput">\n            <van-cell-group inset>\n              <van-field\n                v-model="shanglian"\n                name="shang"\n                label="上联"\n                placeholder="上联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字上联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="xialian"\n                name="xia"\n                label="下联"\n                placeholder="下联"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入7位汉字下联\',\n                    pattern: /^[\\u4e00-\\u9fa5]{7}$/\n                  }\n                ]"\n                clearable\n              />\n              <van-field\n                v-model="hengpi"\n                name="heng"\n                label="横批"\n                placeholder="横批"\n                :rules="[\n                  {\n                    required: true,\n                    message: \'请输入4位汉字横批\',\n                    pattern: /^[\\u4e00-\\u9fa5]{4}$/\n                  }\n                ]"\n                clearable\n              />\n            </van-cell-group>\n            <div style="margin: 16px">\n              <van-button\n                round\n                block\n                type="primary"\n                native-type="submit"\n                color="linear-gradient(to right, #ff6034, #c33825)"\n              >\n                完成\n              </van-button>\n            </div>\n          </van-form>\n        </van-action-sheet>\n      </template>\n    </div>\n\n    \x3c!-- 模式1-春联画布 --\x3e\n    <div\n      v-show="mode === 1"\n      v-for="(item, index) in canvaslist"\n      :key="item.name"\n    >\n      <canvas\n        class="canvas"\n        :class="item.classname"\n        v-show="curcanvasindex === index"\n        :style="{\n          margintop:\n            item.height < clientheight\n              ? `${(clientheight - item.height) / 2}px`\n              : 0,\n          marginleft:\n            item.width < clientwidth ? `${(clientwidth - item.width) / 2}px` : 0\n        }"\n      />\n    </div>\n\n    \x3c!-- 模式2-春联画布 --\x3e\n    <div v-show="mode === 2" class="canvas-mode-2">\n      <div class="row">\n        <canvas id="canvas-top" :width="200 * scale" :height="60 * scale" />\n      </div>\n      <div class="row">\n        <canvas id="canvas-left" :width="60 * scale" :height="364 * scale" />\n        <canvas id="canvas-right" :width="60 * scale" :height="364 * scale" />\n      </div>\n    </div>\n\n    \x3c!-- 贴春联按钮 --\x3e\n    <button class="btn-posters" @click="openposters" />\n\n    \x3c!-- footer-当前对联提示 --\x3e\n    <footer v-if="duilian.shang">\n      <div class="refresh-btn" @click="handlerefresh(true)">\n        <i class="iconfont icon-shuaxin" :class="{ rotate: isrotate }"></i>\n      </div>\n      <dl class="duilian">\n        <dt>对联</dt>\n        <dd>\n          <div>{{ duilian.shang }}</div>\n          <div>{{ duilian.xia }}</div>\n        </dd>\n      </dl>\n      <dl>\n        <dt>横批</dt>\n        <dd>{{ duilian.heng }}</dd>\n      </dl>\n    </footer>\n\n    \x3c!-- 分享按钮 --\x3e\n    <div class="share-btn" v-if="isshowsharebtn" @click="isshowsharetip = true">\n      <i class="iconfont icon-fenxiang"></i>\n    </div>\n    \x3c!-- 微信分享提示语 --\x3e\n    <div\n      class="share-tip"\n      v-if="isshowsharetip"\n      @click="isshowsharetip = false"\n    >\n      点击右上角把这个工具分享给朋友\n      <div class="hand">👆</div>\n    </div>\n\n    \x3c!-- 保存tip --\x3e\n    <p v-if="isshowtip" class="download-tip">*长按图片保存或转发</p>\n\n    \x3c!-- 版权 --\x3e\n    <div class="copyright">公众号「有趣研究社」 ©版权所有</div>\n\n    \x3c!-- 载入图片元素，用于快速贴图使用, 注意设置crossorigin="anonymous"解决跨域 --\x3e\n    <div v-if="isreadimages">\n      <img\n        crossorigin="anonymous"\n        v-for="(item, index) in bglist"\n        :src="item"\n        :key="item"\n        class="hide-img"\n        :id="`bg-img-` + index"\n      />\n      <img\n        crossorigin="anonymous"\n        class="hide-img"\n        id="qrcode"\n        src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/img/qrcode.zul0pldsuao.png"\n      />\n    </div>\n\n    \x3c!-- 背景音乐 --\x3e\n    <audio\n      src="https://cdn.jsdelivr.net/gh/xugaoyi/image_store2@master/cjxq.mp3"\n      id="bgm"\n      ref="bgm"\n      loop\n    />\n    <div\n      class="play-btn"\n      :class="{ paused: !isplay }"\n      ref="playbtn"\n      @click="handleplay"\n    >\n      <i class="iconfont icon-yinle"></i>\n    </div>\n  </div>\n\n  <div class="body-bg-img"></div>\n</template>\n\n<script>\nimport { imagepreview, notify } from \'vant\'\nimport { iswx, ismobile } from \'@/utils\'\nimport button from \'@/components/button.vue\'\nimport dl from \'@/assets/img/yh/dl.jpeg\'\nimport hp from \'@/assets/img/yh/hp.jpeg\'\nimport fz from \'@/assets/img/yh/fz.png\'\n\n// 对联数据\nimport duilianlist from \'@/mock/duilian\'\n\nconst proportion = 0.37 // 图片缩小比例\nconst instantiate_name = \'signature\' // 实例名称\nconst min_width = 3 // 画笔最小宽\nconst max_width = 12 // 画笔最大宽\n\n// 海报背景图大小\nconst bg_width = 750\nconst bg_height = 1448\n\n// 贴图定位和大小\nconst position = [\n  { left: 57, top: 510, width: 90, height: 546 }, // 上联\n  { left: 600, top: 510, width: 90, height: 546 }, // 下联\n  { left: 225, top: 345, width: 300, height: 90 }, // 横幅\n  { left: 460, top: 450, width: 130, height: 130 }, // 福字\n]\n\nexport default {\n  name: "home",\n  components: {\n    button\n  },\n  data() {\n    return {\n      duilianlist,\n      mode: number(localstorage.getitem(\'mode\')) || 1, // 1 手写，2 生成\n      curcanvasindex: 0, // 显示哪个画布\n      progress: 100, // 画笔大小的刻度\n      clientwidth: document.documentelement.clientwidth,\n      clientheight: document.documentelement.clientheight,\n      canvaslist: [\n        {\n          name: \'上联\',\n          classname: \'canvas-a\',\n          bgimage: dl,\n          width: 600 * proportion,\n          height: 3640 * proportion,\n        },\n        {\n          name: \'下联\',\n          classname: \'canvas-b\',\n          bgimage: dl,\n          width: 600 * proportion,\n          height: 3640 * proportion,\n        },\n        {\n          name: \'横批\',\n          classname: \'canvas-c\',\n          bgimage: hp,\n          width: 2000 * proportion,\n          height: 600 * proportion,\n        },\n        {\n          name: \'福字\',\n          classname: \'canvas-d\',\n          bgimage: fz,\n          width: 366,\n          height: 366,\n        }\n      ],\n      colorlist: [\'#000000\', \'#ffd800\', \'#e8bd48\', \'#ddc08c\',],\n      curcolorindex: 0,\n      colorlistvisibility: false, // 画布颜色选择列表可见性\n      isshowtip: false, // 是否显示底部提示语\n      duilian: {}, // 当前对联文本对象\n      isrotate: false, // 刷新icon旋转\n      bglist: [\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/1.4j8qpdnq80i0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/4.4460an8ag5o0.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/5.3axtl4xpvy00.jpeg\',\n        \'https://cdn.jsdelivr.net/gh/xugaoyi/image_store@master/6.2lnbphdqjaq0.jpeg\',\n      ],\n      isreadimages: false, // 延迟加载图片用\n      isshowsharebtn: false, // 是否显示分享按钮\n      isshowsharetip: false, // 是否显示分享提示语\n      isplay: false, // 是否在播放\n\n      // 模式2\n      canvastop: null, // 横批\n      canvasleft: null, // 上联\n      canvasright: null, // 下联\n      imgobj1: null, // 横批图片对象\n      imgobj2: null, // 上下联图片对象\n      scale: math.max(window.devicepixelratio || 1, 2), // 用于增加画布清晰度\n      showpickbox: false, // 挑选对联的弹框\n      showinputbox: false, // 输入对联的弹框\n      shanglian: \'\', // 输入的上联\n      xialian: \'\', // 输入的下联\n      hengpi: \'\', // 输入的横批\n    };\n  },\n  computed: {\n    // 模式1-当前画布实例\n    curcanvasinstantiate() {\n      return this[instantiate_name + this.curcanvasindex]\n    }\n  },\n  created() {\n    // 微信浏览器显示分享按钮\n    this.isshowsharebtn = iswx()\n  },\n  mounted() {\n    if (!ismobile()) {\n      notify({ type: \'warning\', message: \'请用移动端打开获得最佳体验\', duration: 6000, });\n    }\n\n    this.initmode1();\n\n    // 初始化对联提示\n    this.handlerefresh();\n\n    this.initmode2();\n\n    // 按钮添加激活时发光效果class\n    const btnel = document.queryselectorall(\'.btn,.btn-block\');\n    btnel.foreach((item) => {\n      item.addeventlistener(\'touchstart\', () => {\n        item.classlist.add(\'btn-active\')\n      })\n      item.addeventlistener(\'touchend\', () => {\n        settimeout(() => {\n          item.classlist.remove(\'btn-active\')\n        }, 100)\n      })\n    })\n\n    // 延迟加载贴图背景\n    settimeout(() => {\n      this.isreadimages = true\n    }, 1000)\n  },\n\n  watch: {\n    // 切换画笔颜色\n    curcolorindex() {\n      this.curcanvasinstantiate.color = this.colorlist[this.curcolorindex]\n      if (this.mode === 2) {\n        this.refreshduilian()\n      }\n    },\n    // 切换画布时应用当前画笔颜色和大小\n    curcanvasindex() {\n      this.curcanvasinstantiate.color = this.colorlist[this.curcolorindex]\n      this.handlechangesize()\n      window.scrollto(0, 0)\n    }\n  },\n\n  methods: {\n    initmode1() {\n      const { colorlist, curcolorindex } = this\n      this.canvaslist.foreach((item, index) => {\n        const options = {\n          width: item.width,\n          height: item.height,\n          minwidth: min_width, // 画笔最小宽度(px)\n          maxwidth: max_width, // 画笔最大宽度\n          minspeed: 1.8, // 画笔达到最小宽度所需最小速度(px/ms)，取值范围1.0-10.0\n          color: colorlist[curcolorindex],\n          // 新增的配置\n          bgimage: item.bgimage,\n        };\n\n        this[instantiate_name + index] = new smoothsignature(document.queryselector(\'.\' + item.classname), options);\n      })\n    },\n\n    initmode2() {\n      this.canvastop = document.getelementbyid(\'canvas-top\').getcontext(\'2d\')\n      this.canvasleft = document.getelementbyid(\'canvas-left\').getcontext(\'2d\')\n      this.canvasright = document.getelementbyid(\'canvas-right\').getcontext(\'2d\')\n\n      // 设字体样式\n      const font = "36px xs, cursive"\n      this.canvastop.font = font\n      this.canvasleft.font = font\n      this.canvasright.font = font\n\n      // 增强清晰度\n      const { scale } = this\n      this.canvastop.scale(scale, scale);\n      this.canvasleft.scale(scale, scale);\n      this.canvasright.scale(scale, scale);\n\n      // 设背景图\n      this.imgobj1 = new image()\n      this.imgobj2 = new image()\n      this.imgobj1.src = hp\n      this.imgobj2.src = dl\n      this.imgobj1.onload = () => {\n        // 贴背景\n        this.canvastop.drawimage(this.imgobj1, 0, 0, 200, 60)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handletopfilltext()\n        });\n      }\n      this.imgobj2.onload = () => {\n        // 贴背景\n        this.canvasleft.drawimage(this.imgobj2, 0, 0, 60, 364)\n        this.canvasright.drawimage(this.imgobj2, 0, 0, 60, 364)\n\n        // 字体加载完成后\n        document.fonts.ready.then(() => {\n          this.handlelrfilltext(this.canvasleft, this.duilian.shang)\n          this.handlelrfilltext(this.canvasright, this.duilian.xia)\n        });\n      }\n    },\n\n    // 模式2-刷新对联\n    refreshduilian() {\n      this.canvastop.drawimage(this.imgobj1, 0, 0, 200, 60)\n      this.canvasleft.drawimage(this.imgobj2, 0, 0, 60, 364)\n      this.canvasright.drawimage(this.imgobj2, 0, 0, 60, 364)\n      this.handletopfilltext()\n      this.handlelrfilltext(this.canvasleft, this.duilian.shang)\n      this.handlelrfilltext(this.canvasright, this.duilian.xia)\n    },\n\n    // 模式2-贴横批\n    handletopfilltext() {\n      // 贴文本\n      this.canvastop.fillstyle = this.colorlist[this.curcolorindex]\n      if (this.duilian.heng) {\n        this.duilian.heng.split(\'\').foreach((item, index) => {\n          const left = 42 * (index + 1) - 22\n          this.canvastop.filltext(item, left, 40)\n        })\n      }\n    },\n\n    // 模式2-贴上下联\n    handlelrfilltext(ctx, text) {\n      ctx.fillstyle = this.colorlist[this.curcolorindex]\n      if (text) {\n        text.split(\'\').foreach((item, index) => {\n          const top = 50 * (index + 1) - 8\n          ctx.filltext(item, 13, top)\n        })\n      }\n    },\n\n    // 切换模式\n    togglemode() {\n      if (this.mode === 1) {\n        this.mode = 2\n        this.refreshduilian()\n      } else {\n        this.mode = 1\n      }\n      localstorage.setitem(\'mode\', this.mode);\n    },\n\n    // 打开调色板\n    togglepalette() {\n      this.colorlistvisibility = !this.colorlistvisibility\n    },\n\n    // 关闭调色板\n    handletouchstart(e) {\n      // 不是点击选择颜色时\n      if (e.path[1]?.classlist?.value !== \'colorlist\' && e.target.classlist?.value !== \'cur-color\') {\n        this.colorlistvisibility = false\n      }\n    },\n\n    // 选择颜色\n    selectcolor(index) {\n      this.curcolorindex = index\n      this.colorlistvisibility = false\n    },\n\n    // 切换画布\n    changecanvas(index) {\n      this.curcanvasindex = index\n    },\n\n    // 清空画布\n    handleclear() {\n      this.curcanvasinstantiate.clear();\n    },\n\n    // 撤销笔画\n    handleundo() {\n      this.curcanvasinstantiate.undo();\n    },\n\n    // 预览\n    handlepreview() {\n      this.showtoptip();\n      this.isshowtip = true\n      const _this = this\n      imagepreview({\n        images: this.getimagelist(),\n        closeable: true,\n        startposition: this.curcanvasindex,\n        onclose() {\n          _this.isshowtip = false\n        },\n      });\n    },\n\n    // 打开海报预览\n    openposters() {\n      // 创建画布\n      const canvas = document.createelement(\'canvas\');\n      canvas.width = bg_width\n      canvas.height = bg_height\n      const ctx = canvas.getcontext(\'2d\');\n      const resultimagelist = [];\n\n      // 是否隐藏福字\n      const ishidefu = this[instantiate_name + 3].isempty()\n      this.bglist.foreach((item, index) => {\n        // 贴背景图\n        ctx.drawimage(document.getelementbyid(\'bg-img-\' + index), 0, 0, bg_width, bg_height)\n\n        // 贴对联\n        if (this.mode === 1) {\n          this.canvaslist.foreach((item, index) => {\n            if (index === 3 && ishidefu) return;\n            const dlcanvas = document.queryselector(\'.\' + item.classname)\n            const { left, top, width, height } = position[index]\n            ctx.drawimage(dlcanvas, left, top, width, height)\n          })\n        } else {\n          [\'canvas-left\', \'canvas-right\', \'canvas-top\'].foreach((item, index) => {\n            const dlcanvas = document.getelementbyid(item)\n            const { left, top, width, height } = position[index]\n            ctx.drawimage(dlcanvas, left, top, width, height)\n          })\n        }\n\n        // 贴二维码\n        ctx.drawimage(document.getelementbyid("qrcode"), 40, 1280, 580, 136)\n\n        // 贴文本\n        ctx.font = "18px sans-serif"\n        ctx.fillstyle = "#666666"\n        ctx.filltext(\'©公众号「有趣研究社」\', 550, 1420)\n\n        // 导出图片\n        resultimagelist.push(canvas.todataurl(\'image/jpeg\', 0.8))\n      })\n\n      // 打开图片预览\n      this.isshowtip = true\n      const _this = this\n      imagepreview({\n        images: resultimagelist,\n        closeable: true,\n        onclose() {\n          _this.isshowtip = false\n        },\n      });\n      this.showtoptip();\n    },\n\n    // 弹出顶部提示语\n    showtoptip() {\n      if (!sessionstorage.getitem(\'showtip\')) {\n        sessionstorage.setitem(\'showtip\', \'true\');\n        notify({\n          message: \'长按图片可保存到本地\',\n          color: \'#c33825\',\n          background: \'#eed3ae\',\n        });\n      }\n    },\n\n    // 获取对联图片列表\n    getimagelist(type = \'image/png\') {\n      const imagelist = []\n      this.canvaslist.foreach((item, index) => {\n        if (index === 3) {\n          // `福`字必须是png格式\n          type = \'image/png\'\n        }\n        imagelist.push(this[instantiate_name + index].todataurl(type, 0.8))\n      })\n      return imagelist\n    },\n\n    // 进度改变时\n    changeprogress(progress) {\n      this.progress = progress\n      this.handlechangesize()\n    },\n\n    // 调整画笔大小\n    handlechangesize() {\n      const { progress } = this\n      this.curcanvasinstantiate.minwidth = min_width * progress / 100\n      this.curcanvasinstantiate.maxwidth = max_width * progress / 100\n    },\n\n    // 刷新对联\n    handlerefresh(rotate) {\n      this.duilian = duilianlist[math.floor(math.random() * duilianlist.length)]\n\n      if (rotate) {\n        if (this.mode === 2) {\n          this.refreshduilian()\n        }\n        // 使icon旋转\n        this.isrotate = true\n        settimeout(() => {\n          this.isrotate = false\n        }, 300)\n      }\n    },\n\n    // 播放背景音乐\n    handleplay() {\n      const { bgm } = this.$refs\n      if (bgm.paused) {\n        bgm.play()\n        this.isplay = true\n      } else {\n        bgm.pause()\n        this.isplay = false\n      }\n    },\n\n    // 完成输入对联\n    handlesubmitinput(values) {\n      this.duilian = values\n      this.showinputbox = false\n      this.refreshduilian()\n    },\n\n    // 完成挑选对联\n    handlepickduilian(item) {\n      this.duilian = item\n      this.showpickbox = false\n      this.refreshduilian()\n    }\n  },\n};\n<\/script>\n\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n81\n82\n83\n84\n85\n86\n87\n88\n89\n90\n91\n92\n93\n94\n95\n96\n97\n98\n99\n100\n101\n102\n103\n104\n105\n106\n107\n108\n109\n110\n111\n112\n113\n114\n115\n116\n117\n118\n119\n120\n121\n122\n123\n124\n125\n126\n127\n128\n129\n130\n131\n132\n133\n134\n135\n136\n137\n138\n139\n140\n141\n142\n143\n144\n145\n146\n147\n148\n149\n150\n151\n152\n153\n154\n155\n156\n157\n158\n159\n160\n161\n162\n163\n164\n165\n166\n167\n168\n169\n170\n171\n172\n173\n174\n175\n176\n177\n178\n179\n180\n181\n182\n183\n184\n185\n186\n187\n188\n189\n190\n191\n192\n193\n194\n195\n196\n197\n198\n199\n200\n201\n202\n203\n204\n205\n206\n207\n208\n209\n210\n211\n212\n213\n214\n215\n216\n217\n218\n219\n220\n221\n222\n223\n224\n225\n226\n227\n228\n229\n230\n231\n232\n233\n234\n235\n236\n237\n238\n239\n240\n241\n242\n243\n244\n245\n246\n247\n248\n249\n250\n251\n252\n253\n254\n255\n256\n257\n258\n259\n260\n261\n262\n263\n264\n265\n266\n267\n268\n269\n270\n271\n272\n273\n274\n275\n276\n277\n278\n279\n280\n281\n282\n283\n284\n285\n286\n287\n288\n289\n290\n291\n292\n293\n294\n295\n296\n297\n298\n299\n300\n301\n302\n303\n304\n305\n306\n307\n308\n309\n310\n311\n312\n313\n314\n315\n316\n317\n318\n319\n320\n321\n322\n323\n324\n325\n326\n327\n328\n329\n330\n331\n332\n333\n334\n335\n336\n337\n338\n339\n340\n341\n342\n343\n344\n345\n346\n347\n348\n349\n350\n351\n352\n353\n354\n355\n356\n357\n358\n359\n360\n361\n362\n363\n364\n365\n366\n367\n368\n369\n370\n371\n372\n373\n374\n375\n376\n377\n378\n379\n380\n381\n382\n383\n384\n385\n386\n387\n388\n389\n390\n391\n392\n393\n394\n395\n396\n397\n398\n399\n400\n401\n402\n403\n404\n405\n406\n407\n408\n409\n410\n411\n412\n413\n414\n415\n416\n417\n418\n419\n420\n421\n422\n423\n424\n425\n426\n427\n428\n429\n430\n431\n432\n433\n434\n435\n436\n437\n438\n439\n440\n441\n442\n443\n444\n445\n446\n447\n448\n449\n450\n451\n452\n453\n454\n455\n456\n457\n458\n459\n460\n461\n462\n463\n464\n465\n466\n467\n468\n469\n470\n471\n472\n473\n474\n475\n476\n477\n478\n479\n480\n481\n482\n483\n484\n485\n486\n487\n488\n489\n490\n491\n492\n493\n494\n495\n496\n497\n498\n499\n500\n501\n502\n503\n504\n505\n506\n507\n508\n509\n510\n511\n512\n513\n514\n515\n516\n517\n518\n519\n520\n521\n522\n523\n524\n525\n526\n527\n528\n529\n530\n531\n532\n533\n534\n535\n536\n537\n538\n539\n540\n541\n542\n543\n544\n545\n546\n547\n548\n549\n550\n551\n552\n553\n554\n555\n556\n557\n558\n559\n560\n561\n562\n563\n564\n565\n566\n567\n568\n569\n570\n571\n572\n573\n574\n575\n576\n577\n578\n579\n580\n581\n582\n583\n584\n585\n586\n587\n588\n589\n590\n591\n592\n593\n594\n595\n596\n597\n598\n599\n600\n601\n602\n603\n604\n605\n606\n607\n608\n609\n610\n611\n612\n613\n614\n615\n616\n617\n618\n619\n620\n621\n622\n623\n624\n625\n626\n627\n628\n629\n630\n631\n632\n633\n634\n635\n636\n637\n638\n639\n640\n641\n642\n643\n644\n645\n646\n647\n648\n649\n650\n651\n652\n653\n654\n655\n656\n657\n658\n659\n660\n661\n662\n663\n664\n665\n666\n667\n668\n669\n670\n671\n672\n673\n674\n675\n676\n677\n678\n679\n680\n681\n682\n683\n684\n685\n686\n687\n688\n689\n690\n691\n692\n693\n694\n695\n696\n697\n698\n699\n700\n701\n702\n703\n704\n705\n706\n707\n708\n709\n710\n711\n712\n713\n714\n715\n716\n717\n718\n719\n720\n721\n722\n723\n724\n725\n726\n727\n728\n729\n730\n731\n732\n733\n734\n735\n736\n737\n\n\n更多有趣的小网页欢迎关注公众号有趣研究社:\n\n> 手写春联\n> fc在线模拟器\n> 爱国头像生成器\n> 到账语音生成器',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"拥抱生活，拥抱快乐",frontmatter:{title:"拥抱生活，拥抱快乐",date:"2020-06-26T20:40:38.000Z",permalink:"/pages/cd8bde/",sidebar:"auto",categories:["随笔"],tags:["鸡汤"],author:{name:"xugaoyi",link:"https://github.com/xugaoyi"}},regularPath:"/_posts/%E9%9A%8F%E7%AC%94/%E6%8B%A5%E6%8A%B1%E7%94%9F%E6%B4%BB%EF%BC%8C%E6%8B%A5%E6%8A%B1%E5%BF%AB%E4%B9%90.html",relativePath:"_posts/随笔/拥抱生活，拥抱快乐.md",key:"v-43ae2c82",path:"/pages/cd8bde/",excerpt:"<p>生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。</p>\n",headersStr:null,content:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:B站视频《罗翔说刑法》，链接https://b23.tv/K8ulrE",normalizedContent:"生活在后现代的今天，很多人都有一种虚无感，认为人生没有意义。但是，人生不可能没有意义，因为当你认为没有意义的时候，一定有一个与之相对应的概念叫有意义。\n\n当你怀疑人生没有意义时，难道怀疑本身不值得怀疑吗？\n\n不要任由你内心的虚无感蔓延，我们需要去拥抱真实的生活。\n\n所有真实的快乐，都离不开艰辛的努力，无论是金榜题名的快乐，还是事业成功的喜悦，甚至包括洞房花烛的激动。所有真实的快乐，都需要长久的铺垫与努力，没有辛勤的汗水，快乐也就不再真实。\n\n如果快乐触手可及，这种廉价的快乐也就不值得珍惜，随时都可能抛弃。因此，对于年轻人而言，一个重要的功课就是学会去节制欲望。\n\n所有通过捷径所带来的快乐，都是廉价的，以至于所有追求都变得毫无意义，人生就了无生趣。我们需要在每天真实的努力中去拥抱生活，追寻真实的快乐。\n\n\n\n> 文章摘录自:b站视频《罗翔说刑法》，链接https://b23.tv/k8ulre",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:28:41",lastUpdatedTimestamp:1648056521e3},{title:"Home",frontmatter:{home:!0,heroText:"conanan's blog",tagline:"Web前端技术博客，积跬步以至千里，致敬每个爱学习的你。",features:[{title:"前端",details:"JavaScript、ES6、Vue框架等前端技术",link:"/web/",imgUrl:"/img/web.png"},{title:"页面",details:"html(5)/css(3)，前端页面相关技术",link:"/ui/",imgUrl:"/img/ui.png"},{title:"技术",details:"技术文档、教程、技巧、总结等文章",link:"/technology/",imgUrl:"/img/other.png"}]},regularPath:"/",relativePath:"index.md",key:"v-a21e1e74",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2022/03/24, 16:45:21",lastUpdatedTimestamp:1648140321e3},{title:"3 标准内置对象-10 Map",frontmatter:{title:"3 标准内置对象-10 Map",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/1d766f/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/313.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-10Map.html",relativePath:"1200.JS/300.语法/313.标准内置对象-10Map.md",key:"v-55887b9b",path:"/pages/1d766f/",headersStr:null,content:'# 标准内置对象—Map\n\n内置方法基本和 Java 一致\n\nvar map = new Map();\n\nmap.set(1, "value1");\nmap.set({ key: 2 }, "value2");\nmap.set("key3", "value3");\n\nconsole.log(map.get(1)); // value1。此时第二个不能取出来，除非在添加时先声明一个变量\n\nconsole.log(map.has("key3")); // true\n\nmap.forEach((item, index, map) => {\n  console.log(item);\n});\n\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n\nvar iterator = map.entries();\nconsole.log(iterator.next()); // {value: Array(2), done: false}\nconsole.log(iterator.next()); // {value: Array(2), done: false}\nconsole.log(iterator.next()); // {value: Array(2), done: false}\nconsole.log(iterator.next()); // {value: undefined, done: true}\n\n// keys values 不介绍了\n\nmap.delete("key3");\nconsole.log(map);\n\nmap.clear();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n',normalizedContent:'# 标准内置对象—map\n\n内置方法基本和 java 一致\n\nvar map = new map();\n\nmap.set(1, "value1");\nmap.set({ key: 2 }, "value2");\nmap.set("key3", "value3");\n\nconsole.log(map.get(1)); // value1。此时第二个不能取出来，除非在添加时先声明一个变量\n\nconsole.log(map.has("key3")); // true\n\nmap.foreach((item, index, map) => {\n  console.log(item);\n});\n\nfor (const [key, value] of map) {\n  console.log(key, value);\n}\n\nvar iterator = map.entries();\nconsole.log(iterator.next()); // {value: array(2), done: false}\nconsole.log(iterator.next()); // {value: array(2), done: false}\nconsole.log(iterator.next()); // {value: array(2), done: false}\nconsole.log(iterator.next()); // {value: undefined, done: true}\n\n// keys values 不介绍了\n\nmap.delete("key3");\nconsole.log(map);\n\nmap.clear();\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n',charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3},{title:"3 标准内置对象-9 Set",frontmatter:{title:"3 标准内置对象-9 Set",date:"1984-01-24T16:00:00.000Z",permalink:"/pages/41ad52/",categories:["JS"],tags:[null]},regularPath:"/1200.JS/300.%E8%AF%AD%E6%B3%95/312.%E6%A0%87%E5%87%86%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1-9Set.html",relativePath:"1200.JS/300.语法/312.标准内置对象-9Set.md",key:"v-51ff37b9",path:"/pages/41ad52/",headersStr:null,content:"# 标准内置对象—Set\n\n内置方法基本和 Java 一致\n\nvar set = new Set();\n\nset.add(1);\nset.add(2);\nset.add(3);\nconsole.log(set); // Set(3) {1, 2, 3}\nconsole.log(set.size); // 3\n\nset.add(3);\nconsole.log(set); // Set(3) {1, 2, 3}\n\nconsole.log(set.has(3)); // true\n\nset.forEach((item, index, set) => {\n  console.log(item); // 1 2 3\n});\n\nset.delete(3); // 值不是索引\nconsole.log(set); // Set(2) {1, 2}\n\nconsole.log(set.keys()); // SetIterator {1, 2}\nconsole.log(set.values()); // SetIterator {1, 2}\nconsole.log(set.entries()); // SetIterator {1 => 1, 2 => 2}\n\nset.clear();\nconsole.log(set); // Set(0) {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",normalizedContent:"# 标准内置对象—set\n\n内置方法基本和 java 一致\n\nvar set = new set();\n\nset.add(1);\nset.add(2);\nset.add(3);\nconsole.log(set); // set(3) {1, 2, 3}\nconsole.log(set.size); // 3\n\nset.add(3);\nconsole.log(set); // set(3) {1, 2, 3}\n\nconsole.log(set.has(3)); // true\n\nset.foreach((item, index, set) => {\n  console.log(item); // 1 2 3\n});\n\nset.delete(3); // 值不是索引\nconsole.log(set); // set(2) {1, 2}\n\nconsole.log(set.keys()); // setiterator {1, 2}\nconsole.log(set.values()); // setiterator {1, 2}\nconsole.log(set.entries()); // setiterator {1 => 1, 2 => 2}\n\nset.clear();\nconsole.log(set); // set(0) {}\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n",charsets:{cjk:!0},lastUpdated:"2022/03/23, 17:55:39",lastUpdatedTimestamp:1648058139e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"关于",link:"/about/"},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]},{text:"Front End",link:"/pages/fa842a/",items:[{text:"H5&CSS3",link:"/pages/fa842a/"},{text:"JS",link:"/pages/84d48a/"},{text:"TS",link:"/pages/364e02/"},{text:"Node",link:"/pages/b62d08/"},{text:"Webpack",link:"/pages/6f1f8f/"},{text:"Vue2",link:"/pages/b41819/"},{text:"Vue3",link:"/pages/347f26/"},{text:"微信小程序",link:"/pages/00b1d8/"},{text:"Andorid",link:""},{text:"Flutter",link:""}]},{text:"推荐",link:"/pages/d80ad7/",items:[]}],sidebarDepth:2,logo:"/img/logo.png",repo:"xugaoyi/vuepress-theme-vdoing",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",sidebar:{"/00.目录页/":[["01.前端.md","前端","/web"],["02.页面.md","页面","/ui"],["03.技术.md","技术","/technology"],["04.更多.md","更多","/more"]],catalogue:{"前端":"/web","页面":"/ui","技术":"/technology","更多":"/more","《JavaScript教程》笔记":"/note/javascript","《ES6 教程》笔记":"/note/es6/","《Vue》笔记":"/note/vue/","《React》笔记":"/note/react/","《TypeScript 从零实现 axios》":"/note/typescript-axios","《Git》学习笔记":"/note/git"},"/01.前端/":[{title:"JavaScript文章",collapsable:!0,children:[["25.JavaScript文章/01.33个非常实用的JavaScript一行代码.md","33个非常实用的JavaScript一行代码","/pages/a61298/"],["25.JavaScript文章/02.new命令原理.md","new命令原理","/pages/8143cc480faf9a11"],["25.JavaScript文章/03.ES5面向对象.md","ES5面向对象","/pages/b1af5cb8996363c5"],["25.JavaScript文章/04.ES6面向对象.md","ES6面向对象","/pages/1f4123be6f45abcd"],["25.JavaScript文章/06.多种数组去重性能对比.md","多种数组去重性能对比","/pages/e808fba1fa8fbab2"],["25.JavaScript文章/50.js随机打乱数组.md","JS随机打乱数组","/pages/40b4db2d38ba85f2"],["25.JavaScript文章/60.判断是否为移动端浏览器.md","判断是否为移动端浏览器","/pages/40f623be692cf8bc"],["25.JavaScript文章/70.将一维数组按指定长度转为二维数组.md","将一维数组按指定长度转为二维数组","/pages/f1acb712033ac8da"],["25.JavaScript文章/80.防抖与节流函数.md","防抖与节流函数","/pages/0f6a0ac99b62ede5"],["25.JavaScript文章/90.JS获取和修改url参数.md","JS获取和修改url参数","/pages/7a91be2d502346ce"],["25.JavaScript文章/100.比typeof运算符更准确的类型判断.md","比typeof运算符更准确的类型判断","/pages/fd4a16d56b83c1bc"],{title:"三级目录",collapsable:!0,children:[["25.JavaScript文章/1110.三级目录/00.四级文件.md","四级文件(测试)","/pages/8481d1/"]]}]},{title:"学习笔记",collapsable:!0,children:[["40.学习笔记/00.《JavaScript教程》笔记.md","《JavaScript教程》笔记","/note/javascript"],["40.学习笔记/05.《JavaScript高级程序设计》笔记.md","《JavaScript高级程序设计》笔记","/note/js/"],["40.学习笔记/10.《ES6 教程》笔记.md","《ES6 教程》笔记","/note/es6/"],["40.学习笔记/20.《Vue》笔记.md","《Vue》笔记","/note/vue/"],["40.学习笔记/25.《React》笔记.md","《React》笔记","/note/react/"],["40.学习笔记/30.《TypeScript 从零实现 axios》.md","《TypeScript 从零实现 axios》","/note/typescript-axios"],["40.学习笔记/33.《Git》学习笔记.md","《Git》学习笔记","/note/git"],["40.学习笔记/35.TypeScript笔记.md","TypeScript笔记","/pages/51afd6/"],["40.学习笔记/40.小程序笔记.md","小程序笔记","/note/wx-miniprogram"],["40.学习笔记/50.JS设计模式总结笔记.md","JS设计模式总结笔记","/pages/4643cd/"]]}],"/02.页面/":[{title:"HTML",collapsable:!0,children:[["10.HTML/10.常用meta整理.md","常用meta整理","/pages/8309a5b876fc95e3"]]},{title:"CSS",collapsable:!0,children:[["20.CSS/00.CSS教程和技巧收藏.md","CSS教程和技巧收藏","/pages/c8f128/"],["20.CSS/01.flex布局语法.md","flex布局语法","/pages/0a83b083bdf257cb"],["20.CSS/02.flex布局案例-基础.md","flex布局案例-基础","/pages/ea6db1530c42ad51"],["20.CSS/03.flex布局案例-骰子.md","flex布局案例-骰子","/pages/eff61bc8b4f4695d"],["20.CSS/04.flex布局案例-圣杯布局.md","flex布局案例-圣杯布局","/pages/df9e7c7214fa5046"],["20.CSS/05.flex布局案例-网格布局.md","flex布局案例-网格布局","/pages/85b5a3fe218a34b7"],["20.CSS/06.flex布局案例-输入框布局.md","flex布局案例-输入框布局","/pages/05cc577fb51c7998"],["20.CSS/07.CSS3之transition过渡.md","CSS3之transition过渡","/pages/02d7f59d98d87409"],["20.CSS/08.CSS3之animation动画.md","CSS3之animation动画","/pages/c2c0432138f6e042"],["20.CSS/20.「布局技巧」图片未加载前自动撑开元素高度.md","「布局技巧」图片未加载前自动撑开元素高度","/pages/3d52574260725aea"],["20.CSS/30.文字在一行或多行时超出显示省略号.md","文字在一行或多行时超出显示省略号","/pages/42b66999cc27dc25"],["20.CSS/35.从box-sizing属性入手，了解盒子模型.md","从box-sizing属性入手，了解盒子模型","/pages/20a978023139589d"],["20.CSS/40.水平垂直居中的几种方式-案例.md","水平垂直居中的几种方式-案例","/pages/cb7cb251adba4bf7"],["20.CSS/45.如何根据系统主题自动响应CSS深色模式.md","如何根据系统主题自动响应CSS深色模式","/pages/5dde351274f1e39d"],["20.CSS/50.「css技巧」使用hover和attr()定制悬浮提示.md","「css技巧」使用hover和attr()定制悬浮提示","/pages/941581927b4a38f8"],["20.CSS/60.CSS-function汇总.md","CSS-function汇总","/pages/3da0d7"]]}],"/03.技术/":[{title:"技术文档",collapsable:!0,children:[["01.技术文档/01.Git使用手册.md","Git使用手册","/pages/9a7ee40fc232253e"],["01.技术文档/02.Markdown使用教程.md","Markdown使用教程","/pages/ad247c4332211551"],["01.技术文档/03.npm常用命令.md","npm常用命令","/pages/61f2f95fd7da14fd"],["01.技术文档/10.npm packageJson属性详解.md","npm packageJson属性详解","/pages/dec4f3f00e71a312"],["01.技术文档/15.yaml语言教程.md","yaml语言教程","/pages/4e8444e2d534d14f"]]},{title:"GitHub技巧",collapsable:!0,children:[["02.GitHub技巧/01.GitHub高级搜索技巧.md","GitHub高级搜索技巧","/pages/4c778760be26d8b3"],["02.GitHub技巧/02.GitHub Actions 实现自动部署静态博客.md","GitHub Actions 实现自动部署静态博客","/pages/6b9d359ec5aa5019"],["02.GitHub技巧/03.GitHub Actions 定时运行代码：每天定时百度链接推送.md","GitHub Actions 定时运行代码：每天定时百度链接推送","/pages/f44d2f9ad04ab8d3"],["02.GitHub技巧/10.GitHub加速下载项目的方法.md","GitHub加速下载项目的方法","/pages/95331c6a9613faf8"]]},{title:"Nodejs",collapsable:!0,children:[["03.Nodejs/01.nodejs递归读取所有文件.md","nodejs递归读取所有文件","/pages/117708e0af7f0bd9"]]},{title:"博客搭建",collapsable:!0,children:[["04.博客搭建/01.解决百度无法收录搭建在GitHub上的个人博客的问题.md","解决百度无法收录搭建在GitHub上的个人博客的问题","/pages/41f87d890d0a02af"],["04.博客搭建/02.使用Gitalk实现静态博客无后台评论系统.md","使用Gitalk实现静态博客无后台评论系统","/pages/1da0bf9a988eafe5"],["04.博客搭建/03.GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床.md","GitHub + jsDelivr + TinyPNG+ PicGo 打造稳定快速、高效免费图床","/pages/a5f73af5185fdf0a"],["04.博客搭建/10.vdoing主题效果图.md","vdoing主题效果图","/pages/d557b9a89a215d2e"]]}],"/04.更多/":[{title:"学习",collapsable:!0,children:[["01.学习/00.费曼学习法.md","费曼学习法","/pages/f2a556/"],["01.学习/01.笔记方法.md","笔记方法","/pages/e60c81/"],["01.学习/02.提高学习效率的策略.md","提高学习效率的策略","/pages/a8692ab3bdcb4588"],["01.学习/03.提高记忆的技巧.md","提高记忆的技巧","/pages/996822b2a2ca6e3b"],["01.学习/04.自律小建议.md","自律小建议","/pages/c3f302a03c8daf79"],["01.学习/05.处理问题的思路.md","处理问题的思路","/pages/9ba2b8fb13de1957"],["01.学习/10.搜索引擎使用技巧.md","搜索引擎使用技巧","/pages/ce818a"]]},{title:"面试",collapsable:!0,children:[["03.面试/01.面试问题集锦.md","面试问题集锦","/pages/aea6571b7a8bae86"]]},{title:"心情杂货",collapsable:!0,children:[["05.心情杂货/01.一个完美主义者的自我救赎.md","一个完美主义者的自我救赎","/pages/2d615df9a36a98ed"],["05.心情杂货/10.反向拆解让人上瘾的套路，找回自律.md","反向拆解让人上瘾的套路，找回自律","/pages/d6d331/"]]},{title:"实用技巧",collapsable:!0,children:[["10.实用技巧/01.2分钟规则.md","2分钟规则","/pages/baaa02/"],["10.实用技巧/10.一行代码“黑”掉任意网站.md","一行代码“黑”掉任意网站","/pages/dcebaf/","原创"]]},["99.友情链接.md","友情链接","/friends"]],"/05.关于/":[["01.关于.md","关于","/about"]],"/06.收藏夹/":[["01.网站.md","网站","/pages/beb6c0bd8a66cea6"],["02.常用的前端轮子.md","常用的前端轮子","/pages/47cf96/"]],"/1100.H5&CSS3/":[["101.HTML.md","HTML","/pages/fa842a/"],{title:"CSS基础",collapsable:!0,children:[["200.CSS基础/201.CSS-1基础.md","基础","/pages/d8978d/"],["200.CSS基础/202.CSS-2属性.md","属性","/pages/687c1b/"],["200.CSS基础/301.CSS-3动画.md","动画","/pages/528b1e/"],["200.CSS基础/401.CSS-8Less.md","Less","/pages/9aeeea/"]]},{title:"CSS布局",collapsable:!0,children:[["300.CSS布局/301.CSS-盒子模型.md","盒子模型","/pages/335968/"],["300.CSS布局/302.CSS-标准流.md","标准流","/pages/3d870b/"],["300.CSS布局/303.CSS-浮动.md","浮动","/pages/9fccab/"],["300.CSS布局/304.CSS-定位.md","定位","/pages/558f03/"],["300.CSS布局/305.CSS-传统布局总结.md","传统布局总结","/pages/78ced3/"],["300.CSS布局/306.CSS-Flexible.md","Flexible","/pages/b5b50a/"],["300.CSS布局/309.CSS-移动端适配.md","移动端适配","/pages/824a06/"],["300.CSS布局/391.CSS项目案例——京东.md","京东","/pages/ac76d8/"],["300.CSS布局/392.CSS项目案例——考拉.md","考拉","/pages/d2628c/"]]},["401.CSS-高级技巧.md","高级技巧","/pages/da720c/"],["501.代码规范.md","代码规范","/pages/abf94c/"]],"/1200.JS/":[{title:"入门",collapsable:!0,children:[["100.入门/101.入门.md","0 入门-0 入门","/pages/84d48a/"],["100.入门/102.Web 应用的生命周期.md","0 入门-1 Web 应用的生命周期","/pages/e22d1e/"]]},{title:"理解",collapsable:!0,children:[["200.理解/201.函数的定义与参数.md","1 理解-0 函数的定义与参数","/pages/ebb062/"],["200.理解/202..理解函数调用.md","1 理解-1 理解函数调用","/pages/2a1d9d/"],["200.理解/203.this—函数上下文.md","1 理解-2 this—函数上下文","/pages/adb64b/"],["200.理解/204.作用域.md","1 理解-3 作用域","/pages/0afc0f/"],["200.理解/205.闭包.md","1 理解-4 闭包","/pages/f616f1/"]]},{title:"语法",collapsable:!0,children:[["300.语法/301.基础语法.md","2 语法-1 基础语法","/pages/f59f90/"],["300.语法/302.ES6.md","2 语法-1 ES6","/pages/c65afb/"],["300.语法/303.Function.md","2 语法-2 Function","/pages/ea650c/"],["300.语法/304.标准内置对象-1Object.md","3 标准内置对象-1 Object","/pages/fa990b/"],["300.语法/305.标准内置对象-2String.md","3 标准内置对象-2 String","/pages/b412ad/"],["300.语法/306.标准内置对象-3Array.md","3 标准内置对象-3 Array","/pages/e7e591/"],["300.语法/307.标准内置对象-4RegExp.md","3 标准内置对象-4 RegExp","/pages/267da2/"],["300.语法/308.标准内置对象-5Number.md","3 标准内置对象-5 Number","/pages/c814e7/"],["300.语法/309.标准内置对象-6Math.md","3 标准内置对象-6 Math","/pages/00d50a/"],["300.语法/310.标准内置对象-7Date.md","3 标准内置对象-7 Date","/pages/fbbc79/"],["300.语法/311.标准内置对象-8JSON.md","3 标准内置对象-8 JSON","/pages/45bd67/"],["300.语法/312.标准内置对象-9Set.md","3 标准内置对象-9 Set","/pages/41ad52/"],["300.语法/313.标准内置对象-10Map.md","3 标准内置对象-10 Map","/pages/1d766f/"],["300.语法/314.面向对象.md","4 面向对象","/pages/cb9d10/"],["300.语法/315.异常.md","5 异常","/pages/085b49/"]]},{title:"异步",collapsable:!0,children:[["400.异步/401.异步-1定时器.md","6 异步-1 定时器","/pages/925f93/"],["400.异步/402.异步-2Promise.md","6 异步-2 Promise","/pages/0e6a48/"],["400.异步/403.异步-3async&await.md","6 异步-3 async & await","/pages/9ef7a8/"]]},{title:"模块化",collapsable:!0,children:[["500.模块化/501.模块化-1ES6模块化.md","7 模块化-1 ES6模块化","/pages/8313cc/"],["500.模块化/502.模块化-2ES5模块化.md","7 模块化-2 ES5模块化","/pages/e5923d/"],["500.模块化/503.模块化-3常见模块化规范.md","7 模块化-3 常见模块化规范","/pages/c8b589/"]]},{title:"网络",collapsable:!0,children:[["600.网络/601.Ajax.md","8 网络-1 Ajax","/pages/560afc/"]]},{title:"DOM&BOM",collapsable:!0,children:[["700.DOM&BOM/701.DOM.md","DOM","/pages/39c4a3/"],["700.DOM&BOM/702.BOM.md","BOM","/pages/3b0c3a/"]]},{title:"常用框架",collapsable:!0,children:[["800.常用框架/801. jQuery.md","99 jQuery","/pages/bbc451/"],["800.常用框架/802.Layui.md","Layui","/pages/baf83c/"]]}],"/1210.TS/":[["101.入门.md","入门","/pages/364e02/"],["102.JS变量类型.md","JS变量类型","/pages/fb0221/"],["103.TS专属数据类型&使用.md","TS专属数据类型&使用","/pages/1322e7/"],["104.TS函数.md","TS函数","/pages/288b06/"],["105.TS类.md","TS类","/pages/d281f9/"],["106.TS接口.md","TS接口 🔥","/pages/e73701/"],["107.TS泛型.md","TS泛型 🔥","/pages/e0eec1/"],["108.TS补充.md","TS补充","/pages/306c32/"]],"/1300.Node/":[{title:"Node",collapsable:!0,children:[["100.Node/101.入门.md","NodeJS-1 入门","/pages/b62d08/"]]}],"/1301.Webpack/":[{title:"Webpack5",collapsable:!0,children:[["100.Webpack5/101.入门.md","入门","/pages/6f1f8f/"]]},{title:"Webpack3",collapsable:!0,children:[["200.Webpack3/101.入门.md","Webpack-1 入门","/pages/e2b92d/"]]}],"/1402.Vue2.x/":[{title:"基础",collapsable:!0,children:[["100.基础/101.入门.md","入门","/pages/b41819/"],["100.基础/102.插值语法.md","插值语法","/pages/49b47f/"],["100.基础/103.绑定属性.md","绑定属性","/pages/18d9ea/"],["100.基础/104.计算属性和侦听器.md","计算属性和侦听器","/pages/10562f/"],["100.基础/105.事件监听.md","事件监听","/pages/5aff0b/"],["100.基础/106.条件和循环.md","条件和循环","/pages/7627a1/"],["100.基础/107.表单双向绑定.md","表单双向绑定","/pages/6780f9/"]]},{title:"组件",collapsable:!0,children:[["200.组件/201.组件化开发.md","组件化开发","/pages/15ab90/"],["200.组件/202.插槽.md","插槽","/pages/cca4b3/"]]},{title:"Vue CLI",collapsable:!0,children:[["300.Vue CLI/301.入门.md","入门","/pages/ac2e39/"]]},{title:"Vue Router",collapsable:!0,children:[["400.Vue Router/401.Vue Router入门.md","入门","/pages/9741e2/"]]}],"/1403.Vue3.x/":[{title:"基础",collapsable:!0,children:[["100.基础/101.入门.md","入门","/pages/347f26/"],["100.基础/102.模版语法&指令.md","模版语法&指令","/pages/47f5c4/"],["100.基础/103.条件渲染&列表渲染.md","条件渲染&列表渲染","/pages/3dbba2/"],["100.基础/104.计算属性&侦听器.md","计算属性&侦听器","/pages/af8c61/"],["100.基础/105.表单的双向绑定.md","表单的双向绑定","/pages/973ddb/"],["100.基础/106.组件化开发.md","组件化开发","/pages/d2d257/"]]},{title:"组件",collapsable:!0,children:[["200.组件/201.父子组件通讯.md","父子组件通讯","/pages/e8afc3/"],["200.组件/202.非父子组件通讯.md","非父子组件通讯","/pages/9026a0/"],["200.组件/203.插槽.md","插槽","/pages/fff569/"],["200.组件/204.动态组件.md","动态组件","/pages/4e1afb/"],["200.组件/205.异步组件.md","异步组件","/pages/f515e4/"],["200.组件/206.生命周期.md","生命周期","/pages/85ff80/"],["200.组件/207.组件的v-model.md","组件的v-model","/pages/fcbaec/"]]},{title:"动画",collapsable:!0,children:[["300.动画/301.Vue动画.md","Vue 动画","/pages/5570af/"]]},{title:"Composition Api",collapsable:!0,children:[["400.Composition Api/401.旧解决方案.md","旧解决方案","/pages/958e61/"],["400.Composition Api/402.响应式Api.md","响应式Api","/pages/52c08c/"],["400.Composition Api/403.计算属性&侦听器.md","计算属性&侦听器","/pages/4f74c8/"],["400.Composition Api/404.其他.md","其他","/pages/563ede/"]]},{title:"高级语法",collapsable:!0,children:[["500.高级语法/501.h 函数 & JSX.md","h 函数 & JSX","/pages/2b61b7/"],["500.高级语法/502.自定义指令.md","自定义指令","/pages/aa7419/"],["500.高级语法/503.Teleport.md","Teleport","/pages/847cf9/"],["500.高级语法/504.插件.md","插件","/pages/73db51/"],["500.高级语法/505.nextTick与eventloop.md","nextTick与eventloop","/pages/e0a730/"],["500.高级语法/506.historyApiFallback.md","historyApiFallback","/pages/d4f613/"]]},{title:"Vue源码",collapsable:!0,children:[["600.Vue源码/601.源码.md","源码","/pages/2e2905/"],["600.Vue源码/611.MiniVue.md","MiniVue","/pages/6f4bd5/"]]},{title:"VueCLI&Vite",collapsable:!0,children:[["700.VueCLI&Vite/100.VueCLI.md","VueCLI","/pages/af8fd5/"],["700.VueCLI&Vite/200.Vite.md","Vite","/pages/fe7980/"]]},{title:"VueRouter",collapsable:!0,children:[["800.VueRouter/801.路由.md","路由","/pages/39a5b4/"],["800.VueRouter/802.VueRouter.md","VueRouter","/pages/1c8fc2/"]]},{title:"Vuex",collapsable:!0,children:[["900.Vuex/901.状态管理.md","状态管理","/pages/47a190/"],["900.Vuex/902.Vuex.md","Vuex","/pages/fa4384/"]]},{title:"项目",collapsable:!0,children:[["1000.项目/101.搭建项目.md","搭建项目","/pages/3c9e8f/"],["1000.项目/102.重点.md","重点","/pages/b5412c/"]]}],"/1500.微信小程序/":[["101.入门.md","入门","/pages/00b1d8/"]],"/9999.推荐/":[["101.index.md","index","/pages/d80ad7/"]]},author:{name:"xugaoyi",link:"https://github.com/xugaoyi"},blogger:{avatar:"https://cdn.jsdelivr.net/gh/xugaoyi/image_store/blog/20200103123203.jpg",name:"conanan",slogan:"真相只有一个"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:894072666@qq.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/xugaoyi"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2019,copyrightInfo:'conanan | <a href="https://github.com/apple54whn" target="_blank">MIT License</a>'},htmlModules:{homeSidebarB:'<div style="padding: 0.95rem">\n    <p style="\n      color: var(--textColor);\n      opacity: 0.9;\n      font-size: 20px;\n      font-weight: bold;\n      margin: 0 0 8px 0;\n    ">公众号</p>\n    <img src="https://open.weixin.qq.com/qr/code?username=gh_0cf4b813918c"  style="width:100%;" />\n    关注公众号，回复[<b>前端资源</b>]，可获取 <a href="https://game.xugaoyi.com" arget="_blank" >前端学习资源<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>\n    </p>\n    </div>'}},locales:{"/":{lang:"zh-CN",title:"Evan's blog",description:"web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。",path:"/"}}},ss=(t(159),t(218),t(148),t(228)),cs=t(229),ds=(t(393),t(244),t(43));var ps={computed:{$filterPosts:function(){return this.$site.pages.filter((function(n){var e=n.frontmatter,t=e.pageComponent,o=e.article,a=e.home;return!(t||!1===o||!0===a)}))},$sortPosts:function(){return(n=this.$filterPosts).sort((function(n,e){var t=n.frontmatter.sticky,o=e.frontmatter.sticky;return t&&o?t==o?Object(ds.a)(n,e):t-o:t&&!o?-1:!t&&o?1:Object(ds.a)(n,e)})),n;var n},$sortPostsByDate:function(){return(n=this.$filterPosts).sort((function(n,e){return Object(ds.a)(n,e)})),n;var n},$groupPosts:function(){return function(n){for(var e={},t={},o=function(o,a){var i=n[o].frontmatter,r=i.categories,l=i.tags;"array"===Object(ds.n)(r)&&r.forEach((function(t){t&&(e[t]||(e[t]=[]),e[t].push(n[o]))})),"array"===Object(ds.n)(l)&&l.forEach((function(e){e&&(t[e]||(t[e]=[]),t[e].push(n[o]))}))},a=0,i=n.length;a<i;a++)o(a);return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags:function(){return function(n){var e=[],t=[];for(var o in n.categories)e.push({key:o,length:n.categories[o].length});for(var a in n.tags)t.push({key:a,length:n.tags[a].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Ma.component(ss.default),Ma.component(cs.default);function us(n){return n.toString().padStart(2,"0")}t(397);Ma.component("Badge",(function(){return Promise.all([t.e(0),t.e(14)]).then(t.bind(null,773))})),Ma.component("CodeBlock",(function(){return Promise.resolve().then(t.bind(null,228))})),Ma.component("CodeGroup",(function(){return Promise.resolve().then(t.bind(null,229))}));t(398);var ms,hs,gs=t(50),fs=(t(401),t(142),t(227)),vs=t.n(fs),bs=t(107);"valine"===(hs="gitalk")?t.e(194).then(t.t.bind(null,581,7)).then((function(n){return n.default})):"gitalk"===hs&&Promise.all([t.e(0),t.e(193)]).then(t.t.bind(null,582,7)).then((function(){return t.e(192).then(t.t.bind(null,583,7))})).then((function(n){return ms=n.default}));function xs(n,e){var t={};return Reflect.ownKeys(n).forEach((function(o){if("string"==typeof n[o])try{t[o]=vs.a.render(n[o],e)}catch(e){console.warn('Comment config option error at key named "'.concat(o,'"')),console.warn("More info: ".concat(e.message)),t[o]=n[o]}else t[o]=n[o]})),t}console.log('How to use "'.concat("gitalk",'" in ').concat(bs.name,"@v").concat(bs.version,":"),bs.homepage);var ys={render:function(n,e){var t=document.createElement("div");t.id=e,document.querySelector("main.page").appendChild(t),new ms(xs({clientID:"a6e1355287947096b88b",clientSecret:"f0e77d070fabfcd5af95bebb82b2d574d7248d71",repo:"blog-gitalk-comment",owner:"xugaoyi",admin:["xugaoyi"],pagerDirection:"last",id:"<%- (frontmatter.permalink || frontmatter.to.path).slice(-16) %>",title:"「评论」<%- frontmatter.title %>",labels:["Gitalk","Comment"],body:"页面：<%- window.location.origin + (frontmatter.to.path || window.location.pathname) %>"},{frontmatter:n})).render(e)},clear:function(n){var e=document.querySelector("#".concat(n));return e&&e.remove(),!0}},ws=null;function ks(n){return ys.clear("vuepress-plugin-comment")}function js(n){return!1!==n.comment&&!1!==n.comments}function Ts(n){if(clearTimeout(ws),document.querySelector("main.page"))return ys.render(n,"vuepress-plugin-comment");ws=setTimeout((function(){return Ts(n)}),200)}var Ss={mounted:function(){var n=this;ws=setTimeout((function(){var e=Object(gs.a)({to:{},from:{}},n.$frontmatter);ks()&&js(e)&&Ts(e)}),1e3),this.$router.afterEach((function(e,t){if(!e||!t||e.path!==t.path){var o=Object(gs.a)({to:e,from:t},n.$frontmatter);ks()&&js(o)&&Ts(o)}}))}},Es=Object(as.a)(Ss,(function(){var n=this.$createElement;return(this._self._c||n)("div")}),[],!1,null,null,null).exports,Is=[function(n){n.Vue,n.options,n.router,n.siteData},function(n){var e=n.Vue,t=(n.options,n.router,n.siteData);t.pages.map((function(n){var e=n.frontmatter,o=e.date,a=e.author;"string"==typeof o&&"Z"===o.charAt(o.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return"".concat(n.getUTCFullYear(),"-").concat(us(n.getUTCMonth()+1),"-").concat(us(n.getUTCDate())," ").concat(us(n.getUTCHours()),":").concat(us(n.getUTCMinutes()),":").concat(us(n.getUTCSeconds()))}(o)),a?n.author=a:t.themeConfig.author&&(n.author=t.themeConfig.author)})),e.mixin(ps)},{},function(n){n.Vue.mixin({computed:{$dataBlock:function(){return this.$options.__data__block__}}})},{},{},function(n){n.router;"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},function(n){var e=n.router;"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),e.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},function(n){n.Vue.component("Comment",Es)}],zs=["Comment"];t(221);function Cs(n,e){return(Cs=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}t(222);function As(n){return(As=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}function _s(n,e){if(e&&("object"===Er(e)||"function"==typeof e))return e;if(void 0!==e)throw new TypeError("Derived constructors may only return object or undefined");return function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n)}function Ps(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,o=As(n);if(e){var a=As(this).constructor;t=Reflect.construct(o,arguments,a)}else t=o.apply(this,arguments);return _s(this,t)}}var Bs=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),Object.defineProperty(n,"prototype",{writable:!1}),e&&Cs(n,e)}(t,n);var e=Ps(t);function t(){return cl(this,t),e.apply(this,arguments)}return pl(t)}(function(){function n(){cl(this,n),this.store=new Ma({data:{state:{}}})}return pl(n,[{key:"$get",value:function(n){return this.store.state[n]}},{key:"$set",value:function(n,e){Ma.set(this.store.state,n,e)}},{key:"$emit",value:function(){var n;(n=this.store).$emit.apply(n,arguments)}},{key:"$on",value:function(){var n;(n=this.store).$on.apply(n,arguments)}}]),n}());Object.assign(Bs.prototype,{getPageAsyncComponent:Hr,getLayoutAsyncComponent:Rr,getAsyncComponent:qr,getVueComponent:Fr});var Ms={install:function(n){var e=new Bs;n.$vuepress=e,n.prototype.$vuepress=e}};function Os(n){n.beforeEach((function(e,t,o){if(Ds(n,e.path))o();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){var a=e.path.replace(/\/$/,"")+".html";Ds(n,a)?o(a):o()}else o();else{var i=e.path+"/",r=e.path+".html";Ds(n,r)?o(r):Ds(n,i)?o(i):o()}}))}function Ds(n,e){var t=e.toLowerCase();return n.options.routes.some((function(n){return n.path.toLowerCase()===t}))}var $s={props:{pageKey:String,slotKey:{type:String,default:"default"}},render:function(n){var e=this.pageKey||this.$parent.$page.key;return Gr("pageKey",e),Ma.component(e)||Ma.component(e,Hr(e)),Ma.component(e)?n(e):n("")}},Ls={functional:!0,props:{slotKey:String,required:!0},render:function(n,e){var t=e.props,o=e.slots;return n("div",{class:["content__".concat(t.slotKey)]},o()[t.slotKey])}},Ns={computed:{openInNewWindowTitle:function(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Vs=(t(406),t(407),Object(as.a)(Ns,(function(){var n=this.$createElement,e=this._self._c||n;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports);function Us(){return(Us=Object(o.a)(regeneratorRuntime.mark((function n(e){var t,o,a,i;return regeneratorRuntime.wrap((function(n){for(;;)switch(n.prev=n.next){case 0:return t="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:ls.routerBase||ls.base,Os(o=new Tr({base:t,mode:"history",fallback:!1,routes:rs,scrollBehavior:function(n,e,t){return t||(n.hash?!Ma.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})}})),a={},n.prev=4,n.next=7,Promise.all(Is.filter((function(n){return"function"==typeof n})).map((function(n){return n({Vue:Ma,options:a,router:o,siteData:ls,isServer:e})})));case 7:n.next=12;break;case 9:n.prev=9,n.t0=n.catch(4),console.error(n.t0);case 12:return i=new Ma(Object.assign(a,{router:o,render:function(n){return n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},zs.map((function(e){return n(e)})))])}})),n.abrupt("return",{app:i,router:o});case 14:case"end":return n.stop()}}),n,null,[[4,9]])})))).apply(this,arguments)}Ma.config.productionTip=!1,Ma.use(Tr),Ma.use(Ms),Ma.mixin(function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Ma;Sr(e),t.$vuepress.$set("siteData",e);var o=n(t.$vuepress.$get("siteData")),a=new o,i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),r={};return Object.keys(i).reduce((function(n,e){return e.startsWith("$")&&(n[e]=i[e].get),n}),r),{computed:r}}((function(n){return function(){function e(){cl(this,e)}return pl(e,[{key:"setPage",value:function(n){this.__page=n}},{key:"$site",get:function(){return n}},{key:"$themeConfig",get:function(){return this.$site.themeConfig}},{key:"$frontmatter",get:function(){return this.$page.frontmatter}},{key:"$localeConfig",get:function(){var n,e,t=this.$site.locales,o=void 0===t?{}:t;for(var a in o)"/"===a?e=o[a]:0===this.$page.path.indexOf(a)&&(n=o[a]);return n||e||{}}},{key:"$siteTitle",get:function(){return this.$localeConfig.title||this.$site.title||""}},{key:"$canonicalUrl",get:function(){var n=this.$page.frontmatter.canonicalUrl;return"string"==typeof n&&n}},{key:"$title",get:function(){var n=this.$page,e=this.$page.frontmatter.metaTitle;if("string"==typeof e)return e;var t=this.$siteTitle,o=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?o?o+" | "+t:t:o||"VuePress"}},{key:"$description",get:function(){var n=function(n){if(n){var e=n.filter((function(n){return"description"===n.name}))[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}},{key:"$lang",get:function(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}},{key:"$localePath",get:function(){return this.$localeConfig.path||"/"}},{key:"$themeLocaleConfig",get:function(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}},{key:"$page",get:function(){return this.__page?this.__page:function(n,e){for(var t=0;t<n.length;t++){var o=n[t];if(o.path.toLowerCase()===e.toLowerCase())return o}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}}]),e}()}),ls)),Ma.component("Content",$s),Ma.component("ContentSlotsDistributor",Ls),Ma.component("OutboundLink",Vs),Ma.component("ClientOnly",{functional:!0,render:function(n,e){var t=e.parent,o=e.children;if(t._isMounted)return o;t.$once("hook:mounted",(function(){t.$forceUpdate()}))}}),Ma.component("Layout",Rr("Layout")),Ma.component("NotFound",Rr("NotFound")),Ma.prototype.$withBase=function(n){var e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"938baf1"},function(n){return Us.apply(this,arguments)}(!1).then((function(n){var e=n.app;n.router.onReady((function(){e.$mount("#app")}))}))}]);